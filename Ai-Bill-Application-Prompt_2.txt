```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Controller\MenuUI.java`:

```java
package Controller;

import Constants.ConfigConstants;
import Constants.StandardCategories; // Import StandardCategories if needed in UI
import DAO.TransactionDao; // Import if needed
import DAO.SummaryStatisticDao; // Import if needed
import Service.AIservice.AITransactionService; // Import AI services
import Service.AIservice.CollegeStudentNeeds;
import Service.Impl.TransactionServiceImpl;
import Service.Impl.SummaryStatisticService; // Import SummaryStatisticService
import Service.TransactionService;
import Utils.CacheManager;
import model.SummaryStatistic; // Import SummaryStatistic
import model.Transaction;
import model.User;
import Constants.StandardCategories;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.io.IOException;
import java.util.List;
import java.util.Vector;
import java.util.Comparator; // For sorting stats display

public class MenuUI extends JPanel { // Extend JPanel for easier use in Main (optional but common)

    private final User currentUser;
    private final TransactionService transactionService;
    private final SummaryStatisticService summaryStatisticService;
    private final AITransactionService aiTransactionService;
    private final CollegeStudentNeeds collegeStudentNeeds;

    private DefaultTableModel tableModel;

    // Fields for search input components
    private JTextField searchTransactionTimeField;
    private JTextField searchTransactionTypeField;
    private JTextField searchCounterpartyField;
    private JTextField searchCommodityField;
    private JComboBox<String> searchInOutComboBox;
    private JTextField searchPaymentMethodField;
    private JButton searchButton;

    private JTable table;
    // REMOVED: private HistogramPanelContainer histogramPanelContainer; // No longer needed

    private JPanel rightPanel;
    private CardLayout cardLayout;

    // UI components for AI panel (existing)
    private JTextArea aiResultArea;
    private JTextField aiStartTimeField;
    private JTextField aiEndTimeField;
    private JButton aiAnalyzeButton;
    private JButton aiBudgetButton;
    private JButton aiTipsButton;
    private JButton aiPersonalSummaryButton;
    private JButton aiSavingsGoalsButton;
    private JButton aiPersonalSavingTipsButton;


    // UI components for Admin Stats panel (existing)
    private JTextArea adminStatsArea;
    private JButton generateStatsButton;
    private JButton refreshDisplayButton;

    // New panel for Visualization
    private VisualizationPanel visualizationPanel; // Add instance field


    // Constructor now accepts all necessary service instances (same as before)
    public MenuUI(User authenticatedUser, TransactionService transactionService,
                  SummaryStatisticService summaryStatisticService,
                  AITransactionService aiTransactionService,
                  CollegeStudentNeeds collegeStudentNeeds) {

        this.currentUser = authenticatedUser;
        this.transactionService = transactionService;
        this.summaryStatisticService = summaryStatisticService;
        this.aiTransactionService = aiTransactionService;
        this.collegeStudentNeeds = collegeStudentNeeds;

        // Initialize table model (same as before)
        String[] columnNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注", "Modify", "Delete"};
        this.tableModel = new DefaultTableModel(columnNames, 0);
        this.table = new JTable(this.tableModel);

        // Initialize the main panel layout (same as before)
        setLayout(new BorderLayout());

        // Add the left panel (will be modified)
        add(createLeftPanel(), BorderLayout.WEST);

        // Add the right panel (will be modified)
        setupRightPanel();
        add(rightPanel, BorderLayout.CENTER);

        // Initial data load is done in createMainPanel (same as before)
        // loadCSVDataForCurrentUser("收入");

        System.out.println("MenuUI initialized for user: " + currentUser.getUsername() + " (" + currentUser.getRole() + ")");
    }

    public JPanel createMainPanel() {
        // MenuUI itself is the main panel, just add the initial data
        loadCSVDataForCurrentUser(""); // Load and display only income initially
        return this; // Return itself
    }


    // Method to load CSV data for the current user with optional initial filter
    // Same logic as before
    public void loadCSVDataForCurrentUser(String initialInOutFilter) {
        // ... existing implementation ...
        this.tableModel.setRowCount(0); // Clear the table model

        try {
            List<Transaction> transactions = transactionService.getAllTransactions();
            System.out.println("Loaded total " + transactions.size() + " transactions from service for user " + currentUser.getUsername());

            List<Transaction> filteredTransactions = new java.util.ArrayList<>();
            if (initialInOutFilter == null || initialInOutFilter.trim().isEmpty()) {
                filteredTransactions.addAll(transactions);
            } else {
                String filter = initialInOutFilter.trim();
                filteredTransactions = transactions.stream()
                        .filter(t -> t.getInOut() != null && (t.getInOut().equalsIgnoreCase(filter) ||
                                (filter.equalsIgnoreCase("收入") && t.getInOut().equalsIgnoreCase("收")) ||
                                (filter.equalsIgnoreCase("支出") && t.getInOut().equalsIgnoreCase("支")) ))
                        .collect(java.util.stream.Collectors.toList());
            }

            for (Transaction transaction : filteredTransactions) {
                Vector<String> row = createRowFromTransaction(transaction);
                this.tableModel.addRow(row);
            }
            System.out.println("Displayed " + filteredTransactions.size() + " transactions in the table.");

        } catch (Exception e) {
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, "加载用户交易数据失败！", "错误", JOptionPane.ERROR_MESSAGE);
        }
    }

    // Method to create the left panel (Menu/AI/Admin/Visualization buttons) - MODIFIED
    private JPanel createLeftPanel() {
        JPanel leftPanel = new JPanel();
        leftPanel.setLayout(new BoxLayout(leftPanel, BoxLayout.Y_AXIS));
        leftPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        JButton menuButton = new JButton("交易列表");
        JButton aiButton = new JButton("AI分析");
        JButton adminButton = new JButton("管理员统计");
        JButton visualizationButton = new JButton("可视化"); // NEW Visualization button

        // Set consistent size for buttons
        Dimension buttonSize = new Dimension(150, 40);
        menuButton.setMaximumSize(buttonSize);
        aiButton.setMaximumSize(buttonSize);
        adminButton.setMaximumSize(buttonSize);
        visualizationButton.setMaximumSize(buttonSize); // Set size for new button


        menuButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        aiButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        adminButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        visualizationButton.setAlignmentX(Component.CENTER_ALIGNMENT); // Align new button


        leftPanel.add(menuButton);
        leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        leftPanel.add(aiButton);
        leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));

        // Add Admin button only if the user is admin (same as before)
        if ("admin".equalsIgnoreCase(currentUser.getRole())) {
            leftPanel.add(adminButton);
            leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        }

        // Add Visualization button (visible for all users)
        leftPanel.add(visualizationButton); // Add the visualization button
        leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));


        // Add action listeners (existing for Menu, AI, Admin)
        menuButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Table");
            loadCSVDataForCurrentUser("收入");
        });

        aiButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "AI");
        });

        if ("admin".equalsIgnoreCase(currentUser.getRole())) {
            adminButton.addActionListener(e -> {
                cardLayout.show(rightPanel, "AdminStats");
                displaySummaryStatistics(); // Refresh stats display when switching
            });
        }

        // Add action listener for Visualization button - NEW
        visualizationButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Visualization"); // Switch to visualization view
            // Optional: Trigger initial chart load or setup in VisualizationPanel
            // visualizationPanel.loadAndDisplayCharts(); // Needs a method in VisualizationPanel
        });


        leftPanel.add(Box.createVerticalGlue());

        return leftPanel;
    }

    // Method to set up the right panel, adding different views - MODIFIED
    private void setupRightPanel() {
        this.cardLayout = new CardLayout();
        this.rightPanel = new JPanel(this.cardLayout);

        // Create and add different panels (views)
        JPanel tablePanel = createTablePanel(); // Table view
        JPanel aiPanel = createAIPanel(); // AI view
        JPanel adminStatsPanel = createAdminStatsPanel(); // Admin stats view
        this.visualizationPanel = new VisualizationPanel(this.transactionService); // NEW: Create VisualizationPanel, inject TransactionService


        rightPanel.add(tablePanel, "Table");
        rightPanel.add(aiPanel, "AI");
        if ("admin".equalsIgnoreCase(currentUser.getRole())) {
            rightPanel.add(adminStatsPanel, "AdminStats");
        }
        rightPanel.add(visualizationPanel, "Visualization"); // NEW: Add Visualization panel


        // Set the initially visible card (Table view)
        cardLayout.show(rightPanel, "Table");
    }

    // Method to create the table panel - same as before
    private JPanel createTablePanel() {
        JPanel tablePanel = new JPanel(new BorderLayout());

        JPanel inputPanel = createInputPanel(); // This method now initializes search fields
        tablePanel.add(inputPanel, BorderLayout.NORTH);

        JScrollPane tableScrollPane = new JScrollPane(this.table);
        tableScrollPane.setPreferredSize(new Dimension(1000, 250)); // Preferred size hint
        this.table.setFillsViewportHeight(true); // Make table fill the scroll pane height
        this.table.setRowHeight(30);

        tablePanel.add(tableScrollPane, BorderLayout.CENTER);

        // Set cell renderers and editors
        this.table.getColumnModel().getColumn(11).setCellRenderer(new ButtonRenderer());
        this.table.getColumnModel().getColumn(11).setCellEditor(new ButtonEditor(this));

        this.table.getColumnModel().getColumn(12).setCellRenderer(new ButtonRenderer());
        this.table.getColumnModel().getColumn(12).setCellEditor(new ButtonEditor(this));

        // Initial data load is done in the MenuUI constructor or createMainPanel
        // loadCSVDataForCurrentUser("收入"); // Moved to createMainPanel

        return tablePanel;
    }

    // Inside MenuUI class
    private JPanel createInputPanel() {
        JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));

        // Create input fields and capture references (existing code)
        searchTransactionTimeField = new JTextField(10);
        searchTransactionTypeField = new JTextField(10);
        searchCounterpartyField = new JTextField(10);
        searchCommodityField = new JTextField(10);
        searchInOutComboBox = new JComboBox<>(new String[]{"", "收入", "支出"});
        searchPaymentMethodField = new JTextField(10);

        // Add labels and input fields (existing code)
        inputPanel.add(new JLabel("交易时间:")); inputPanel.add(searchTransactionTimeField);
        inputPanel.add(new JLabel("交易类型:")); inputPanel.add(searchTransactionTypeField);
        inputPanel.add(new JLabel("交易对方:")); inputPanel.add(searchCounterpartyField);
        inputPanel.add(new JLabel("商品:")); inputPanel.add(searchCommodityField);
        inputPanel.add(new JLabel("收/支:")); inputPanel.add(searchInOutComboBox);
        inputPanel.add(new JLabel("支付方式:")); inputPanel.add(searchPaymentMethodField);

        // Create Search, Add, and Import buttons
        searchButton = new JButton("Search");
        JButton addButton = new JButton("Add");
        JButton importButton = new JButton("导入 CSV"); // 新增导入按钮

        // Add buttons
        inputPanel.add(searchButton);
        inputPanel.add(addButton);
        inputPanel.add(importButton); // 添加导入按钮

        // Add ActionListeners (existing code for Search and Add)
        searchButton.addActionListener(e -> triggerCurrentSearch());
        addButton.addActionListener(e -> showAddTransactionDialog());

        // Add ActionListener for Import button
        importButton.addActionListener(e -> {
            showImportDialog(); // Call a new method to handle import
        });

        return inputPanel;
    }

    // Inside MenuUI class
    private void showImportDialog() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("选择要导入的CSV文件");
        // Optional: Add file filter for .csv files
        fileChooser.setFileFilter(new javax.swing.filechooser.FileNameExtensionFilter("CSV Files (*.csv)", "csv"));

        int userSelection = fileChooser.showOpenDialog(this); // Show dialog relative to MenuUI panel

        if (userSelection == JFileChooser.APPROVE_OPTION) {
            java.io.File fileToImport = fileChooser.getSelectedFile();
            String filePath = fileToImport.getAbsolutePath();
            System.out.println("用户选择了导入文件: " + filePath);

            // Display "Importing..." message and disable button (optional UI feedback)
            // This needs a status area, maybe in the main panel or a separate progress dialog.
            // For simplicity now, we'll just show messages.

            // Run import in a background thread
            // Need to pass the file path and the current user's file path to the service
            new Thread(() -> {
                String message;
                try {
                    // Call the service method to handle the import logic
                    int importedCount = transactionService.importTransactionsFromCsv(currentUser.getTransactionFilePath(), filePath);

                    message = "成功导入 " + importedCount + " 条交易记录。";
                    System.out.println(message);

                    // Update UI on EDT after successful import
                    String finalMessage = message;
                    SwingUtilities.invokeLater(() -> {
                        loadCSVDataForCurrentUser(""); // Reload all data to show imported items
                        clearSearchFields(); // Clear search fields after reload
                        JOptionPane.showMessageDialog(this, finalMessage, "导入成功", JOptionPane.INFORMATION_MESSAGE);
                    });

                } catch (Exception ex) { // Catch exceptions from the service layer
                    message = "导入失败！\n" + ex.getMessage();
                    System.err.println("CSV Import failed: " + ex.getMessage());
                    ex.printStackTrace();
                    // Update UI on EDT with error message
                    String finalMessage1 = message;
                    SwingUtilities.invokeLater(() -> {
                        JOptionPane.showMessageDialog(this, finalMessage1, "导入错误", JOptionPane.ERROR_MESSAGE);
                    });
                }
            }).start();
        } else {
            System.out.println("用户取消了文件选择。");
        }
    }

    // Inside MenuUI class, showAddTransactionDialog method
    private void showAddTransactionDialog() {
        JDialog addDialog = new JDialog();
        addDialog.setTitle("添加交易");
        JPanel dialogPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.insets = new Insets(5, 5, 5, 5);

        JTextField transactionTimeField = new JTextField(15);
        JTextField transactionTypeField = new JTextField(15);
        JButton aiSuggestButton = new JButton("AI分类建议");
        // Removed aiStatusLabel as we use a separate waiting dialog


        JTextField counterpartyField = new JTextField(15);
        JTextField commodityField = new JTextField(15);
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"});
        JTextField paymentAmountField = new JTextField(15);
        JTextField paymentMethodField = new JTextField(15);
        JTextField currentStatusField = new JTextField(15);
        JTextField orderNumberField = new JTextField(15);
        JTextField merchantNumberField = new JTextField(15);
        JTextField remarksField = new JTextField(15);


        gbc.gridx = 0; gbc.gridy = 0; dialogPanel.add(new JLabel("交易时间:"), gbc);
        gbc.gridx = 1; gbc.gridy = 0; gbc.gridwidth = 2; dialogPanel.add(transactionTimeField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 1; dialogPanel.add(new JLabel("交易类型:"), gbc);
        gbc.gridx = 1; gbc.gridy = 1; gbc.weightx = 1.0; dialogPanel.add(transactionTypeField, gbc);
        gbc.gridx = 2; gbc.gridy = 1; gbc.weightx = 0.0; dialogPanel.add(aiSuggestButton, gbc);


        gbc.gridx = 0; gbc.gridy = 2; gbc.gridwidth = 1; dialogPanel.add(new JLabel("交易对方:"), gbc);
        gbc.gridx = 1; gbc.gridy = 2; gbc.gridwidth = 2; dialogPanel.add(counterpartyField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 3; gbc.gridwidth = 1; dialogPanel.add(new JLabel("商品:"), gbc);
        gbc.gridx = 1; gbc.gridy = 3; gbc.gridwidth = 2; dialogPanel.add(commodityField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 4; gbc.gridwidth = 1; dialogPanel.add(new JLabel("收/支:"), gbc);
        gbc.gridx = 1; gbc.gridy = 4; gbc.gridwidth = 2; dialogPanel.add(inOutComboBox, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 5; gbc.gridwidth = 1; dialogPanel.add(new JLabel("金额(元):"), gbc);
        gbc.gridx = 1; gbc.gridy = 5; gbc.gridwidth = 2; dialogPanel.add(paymentAmountField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 6; gbc.gridwidth = 1; dialogPanel.add(new JLabel("支付方式:"), gbc);
        gbc.gridx = 1; gbc.gridy = 6; gbc.gridwidth = 2; dialogPanel.add(paymentMethodField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 7; gbc.gridwidth = 1; dialogPanel.add(new JLabel("当前状态:"), gbc);
        gbc.gridx = 1; gbc.gridy = 7; gbc.gridwidth = 2; dialogPanel.add(currentStatusField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 8; gbc.gridwidth = 1; dialogPanel.add(new JLabel("交易单号:"));
        gbc.gridx = 1; gbc.gridy = 8; gbc.gridwidth = 2; dialogPanel.add(orderNumberField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 9; gbc.gridwidth = 1; dialogPanel.add(new JLabel("商户单号:"));
        gbc.gridx = 1; gbc.gridy = 9; gbc.gridwidth = 2; dialogPanel.add(merchantNumberField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 10; gbc.gridwidth = 1; dialogPanel.add(new JLabel("备注:"));
        gbc.gridx = 1; gbc.gridy = 10; gbc.gridwidth = 2; dialogPanel.add(remarksField, gbc); gbc.gridwidth = 1;


        // --- Define the modal waiting dialog ---
        JDialog waitingDialog = new JDialog(addDialog, "请稍候", true); // Modal dialog owned by addDialog
        waitingDialog.setLayout(new FlowLayout());
        waitingDialog.add(new JLabel("正在获取AI分类建议..."));
        waitingDialog.setSize(200, 100);
        waitingDialog.setResizable(false);
        // waitingDialog.setLocationRelativeTo(addDialog); // Set location later before showing
        // --- End waiting dialog definition ---


        // Add Confirm and Cancel buttons
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        JButton confirmButton = new JButton("确认");
        JButton cancelButton = new JButton("取消");
        buttonPanel.add(confirmButton);
        buttonPanel.add(cancelButton);

        gbc.gridx = 0; gbc.gridy = 11; gbc.gridwidth = 3; gbc.anchor = GridBagConstraints.CENTER; gbc.fill = GridBagConstraints.NONE; // Adjust gridy
        dialogPanel.add(buttonPanel, gbc);


        addDialog.add(dialogPanel, BorderLayout.CENTER);


        // Add AI Suggest button action listener - MODIFIED LOGIC FLOW
        aiSuggestButton.addActionListener(e -> {
            System.out.println("AI Suggest button clicked (EDT).");

            // 1. Disable button immediately on EDT
            aiSuggestButton.setEnabled(false);
            // confirmButton.setEnabled(false); // Optional: also disable confirm

            // 2. Build temporary transaction object from current fields
            Transaction tempTransaction = new Transaction(
                    emptyIfNull(transactionTimeField.getText().trim()),
                    emptyIfNull(transactionTypeField.getText().trim()), // Capture current potentially incomplete type
                    emptyIfNull(counterpartyField.getText().trim()),
                    emptyIfNull(commodityField.getText().trim()),
                    (String) inOutComboBox.getSelectedItem(),
                    safeParseDouble(paymentAmountField.getText().trim()),
                    emptyIfNull(paymentMethodField.getText().trim()),
                    emptyIfNull(currentStatusField.getText().trim()),
                    emptyIfNull(orderNumberField.getText().trim()),
                    emptyIfNull(merchantNumberField.getText().trim()),
                    emptyIfNull(remarksField.getText().trim())
            );

            // 3. Create and start the background thread FIRST
            new Thread(() -> {
                System.out.println("Background thread started for AI classification...");
                String aiSuggestion = null;
                try {
                    // Simulate delay for testing thread behavior
                    // Thread.sleep(3000); // Uncomment to simulate a 3-second delay
                    aiSuggestion = collegeStudentNeeds.RecognizeTransaction(tempTransaction);
                    System.out.println("AI Classification returned in background thread: " + aiSuggestion);
                } catch (Exception ex) {
                    System.err.println("Error in background AI thread: " + ex.getMessage());
                    ex.printStackTrace();
                    aiSuggestion = "Error: " + ex.getMessage(); // Capture error to display later
                }


                // 4. Schedule the UI update and dialog hiding on the EDT from the background thread
                String finalSuggestion = aiSuggestion; // Need a final variable for use in lambda
                SwingUtilities.invokeLater(() -> {
                    System.out.println("Updating UI on EDT from background thread.");
                    // --- Hide waiting dialog ---
                    waitingDialog.setVisible(false); // This is the call that unblocks the initial setVisible(true)

                    // --- Display AI suggestion ---
                    if (finalSuggestion != null && !finalSuggestion.isEmpty() && !finalSuggestion.startsWith("Error:")) {
                        // Safety Check: Although prompt asks for standard, AI might deviate.
                        // If AI *strictly* follows the prompt, this check might be redundant,
                        // but adding it makes the UI robust against unexpected AI output.
                        if (StandardCategories.ALL_KNOWN_TYPES.contains(finalSuggestion.trim())) {
                            transactionTypeField.setText(finalSuggestion.trim());
                        } else {
                            System.err.println("AI returned non-standard category despite prompt: " + finalSuggestion);
                            // Handle non-standard: Maybe use it anyway, or warn and clear.
                            // According to requirement: "分类严格符合所规定的那几类". If AI fails, we should not inject non-standard.
                            JOptionPane.showMessageDialog(addDialog, "AI返回了非预期的分类格式：\n" + finalSuggestion + "\n请手动输入。", "AI结果异常", JOptionPane.WARNING_MESSAGE);
                            transactionTypeField.setText(""); // Clear or set to default if AI fails strict adherence
                        }
                    } else if (finalSuggestion != null && finalSuggestion.startsWith("Error:")) {
                        // Handle the error case
                        JOptionPane.showMessageDialog(addDialog, "获取AI分类建议失败！\n" + finalSuggestion.substring(6), "AI错误", JOptionPane.ERROR_MESSAGE);
                        transactionTypeField.setText(""); // Clear the field on error
                    }
                    else { // AI returned null or empty
                        JOptionPane.showMessageDialog(addDialog, "AI未能提供分类建议。", "AI提示", JOptionPane.INFORMATION_MESSAGE);
                        transactionTypeField.setText("");
                    }

                    // 5. Re-enable buttons on EDT
                    aiSuggestButton.setEnabled(true);
                    // confirmButton.setEnabled(true);
                    System.out.println("UI update complete, buttons re-enabled.");
                });
            }).start();

            // --- 6. Show the modal waiting dialog LAST in the EDT block ---
            // This call will block the EDT until waitingDialog.setVisible(false) is called from the thread.
            System.out.println("Showing waiting dialog (EDT block continues here).");
            waitingDialog.setLocationRelativeTo(addDialog); // Center relative to add dialog before showing
            waitingDialog.setVisible(true); // THIS IS THE CALL THAT BLOCKS THE EDT
            System.out.println("waiting dialog is now hidden (EDT unblocked)."); // This line prints after dialog is hidden by the thread
        });


        // Add Confirm button action listener (existing validation logic)
        confirmButton.addActionListener(e -> {
            String transactionTime = emptyIfNull(transactionTimeField.getText().trim());
            String finalTransactionType = emptyIfNull(transactionTypeField.getText().trim());
            String counterparty = emptyIfNull(counterpartyField.getText().trim());
            String commodity = emptyIfNull(commodityField.getText().trim());
            String inOut = (String) inOutComboBox.getSelectedItem();
            String paymentAmountText = paymentAmountField.getText().trim();
            String paymentMethod = emptyIfNull(paymentMethodField.getText().trim());
            String currentStatus = emptyIfNull(currentStatusField.getText().trim());
            String orderNumber = emptyIfNull(orderNumberField.getText().trim());
            String merchantNumber = emptyIfNull(merchantNumberField.getText().trim());
            String remarks = emptyIfNull(remarksField.getText().trim());

            // --- Input Validation ---
            if (orderNumber.isEmpty()) {
                JOptionPane.showMessageDialog(addDialog, "交易单号不能为空！", "输入错误", JOptionPane.ERROR_MESSAGE);
                return;
            }

            if (finalTransactionType.isEmpty()) {
                JOptionPane.showMessageDialog(addDialog, "交易类型不能为空！", "输入错误", JOptionPane.ERROR_MESSAGE);
                return;
            }
            // Validate against standard categories if strict input is desired from user too
            if (!StandardCategories.ALL_KNOWN_TYPES.contains(finalTransactionType)) {
                JOptionPane.showMessageDialog(addDialog, "交易类型必须是标准类别之一！\n允许的类别:\n" + StandardCategories.getAllCategoriesString(), "输入错误", JOptionPane.ERROR_MESSAGE);
                return; // Enforce standard categories for manual input
            }


            double paymentAmount = 0.0;
            if (!paymentAmountText.isEmpty()) {
                try {
                    paymentAmount = Double.parseDouble(paymentAmountText);
                    // Optional: Check for non-negative amount for expenses/income
                    if (paymentAmount < 0) {
                        JOptionPane.showMessageDialog(addDialog, "金额不能为负数！", "输入错误", JOptionPane.ERROR_MESSAGE);
                        return;
                    }
                } catch (NumberFormatException ex) {
                    JOptionPane.showMessageDialog(addDialog, "金额格式不正确！请输入数字。", "输入错误", JOptionPane.ERROR_MESSAGE);
                    return;
                }
            }
            // --- End Validation ---


            Transaction newTransaction = new Transaction(
                    transactionTime,
                    finalTransactionType, // Use the final value from the field (now validated to be standard)
                    counterparty,
                    commodity,
                    inOut,
                    paymentAmount,
                    paymentMethod,
                    currentStatus,
                    orderNumber,
                    merchantNumber,
                    remarks
            );

            // Order number uniqueness check is better in service layer before saving

            try {
                // Optional: Check for duplicate order number in service layer before adding
                // if (!transactionService.isOrderNumberUnique(orderNumber)) {
                //      JOptionPane.showMessageDialog(addDialog, "交易单号 '" + orderNumber + "' 已存在！", "输入错误", JOptionPane.ERROR_MESSAGE);
                //      return;
                // }

                transactionService.addTransaction(newTransaction);

                loadCSVDataForCurrentUser(""); // Load all data after adding
                clearSearchFields();

                addDialog.dispose();
                JOptionPane.showMessageDialog(null, "交易添加成功！", "提示", JOptionPane.INFORMATION_MESSAGE);

            } catch (IOException ex) {
                ex.printStackTrace();
                // Change ERROR_ERROR to ERROR_MESSAGE
                JOptionPane.showMessageDialog(null, "交易添加失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
            } catch (Exception ex) {
                ex.printStackTrace();
                // Change ERROR_ERROR to ERROR_MESSAGE
                JOptionPane.showMessageDialog(null, "交易添加失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
            }
        });

        cancelButton.addActionListener(e -> addDialog.dispose());

        // --- Dialog setup and showing ---
        addDialog.pack(); // Pack the dialog to fit its components
        addDialog.setLocationRelativeTo(this); // Center relative to the MenuUI panel
        addDialog.setVisible(true); // Show the add dialog (this is the initial blocking call for the add dialog itself)
        // --- End Dialog setup ---
    }


    // Method to edit row - updated for AI integration and getting data from table model
    public void editRow(int rowIndex) {
        System.out.println("编辑行: " + rowIndex + " for user " + currentUser.getUsername());
        // Define JDialog, JPanel, GridBagConstraints at the start
        JDialog editDialog = new JDialog();
        JPanel dialogPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();


        if (rowIndex >= 0 && rowIndex < this.tableModel.getRowCount()) {
            Vector<String> rowData = new Vector<>();
            for (int i = 0; i <= 10; i++) { // Columns 0 to 10 are Transaction fields
                Object value = this.tableModel.getValueAt(rowIndex, i);
                rowData.add(value != null ? value.toString() : "");
            }
            System.out.println("Retrieved row data from table model for editing: " + rowData);

            String originalOrderNumber = rowData.get(8).trim();
            if (originalOrderNumber.isEmpty()) {
                JOptionPane.showMessageDialog(null, "无法编辑：交易单号为空！", "错误", JOptionPane.ERROR_MESSAGE);
                System.err.println("Attempted to edit row " + rowIndex + " but order number is empty.");
                // editDialog remains undefined here if this happens, might crash later if used.
                // Return immediately
                return;
            }


            editDialog.setTitle("修改交易信息 (订单号: " + originalOrderNumber + ")");
            editDialog.setModal(true);

            gbc.fill = GridBagConstraints.HORIZONTAL;
            gbc.insets = new Insets(5, 5, 5, 5);

            JTextField[] fields = new JTextField[11];
            String[] fieldNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"};
            JButton aiSuggestButton = new JButton("AI分类建议");


            for (int i = 0; i < fieldNames.length; i++) {
                gbc.gridx = 0; gbc.gridy = i; gbc.gridwidth = 1; gbc.weightx = 0.0; dialogPanel.add(new JLabel(fieldNames[i] + ":"), gbc);
                fields[i] = new JTextField(rowData.get(i));
                if (i == 1) { // Transaction Type field
                    gbc.gridx = 1; gbc.gridy = i; gbc.weightx = 1.0; dialogPanel.add(fields[i], gbc);
                    gbc.gridx = 2; gbc.gridy = i; gbc.weightx = 0.0; dialogPanel.add(aiSuggestButton, gbc);
                    gbc.gridwidth = 1;
                } else {
                    gbc.gridx = 1; gbc.gridy = i; gbc.gridwidth = 2; gbc.weightx = 1.0; dialogPanel.add(fields[i], gbc);
                    gbc.gridwidth = 1;
                }
            }

            fields[8].setEditable(false); // Disable editing OrderNumber field


            // --- Define the modal waiting dialog ---
            JDialog waitingDialog = new JDialog(editDialog, "请稍候", true); // Modal dialog owned by editDialog
            waitingDialog.setLayout(new FlowLayout());
            waitingDialog.add(new JLabel("正在获取AI分类建议..."));
            waitingDialog.setSize(200, 100);
            waitingDialog.setResizable(false);
            // waitingDialog.setLocationRelativeTo(editDialog); // Set location later before showing
            // --- End waiting dialog definition ---


            // Add Confirm and Cancel buttons
            JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
            JButton confirmButton = new JButton("确认");
            JButton cancelButton = new JButton("取消");
            buttonPanel.add(confirmButton);
            buttonPanel.add(cancelButton);

            gbc.gridx = 0; gbc.gridy = fieldNames.length; gbc.gridwidth = 3; gbc.anchor = GridBagConstraints.CENTER; gbc.fill = GridBagConstraints.NONE; dialogPanel.add(buttonPanel, gbc);


            editDialog.add(dialogPanel, BorderLayout.CENTER);


            // Add AI Suggest button action listener - MODIFIED LOGIC FLOW
            aiSuggestButton.addActionListener(e -> {
                System.out.println("AI Suggest button clicked (EDT) in edit dialog.");
                // 1. Disable button immediately on EDT
                aiSuggestButton.setEnabled(false);
                // confirmButton.setEnabled(false); // Optional: also disable confirm

                // 2. Build temporary transaction object from current fields
                Transaction tempTransaction = new Transaction(
                        fields[0].getText().trim(), fields[1].getText().trim(), fields[2].getText().trim(),
                        fields[3].getText().trim(), fields[4].getText().trim(), safeParseDouble(fields[5].getText().trim()),
                        fields[6].getText().trim(), fields[7].getText().trim(), fields[8].getText().trim(),
                        fields[9].getText().trim(), fields[10].getText().trim()
                );

                // 3. Create and start the background thread FIRST
                new Thread(() -> {
                    System.out.println("Background thread started for AI classification (edit dialog)...");
                    String aiSuggestion = null;
                    try {
                        // Simulate delay for testing thread behavior
                        // Thread.sleep(3000); // Uncomment to simulate a 3-second delay
                        aiSuggestion = collegeStudentNeeds.RecognizeTransaction(tempTransaction);
                        System.out.println("AI Classification returned in background thread (edit dialog): " + aiSuggestion);
                    } catch (Exception ex) {
                        System.err.println("Error in background AI thread (edit dialog): " + ex.getMessage());
                        ex.printStackTrace();
                        aiSuggestion = "Error: " + ex.getMessage(); // Capture error to display later
                    }


                    // 4. Schedule the UI update and dialog hiding on the EDT from the background thread
                    String finalSuggestion = aiSuggestion; // Need a final variable for use in lambda
                    SwingUtilities.invokeLater(() -> {
                        System.out.println("Updating UI on EDT from background thread (edit dialog).");
                        // --- Hide waiting dialog ---
                        waitingDialog.setVisible(false); // This is the call that unblocks the initial setVisible(true)

                        // --- Display AI suggestion ---
                        if (finalSuggestion != null && !finalSuggestion.isEmpty() && !finalSuggestion.startsWith("Error:")) {
                            // Safety Check: Although prompt asks for standard, AI might deviate.
                            if (StandardCategories.ALL_KNOWN_TYPES.contains(finalSuggestion.trim())) {
                                fields[1].setText(finalSuggestion.trim());
                            } else {
                                System.err.println("AI returned non-standard category despite prompt: " + finalSuggestion);
                                // Handle non-standard: Warn and clear/set to default
                                JOptionPane.showMessageDialog(editDialog, "AI返回了非预期的分类格式：\n" + finalSuggestion + "\n请手动输入。", "AI结果异常", JOptionPane.WARNING_MESSAGE);
                                fields[1].setText("");
                            }
                        } else if (finalSuggestion != null && finalSuggestion.startsWith("Error:")) {
                            // Handle the error case
                            JOptionPane.showMessageDialog(editDialog, "获取AI分类建议失败！\n" + finalSuggestion.substring(6), "AI错误", JOptionPane.ERROR_MESSAGE);
                            fields[1].setText("");
                        }
                        else { // AI returned null or empty
                            JOptionPane.showMessageDialog(editDialog, "AI未能提供分类建议。", "AI提示", JOptionPane.INFORMATION_MESSAGE);
                            fields[1].setText("");
                        }

                        // 5. Re-enable buttons on EDT
                        aiSuggestButton.setEnabled(true);
                        // confirmButton.setEnabled(true);
                        System.out.println("UI update complete, buttons re-enabled (edit dialog).");
                    });
                }).start();

                // --- 6. Show the modal waiting dialog LAST in the EDT block ---
                // This call will block the EDT until waitingDialog.setVisible(false) is called from the thread.
                System.out.println("Showing waiting dialog (EDT block continues here in edit dialog).");
                waitingDialog.setLocationRelativeTo(editDialog); // Center relative to edit dialog before showing
                waitingDialog.setVisible(true); // THIS IS THE CALL THAT BLOCKS THE EDT
                System.out.println("waiting dialog is now hidden (EDT unblocked in edit dialog)."); // This line prints after dialog is hidden by the thread
            });


            // Add Confirm and Cancel button listeners
            confirmButton.addActionListener(e -> {
                String transactionTime = fields[0].getText().trim();
                String finalTransactionType = fields[1].getText().trim();
                String counterparty = fields[2].getText().trim();
                String commodity = fields[3].getText().trim();
                String inOut = fields[4].getText().trim();
                String paymentAmountText = fields[5].getText().trim();
                String paymentMethod = fields[6].getText().trim();
                String currentStatus = fields[7].getText().trim();
                // Original ON is used from the variable 'originalOrderNumber' defined outside this listener
                String merchantNumber = fields[9].getText().trim();
                String remarks = fields[10].getText().trim();

                // --- Input Validation ---
                if (finalTransactionType.isEmpty()) {
                    JOptionPane.showMessageDialog(editDialog, "交易类型不能为空！", "输入错误", JOptionPane.ERROR_MESSAGE);
                    return;
                }
                // Validate against standard categories
                if (!StandardCategories.ALL_KNOWN_TYPES.contains(finalTransactionType)) {
                    JOptionPane.showMessageDialog(editDialog, "交易类型必须是标准类别之一！\n允许的类别:\n" + StandardCategories.getAllCategoriesString(), "输入错误", JOptionPane.ERROR_MESSAGE);
                    return; // Enforce standard categories for manual input
                }
                // Validate 收/支 is one of expected values
                if (!inOut.equals("收入") && !inOut.equals("支出") && !inOut.equals("收") && !inOut.equals("支")) {
                    JOptionPane.showMessageDialog(editDialog, "收/支字段必须是 '收入' 或 '支出'。", "输入错误", JOptionPane.ERROR_MESSAGE);
                    return;
                }

                double paymentAmount = 0.0;
                if (!paymentAmountText.isEmpty()) {
                    try {
                        paymentAmount = Double.parseDouble(paymentAmountText);
                        if (paymentAmount < 0) {
                            JOptionPane.showMessageDialog(editDialog, "金额不能为负数！", "输入错误", JOptionPane.ERROR_MESSAGE);
                            return;
                        }
                    } catch (NumberFormatException ex) {
                        JOptionPane.showMessageDialog(editDialog, "金额格式不正确！请输入数字。", "输入错误", JOptionPane.ERROR_MESSAGE);
                        return;
                    }
                }
                // --- End Validation ---


                Transaction updatedTransaction = new Transaction(
                        transactionTime, finalTransactionType, counterparty, commodity, inOut,
                        paymentAmount, paymentMethod, currentStatus, originalOrderNumber, // Use the correct originalOrderNumber
                        merchantNumber, remarks
                );


                try {
                    transactionService.changeTransaction(updatedTransaction);
                    System.out.println("Edit successful. Preparing to refresh display filtered by InOut: " + updatedTransaction.getInOut());
                    clearSearchFields();
                    String updatedInOut = updatedTransaction.getInOut();
                    boolean foundInOut = false;
                    for(int i=0; i < searchInOutComboBox.getItemCount(); i++) {
                        if (updatedInOut != null && updatedInOut.equals(searchInOutComboBox.getItemAt(i))) {
                            searchInOutComboBox.setSelectedItem(updatedInOut);
                            foundInOut = true;
                            break;
                        }
                    }
                    if (!foundInOut) { searchInOutComboBox.setSelectedItem(""); }

                    triggerCurrentSearch();

                    editDialog.dispose();
                    JOptionPane.showMessageDialog(null, "修改成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                    System.out.println("Edited row " + rowIndex + " for order number " + originalOrderNumber + " and refreshed display.");

                } catch (IllegalArgumentException ex) {
                    JOptionPane.showMessageDialog(editDialog, "修改失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
                    ex.printStackTrace();
                } catch (Exception ex) {
                    ex.printStackTrace();
                    // Change ERROR_ERROR to ERROR_MESSAGE
                    JOptionPane.showMessageDialog(editDialog, "修改失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
                }
            });

            cancelButton.addActionListener(e -> editDialog.dispose());

            // --- Dialog setup and showing ---
            editDialog.pack();
            editDialog.setLocationRelativeTo(this);
            editDialog.setVisible(true); // Show the edit dialog (this is the initial blocking call for the edit dialog itself)
            // --- End Dialog setup ---

        } else {
            // This block is for invalid rowIndex. The dialog shouldn't be shown.
            // Remove the confusing editDialog.pack/setLocation/setVisible calls here.
            System.err.println("Attempted to edit row with invalid index: " + rowIndex + ". Table row count: " + this.tableModel.getRowCount());
        }
        // Remove the final redundant pack/setLocation/setVisible calls outside the if block
        // if (editDialog != null) { editDialog.pack(); }
        // if (editDialog != null) { editDialog.setLocationRelativeTo(this); }
        // if (editDialog != null) { editDialog.setVisible(true); } // Redundant if dialog shown in the if block
    }

    // Method to create the AI panel - UPDATED
    private JPanel createAIPanel() {
        JPanel panel = new JPanel(new BorderLayout(10, 10));
        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // Panel for General AI Analysis
        JPanel generalAnalysisPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));
        JTextField userRequestField = new JTextField(40);
        aiStartTimeField = new JTextField(10);
        aiEndTimeField = new JTextField(10);
        aiAnalyzeButton = new JButton("通用分析 (按原始数据)"); // Clarify this uses raw data


        generalAnalysisPanel.add(new JLabel("通用分析要求:"));
        generalAnalysisPanel.add(userRequestField);
        generalAnalysisPanel.add(new JLabel("时间范围 (yyyy/MM/dd HH:mm): 从:"));
        generalAnalysisPanel.add(aiStartTimeField);
        generalAnalysisPanel.add(new JLabel("到:"));
        generalAnalysisPanel.add(aiEndTimeField);
        generalAnalysisPanel.add(aiAnalyzeButton);


        // Panel for Summary-Based AI Analysis (NEW)
        JPanel summaryAnalysisPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));
        aiPersonalSummaryButton = new JButton("个人消费总结"); // New button
        aiSavingsGoalsButton = new JButton("储蓄目标建议"); // New button
        aiPersonalSavingTipsButton = new JButton("个性化节约建议"); // New button

        summaryAnalysisPanel.add(new JLabel("基于月度总结分析:"));
        summaryAnalysisPanel.add(aiPersonalSummaryButton);
        summaryAnalysisPanel.add(aiSavingsGoalsButton);
        summaryAnalysisPanel.add(aiPersonalSavingTipsButton);


        // Panel for College Student Needs buttons (existing)
        JPanel csButtonsPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10)); // Align left for consistency
        aiBudgetButton = new JButton("预算建议 (学生)"); // Clarify this is student-specific
        aiTipsButton = new JButton("省钱技巧 (学生)"); // Clarify this is student-specific
        csButtonsPanel.add(new JLabel("大学生专属功能:"));
        csButtonsPanel.add(aiBudgetButton);
        csButtonsPanel.add(aiTipsButton);


        // Combine all control panels in a box layout
        JPanel topControlPanel = new JPanel();
        topControlPanel.setLayout(new BoxLayout(topControlPanel, BoxLayout.Y_AXIS));
        topControlPanel.add(generalAnalysisPanel);
        topControlPanel.add(Box.createRigidArea(new Dimension(0, 10))); // Spacing
        topControlPanel.add(summaryAnalysisPanel); // Add new panel
        topControlPanel.add(Box.createRigidArea(new Dimension(0, 10))); // Spacing
        topControlPanel.add(csButtonsPanel); // Add existing CS panel
        topControlPanel.add(Box.createRigidArea(new Dimension(0, 10))); // Spacing


        panel.add(topControlPanel, BorderLayout.NORTH);

        // Center area for displaying AI results - same as before
        aiResultArea = new JTextArea();
        aiResultArea.setFont(new Font("微软雅黑", Font.PLAIN, 14));
        aiResultArea.setLineWrap(true);
        aiResultArea.setWrapStyleWord(true);
        aiResultArea.setEditable(false);
        aiResultArea.setText("欢迎使用AI个人财务分析功能。\n\n" +
                "您可以尝试以下操作：\n" +
                "1. 在上方输入框提出通用分析要求（基于原始数据，可指定时间范围），点击\"通用分析\"。\n" +
                "2. 点击\"个人消费总结\"，获取基于您月度收支汇总的详细总结。\n" +
                "3. 点击\"储蓄目标建议\"，获取基于您收支情况的储蓄建议。\n" +
                "4. 点击\"个性化节约建议\"，获取基于您消费类别的节约建议。\n" +
                "5. 大学生用户可点击\"预算建议\"和\"省钱技巧\"获取专属建议。\n");


        JScrollPane resultScrollPane = new JScrollPane(aiResultArea);
        panel.add(resultScrollPane, BorderLayout.CENTER);


        // --- Add Action Listeners for NEW Buttons ---

        aiPersonalSummaryButton.addActionListener(e -> {
            aiResultArea.setText("--- 个人消费总结生成中 ---\n\n正在根据您的月度消费数据生成总结，请稍候...\n");
            setAIButtonsEnabled(false);

            new Thread(() -> {
                String result = aiTransactionService.generatePersonalSummary(currentUser.getTransactionFilePath()); // Call the new method

                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- 个人消费总结 ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        aiSavingsGoalsButton.addActionListener(e -> {
            aiResultArea.setText("--- 储蓄目标建议生成中 ---\n\n正在根据您的收支情况生成储蓄目标建议，请稍候...\n");
            setAIButtonsEnabled(false);

            new Thread(() -> {
                String result = aiTransactionService.suggestSavingsGoals(currentUser.getTransactionFilePath()); // Call the new method

                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- 储蓄目标建议 ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        aiPersonalSavingTipsButton.addActionListener(e -> {
            aiResultArea.setText("--- 个性化节约建议生成中 ---\n\n正在根据您的消费类别生成节约建议，请稍候...\n");
            setAIButtonsEnabled(false);

            new Thread(() -> {
                String result = aiTransactionService.givePersonalSavingTips(currentUser.getTransactionFilePath()); // Call the new method

                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- 个性化节约建议 ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });


        // --- Action Listeners for EXISTING Buttons (UPDATE PROMPTS/HEADERS) ---
        // Update existing listeners to use better headers/messages

        // General Analyze Button
        aiAnalyzeButton.addActionListener(e -> {
            String userRequest = userRequestField.getText().trim();
            String startTimeStr = aiStartTimeField.getText().trim();
            String endTimeStr = aiEndTimeField.getText().trim();

            if (userRequest.isEmpty()) {
                JOptionPane.showMessageDialog(this, "请输入AI通用分析要求。", "输入提示", JOptionPane.INFORMATION_MESSAGE);
                return;
            }
            if (startTimeStr.isEmpty() && !endTimeStr.isEmpty()) {
                JOptionPane.showMessageDialog(this, "请至少输入分析的开始时间。", "输入提示", JOptionPane.INFORMATION_MESSAGE);
                return;
            }


            aiResultArea.setText("--- 通用分析生成中 ---\n\n" + "正在进行AI通用分析，请稍候...\n");
            setAIButtonsEnabled(false);


            new Thread(() -> {
                String result = aiTransactionService.analyzeTransactions(userRequest, currentUser.getTransactionFilePath(), startTimeStr, endTimeStr);

                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- 通用分析结果 ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        // College Student Budget Button
        aiBudgetButton.addActionListener(e -> {
            aiResultArea.setText("--- 大学生预算建议生成中 ---\n\n正在根据您的历史支出生成预算建议，请稍候...\n");
            setAIButtonsEnabled(false);

            new Thread(() -> {
                String resultMessage;
                try {
                    double[] budgetRange = collegeStudentNeeds.generateBudget(currentUser.getTransactionFilePath());
                    if (budgetRange != null && budgetRange.length == 2 && budgetRange[0] != -1) {
                        resultMessage = String.format("根据您的消费记录，下周的建议预算范围是: [%.2f元, %.2f元]", budgetRange[0], budgetRange[1]);
                    } else if (budgetRange != null && budgetRange.length == 2 && budgetRange[0] == -1) {
                        resultMessage = "暂无足够的消费记录来计算周预算建议。";
                    }
                    else {
                        resultMessage = "生成预算建议失败，AI未能返回有效范围。";
                        System.err.println("AI Budget generation failed, invalid response format.");
                    }
                } catch (Exception ex) {
                    resultMessage = "生成预算建议失败！\n" + ex.getMessage();
                    System.err.println("Error generating AI budget:");
                    ex.printStackTrace();
                }

                String finalResultMessage = resultMessage;
                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- 大学生预算建议 ---\n\n" + finalResultMessage);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        // College Student Tips Button
        aiTipsButton.addActionListener(e -> {
            aiResultArea.setText("--- 大学生省钱技巧生成中 ---\n\n正在生成省钱技巧，请稍候...\n");
            setAIButtonsEnabled(false);

            new Thread(() -> {
                String resultMessage;
                try {
                    // Call the CollegeStudentNeeds method (now uses monthly summary)
                    resultMessage = collegeStudentNeeds.generateTipsForSaving(currentUser.getTransactionFilePath());

                } catch (Exception ex) {
                    resultMessage = "生成省钱技巧失败！\n" + ex.getMessage();
                    System.err.println("Error generating AI tips:");
                    ex.printStackTrace();
                }

                String finalResultMessage = resultMessage;
                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- 大学生省钱技巧 ---\n\n" + finalResultMessage);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });


        return panel;
    }

    // Helper method to enable/disable all AI related buttons - UPDATED
    private void setAIButtonsEnabled(boolean enabled) {
        if (aiAnalyzeButton != null) aiAnalyzeButton.setEnabled(enabled);
        if (aiBudgetButton != null) aiBudgetButton.setEnabled(enabled);
        if (aiTipsButton != null) aiTipsButton.setEnabled(enabled);
        // Enable/disable new buttons
        if (aiPersonalSummaryButton != null) aiPersonalSummaryButton.setEnabled(enabled);
        if (aiSavingsGoalsButton != null) aiSavingsGoalsButton.setEnabled(enabled);
        if (aiPersonalSavingTipsButton != null) aiPersonalSavingTipsButton.setEnabled(enabled);
    }


    // Method to create the Admin Stats panel (Implement the placeholder)
    private JPanel createAdminStatsPanel() {
        JPanel panel = new JPanel(new BorderLayout(10, 10));
        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        generateStatsButton = new JButton("生成/更新统计数据"); // Assign to instance field
        refreshDisplayButton = new JButton("刷新显示"); // Assign to instance field

        controlPanel.add(generateStatsButton);
        controlPanel.add(refreshDisplayButton);

        panel.add(controlPanel, BorderLayout.NORTH);

        adminStatsArea = new JTextArea(); // Assign to instance field
        adminStatsArea.setFont(new Font("微软雅黑", Font.PLAIN, 14));
        adminStatsArea.setEditable(false);
        adminStatsArea.setLineWrap(true); // Enable line wrapping
        adminStatsArea.setWrapStyleWord(true); // Wrap at word boundaries
        JScrollPane scrollPane = new JScrollPane(adminStatsArea);
        panel.add(scrollPane, BorderLayout.CENTER);


        generateStatsButton.addActionListener(e -> {
            adminStatsArea.setText("正在生成/更新汇总统计数据，请稍候...\n");
            generateStatsButton.setEnabled(false);
            refreshDisplayButton.setEnabled(false);

            new Thread(() -> {
                String message;
                try {
                    // Use the injected SummaryStatisticService
                    summaryStatisticService.generateAndSaveWeeklyStatistics();
                    message = "汇总统计数据生成/更新成功！\n请点击 '刷新显示' 查看最新数据。";
                    System.out.println(message);
                } catch (Exception ex) {
                    message = "汇总统计数据生成/更新失败！\n" + ex.getMessage();
                    System.err.println(message);
                    ex.printStackTrace();
                }

                String finalMessage = message;
                SwingUtilities.invokeLater(() -> {
                    adminStatsArea.setText(finalMessage);
                    generateStatsButton.setEnabled(true);
                    refreshDisplayButton.setEnabled(true);
                });
            }).start();
        });

        refreshDisplayButton.addActionListener(e -> {
            displaySummaryStatistics();
        });

        // Initial display when the panel is first shown (Optional)
        // Load existing stats when the panel is created, before it's potentially shown
        // This avoids a blank screen initially.
        new Thread(() -> {
            SwingUtilities.invokeLater(() -> adminStatsArea.setText("正在加载现有统计数据...\n"));
            try {
                List<SummaryStatistic> initialStats = summaryStatisticService.getAllSummaryStatistics();
                if (!initialStats.isEmpty()) {
                    // If initial stats exist, display them
                    SwingUtilities.invokeLater(this::displaySummaryStatistics);
                } else {
                    SwingUtilities.invokeLater(() -> adminStatsArea.setText("没有找到现有的汇总统计数据。\n请点击 '生成/更新统计数据' 按钮来生成。"));
                }
            } catch (IOException ex) {
                SwingUtilities.invokeLater(() -> adminStatsArea.setText("加载现有统计数据失败！\n" + ex.getMessage()));
                ex.printStackTrace();
            }
        }).start();


        return panel;
    }

    // Method to display summary statistics (Implement the placeholder)
    private void displaySummaryStatistics() {
        adminStatsArea.setText("正在加载汇总统计数据...\n");
        // Optional: Disable buttons while loading
        if(generateStatsButton != null) generateStatsButton.setEnabled(false);
        if(refreshDisplayButton != null) refreshDisplayButton.setEnabled(false);


        new Thread(() -> {
            String displayContent;
            try {
                List<SummaryStatistic> stats = summaryStatisticService.getAllSummaryStatistics();
                if (stats.isEmpty()) {
                    displayContent = "目前没有汇总统计数据。\n请先点击 '生成/更新统计数据' 按钮。";
                } else {
                    StringBuilder sb = new StringBuilder("===== 汇总统计数据 =====\n\n");
                    // Sort stats by week identifier (chronologically) before displaying
                    stats.sort(Comparator.comparing(SummaryStatistic::getWeekIdentifier));

                    // Display newest week first
                    for (int i = stats.size() - 1; i >= 0; i--) {
                        SummaryStatistic stat = stats.get(i);
                        sb.append("周标识: ").append(stat.getWeekIdentifier()).append("\n");
                        sb.append("  总收入: ").append(String.format("%.2f", stat.getTotalIncomeAllUsers())).append("元\n");
                        sb.append("  总支出: ").append(String.format("%.2f", stat.getTotalExpenseAllUsers())).append("元\n");
                        // Only show top category if there was actual expense in that category
                        if (stat.getTopExpenseCategoryAmount() > 0) {
                            sb.append("  最高支出类别: ").append(stat.getTopExpenseCategory()).append(" (").append(String.format("%.2f", stat.getTopExpenseCategoryAmount())).append("元)\n");
                        } else {
                            sb.append("  最高支出类别: 无显著支出类别\n"); // Or "无支出" if total expense is 0
                        }

                        sb.append("  参与用户数: ").append(stat.getNumberOfUsersWithTransactions()).append("\n");
                        sb.append("  生成时间: ").append(stat.getTimestampGenerated()).append("\n");
                        sb.append("--------------------\n");
                    }
                    displayContent = sb.toString();
                }
            } catch (IOException ex) {
                displayContent = "加载汇总统计数据失败！\n" + ex.getMessage();
                ex.printStackTrace();
            }

            String finalDisplayContent = displayContent;
            SwingUtilities.invokeLater(() -> {
                adminStatsArea.setText(finalDisplayContent);
                // Re-enable buttons
                if(generateStatsButton != null) generateStatsButton.setEnabled(true);
                if(refreshDisplayButton != null) refreshDisplayButton.setEnabled(true);
            });
        }).start();
    }

    // Method to delete row - get data from tableModel (remove allData usage)
    public void deleteRow(int rowIndex) {
        System.out.println("尝试删除行: " + rowIndex + " for user " + currentUser.getUsername());
        if (rowIndex >= 0 && rowIndex < this.tableModel.getRowCount()) { // Use tableModel row count

            // Get the order number directly from the displayed table row
            String orderNumber = (String) this.tableModel.getValueAt(rowIndex, 8); // OrderNumber is at index 8
            if (orderNumber == null || orderNumber.trim().isEmpty()) {
                JOptionPane.showMessageDialog(null, "无法删除：交易单号为空！", "错误", JOptionPane.ERROR_MESSAGE);
                System.err.println("Attempted to delete row " + rowIndex + " but order number is null or empty.");
                return; // Cannot delete without an order number
            }
            orderNumber = orderNumber.trim();
            System.out.println("Deleting transaction with order number: " + orderNumber);

            // Optional: Ask for confirmation before deleting
            int confirm = JOptionPane.showConfirmDialog(
                    this, // Parent component
                    "确定要删除订单号为 '" + orderNumber + "' 的交易吗？",
                    "确认删除",
                    JOptionPane.YES_NO_OPTION,
                    JOptionPane.QUESTION_MESSAGE
            );

            if (confirm == JOptionPane.YES_OPTION) {
                try {
                    // Use the injected transactionService instance
                    boolean deleted = transactionService.deleteTransaction(orderNumber);

                    if (deleted) {
                        // Data is removed from CSV and cache invalidated by service.
                        // Update the UI model directly by removing the row.
                        // This is faster than reloading all data for just one deletion.
                        this.tableModel.removeRow(rowIndex);

                        JOptionPane.showMessageDialog(null, "删除成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                        System.out.println("Deleted row " + rowIndex + " with order number " + orderNumber + " from UI.");

                        // After delete, refresh the view by re-applying the current search/filter criteria.
                        triggerCurrentSearch();

                    } else {
                        // This case means the service said it wasn't deleted (likely not found)
                        // This might happen if the underlying data changed between loading and deleting
                        JOptionPane.showMessageDialog(null, "删除失败：未找到对应的交易单号 " + orderNumber, "错误", JOptionPane.ERROR_MESSAGE);
                        System.err.println("Delete failed: order number " + orderNumber + " not found by service.");
                    }
                } catch (Exception ex) {
                    ex.printStackTrace();
                    JOptionPane.showMessageDialog(null, "删除失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
                    System.err.println("Error during deletion for order number " + orderNumber);
                }
            } else {
                System.out.println("Deletion cancelled by user for order number: " + orderNumber);
            }
        } else {
            System.err.println("Attempted to delete row with invalid index: " + rowIndex + ". Table row count: " + this.tableModel.getRowCount());
        }
    }

    // Method to create table row from Transaction object - no changes needed here
    private Vector<String> createRowFromTransaction(Transaction transaction) {
        Vector<String> row = new Vector<>();
        row.add(emptyIfNull(transaction.getTransactionTime()));
        row.add(emptyIfNull(transaction.getTransactionType()));
        row.add(emptyIfNull(transaction.getCounterparty()));
        row.add(emptyIfNull(transaction.getCommodity()));
        row.add(emptyIfNull(transaction.getInOut()));
        row.add(String.valueOf(transaction.getPaymentAmount()));
        row.add(emptyIfNull(transaction.getPaymentMethod()));
        row.add(emptyIfNull(transaction.getCurrentStatus()));
        row.add(emptyIfNull(transaction.getOrderNumber()));
        row.add(emptyIfNull(transaction.getMerchantNumber()));
        row.add(emptyIfNull(transaction.getRemarks()));
        row.add("Modify");
        row.add("Delete");
        return row;
    }

    // Method to search data - same as before
    public void searchData(String query1, String query2, String query3, String query4, String query6, String query5) {
        // ... existing implementation ...
        System.out.println("Searching with criteria: time='" + query1 + "', type='" + query2 + "', counterparty='" + query3 + "', commodity='" + query4 + "', inOut='" + query6 + "', paymentMethod='" + query5 + "'");
        this.tableModel.setRowCount(0);

        Transaction searchCriteria = new Transaction(
                query1, query2, query3, query4, query6,
                0,
                query5,
                "", "", "", ""
        );

        try {
            List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);
            System.out.println("Search results count: " + transactions.size());
            for (Transaction transaction : transactions) {
                Vector<String> row = createRowFromTransaction(transaction);
                this.tableModel.addRow(row);
            }

        } catch (Exception ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(null, "查询失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
        }
    }


    // ... safeParseDouble, clearSearchFields, triggerCurrentSearch, emptyIfNull, getTable methods ...
    private double safeParseDouble(String value) {
        if (value == null || value.trim().isEmpty()) return 0.0;
        try { return Double.parseDouble(value.trim()); }
        catch (NumberFormatException e) { System.err.println("Failed to parse double from string: '" + value + "'"); return 0.0; }
    }
    private void clearSearchFields() {
        searchTransactionTimeField.setText("");
        searchTransactionTypeField.setText("");
        searchCounterpartyField.setText("");
        searchCommodityField.setText("");
        searchInOutComboBox.setSelectedItem("");
        searchPaymentMethodField.setText("");
        System.out.println("Cleared search fields.");
    }
    private void triggerCurrentSearch() {
        searchData(
                searchTransactionTimeField.getText().trim(),
                searchTransactionTypeField.getText().trim(),
                searchCounterpartyField.getText().trim(),
                searchCommodityField.getText().trim(),
                (String) searchInOutComboBox.getSelectedItem(),
                searchPaymentMethodField.getText().trim()
        );
        System.out.println("Triggered search with current field values.");
    }
    private String emptyIfNull(String value) {
        return value == null ? "" : value;
    }
    public JTable getTable() {
        return table;
    }

}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Controller\VisualizationPanel.java`:

```java
package Controller;

import Service.TransactionService;
import model.MonthlySummary;

import java.awt.*;
import java.util.Map;
import java.util.List; // Import List
import java.util.ArrayList; // Import ArrayList
import java.util.HashMap; // Import HashMap
import java.util.Collections; // Import Collections for sorting
import java.util.Comparator; // Import Comparator

import javax.swing.*;

// Import XChart classes
import org.knowm.xchart.CategoryChart;
import org.knowm.xchart.CategoryChartBuilder;
import org.knowm.xchart.PieChart;
import org.knowm.xchart.PieChartBuilder;
import org.knowm.xchart.SwingWrapper; // Might be needed for Swing components
import org.knowm.xchart.XChartPanel; // Use XChartPanel for Swing display
import org.knowm.xchart.style.Styler.LegendPosition; // For chart styling


/**
 * Panel to display transaction data visualizations using XChart.
 */
public class VisualizationPanel extends JPanel {

    private final TransactionService transactionService;

    private JComboBox<String> monthSelector;
    private JComboBox<String> chartTypeSelector;
    private JButton generateChartButton;
    private JPanel chartDisplayPanel;


    /**
     * Constructor to inject the TransactionService.
     * @param transactionService The service to retrieve user transaction data.
     */
    public VisualizationPanel(TransactionService transactionService) {
        this.transactionService = transactionService;
        setLayout(new BorderLayout(10, 10));
        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // --- Control Panel (Top) ---
        JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 5));

        chartTypeSelector = new JComboBox<>(new String[]{"请选择图表类型", "月度支出分类饼图", "月度收支趋势柱状图"});
        controlPanel.add(new JLabel("图表类型:"));
        controlPanel.add(chartTypeSelector);

        monthSelector = new JComboBox<>();
        monthSelector.setEnabled(false);
        controlPanel.add(new JLabel("选择月份:"));
        controlPanel.add(monthSelector);


        generateChartButton = new JButton("生成图表");
        controlPanel.add(generateChartButton);

        add(controlPanel, BorderLayout.NORTH);


        // --- Chart Display Panel (Center) ---
        chartDisplayPanel = new JPanel(new BorderLayout());
        chartDisplayPanel.setBackground(Color.WHITE);
        add(chartDisplayPanel, BorderLayout.CENTER);


        // --- Action Listeners ---
        chartTypeSelector.addActionListener(e -> {
            String selectedType = (String) chartTypeSelector.getSelectedItem();
            boolean needsMonth = "月度支出分类饼图".equals(selectedType);
            monthSelector.setEnabled(needsMonth);
            // Populate months only when Pie Chart is selected
            if (needsMonth) {
                populateMonthSelector();
            } else {
                monthSelector.removeAllItems(); // Clear months if not needed
                monthSelector.addItem("请选择月份"); // Add default item back
            }
        });

        generateChartButton.addActionListener(e -> {
            generateAndDisplayChart();
        });

        // Initial state display
        displayPlaceholderChart("请选择一种图表类型和必要参数来生成图表。");

        // Initial data loading if needed on panel creation - Let's load months when Pie Chart is selected
        // populateMonthSelector(); // Removed, triggered by chart type selection
    }

    /**
     * Populates the month selector combo box with months from available data.
     */
    private void populateMonthSelector() {
        monthSelector.removeAllItems();
        monthSelector.addItem("请选择月份");

        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            if (summaries != null && !summaries.isEmpty()) {
                // Sort month identifiers chronologically
                summaries.keySet().stream().sorted().forEach(monthSelector::addItem);
                // monthSelector.setEnabled(true); // Enabled by chartTypeSelector listener
            } else {
                // monthSelector.setEnabled(false); // Disabled by chartTypeSelector listener
                JOptionPane.showMessageDialog(this, "没有找到月度交易数据来生成图表。", "数据不足", JOptionPane.INFORMATION_MESSAGE);
            }
        } catch (Exception e) {
            System.err.println("Error loading monthly summaries for month selector: " + e.getMessage());
            // monthSelector.setEnabled(false); // Disabled by chartTypeSelector listener
            JOptionPane.showMessageDialog(this, "加载月份数据失败！\n" + e.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
        }
    }


    /**
     * Generates and displays the selected chart based on user selection using XChart.
     */
    private void generateAndDisplayChart() {
        String selectedChartType = (String) chartTypeSelector.getSelectedItem();
        String selectedMonth = (String) monthSelector.getSelectedItem();

        // Clear previous chart
        chartDisplayPanel.removeAll();
        chartDisplayPanel.revalidate();
        chartDisplayPanel.repaint();

        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            if (summaries == null || summaries.isEmpty()) {
                displayPlaceholderChart("没有找到月度交易数据来生成图表。");
                return;
            }

            if ("月度支出分类饼图".equals(selectedChartType)) {
                if (selectedMonth == null || selectedMonth.equals("请选择月份") || selectedMonth.trim().isEmpty()) {
                    JOptionPane.showMessageDialog(this, "请选择要查看的月份。", "提示", JOptionPane.INFORMATION_MESSAGE);
                    displayPlaceholderChart("请选择一个有效的月份来生成饼图。");
                    return;
                }
                // --- Generate Pie Chart ---
                MonthlySummary selectedMonthSummary = summaries.get(selectedMonth);
                if (selectedMonthSummary == null || selectedMonthSummary.getExpenseByCategory().isEmpty()) {
                    displayPlaceholderChart(selectedMonth + " 月没有支出分类数据。");
                    return;
                }

                System.out.println("Generating Pie Chart for " + selectedMonth + "...");
                PieChart chart = new PieChartBuilder()
                        .width(chartDisplayPanel.getWidth())
                        .height(chartDisplayPanel.getHeight())
                        .title(selectedMonth + " 月支出分类")
                        .build();

                selectedMonthSummary.getExpenseByCategory().entrySet().stream()
                        .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                        .forEach(entry -> chart.addSeries(entry.getKey(), entry.getValue()));

                // Customize chart style (optional - COMMENT OUT lines causing errors)
                // chart.getStyler().setLegendVisible(true); // Keep if it works
                // chart.getStyler().setAnnotationType(org.knowm.xchart.style.Styler.AnnotationType.LabelAndPercentage); // COMMENT OUT or FIX
                // chart.getStyler().setDonutTogether(true); // COMMENT OUT or FIX

                // Add the chart to the display panel
                XChartPanel<PieChart> chartPanel = new XChartPanel<>(chart);
                chartDisplayPanel.add(chartPanel, BorderLayout.CENTER);
                System.out.println("Pie Chart generated and displayed.");


            } else if ("月度收支趋势柱状图".equals(selectedChartType)) {
                // --- Generate Bar Chart (Category Chart) ---
                System.out.println("Generating Monthly Income/Expense Trend Bar Chart...");

                List<String> months = new ArrayList<>();
                List<Double> totalIncomes = new ArrayList<>();
                List<Double> totalExpenses = new ArrayList<>();

                List<String> sortedMonths = new ArrayList<>(summaries.keySet());
                Collections.sort(sortedMonths);

                for (String month : sortedMonths) {
                    MonthlySummary ms = summaries.get(month);
                    months.add(month);
                    totalIncomes.add(ms.getTotalIncome());
                    totalExpenses.add(ms.getTotalExpense());
                }

                CategoryChart chart = new CategoryChartBuilder()
                        .width(chartDisplayPanel.getWidth())
                        .height(chartDisplayPanel.getHeight())
                        .title("月度收支趋势")
                        .xAxisTitle("月份")
                        .yAxisTitle("金额 (元)")
                        .build();

                chart.addSeries("总收入", months, totalIncomes);
                chart.addSeries("总支出", months, totalExpenses);

                // Customize chart style (optional - COMMENT OUT lines causing errors)
                // chart.getStyler().setLegendPosition(LegendPosition.OutsideS); // Keep if it works
                // chart.getStyler().setHasAnnotations(true); // COMMENT OUT or FIX
                // chart.getStyler().setStacked(false); // Keep if it works

                // Add the chart to the display panel
                XChartPanel<CategoryChart> chartPanel = new XChartPanel<>(chart);
                chartDisplayPanel.add(chartPanel, BorderLayout.CENTER);
                System.out.println("Bar Chart generated and displayed.");


            } else {
                displayPlaceholderChart("请选择一种图表类型和必要参数来生成图表。");
            }

        } catch (Exception e) {
            System.err.println("Error generating chart: " + selectedChartType);
            e.printStackTrace();
            displayPlaceholderChart("生成图表失败！\n" + e.getMessage());
            JOptionPane.showMessageDialog(this, "生成图表失败！\n" + e.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
        } finally {
            chartDisplayPanel.revalidate();
            chartDisplayPanel.repaint();
        }
    }

    /**
     * Helper method to display a placeholder message.
     */
    private void displayPlaceholderChart(String message) {
        // Clear previous content first
        chartDisplayPanel.removeAll();

        JLabel placeholderLabel = new JLabel(message, SwingConstants.CENTER);
        placeholderLabel.setFont(new Font("微软雅黑", Font.PLAIN, 16));
        chartDisplayPanel.add(placeholderLabel, BorderLayout.CENTER);

        chartDisplayPanel.revalidate();
        chartDisplayPanel.repaint();
    }

    // Optional: Method to trigger initial setup when panel is displayed
    // Call this from MenuUI's ActionListener for the Visualization button
    public void refreshPanelData() {
        System.out.println("VisualizationPanel refreshPanelData called.");
        // Populate month selector when the panel is visible
        // It's populated by the chartTypeSelector listener when Pie chart is selected.
        // So, no need to call populateMonthSelector here directly.

        // Reset chart type selector to default on refresh
        chartTypeSelector.setSelectedItem("请选择图表类型");
        // This action will trigger monthSelector logic

        // Display initial instruction message
        displayPlaceholderChart("请选择一种图表类型和必要参数来生成图表。");
    }

}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\DAO\Impl\CsvSummaryStatisticDao.java`:

```java
package DAO.Impl;

import DAO.SummaryStatisticDao;
import model.SummaryStatistic;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class CsvSummaryStatisticDao implements SummaryStatisticDao {

    // Define the header for the summary statistics CSV
    private static final String[] HEADERS = {
            "week_identifier", "total_income_all_users", "total_expense_all_users",
            "top_expense_category", "top_expense_category_amount",
            "number_of_users_with_transactions", "timestamp_generated"
    };

    @Override
    public List<SummaryStatistic> loadAllStatistics(String filePath) throws IOException {
        List<SummaryStatistic> statistics = new ArrayList<>();
        Path path = Paths.get(filePath);

        if (!Files.exists(path) || Files.size(path) == 0) {
            System.out.println("Summary statistics CSV file not found or is empty: " + filePath);
            return statistics;
        }

        try (Reader reader = new InputStreamReader(
                new BOMInputStream(Files.newInputStream(path)),
                StandardCharsets.UTF_8)) {

            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()
                    .withIgnoreHeaderCase(true)
                    .withTrim(true);

            try (CSVParser csvParser = new CSVParser(reader, format)) {
                Map<String, Integer> headerMap = csvParser.getHeaderMap();
                // Basic header validation
                List<String> requiredHeaders = List.of(HEADERS);
                if (headerMap == null || !headerMap.keySet().containsAll(requiredHeaders)) {
                    throw new IOException("Missing required headers in summary statistics CSV file: " + requiredHeaders +
                            " Found: " + (headerMap == null ? "null" : headerMap.keySet()));
                }

                for (CSVRecord record : csvParser) {
                    try {
                        SummaryStatistic stat = parseRecord(record);
                        if (stat != null) { // parseRecord might return null on error
                            statistics.add(stat);
                        }
                    } catch (Exception e) {
                        System.err.println("Skipping malformed summary statistic record at line " + record.getRecordNumber() + ": " + record.toString());
                        e.printStackTrace();
                    }
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading summary statistics from CSV: " + filePath);
            e.printStackTrace();
            throw e;
        }
        System.out.println("Successfully loaded " + statistics.size() + " summary statistics from " + filePath);
        return statistics;
    }

    // Helper to parse a single CSV record into a SummaryStatistic object
    private SummaryStatistic parseRecord(CSVRecord record) {
        // Defensive getting of values to prevent exceptions on missing columns
        String weekIdentifier = record.get("week_identifier");
        String totalIncomeStr = record.get("total_income_all_users");
        String totalExpenseStr = record.get("total_expense_all_users");
        String topExpenseCategory = record.get("top_expense_category");
        String topExpenseAmountStr = record.get("top_expense_category_amount");
        String numUsersStr = record.get("number_of_users_with_transactions");
        String timestampGenerated = record.get("timestamp_generated");

        // Basic validation for essential fields
        if (weekIdentifier == null || weekIdentifier.trim().isEmpty() ||
                totalIncomeStr == null || totalIncomeStr.trim().isEmpty() ||
                totalExpenseStr == null || totalExpenseStr.trim().isEmpty() ||
                numUsersStr == null || numUsersStr.trim().isEmpty() ||
                timestampGenerated == null || timestampGenerated.trim().isEmpty()) {
            System.err.println("Skipping summary record due to missing essential fields: " + record.toMap());
            return null; // Indicate parsing failed for this record
        }

        try {
            double totalIncome = Double.parseDouble(totalIncomeStr.trim());
            double totalExpense = Double.parseDouble(totalExpenseStr.trim());
            double topExpenseAmount = (topExpenseAmountStr != null && !topExpenseAmountStr.trim().isEmpty()) ? Double.parseDouble(topExpenseAmountStr.trim()) : 0.0;
            int numUsers = Integer.parseInt(numUsersStr.trim());

            return new SummaryStatistic(
                    weekIdentifier.trim(),
                    totalIncome,
                    totalExpense,
                    topExpenseCategory != null ? topExpenseCategory.trim() : "N/A", // Top category might be empty if no expenses
                    topExpenseAmount,
                    numUsers,
                    timestampGenerated.trim()
            );
        } catch (NumberFormatException e) {
            System.err.println("Skipping summary record due to number format error: " + record.toMap());
            e.printStackTrace();
            return null; // Indicate parsing failed
        }
    }


    @Override
    public void writeAllStatistics(String filePath, List<SummaryStatistic> statistics) throws IOException {
        Path path = Paths.get(filePath);
        // Ensure the directory exists
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }

        // Use a temporary file for atomic write
        File targetFile = path.toFile();
        File tempFile = File.createTempFile("summary_temp", ".csv", targetFile.getParentFile());

        try (BufferedWriter writer = Files.newBufferedWriter(tempFile.toPath(), StandardCharsets.UTF_8);
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(HEADERS).withTrim())) { // Always write header for overwrite

            for (SummaryStatistic stat : statistics) {
                csvPrinter.printRecord(
                        stat.getWeekIdentifier(),
                        stat.getTotalIncomeAllUsers(),
                        stat.getTotalExpenseAllUsers(),
                        stat.getTopExpenseCategory(),
                        stat.getTopExpenseCategoryAmount(),
                        stat.getNumberOfUsersWithTransactions(),
                        stat.getTimestampGenerated()
                );
            }
            // csvPrinter.flush(); // Auto-flushed on close
        } catch (IOException e) {
            tempFile.delete(); // Clean up temp file on failure
            System.err.println("Error writing summary statistics to temporary CSV file: " + tempFile.toPath());
            e.printStackTrace();
            throw e; // Re-throw
        }

        // Atomic replacement
        try {
            Files.move(tempFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
            System.out.println("Atomically replaced " + filePath + " with updated summary statistics.");
        } catch (IOException e) {
            System.err.println("Failed to atomically replace original summary file: " + targetFile.toPath());
            tempFile.delete(); // Clean up temp file
            e.printStackTrace();
            throw e; // Re-throw
        }
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\DAO\Impl\CsvTransactionDao.java`:

```java
package DAO.Impl; // Changed package

import Constants.ConfigConstants;
import DAO.TransactionDao; // Implement the interface
import model.Transaction;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional; // Using Optional for getTransactionByOrderNumber
import java.util.stream.Collectors;


public class CsvTransactionDao implements TransactionDao { // Implement TransactionDao interface

    // Remove the 'transactions' field and 'isLoad' flag, the cache/service layer will handle loading
    // private List<Transaction> transactions;
    // private boolean isLoad= false;

    // Keep the load method, it will be used by the cache loader
    @Override
    public List<Transaction> loadFromCSV(String filePath) throws IOException {
        List<Transaction> transactions = new ArrayList<>();
        Path path = Paths.get(filePath);

        // Check if file exists and is not empty before attempting to read
        if (!Files.exists(path) || Files.size(path) == 0) {
            System.out.println("CSV file not found or is empty: " + filePath);
            return transactions; // Return empty list if file doesn't exist or is empty
        }

        // Use BOMInputStream and InputStreamReader with UTF-8
        try (Reader reader = new InputStreamReader(
                new BOMInputStream(Files.newInputStream(path)), // Use path here directly
                StandardCharsets.UTF_8)) {

            // *** Simplified Header Handling: Let CSVParser handle the header detection ***
            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()    // Tell parser to treat the first line as header
                    .withIgnoreHeaderCase(true)  // Ignore case for robustness
                    .withTrim(true);             // Trim fields

            try (CSVParser csvParser = new CSVParser(reader, format)) {
                // After creating the parser with withFirstRecordAsHeader,
                // the header map should be available *if* a header was found.
                // Check if the required headers are present
                List<String> requiredHeaders = List.of(
                        "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)",
                        "支付方式", "当前状态", "交易单号", "商户单号", "备注"
                );

                // Now check the header map obtained *by the parser*
                Map<String, Integer> headerMap = csvParser.getHeaderMap();
                if (headerMap == null || !headerMap.keySet().containsAll(requiredHeaders)) {
                    // If headerMap is null (no header found) or incomplete
                    throw new IOException("Missing required headers in CSV file: " + requiredHeaders +
                            " Found: " + (headerMap == null ? "null" : headerMap.keySet()));
                }
                System.out.println("Successfully identified headers: " + headerMap.keySet() + " in file: " + filePath);


                for (CSVRecord record : csvParser) {
                    try {
                        transactions.add(parseRecord(record));
                    } catch (Exception e) {
                        System.err.println("Skipping malformed record at line " + record.getRecordNumber() + ": " + record.toString());
                        e.printStackTrace();
                    }
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading CSV file: " + filePath);
            e.printStackTrace();
            throw e;
        }
        System.out.println("Successfully loaded " + transactions.size() + " records from " + filePath);
        return transactions;
    }


    // Keep parseRecord private as it's an internal helper
    private Transaction parseRecord(CSVRecord record) {
        // Safely get and trim values, handle potential missing columns gracefully if needed
        String amountStr = record.get("金额(元)").trim();
        double paymentAmount = 0.0;
        try {
            if (amountStr.startsWith("¥")) {
                amountStr = amountStr.substring(1);
            }
            paymentAmount = Double.parseDouble(amountStr);
        } catch (NumberFormatException e) {
            System.err.println("Warning: Could not parse payment amount '" + record.get("金额(元)") + "' at line " + record.getRecordNumber());
            // Keep paymentAmount as 0.0 or handle as an error depending on strictness
        } catch (IllegalArgumentException e) {
            System.err.println("Warning: Missing '金额(元)' column or empty value at line " + record.getRecordNumber());
        }


        return new Transaction(
                record.get("交易时间").trim(),
                record.get("交易类型").trim(),
                record.get("交易对方").trim(),
                record.get("商品").trim(),
                record.get("收/支").trim(),
                paymentAmount, // Use parsed amount
                record.get("支付方式").trim(),
                record.get("当前状态").trim(),
                record.get("交易单号").trim(),
                record.get("商户单号").trim(),
                record.get("备注").trim()
        );
    }

    // Implement DAO interface methods properly
    public List<Transaction> getAllTransactions() throws IOException {
        // This method is now handled by the service layer using the cache.
        // The DAO should focus on direct file operations.
        // This interface method might be redundant if service layer always uses cache.
        // For clarity, let's make it load from CSV directly, but the service will prefer cache.
        // Note: This might re-read the file even if cached. Service layer needs to manage this.
        // Alternatively, this method could be removed from the interface/DAO if only cache loader uses loadFromCSV.
        // Let's keep it for now, assuming it's a direct file read fallback.
        System.out.println("DAO: Calling getAllTransactions directly from file (consider using service/cache)");
        // We need a way to know *which* file here. This method signature is problematic for multi-user.
        // The interface needs filePath, or the DAO instance needs to be created per file.
        // Let's adjust the interface/DAO to be file-specific or pass path to methods.
        // Option 1: DAO instance per file.
        // Option 2: Add filePath parameter to all relevant interface methods.
        // Option 2 seems more flexible for a single CsvTransactionDao class.
        // Let's add filePath to interface methods and implement here.

        // *** Decision: Modify TransactionDao interface to include filePath ***
        throw new UnsupportedOperationException("This method signature is not suitable for multi-user. Use the overloaded method with filePath.");
    }

    // Adding filePath parameter to relevant interface methods definition (will update interface next)
    // This implementation will be part of the updated DAO after interface change.
    public List<Transaction> getAllTransactions(String filePath) throws IOException {
        return loadFromCSV(filePath); // Simple implementation using the existing load method
    }


    // Add transaction
    public void addTransaction(Transaction newTransaction) throws IOException {
        throw new UnsupportedOperationException("This method signature is not suitable for multi-user. Use the overloaded method with filePath.");
    }

    public void addTransaction(String filePath, Transaction newTransaction) throws IOException {
        // Ensure the directory exists
        Path path = Paths.get(filePath);
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }

        boolean fileExists = Files.exists(path) && Files.size(path) > 0;

        // Define the header based on your CSV structure
        String[] headers = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"};

        // Use StandardOpenOption.CREATE and StandardOpenOption.APPEND
        // If the file doesn't exist, CREATE will create it. If it exists, APPEND will add to the end.
        // We need to handle writing the header only if the file is new or empty.
        try (BufferedWriter writer = Files.newBufferedWriter(path, StandardOpenOption.CREATE, StandardOpenOption.APPEND)) {

            // Check if header needs to be written. A simple way is to check file size before opening in APPEND mode.
            // However, opening in CREATE/APPEND and then checking size *after* opening might not work as expected if the file is created.
            // A better approach is to check size *before* getting the writer or read the first line after opening if needed.
            // The Apache CSVPrinter can handle writing headers IF the file is new.
            // Let's adapt the existing logic slightly. Check exists and non-empty *before* opening.

            // Re-check file state after potential creation by StandardOpenOption.CREATE
            boolean fileWasEmptyBeforeAppend = !fileExists; // Or check if file size is 0 after creation if needed

            // Configure CSV format - with header if file is new/empty, without if appending
            CSVFormat format;
            if (fileWasEmptyBeforeAppend) {
                format = CSVFormat.DEFAULT.withHeader(headers).withTrim();
            } else {
                format = CSVFormat.DEFAULT.withTrim(); // Assume header is already there
            }

            // Create CSVPrinter
            try (CSVPrinter csvPrinter = new CSVPrinter(writer, format)) {
                csvPrinter.printRecord(
                        newTransaction.getTransactionTime(),
                        newTransaction.getTransactionType(),
                        newTransaction.getCounterparty(),
                        newTransaction.getCommodity(),
                        newTransaction.getInOut(),
                        // Format amount with ¥ sign and two decimal places
                        String.format("¥%.2f", newTransaction.getPaymentAmount()),
                        newTransaction.getPaymentMethod(),
                        newTransaction.getCurrentStatus(),
                        newTransaction.getOrderNumber(),
                        newTransaction.getMerchantNumber(),
                        newTransaction.getRemarks()
                );
                // No need to flush immediately, writer will be closed by try-with-resources.
                // csvPrinter.flush();
            }
            System.out.println("Added transaction to " + filePath);
        } catch (IOException e) {
            System.err.println("Error adding transaction to CSV: " + filePath);
            e.printStackTrace();
            throw e; // Re-throw
        }
    }


    // Delete transaction by order number
    public boolean deleteTransaction(String orderNumber) throws IOException {
        throw new UnsupportedOperationException("This method signature is not suitable for multi-user. Use the overloaded method with filePath.");
    }

    public boolean deleteTransaction(String filePath, String orderNumber) throws IOException {
        // Load all transactions first
        List<Transaction> allTransactions = loadFromCSV(filePath);

        // Filter out the transaction to be deleted
        List<Transaction> updatedTransactions = allTransactions.stream()
                .filter(t -> !t.getOrderNumber().trim().equals(orderNumber.trim()))
                .collect(Collectors.toList());

        // Check if any transaction was actually removed
        boolean deleted = allTransactions.size() > updatedTransactions.size();

        if (deleted) {
            // Write the remaining transactions back to the CSV file
            writeTransactionsToCSV(filePath, updatedTransactions);
            System.out.println("Deleted transaction with order number " + orderNumber + " from " + filePath);
        } else {
            System.out.println("Transaction with order number " + orderNumber + " not found in " + filePath);
        }

        return deleted;
    }


    // Update a specific field (implementing the interface method)
    public boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException {
        // This interface method needs a filePath parameter to be useful in a multi-user context.
        // Let's add an overloaded method that includes filePath.
        throw new UnsupportedOperationException("This method signature is not suitable for multi-user. Use the overloaded method with filePath.");
    }

    public boolean updateTransaction(String filePath, String orderNumber, String fieldName, String newValue) throws IOException {
        // Load all transactions
        List<Transaction> allTransactions = loadFromCSV(filePath);

        // Find the transaction by order number
        Optional<Transaction> transactionToUpdateOpt = allTransactions.stream()
                .filter(t -> t.getOrderNumber().trim().equals(orderNumber.trim()))
                .findFirst();

        if (!transactionToUpdateOpt.isPresent()) {
            System.out.println("Transaction with order number " + orderNumber + " not found for update in " + filePath);
            return false; // Transaction not found
        }

        Transaction transactionToUpdate = transactionToUpdateOpt.get();
        boolean updated = false;

        // Use reflection or a switch/if-else block to update the specific field
        // A switch is more explicit and safer than reflection here.
        switch (fieldName) {
            case "transactionTime": transactionToUpdate.setTransactionTime(newValue); updated = true; break;
            case "transactionType": transactionToUpdate.setTransactionType(newValue); updated = true; break;
            case "counterparty": transactionToUpdate.setCounterparty(newValue); updated = true; break;
            case "commodity": transactionToUpdate.setCommodity(newValue); updated = true; break;
            case "inOut": transactionToUpdate.setInOut(newValue); updated = true; break;
            case "paymentAmount":
                try {
                    transactionToUpdate.setPaymentAmount(Double.parseDouble(newValue));
                    updated = true;
                } catch (NumberFormatException e) {
                    System.err.println("Invalid number format for paymentAmount update: " + newValue);
                    throw new NumberFormatException("Invalid number format for paymentAmount: " + newValue);
                }
                break;
            case "paymentMethod": transactionToUpdate.setPaymentMethod(newValue); updated = true; break;
            case "currentStatus": transactionToUpdate.setCurrentStatus(newValue); updated = true; break;
            case "orderNumber": transactionToUpdate.setOrderNumber(newValue); updated = true; break; // Caution: Updating ID can be tricky
            case "merchantNumber": transactionToUpdate.setMerchantNumber(newValue); updated = true; break;
            case "remarks": transactionToUpdate.setRemarks(newValue); updated = true; break;
            default:
                System.err.println("Invalid field name for update: " + fieldName);
                throw new IllegalArgumentException("Invalid field name: " + fieldName);
        }

        if (updated) {
            // Write the modified list back to the CSV file
            writeTransactionsToCSV(filePath, allTransactions);
            System.out.println("Updated transaction with order number " + orderNumber + " in " + filePath + " field: " + fieldName);
        }

        return updated;
    }


    // Keep writeTransactionsToCSV, ensure it uses the filePath parameter correctly
    // This method seems OK as it already accepts filePath.
    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
        // Ensure the directory exists
        Path path = Paths.get(filePath);
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }

        File targetFile = path.toFile();
        // Create temporary file in the same directory
        File tempFile = File.createTempFile("transaction_temp", ".csv", targetFile.getParentFile());

        // Define the header explicitly
        String[] headers = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"};

        try (BufferedWriter writer = Files.newBufferedWriter(tempFile.toPath(), StandardCharsets.UTF_8);
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(headers).withTrim())) { // Always write header for overwrite

            for (Transaction t : transactions) {
                csvPrinter.printRecord(
                        t.getTransactionTime(),
                        t.getTransactionType(),
                        t.getCounterparty(),
                        t.getCommodity(),
                        t.getInOut(),
                        String.format("¥%.2f", t.getPaymentAmount()), // Format amount
                        t.getPaymentMethod(),
                        t.getCurrentStatus(),
                        t.getOrderNumber(),
                        t.getMerchantNumber(),
                        t.getRemarks()
                );
            }
            // csvPrinter.flush(); // Auto-flushed on close
        } catch (IOException e) {
            tempFile.delete(); // Clean up temp file on failure
            System.err.println("Error writing transactions to temporary CSV file: " + tempFile.toPath());
            e.printStackTrace();
            throw e; // Re-throw
        }

        // Atomic replacement of the original file
        try {
            Files.move(tempFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
            System.out.println("Atomically replaced " + filePath + " with updated data.");
        } catch (IOException e) {
            System.err.println("Failed to atomically replace original file: " + targetFile.toPath() + " with " + tempFile.toPath());
            tempFile.delete(); // Clean up temp file
            e.printStackTrace();
            throw e; // Re-throw
        }
    }

    // Implement getTransactionByOrderNumber from the interface
    public Transaction getTransactionByOrderNumber(String orderNumber) throws IOException {
        throw new UnsupportedOperationException("This method signature is not suitable for multi-user. Use the overloaded method with filePath.");
    }

    public Transaction getTransactionByOrderNumber(String filePath, String orderNumber) throws IOException {
        // Load all transactions
        List<Transaction> allTransactions = loadFromCSV(filePath);

        // Find the transaction by order number
        Optional<Transaction> transactionOpt = allTransactions.stream()
                .filter(t -> t.getOrderNumber().trim().equals(orderNumber.trim()))
                .findFirst();

        return transactionOpt.orElse(null); // Return Transaction object or null
    }


    // Remove or update these old methods
    // private CSVFormat getCsvFormatWithHeader(String filePath) throws IOException { ... } // No longer needed with explicit headers
    // private CSVFormat getCsvFormatWithoutHeader() { ... } // No longer needed with explicit headers
    // boolean changeInformation(String orderNumber, String head, String value,String path) throws IOException // This is similar to updateTransaction, prefer the standard update method
    // Let's remove changeInformation and update the service to use updateTransaction

    // Removed changeInformation method based on the plan to use updateTransaction instead.
    // Removed getCsvFormatWithHeader/WithoutHeader as we now use explicit headers in writeTransactionsToCSV.
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\DAO\Impl\CsvUserDao.java`:

```java
package DAO.Impl;

import Constants.ConfigConstants;
import DAO.UserDao;
import model.User;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

public class CsvUserDao implements UserDao {

    private final String filePath;

    public CsvUserDao(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public List<User> getAllUsers() throws IOException {
        List<User> users = new ArrayList<>();
        // Use BOMInputStream to handle potential Byte Order Mark issues
        try (Reader reader = new InputStreamReader(
                new BOMInputStream(Files.newInputStream(Paths.get(filePath))),
                StandardCharsets.UTF_8)) {

            // Configure CSVFormat to handle headers
            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()
                    .withIgnoreHeaderCase(true) // Ignore header case for robustness
                    .withTrim(true); // Trim leading/trailing whitespace

            try (CSVParser csvParser = new CSVParser(reader, format)) {
                // Check if the required headers are present
                List<String> requiredHeaders = List.of("username", "password", "role", "transaction_csv_path");
                if (!csvParser.getHeaderMap().keySet().containsAll(requiredHeaders)) {
                    throw new IOException("Missing required headers in users CSV file: " + requiredHeaders);
                }

                for (CSVRecord record : csvParser) {
                    // Basic error handling for potentially missing fields in a row
                    String username = record.get("username");
                    String password = record.get("password");
                    String role = record.get("role");
                    String transactionFilePath = record.get("transaction_csv_path");

                    if (username == null || username.trim().isEmpty() || password == null || password.trim().isEmpty() || role == null || role.trim().isEmpty() || transactionFilePath == null || transactionFilePath.trim().isEmpty()) {
                        System.err.println("Skipping malformed user record: " + record.toMap());
                        continue; // Skip this row
                    }

                    User user = new User(username.trim(), password.trim(), role.trim(), transactionFilePath.trim());
                    users.add(user);
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading users from CSV file: " + filePath);
            e.printStackTrace();
            throw e; // Re-throw the exception after logging
        }
        return users;
    }

    // Helper method to parse a single record (optional, can be in getAllUsers)
    // private User parseRecord(CSVRecord record) { ... }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\DAO\SummaryStatisticDao.java`:

```java
package DAO;

import model.SummaryStatistic;

import java.io.IOException;
import java.util.List;

public interface SummaryStatisticDao {

    /**
     * Loads all summary statistics from the configured data source.
     * @param filePath The path to the summary statistics CSV file.
     * @return A list of all summary statistics.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<SummaryStatistic> loadAllStatistics(String filePath) throws IOException;

    /**
     * Writes a list of summary statistics to the configured data source, overwriting existing data.
     * @param filePath The path to the summary statistics CSV file.
     * @param statistics The list of statistics to write.
     * @throws IOException If an I/O error occurs during saving.
     */
    void writeAllStatistics(String filePath, List<SummaryStatistic> statistics) throws IOException;

    // Optional: Add method to get statistic by week identifier if needed
    // SummaryStatistic getStatisticByWeek(String filePath, String weekIdentifier) throws IOException;
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\DAO\TransactionDao.java`:

```java
package DAO;

import model.Transaction;

import java.io.IOException;
import java.util.List;

/**
 * Interface for Data Access Object (DAO) operations related to Transactions.
 * Defines the contract for loading, adding, deleting, and updating transaction data.
 */
public interface TransactionDao {

    // Keep loadFromCSV - used by cache loader
    List<Transaction> loadFromCSV(String filePath) throws IOException;

    /**
     * Loads all transactions from the specified data source file.
     * @param filePath The path to the user's CSV file.
     * @return A list of all transactions.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<Transaction> getAllTransactions(String filePath) throws IOException;


    /**
     * Adds a new transaction to the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param transaction The new transaction to add.
     * @throws IOException If an I/O error occurs during saving.
     */
    void addTransaction(String filePath, Transaction transaction) throws IOException;

    /**
     * Deletes a transaction identified by its order number from the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param orderNumber The unique order number of the transaction to delete.
     * @return true if a transaction was found and deleted, false otherwise.
     * @throws IOException If an I/O error occurs during loading or saving.
     */
    boolean deleteTransaction(String filePath, String orderNumber) throws IOException;

    /**
     * Updates a specific field of an existing transaction identified by its order number
     * in the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param orderNumber The unique order number of the transaction to update.
     * @param fieldName   The name of the field to update (e.g., "transactionType", "paymentAmount").
     * @param newValue    The new value for the specified field.
     * @return true if the transaction was found and updated, false otherwise.
     * @throws IOException             If an I/O error occurs during loading or saving.
     * @throws NumberFormatException   If updating 'paymentAmount' and newValue is not a valid double.
     * @throws IllegalArgumentException If the fieldName is invalid.
     */
    boolean updateTransaction(String filePath, String orderNumber, String fieldName, String newValue) throws IOException;

    /**
     * Retrieves a transaction by its unique order number from the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param orderNumber The unique order number.
     * @return The Transaction object if found, null otherwise.
     * @throws IOException If an I/O error occurs during loading.
     */
    Transaction getTransactionByOrderNumber(String filePath, String orderNumber) throws IOException;

    void writeTransactionsToCSV(String currentUserTransactionFilePath, List<Transaction> updatedList) throws IOException;

    // Remove the old methods without filePath parameter from the interface
    // List<Transaction> getAllTransactions() throws IOException; // Removed
    // void addTransaction(Transaction transaction) throws IOException; // Removed
    // boolean deleteTransaction(String orderNumber) throws IOException; // Removed
    // boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException; // Removed
    // Transaction getTransactionByOrderNumber(String orderNumber) throws IOException; // Removed
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\DAO\UserDao.java`:

```java
package DAO;

import model.User;

import java.io.IOException;
import java.util.List;

/**
 * Interface for Data Access Object (DAO) operations related to Users.
 */
public interface UserDao {

    /**
     * Loads all users from the configured data source.
     *
     * @return A list of all users.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<User> getAllUsers() throws IOException;

    // Add other user-related methods if needed later (e.g., addUser, deleteUser)
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Interceptor\Login\LoginDialog.java`:

```java
package Interceptor.Login;

import Service.User.UserService; // Import the new UserService
import model.User;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class LoginDialog extends JDialog {
    private User authenticatedUser = null; // Change from boolean flag to User object
    private JTextField usernameField;
    private JPasswordField passwordField;
    // UserService should ideally be injected, but for simplicity in LoginDialog,
    // we might initialize it here or pass it from Main. Let's pass it from Main.
    private final UserService userService;

    // Constructor now accepts UserService
    public LoginDialog(UserService userService) {
        this.userService = userService; // Inject UserService

        setTitle("用户登录");
        setLayout(new GridLayout(3, 2));
        setModal(true);
        setSize(300, 150);
        setResizable(false); // Prevent resizing

        // Input components
        usernameField = new JTextField();
        passwordField = new JPasswordField();
        JButton loginButton = new JButton("登录");
        JButton cancelButton = new JButton("取消");

        // Add components
        add(new JLabel("用户名:"));
        add(usernameField);
        add(new JLabel("密码:"));
        add(passwordField);
        add(loginButton);
        add(cancelButton);

        // Login button logic
        loginButton.addActionListener(e -> {
            String username = usernameField.getText().trim();
            String password = new String(passwordField.getPassword()).trim();

            authenticatedUser = userService.authenticate(username, password); // Use new authenticate method

            if (authenticatedUser != null) { // Check if a User object was returned
                dispose(); // Close dialog
            } else {
                JOptionPane.showMessageDialog(
                        this,
                        "用户名或密码错误！",
                        "登录失败",
                        JOptionPane.ERROR_MESSAGE
                );
                clearFields(); // Clear fields on failure
            }
        });

        // Cancel button logic
        cancelButton.addActionListener(e -> {
            authenticatedUser = null; // Ensure no user is set on cancel
            dispose();
            System.exit(0); // Exit application on cancel
        });

        setLocationRelativeTo(null); // Center dialog
    }

    // Method to clear input fields
    private void clearFields() {
        usernameField.setText("");
        passwordField.setText("");
        usernameField.requestFocusInWindow(); // Focus back to username field
    }

    /**
     * Shows the login dialog and returns the authenticated user upon successful login.
     * Blocking call.
     * @return The authenticated User object, or null if login failed or was cancelled.
     */
    public User showDialogAndGetResult() {
        setVisible(true); // Show the dialog (this call is blocking because modal is true)
        return authenticatedUser; // Return the result after dialog is closed
    }

    // Remove isLoginSuccessful() as we now return the User object
    // public boolean isLoginSuccessful() { return loginSuccessful; }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Main.java`:

```java
import javax.swing.*;

import Controller.MenuUI;
import DAO.Impl.CsvTransactionDao;
import DAO.Impl.CsvUserDao;
import DAO.Impl.CsvSummaryStatisticDao;
import DAO.UserDao;
import DAO.TransactionDao;
import DAO.SummaryStatisticDao;
import Interceptor.Login.LoginDialog;
import Service.Impl.TransactionServiceImpl;
import Service.Impl.SummaryStatisticService;
import Service.AIservice.AITransactionService; // Import AI Service classes
import Service.AIservice.CollegeStudentNeeds;
import Service.TransactionService;
import Service.User.UserService;
import model.User;
import Constants.ConfigConstants;

public class Main {
    public static void main(String[] args) {
        // Ensure ConfigConstants is loaded first
        String usersCsvPath = ConfigConstants.USERS_CSV_PATH;
        String summaryCsvPath = ConfigConstants.SUMMARY_CSV_PATH;
        System.out.println("Attempting to load users from: " + usersCsvPath);
        System.out.println("Summary statistics will be saved to: " + summaryCsvPath);


        // Initialize DAOs
        UserDao userDao = new CsvUserDao(usersCsvPath);
        TransactionDao transactionDao = new CsvTransactionDao();
        SummaryStatisticDao summaryStatisticDao = new CsvSummaryStatisticDao();


        // Initialize Services
        UserService userService = new UserService(userDao);
        // TransactionServiceImpl is initialized per user in MenuUI -> NO, initialize it here and pass it!
        // The TransactionServiceImpl instance *is* user-specific, so it's better to create it *after* login.
        // But AI Services need it *before* MenuUI is fully constructed and shows the panel.
        // Option 1: Pass TransactionService to MenuUI constructor and AI/CS services are initialized in MenuUI. (Current approach)
        // Option 2: Create AI/CS services here in Main and pass them to MenuUI. They would need the user-specific TS instance.
        // Let's stick with Option 1 for now, initializing AI/CS in MenuUI after getting TS.

        SummaryStatisticService summaryStatisticService = new SummaryStatisticService(userDao, transactionDao, summaryStatisticDao);


        // In the event dispatch thread (EDT) start GUI
        SwingUtilities.invokeLater(() -> {
            LoginDialog loginDialog = new LoginDialog(userService);
            User authenticatedUser = loginDialog.showDialogAndGetResult();

            if (authenticatedUser != null) {
                System.out.println("Logged in as: " + authenticatedUser.getUsername() + " (" + authenticatedUser.getRole() + ")");
                System.out.println("User's transaction file: " + authenticatedUser.getTransactionFilePath());

                // Initialize TransactionServiceImpl *for the logged-in user*
                TransactionService transactionServiceForCurrentUser = new TransactionServiceImpl(authenticatedUser.getTransactionFilePath());

                // Initialize AI Services *with* the user-specific TransactionService
                // This is where AI/CS services are created with their dependency injected
                AITransactionService aiTransactionService = new AITransactionService(transactionServiceForCurrentUser);
                CollegeStudentNeeds collegeStudentNeeds = new CollegeStudentNeeds(transactionServiceForCurrentUser);


                // Pass the authenticated user, their transaction service, summary statistic service, AND AI services to MenuUI
                MenuUI menuUI = new MenuUI(authenticatedUser, transactionServiceForCurrentUser, summaryStatisticService, aiTransactionService, collegeStudentNeeds); // Modify MenuUI constructor


                JFrame frame = new JFrame("交易管理系统 - " + authenticatedUser.getUsername());
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.setSize(1200, 600);
                frame.setLocationRelativeTo(null);
                frame.add(menuUI.createMainPanel());
                frame.setVisible(true);
            } else {
                System.out.println("Login failed or cancelled. Exiting.");
                System.exit(0);
            }
        });
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\AIservice\AIAnalyzerThread.java`:

```java
package Service.AIservice;

// Add required imports
import Service.TransactionService; // Import if analyzeTransactions throws Exception


public class AIAnalyzerThread implements Runnable {
    private final String userRequest;
    private final String filePath; // Still needed for analyzeTransactions method signature
    private final String startTimeStr;
    private final String endTimeStr;

    // Field to hold the injected AITransactionService service instance
    private final AITransactionService aiTransactionService;


    /**
     * Constructor now accepts the AITransactionService service instance
     * and the parameters for the analysis request.
     *
     * @param aiTransactionService The AITransactionService service instance to use.
     * @param userRequest The user's natural language request.
     * @param filePath The path to the user's transaction data file.
     * @param startTimeStr The start time string for filtering.
     * @param endTimeStr The end time string for filtering.
     */
    public AIAnalyzerThread(AITransactionService aiTransactionService, String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        this.aiTransactionService = aiTransactionService; // Inject the service
        this.userRequest = userRequest;
        this.filePath = filePath; // Still needed for analyzeTransactions call
        this.startTimeStr = startTimeStr;
        this.endTimeStr = endTimeStr;
        System.out.println("AIAnalyzerThread initialized for file: " + filePath);
    }

    @Override
    public void run() {
        System.out.println("AIAnalyzerThread started for analysis request: '" + userRequest + "' on file: " + filePath);
        try {
            // Call the analyzeTransactions method on the injected service instance
            String result = aiTransactionService.analyzeTransactions(userRequest, filePath, startTimeStr, endTimeStr);

            // Print the result or handle it as needed by the test/caller that starts this thread
            System.out.println("AI analysis result from thread: " + result);

            // TODO: If this thread is used by a UI program, use SwingUtilities.invokeLater() to update a UI component with 'result'
            // This indicates this class might be intended for background tasks separate from the main UI refresh cycle handled in MenuUI.
        } catch (Exception e) { // Catch Exception as analyzeTransactions throws Exception
            System.err.println("Error during AI analysis in thread for file " + filePath + ": " + e.getMessage());
            e.printStackTrace();
            // You might want to pass this error back to the caller if it's a UI context.
        }
        System.out.println("AIAnalyzerThread finished for file: " + filePath);
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\AIservice\AITransactionService.java`:

```java
package Service.AIservice;
// Remove import Service.Impl.TransactionServiceImpl;
// Remove import Service.TransactionService;
// Remove import Constants.ConfigConstants; // ConfigConstants might still be needed for API key logic if not elsewhere
// Remove import DAO.CsvTransactionDao; // No longer directly used
// Remove import Utils.CacheUtil; // No longer directly used

import DAO.TransactionDao; // Use the interface
import DAO.Impl.CsvTransactionDao; // Use the implementation to create instance for loader
import Service.TransactionService;
import Utils.CacheManager; // Import CacheManager
import model.MonthlySummary;
import model.Transaction; // Import Transaction

import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;

import java.io.IOException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;
import java.util.concurrent.*;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
// Remove import static Constants.ConfigConstants.CSV_PATH; // No longer use static CSV_PATH

public class AITransactionService {
    // Keep static ArkService as it's typically thread-safe and stateless
    private static final String API_KEY = System.getenv("ARK_API_KEY"); // Or load from config.properties
    private static final ArkService service = ArkService.builder()
            .timeout(Duration.ofSeconds(1800))
            .connectTimeout(Duration.ofSeconds(20))
            .baseUrl("https://ark.cn-beijing.volces.com/api/v3")
            .apiKey(API_KEY) // Ensure API_KEY is loaded
            .build();

    // Need access to TransactionService to get monthly summaries
    private final TransactionService transactionService; // Inject TransactionService


    /**
     * Constructor now accepts TransactionService instance.
     */
    public AITransactionService(TransactionService transactionService) {
        this.transactionService = transactionService; // Inject the service
        System.out.println("AITransactionService initialized with TransactionService.");
    }

    /**
     * Analyzes transactions from a specific user's file based on user request and time range.
     *
     * @param userRequest The user's natural language request.
     * @param filePath The path to the user's transaction CSV file.
     * @param startTimeStr The start time string for filtering.
     * @param endTimeStr The end time string for filtering.
     * @return AI analysis result as a String.
     */
    public String analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        try {
            // Get transactions for the specified file path using CacheManager
            // Need to pass a DAO instance for the CacheManager's loader if it needs to load from file.
            TransactionDao transactionDaoForLoading = new CsvTransactionDao(); // Create a DAO instance for loading
            List<Transaction> transactions = CacheManager.getTransactions(filePath, transactionDaoForLoading);
            System.out.println("AI Service: Retrieved " + transactions.size() + " transactions for file: " + filePath);


            // Format filtered transactions for the AI prompt
            List<String> transactionDetails = formatTransactions(transactions, startTimeStr, endTimeStr);
            System.out.println("AI Service: Formatted " + transactionDetails.size() + " transactions for AI.");


            // Check if any transactions were found after filtering
            if (transactionDetails.isEmpty() || (transactionDetails.size() == 1 && transactionDetails.get(0).startsWith("该时间段内没有交易记录"))) {
                return "在该时间段内没有找到符合条件的交易记录，无法进行分析。请检查时间和交易数据。";
            }

            String aiPrompt = userRequest + "\n" + "以下是我的账单信息：\n" + String.join("\n", transactionDetails);
            System.out.println("AI Service: Sending prompt to AI. Prompt length: " + aiPrompt.length());
            return askAi(aiPrompt);
        } catch (IllegalArgumentException e) {
            System.err.println("AI analysis failed due to invalid time format: " + e.getMessage());
            return "AI分析失败: 时间格式不正确。" + e.getMessage();
        }
        catch (Exception e) {
            System.err.println("AI analysis failed during data retrieval or AI call for file: " + filePath);
            e.printStackTrace();
            return "AI分析失败: 获取数据或调用AI服务时发生错误。" + e.getMessage();
        }
    }


    // Keep formatTransactions, parseDateTime, askAi methods. Ensure parseDateTime is robust.
    // The formatTransactions method relies on parseDateTime, ensure consistency with TransactionServiceImpl's parser.

    public List<String> formatTransactions(List<Transaction> transactions, String startTimeStr, String endTimeStr) {
        LocalDateTime startTime = parseDateTime(startTimeStr);
        // If end time is empty, use current time
        LocalDateTime endTime = (endTimeStr == null || endTimeStr.trim().isEmpty())
                ? LocalDateTime.now()
                : parseDateTime(endTimeStr);

        if (startTime == null) {
            // Handle the case where start time is invalid.
            // Depending on requirements, you might throw an exception or return an error message list.
            // Throwing IllegalArgumentException is better for analyzeTransactions to catch.
            throw new IllegalArgumentException("起始时间格式不正确: " + startTimeStr);
        }
        // If endTime parsing fails, treat it as current time as per original logic if endTimeStr was not empty
        if ((endTimeStr != null && !endTimeStr.trim().isEmpty()) && endTime == null) {
            throw new IllegalArgumentException("结束时间格式不正确: " + endTimeStr);
        }
        // If endTimeStr was empty, endTime is already LocalDateTime.now() which is not null.

        System.out.println("Filtering transactions from " + startTime + " to " + endTime);


        List<Transaction> filtered = transactions.stream()
                .filter(t -> {
                    LocalDateTime tTime = parseDateTime(t.getTransactionTime());
                    // Include transactions exactly at startTime, exclude transactions exactly at endTime (standard range behavior [start, end))
                    // If endTime should be inclusive, change isBefore(startTime) to !isAfter(startTime) and isAfter(endTime) to !isBefore(endTime)
                    // Or use isBefore(startTime) || isAfter(endTime) and negate.
                    // Let's use !isBefore(startTime) && !isAfter(endTime) as it seems more intuitive for a date range, inclusive.
                    return tTime != null && !tTime.isBefore(startTime) && !tTime.isAfter(endTime); // Range [startTime, endTime]
                })
                .collect(Collectors.toList());
        System.out.println("Filtered down to " + filtered.size() + " transactions within range.");


        // Group by Counterparty and summarize net amount and count
        Map<String, double[]> grouped = new HashMap<>(); // double[0] = net amount, double[1] = count
        for (Transaction t : filtered) {
            String counterparty = t.getCounterparty();
            double amount = t.getPaymentAmount();
            if (t.getInOut().equals("支出") || t.getInOut().equals("支")) { // Normalize "支" to "支出" internally if needed, but compare against source
                amount = -amount;
            } else if (!t.getInOut().equals("收入") && !t.getInOut().equals("收")) {
                System.err.println("Warning: Unknown 收/支 type for transaction: " + t.getOrderNumber() + " - " + t.getInOut());
                // Decide how to handle unknown types - ignore from analysis? Treat as 0?
                continue; // Skip unknown types for aggregation
            }

            grouped.putIfAbsent(counterparty, new double[]{0.0, 0});
            grouped.get(counterparty)[0] += amount;
            grouped.get(counterparty)[1] += 1;
        }
        System.out.println("Grouped transactions by counterparty. Found " + grouped.size() + " counterparties.");


        List<String> results = grouped.entrySet().stream()
                .map(e -> {
                    String cp = e.getKey();
                    double net = e.getValue()[0];
                    int count = (int) e.getValue()[1];
                    String inOut = net >= 0 ? "总收入" : "总支出"; // Changed label to reflect aggregate
                    if (Math.abs(net) < 0.01 && count > 0) { // If net is near zero but there were transactions
                        inOut = "净零"; // Or specify "收支相抵"
                    }
                    return String.format("交易对方: %s, 净%s: %.2f元，交易次数: %d",
                            cp, inOut, Math.abs(net), count);
                })
                .collect(Collectors.toList());
        System.out.println("Formatted grouped results.");


        // Add time range information to the results list
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm");
        String rangeInfo = String.format("分析交易时间范围：%s - %s",
                formatter.format(startTime), formatter.format(endTime));
        results.add(0, rangeInfo); // Add range info at the beginning

        return results.isEmpty() ? List.of(rangeInfo, "该时间段内没有交易记录。") : results; // Ensure range info is always included
    }


    // Keep parseDateTime method - ensure it matches the one in TransactionServiceImpl
    private LocalDateTime parseDateTime(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // Clean whitespace
        timeStr = timeStr.trim().replaceAll("\\s+", " ");

        // Append time if only date
        if (timeStr.matches("\\d{4}/\\d{1,2}/\\d{1,2}")) {
            timeStr += " 00:00"; // Assuming minutes format
        } else if (timeStr.matches("\\d{4}-\\d{1,2}-\\d{1,2}")) {
            timeStr += " 00:00:00"; // Assuming seconds format
        }


        // Try parsing with multiple formats
        List<String> patterns = List.of(
                "yyyy/M/d H:mm", "yyyy/M/d HH:mm",
                "yyyy/MM/d H:mm", "yyyy/MM/d HH:mm",
                "yyyy/M/dd H:mm", "yyyy/M/dd HH:mm",
                "yyyy/MM/dd H:mm", "yyyy/MM/dd HH:mm",
                "yyyy/MM/dd HH:mm:ss", // Added seconds format
                "yyyy-MM-dd HH:mm:ss", // Added dash format
                "yyyy/MM/dd" // Date only (handled above)
                // Add more patterns if needed based on your CSV data
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDateTime.parse(timeStr, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern and try the next
            }
        }
        System.err.println("AI Service: Failed to parse date string: " + timeStr);
        return null; // Return null if no pattern matches
    }


    // Keep askAi method
    public String askAi(String prompt) {
        try {
            if (API_KEY == null || API_KEY.trim().isEmpty()) {
                System.err.println("ARK_API_KEY environment variable is not set.");
                return "AI服务配置错误: ARK_API_KEY 未设置。";
            }
            // Ensure the static service instance is properly built with the key
            // This might be better done once at application startup if API_KEY is loaded from config.
            // For now, relying on the static final initialization is acceptable if the env var is set before class loading.


            List<ChatMessage> messages = List.of(
                    ChatMessage.builder().role(ChatMessageRole.USER).content(prompt).build()
            );

            ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
                    .model("ep-20250308174053-7pbkq") // Use your model name
                    .messages(messages)
                    .build();

            System.out.println("AI Service: Sending request to VolcEngine Ark...");
            // Use the static service instance
            String responseContent = (String) service.createChatCompletion(chatCompletionRequest)
                    .getChoices().get(0).getMessage().getContent();
            System.out.println("AI Service: Received response from AI.");
            return responseContent;

        } catch (Exception e) {
            System.err.println("AI Service: AI request failed.");
            e.printStackTrace();
            return "AI请求失败: " + e.getMessage();
        }
    }

    // Keep runAiInThread method, ensure it uses the correct analyzeTransactions method
    public void runAiInThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        // ExecutorService should ideally be managed at a higher level in a larger app,
        // but a simple single thread executor per request is acceptable for this scale.
        // However, this creates a new thread and executor every time.
        // A fixed thread pool managed statically or by a dedicated AI Service Manager would be more efficient.
        // For now, let's keep it simple as in the original code.

        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            // Call the instance method analyzeTransactions
            String result = this.analyzeTransactions(userRequest, filePath,startTimeStr, endTimeStr);
            System.out.println("AI analysis thread finished. Result: " + result);
            // TODO: How to pass the result back to the UI?
            // This thread doesn't have access to the UI components directly.
            // Need a mechanism like a callback or SwingUtilities.invokeLater.
            // This will be addressed when integrating AI output into the UI (Step 10).
        });
        // Consider shutting down the executor more gracefully, e.g., when the app exits.
        // executor.shutdown(); // Shutting down immediately might cancel the task
        // A better approach is `executor.shutdown()` after submitting, but manage the executor lifecycle elsewhere.
    }

    /**
     * Generates a personal consumption summary based on monthly data.
     * @param userFilePath The path to the user's transaction CSV file. (Might not be strictly needed if service handles context)
     * @return AI analysis result as a String.
     */
    public String generatePersonalSummary(String userFilePath) {
        try {
            // Get monthly summary data from TransactionService
            // Note: TransactionService already operates on the current user's data implicitly if passed correctly.
            // We might not need userFilePath explicitly in this method signature if the service instance is user-specific.
            // Let's assume the injected transactionService is already scoped to the current user.
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("AI Service: Retrieved " + summaries.size() + " months of summary data.");

            if (summaries.isEmpty()) {
                return "没有找到足够的交易数据来生成个人消费总结。";
            }

            // Format the summary data for the AI prompt
            StringBuilder summaryPromptBuilder = new StringBuilder();
            summaryPromptBuilder.append("请根据以下月度消费总结数据，生成一份个人消费习惯总结，分析主要开销类别、月度变化趋势，并评估我的消费健康度：\n\n");

            // Sort months chronologically for better trend analysis by AI
            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                summaryPromptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                summaryPromptBuilder.append("  总收入: ").append(String.format("%.2f", ms.getTotalIncome())).append("元\n");
                summaryPromptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                summaryPromptBuilder.append("  支出明细:\n");
                if (ms.getExpenseByCategory().isEmpty()) {
                    summaryPromptBuilder.append("    (无支出)\n");
                } else {
                    // Sort categories by amount descending for AI to easily see major categories
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    summaryPromptBuilder.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                            );
                }
                summaryPromptBuilder.append("\n"); // Add space between months
            }

            String aiPrompt = summaryPromptBuilder.toString();
            System.out.println("AI Service: Sending personal summary prompt to AI. Prompt length: " + aiPrompt.length());

            return askAi(aiPrompt); // Call the generic AI method
        } catch (Exception e) {
            System.err.println("AI Service: Failed to generate personal summary.");
            e.printStackTrace();
            return "生成个人消费总结失败: " + e.getMessage();
        }
    }

    /**
     * Generates suggestions for savings goals based on monthly data.
     * @param userFilePath The path to the user's transaction CSV file. (Might not be strictly needed)
     * @return AI suggestions as a String.
     */
    public String suggestSavingsGoals(String userFilePath) {
        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("AI Service: Retrieved " + summaries.size() + " months of summary data for savings goal suggestion.");

            if (summaries.isEmpty()) {
                return "没有找到足够的交易数据来建议储蓄目标。";
            }

            StringBuilder promptBuilder = new StringBuilder();
            promptBuilder.append("请根据以下月度收支总结数据，为我这个消费习惯提供一些合理的储蓄目标建议：\n\n");

            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  总收入: ").append(String.format("%.2f", ms.getTotalIncome())).append("元\n");
                promptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                double net = ms.getTotalIncome() - ms.getTotalExpense();
                promptBuilder.append("  月度净收支: ").append(String.format("%.2f", net)).append("元\n");
                promptBuilder.append("\n");
            }

            String aiPrompt = promptBuilder.toString();
            System.out.println("AI Service: Sending savings goals prompt to AI. Prompt length: " + aiPrompt.length());

            return askAi(aiPrompt);
        } catch (Exception e) {
            System.err.println("AI Service: Failed to suggest savings goals.");
            e.printStackTrace();
            return "建议储蓄目标失败: " + e.getMessage();
        }
    }

    /**
     * Generates personalized cost-cutting recommendations based on monthly data.
     * @param userFilePath The path to the user's transaction CSV file. (Might not be strictly needed)
     * @return AI recommendations as a String.
     */
    public String givePersonalSavingTips(String userFilePath) {
        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("AI Service: Retrieved " + summaries.size() + " months of summary data for saving tips.");

            if (summaries.isEmpty()) {
                return "没有找到足够的交易数据来提供个性化节约建议。";
            }

            StringBuilder promptBuilder = new StringBuilder();
            promptBuilder.append("请根据以下月度消费总结数据，为我提供一些针对性的节约开销建议：\n\n");

            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                promptBuilder.append("  支出明细:\n");
                if (ms.getExpenseByCategory().isEmpty()) {
                    promptBuilder.append("    (无支出)\n");
                } else {
                    // Sort categories by amount descending
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    promptBuilder.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                            );
                }
                promptBuilder.append("\n");
            }

            String aiPrompt = promptBuilder.toString();
            System.out.println("AI Service: Sending personal saving tips prompt to AI. Prompt length: " + aiPrompt.length());

            return askAi(aiPrompt);
        } catch (Exception e) {
            System.err.println("AI Service: Failed to give personal saving tips.");
            e.printStackTrace();
            return "生成个性化节约建议失败: " + e.getMessage();
        }
    }


    // ... Keep other methods like analyzeTransactions, formatTransactions, parseDateTime, askAi ...

    // The existing CollegeStudentNeeds class also has budget and tips methods.
    // We need to decide: should AITransactionService offer general AI for anyone,
    // and CollegeStudentNeeds offer student-specific prompts/logic?
    // Or should AITransactionService be the main AI interaction point,
    // and CollegeStudentNeeds just holds student-specific logic/prompts used by AITransactionService?
    // Given the project structure, it might be better to keep student logic in CollegeStudentNeeds
    // and call it from MenuUI or a wrapper service.
    // Let's adjust: generatePersonalSummary, suggestSavingsGoals, givePersonalSavingTips will use monthly summary.
    // CollegeStudentNeeds.generateBudget and generateTipsForSaving can remain using their current logic
    // (budget uses weekly expenses, tips is generic for now).
    // The prompt for CollegeStudentNeeds.generateBudget might need to be updated to use the monthly summary data too for better context.
    // Let's refine CollegeStudentNeeds methods in the next step.

    // For now, the three new methods above will use the monthly summary.
    // The existing analyzeTransactions method in AITransactionService and the methods in CollegeStudentNeeds remain as is for now,
    // but their usage in UI might change slightly.

}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\AIservice\ColledgeStudentThread.java`:

```java
package Service.AIservice;

// Add required imports
import Service.TransactionService; // Keep import if generateBudget throws Exception
// import java.io.IOException; // Removed specific IOException import if using general Exception


public class ColledgeStudentThread implements Runnable{
    // Remove the old budgetRange field, it's not used here
    // public String budgetRange;

    // Field to hold the injected CollegeStudentNeeds service instance
    private final CollegeStudentNeeds collegeStudentNeeds;
    // The file path is still needed to pass to the generateBudget method
    private final String filePath;


    /**
     * Constructor now accepts the CollegeStudentNeeds service instance and the file path.
     * The injected service instance already contains the necessary TransactionService.
     *
     * @param collegeStudentNeeds The CollegeStudentNeeds service instance to use for generating the budget.
     * @param filePath The path to the user's transaction data file.
     */
    public ColledgeStudentThread(CollegeStudentNeeds collegeStudentNeeds, String filePath) {
        this.collegeStudentNeeds = collegeStudentNeeds;
        this.filePath = filePath;
        System.out.println("ColledgeStudentThread initialized for file: " + filePath);
    }

    @Override
    public void run(){
        System.out.println("ColledgeStudentThread started for file: " + filePath);
        try {
            // Call the generateBudget method on the injected service instance
            double[] budget = collegeStudentNeeds.generateBudget(filePath);

            // Print the result or handle it as needed by the test/caller that starts this thread
            if (budget != null && budget.length == 2 && budget[0] != -1) {
                System.out.println("Budget generated in thread for file " + filePath + ": [" + budget[0] + ", " + budget[1] + "]");
            } else {
                // handle the case where budget generation failed or returned -1
                System.out.println("Budget generation in thread finished, but no valid budget was returned for file " + filePath + ".");
                // You might want to distinguish between "no data" (-1,-1) and other exceptions here.
            }
        } catch (Exception e) { // Catch Exception as generateBudget throws Exception
            System.err.println("Error generating budget in thread for file " + filePath + ": " + e.getMessage());
            e.printStackTrace();
        }
        System.out.println("ColledgeStudentThread finished for file: " + filePath);
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\AIservice\CollegeStudentNeeds.java`:

```java
package Service.AIservice;

// ... existing imports ...
import Constants.StandardCategories;
import DAO.TransactionDao;
import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheManager;
import model.Transaction;
import model.MonthlySummary; // Import MonthlySummary
import Service.TransactionService; // Import TransactionService interface


import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.Map; // Import Map
import java.util.Collections; // For sorting map entries
import java.util.Optional;
import java.util.stream.Collectors;


public class CollegeStudentNeeds {
    // Keep existing prompts, maybe refine them to mention using the data provided
    private final String requestBudge="我是一名预算有限的大学生，请根据下面我给出的历史周花费和月度收支总结，帮助我给下周预算范围，必须以[最低预算，最高预算],的方式给出回答，不能有多余的回复。";
    private final String requestTips="我是一名预算有限的大学生，请结合下面我给出的月度消费总结数据，为我推荐一些有针对性的省钱方法。"; // Refined prompt
    // Add the missing constant:
    private final String requestRecognition =
            "请根据以下账单信息推测最合适的交易类型。返回的类型必须精确匹配以下列表中的一个条目：\n" +
                    StandardCategories.getAllCategoriesString() + "\n" + // Include the list of valid categories
                    "如果无法确定，请返回 '其他支出' 或 '其他收入'（取决于收支方向）。只返回类型字符串，不要包含额外文本或解释。账单信息：";
    // AITransactionService is used for asking AI, can be an instance or created on demand
    // private final AITransactionService aiService = new AITransactionService(); // This instance won't have injected TransactionService

    // Need a way to get TransactionService here to generate monthly summaries
    // Option 1: Inject TransactionService into CollegeStudentNeeds constructor
    private final TransactionService transactionService; // Inject TransactionService

    /**
     * Constructor now accepts TransactionService instance.
     */
    public CollegeStudentNeeds(TransactionService transactionService) {
        this.transactionService = transactionService; // Inject the service
        System.out.println("CollegeStudentNeeds initialized with TransactionService.");
    }


    /**
     * Recognizes the spending category of a single transaction using AI. (Keep as is, uses raw transaction)
     *
     * @param transaction The transaction to recognize.
     * @return The AI's suggested category.
     */
    public String RecognizeTransaction(Transaction transaction){
        if (transaction == null) {
            return "无法识别空交易信息";
        }
        StringBuilder sb=new StringBuilder();
        sb.append("交易类型:").append(transaction.getTransactionType()).append(",")
                .append("交易对方:").append(transaction.getCounterparty()).append(",")
                .append("商品:").append(transaction.getCommodity()).append(",")
                .append("收/支:").append(transaction.getInOut()).append(",")
                .append("金额(元):").append(String.format("%.2f", transaction.getPaymentAmount())).append(",") // Format amount
                .append("支付方式:").append(transaction.getPaymentMethod()).append(",")
                .append("备注:").append(transaction.getRemarks());

        System.out.println("CollegeStudentNeeds: Sending recognition request to AI: " + sb.toString());
        // Need a separate AITransactionService instance or method call that doesn't depend on injected TransactionService
        // Option 2: Create a local AITransactionService instance just for askAi calls
        AITransactionService localAiService = new AITransactionService(null); // Pass null for TransactionService as it's not needed by askAi
        return  localAiService.askAi(requestRecognition + sb.toString());
    }

    /**
     * Generates saving tips for college students using AI, now based on monthly summary.
     * @param userFilePath The path to the user's transaction CSV file. (Not strictly needed if service is user-scoped)
     * @return AI's suggested saving tips.
     */
    // Refined to use monthly summary data
    public String generateTipsForSaving(String userFilePath){ // Keep filePath parameter for consistency or remove if service is user-scoped
        try {
            // Get monthly summary data from TransactionService
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary(); // Use injected service
            System.out.println("CollegeStudentNeeds: Retrieved " + summaries.size() + " months of summary data for tips.");

            if (summaries.isEmpty()) {
                return "没有找到足够的交易数据来提供个性化节约建议。";
            }

            StringBuilder promptBuilder = new StringBuilder();
            promptBuilder.append(requestTips).append("\n\n以下是我的月度消费总结数据：\n\n");

            // Sort months chronologically
            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                promptBuilder.append("  支出明细:\n");
                if (ms.getExpenseByCategory().isEmpty()) {
                    promptBuilder.append("    (无支出)\n");
                } else {
                    // Sort categories by amount descending
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    promptBuilder.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                            );
                }
                promptBuilder.append("\n");
            }

            String aiPrompt = promptBuilder.toString();
            System.out.println("CollegeStudentNeeds: Sending saving tips prompt to AI. Prompt length: " + aiPrompt.length());

            // Need a separate AITransactionService instance or method call that doesn't depend on injected TransactionService
            AITransactionService localAiService = new AITransactionService(null); // Pass null for TransactionService
            return localAiService.askAi(aiPrompt);

        } catch (Exception e) {
            System.err.println("CollegeStudentNeeds: Failed to generate saving tips.");
            e.printStackTrace();
            return "生成个性化节约建议失败: " + e.getMessage();
        }
    }

    /**
     * Analyzes weekly spending and asks AI for a budget range, now also includes monthly summary context.
     * @param filePath The path to the user's transaction CSV file.
     * @return A double array [minBudget, maxBudget] parsed from AI response, or [-1, -1] on failure.
     * @throws Exception If there's an error accessing the transaction data.
     */
    // Inside CollegeStudentNeeds class, modify the generateBudget method:

    public double[] generateBudget(String filePath) throws Exception {
        List<Transaction> transactions;
        Map<String, MonthlySummary> summaries; // Declare the summaries variable here

        try {
            // Get transactions using CacheManager
            TransactionDao transactionDaoForLoading = new CsvTransactionDao();
            transactions = CacheManager.getTransactions(filePath, transactionDaoForLoading);
            System.out.println("CollegeStudentNeeds: Retrieved " + transactions.size() + " transactions for budget analysis from: " + filePath);

            // Get monthly summary data for context
            summaries = transactionService.getMonthlyTransactionSummary(); // Assign to the declared variable
            System.out.println("CollegeStudentNeeds: Retrieved " + summaries.size() + " months of summary data for budget context.");

        } catch (Exception e) {
            System.err.println("CollegeStudentNeeds: Error retrieving transactions or summary for budget analysis: " + filePath);
            e.printStackTrace();
            throw e;
        }

        int size = transactions.size();
        if (size == 0) {
            System.out.println("CollegeStudentNeeds: No transactions found for budget analysis.");
            // If no transactions, prompt AI using only the monthly summary (if available)
            if (!summaries.isEmpty()) {
                // Build prompt with only monthly summary
                StringBuilder promptBuilder = new StringBuilder();
                promptBuilder.append("以下是我的月度收支总结数据：\n\n");
                // ... (Code to format monthly summaries for prompt - copy from generatePersonalSummary or generateTipsForSaving) ...
                List<String> sortedMonths = new ArrayList<>(summaries.keySet());
                Collections.sort(sortedMonths);
                for (String month : sortedMonths) {
                    MonthlySummary ms = summaries.get(month);
                    promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                    promptBuilder.append("  总收入: ").append(String.format("%.2f", ms.getTotalIncome())).append("元\n");
                    promptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                    double net = ms.getTotalIncome() - ms.getTotalExpense();
                    promptBuilder.append("  月度净收支: ").append(String.format("%.2f", net)).append("元\n");
                    promptBuilder.append("  主要支出类别:\n"); // Include expense category details
                    if (ms.getExpenseByCategory().isEmpty()) {
                        promptBuilder.append("    (无支出)\n");
                    } else {
                        ms.getExpenseByCategory().entrySet().stream()
                                .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                                .forEach(entry ->
                                        promptBuilder.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                                );
                    }
                    promptBuilder.append("\n");
                }
                // Use the local AI service instance to ask AI
                String answer = new AITransactionService(null).askAi(requestBudge + "\n\n没有找到周支出数据。\n" + promptBuilder.toString());
                return parseDoubleArrayFromString(answer);

            }
            return new double[]{-1, -1}; // No data at all
        }

        // Filter for '支出' transactions and sort them by date (newest first)
        List<Transaction> expenseTransactions = transactions.stream()
                .filter(t -> t.getInOut() != null && (t.getInOut().equals("支出") || t.getInOut().equals("支")))
                .sorted((t1, t2) -> {
                    LocalDate date1 = parseDateSafe(t1.getTransactionTime());
                    LocalDate date2 = parseDateSafe(t2.getTransactionTime());
                    if (date1 != null && date2 != null) { return date2.compareTo(date1); } else if (date1 == null && date2 == null) { return 0; } else if (date1 == null) { return 1; } else { return -1; }
                })
                .collect(Collectors.toList());
        System.out.println("CollegeStudentNeeds: Filtered " + expenseTransactions.size() + " expense transactions for budget analysis.");


        if (expenseTransactions.isEmpty()) {
            System.out.println("CollegeStudentNeeds: No expense transactions found for budget analysis.");
            // Still provide monthly summary context to AI if available
            if (!summaries.isEmpty()) {
                // Build prompt with only monthly summary
                StringBuilder promptBuilder = new StringBuilder();
                promptBuilder.append("以下是我的月度收支总结数据：\n\n");
                // ... (Code to format monthly summaries for prompt - copy from above) ...
                List<String> sortedMonths = new ArrayList<>(summaries.keySet());
                Collections.sort(sortedMonths);
                for (String month : sortedMonths) {
                    MonthlySummary ms = summaries.get(month);
                    promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                    promptBuilder.append("  总收入: ").append(String.format("%.2f", ms.getTotalIncome())).append("元\n");
                    promptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                    double net = ms.getTotalIncome() - ms.getTotalExpense();
                    promptBuilder.append("  月度净收支: ").append(String.format("%.2f", net)).append("元\n");
                    promptBuilder.append("  主要支出类别:\n"); // Include expense category details
                    if (ms.getExpenseByCategory().isEmpty()) {
                        promptBuilder.append("    (无支出)\n");
                    } else {
                        ms.getExpenseByCategory().entrySet().stream()
                                .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                                .forEach(entry ->
                                        promptBuilder.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                                );
                    }
                    promptBuilder.append("\n");
                }
                String answer = new AITransactionService(null).askAi(requestBudge + "\n\n没有找到周支出数据。\n" + promptBuilder.toString());
                return parseDoubleArrayFromString(answer);
            }
            return new double[]{-1, -1}; // No expense data and no summary data
        }

        // --- Weekly Expense Calculation (Keep existing logic) ---
        List<Double> weeklyExpenses = new ArrayList<>();
        LocalDate currentWeekStart = null;
        double currentWeekTotal = 0;

        for (Transaction expense : expenseTransactions) {
            LocalDate transactionDate = parseDateSafe(expense.getTransactionTime());
            if (transactionDate == null) continue;

            if (currentWeekStart == null) {
                currentWeekStart = transactionDate;
            }

            long daysDifference = ChronoUnit.DAYS.between(transactionDate, currentWeekStart);

            if (daysDifference >= 0 && daysDifference < 7) {
                currentWeekTotal += expense.getPaymentAmount();
            } else if (daysDifference >= 7) {
                weeklyExpenses.add(currentWeekTotal);
                currentWeekStart = transactionDate;
                currentWeekTotal = expense.getPaymentAmount();
            }
        }
        if (currentWeekTotal > 0 || currentWeekStart != null) {
            weeklyExpenses.add(currentWeekTotal);
        }
        System.out.println("CollegeStudentNeeds: Calculated weekly expenses for " + weeklyExpenses.size() + " weeks: " + weeklyExpenses);


        // --- Format Prompt including Weekly Expenses and Monthly Summary ---
        StringBuilder promptBuilder = new StringBuilder();
        promptBuilder.append(requestBudge).append("\n\n"); // Start with the budget request prompt

        // Add Weekly Expenses Section
        promptBuilder.append("以下是我最近的每周花费数据：\n");
        if (weeklyExpenses.isEmpty()) {
            promptBuilder.append("(没有找到足够周期的支出数据)\n");
        } else {
            for (int i = 0; i < weeklyExpenses.size(); i++) {
                promptBuilder.append("第");
                promptBuilder.append(weeklyExpenses.size() - 1 - i);
                promptBuilder.append("周:花费");
                promptBuilder.append(String.format("%.2f", weeklyExpenses.get(i)));
                promptBuilder.append("元; ");
            }
            promptBuilder.append("\n");
        }

        // Add Monthly Summary Section
        promptBuilder.append("\n同时，以下是我的月度收支总结数据：\n\n");
        if (summaries.isEmpty()) {
            promptBuilder.append("(没有找到月度总结数据)\n");
        } else {
            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  总收入: ").append(String.format("%.2f", ms.getTotalIncome())).append("元\n");
                promptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                double net = ms.getTotalIncome() - ms.getTotalExpense();
                promptBuilder.append("  月度净收支: ").append(String.format("%.2f", net)).append("元\n");
                promptBuilder.append("  主要支出类别:\n"); // Include expense category details
                if (ms.getExpenseByCategory().isEmpty()) {
                    promptBuilder.append("    (无支出)\n");
                } else {
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    promptBuilder.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                            );
                }
                promptBuilder.append("\n");
            }
        }


        String aiPrompt = promptBuilder.toString(); // This now contains the full prompt
        System.out.println("CollegeStudentNeeds: Sending budget request to AI. Prompt length: " + aiPrompt.length());

        // Use the local AI service instance to ask AI
        String answer = new AITransactionService(null).askAi(aiPrompt); // Pass null as askAi doesn't need TransactionService
        System.out.println("CollegeStudentNeeds: Received budget response from AI: " + answer);

        double[] ret = parseDoubleArrayFromString(answer);
        if (ret == null || ret.length != 2) {
            System.err.println("CollegeStudentNeeds: Failed to parse budget array from AI response: " + answer + ". Full AI Response: " + answer); // Log the full response
            return new double[]{-1, -1};
        }

        return ret;
    }

    // Helper method to safely parse date from transaction time string (must be consistent!)
    private LocalDate parseDateSafe(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // Clean whitespace and potential hyphens if the expected format is slash-separated
        String datePart = timeStr.split(" ")[0]; // Get the date part

        datePart = datePart.trim().replace('-', '/').replaceAll("\\s+", "");

        List<String> patterns = List.of(
                "yyyy/M/d", "yyyy/MM/d", "yyyy/M/dd", "yyyy/MM/dd",
                "yyyy-MM-dd" // Add dash format just in case
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDate.parse(datePart, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern
            }
        }
        System.err.println("CollegeStudentNeeds: Failed to parse date part '" + datePart + "' from transaction time: " + timeStr);
        return null; // Return null if no pattern matches
    }

    // Keep parseDoubleArrayFromString method - ensure robustness
    public double[] parseDoubleArrayFromString(String input) {
        // ... existing robust implementation ...
        if (input == null) { return null; }
        String trimmedInput = input.trim();
        System.out.println("CollegeStudentNeeds: Attempting to parse budget string: '" + trimmedInput + "'");
        int startIndex = trimmedInput.indexOf('[');
        int endIndex = trimmedInput.lastIndexOf(']');
        if (startIndex == -1 || endIndex == -1 || endIndex < startIndex) {
            System.err.println("CollegeStudentNeeds: Budget string does not contain valid []. Input: " + trimmedInput);
            return null;
        }
        String content = trimmedInput.substring(startIndex + 1, endIndex).trim();
        String[] numberStrings = content.split("\\s*,\\s*");
        if (numberStrings.length != 2) {
            System.err.println("CollegeStudentNeeds: Budget string content does not contain exactly two numbers separated by comma. Content: " + content);
            return null;
        }
        double[] result = new double[2];
        try {
            result[0] = Double.parseDouble(numberStrings[0].trim());
            result[1] = Double.parseDouble(numberStrings[1].trim());
            System.out.println("CollegeStudentNeeds: Successfully parsed budget: [" + result[0] + ", " + result[1] + "]");
            return result;
        } catch (NumberFormatException e) {
            System.err.println("CollegeStudentNeeds: Error parsing numbers from budget string: " + content);
            e.printStackTrace();
            return null;
        }
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\Impl\SummaryStatisticService.java`:

```java
package Service.Impl;

import Constants.StandardCategories; // Import StandardCategories
import DAO.TransactionDao; // Import TransactionDao interface
import DAO.UserDao; // Import UserDao interface
import DAO.SummaryStatisticDao; // Import SummaryStatisticDao interface
import model.SummaryStatistic;
import model.Transaction;
import model.User;
import Utils.CacheManager; // Import CacheManager
import Constants.ConfigConstants; // Import ConfigConstants for summary file path

import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.temporal.WeekFields; // For getting week of year
import java.util.*;
import java.util.stream.Collectors;
import java.time.format.DateTimeFormatter; // For generating timestamp

public class SummaryStatisticService {

    private final UserDao userDao;
    private final TransactionDao transactionDao; // Need a DAO instance for CacheManager loading
    private final SummaryStatisticDao summaryStatisticDao;
    private final String summaryFilePath;

    /**
     * Constructor to inject dependencies.
     * @param userDao DAO for user data.
     * @param transactionDao DAO for transaction data (used by CacheManager loader).
     * @param summaryStatisticDao DAO for summary statistics data.
     */
    public SummaryStatisticService(UserDao userDao, TransactionDao transactionDao, SummaryStatisticDao summaryStatisticDao) {
        this.userDao = userDao;
        this.transactionDao = transactionDao; // Injected for use in CacheManager loader
        this.summaryStatisticDao = summaryStatisticDao;
        this.summaryFilePath = ConfigConstants.SUMMARY_CSV_PATH; // Get summary file path from config
        System.out.println("SummaryStatisticService initialized. Summary file: " + summaryFilePath);
    }

    /**
     * Helper method to load all transactions from all user files.
     * Uses CacheManager to benefit from caching.
     * @param users List of all users.
     * @return A single list containing all transactions from all users.
     * @throws Exception If loading from any user file fails.
     */
    private List<Transaction> loadAllTransactionsFromAllUsers(List<User> users) throws Exception {
        List<Transaction> allTransactions = new ArrayList<>();
        for (User user : users) {
            String userFilePath = user.getTransactionFilePath();
            if (userFilePath != null && !userFilePath.trim().isEmpty()) {
                try {
                    // Use CacheManager to get transactions for this user's file
                    // Pass the transactionDao instance for the loader
                    List<Transaction> userTransactions = CacheManager.getTransactions(userFilePath, transactionDao);
                    allTransactions.addAll(userTransactions);
                    System.out.println("Loaded " + userTransactions.size() + " transactions for user: " + user.getUsername() + " from " + userFilePath);
                } catch (Exception e) {
                    System.err.println("Error loading transactions for user " + user.getUsername() + " from " + userFilePath + ". Skipping this user.");
                    e.printStackTrace();
                    // Decide whether to stop or continue if one user's file fails.
                    // Continuing is more robust for aggregate statistics.
                    // throw e; // Uncomment to stop processing if any user file fails
                }
            } else {
                System.out.println("User " + user.getUsername() + " has no transaction file path configured. Skipping.");
            }
        }
        return allTransactions;
    }


    /**
     * Helper method to group transactions by week identifier (YYYY-Www).
     * @param transactions The list of transactions.
     * @return A map where keys are week identifiers and values are lists of transactions in that week.
     */
    private Map<String, List<Transaction>> groupTransactionsByWeek(List<Transaction> transactions) {
        WeekFields weekFields = WeekFields.ISO; // ISO 8601 week numbering (Monday is the first day of the week)
        DateTimeFormatter weekFormatter = DateTimeFormatter.ofPattern("yyyy-'W'ww"); // Format as "YYYY-Www"

        return transactions.stream()
                .filter(t -> t.getTransactionTime() != null && !t.getTransactionTime().trim().isEmpty()) // Filter out transactions with no time
                .collect(Collectors.groupingBy(t -> {
                    try {
                        // Safely parse the transaction date (only date part is needed for week)
                        // Need to ensure the parser is consistent with the one in TransactionServiceImpl/AITransactionService
                        // Let's re-use the safe parsing logic or ensure consistency.
                        // Simplest: Use a helper method for date parsing just for this service, matching expected formats.
                        LocalDate date = parseDateFromTransactionTime(t.getTransactionTime());
                        if (date != null) {
                            return date.format(weekFormatter); // Format date to week identifier
                        }
                    } catch (Exception e) {
                        System.err.println("Failed to parse date for week grouping: " + t.getTransactionTime() + ". Skipping transaction.");
                        // Transaction with unparseable date will be grouped under 'null' or skipped by filter
                    }
                    return "未知周"; // Group unparseable dates under an 'unknown' key
                }));
    }

    // Helper method to parse date from transaction time string (should match other parsers)
    private LocalDate parseDateFromTransactionTime(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // Clean whitespace and potential hyphens if the expected format is slash-separated
        // Assume the format used in CSV/Transaction model is one of the parsers in other services
        // Let's use a robust set of date patterns matching parseDateTimeSafe in TransactionServiceImpl
        String datePart = timeStr.split(" ")[0]; // Get the date part

        datePart = datePart.trim().replace('-', '/').replaceAll("\\s+", "");


        // Try parsing with multiple slash formats
        List<String> patterns = List.of(
                "yyyy/M/d", "yyyy/MM/d", "yyyy/M/dd", "yyyy/MM/dd",
                "yyyy-MM-dd" // Add dash format just in case
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDate.parse(datePart, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern
            }
        }
        System.err.println("SummaryStatisticService: Failed to parse date part '" + datePart + "' from transaction time: " + timeStr);
        return null; // Return null if no pattern matches
    }


    /**
     * Retrieves all summary statistics from the data source.
     * @return List of summary statistics.
     * @throws IOException If loading fails.
     */
    public List<SummaryStatistic> getAllSummaryStatistics() throws IOException {
        // Simply delegate to the DAO
        return summaryStatisticDao.loadAllStatistics(summaryFilePath);
    }


    // --- Revised Plan for generateAndSaveWeeklyStatistics ---
    // The previous approach of loading all transactions and then grouping by week
    // doesn't easily allow counting unique users per week unless we augment the Transaction object
    // or wrap it with User info during loading.
    // A better approach for unique user count is to process user by user.

    public void generateAndSaveWeeklyStatistics() throws Exception {
        System.out.println("Generating weekly summary statistics (Revised approach)...");
        List<User> allUsers = userDao.getAllUsers();
        System.out.println("Loaded " + allUsers.size() + " users.");

        // Map to hold weekly stats per user (WeekId -> Map<UserId, UserWeeklyStats>)
        // This intermediate structure is complex.

        // Map to hold aggregated stats for each week (WeekId -> AggregatedWeeklyStats)
        Map<String, Double> totalIncomeByWeek = new HashMap<>();
        Map<String, Double> totalExpenseByWeek = new HashMap<>();
        Map<String, Map<String, Double>> expenseByCategoryByWeek = new HashMap<>(); // WeekId -> (Category -> Amount)
        Map<String, Set<String>> usersByWeek = new HashMap<>(); // WeekId -> Set<Username>

        WeekFields weekFields = WeekFields.ISO;
        DateTimeFormatter weekFormatter = DateTimeFormatter.ofPattern("yyyy-'W'ww");


        // Iterate through each user
        for (User user : allUsers) {
            String userFilePath = user.getTransactionFilePath();
            String username = user.getUsername();

            if (userFilePath != null && !userFilePath.trim().isEmpty()) {
                try {
                    // Load transactions for this user
                    List<Transaction> userTransactions = CacheManager.getTransactions(userFilePath, transactionDao);
                    System.out.println("Processing " + userTransactions.size() + " transactions for user: " + username);

                    // Iterate through transactions for this user
                    for (Transaction t : userTransactions) {
                        if (t.getTransactionTime() == null || t.getTransactionTime().trim().isEmpty()) {
                            System.err.println("Skipping transaction with no time for user " + username + ": " + t.getOrderNumber());
                            continue; // Skip transactions with no time
                        }

                        LocalDate date = parseDateFromTransactionTime(t.getTransactionTime());
                        if (date == null) {
                            System.err.println("Skipping transaction with unparseable date for user " + username + ": " + t.getTransactionTime());
                            continue; // Skip transactions with invalid date
                        }

                        String weekIdentifier = date.format(weekFormatter);

                        // Add user to the set for this week
                        usersByWeek.computeIfAbsent(weekIdentifier, k -> new HashSet<>()).add(username);

                        // Aggregate income/expense
                        if (t.getInOut() != null) {
                            String inOut = t.getInOut().trim();
                            if (inOut.equals("收入") || inOut.equals("收")) {
                                totalIncomeByWeek.put(weekIdentifier, totalIncomeByWeek.getOrDefault(weekIdentifier, 0.0) + t.getPaymentAmount());
                            } else if (inOut.equals("支出") || inOut.equals("支")) {
                                totalExpenseByWeek.put(weekIdentifier, totalExpenseByWeek.getOrDefault(weekIdentifier, 0.0) + t.getPaymentAmount());

                                // Aggregate expense by standard category
                                String rawType = t.getTransactionType();
                                String standardCategory = StandardCategories.getStandardCategory(rawType);
                                // Only aggregate standard expense categories for the top category calculation
                                if (StandardCategories.isStandardExpenseCategory(standardCategory) || !StandardCategories.ALL_KNOWN_TYPES.contains(standardCategory)) {
                                    String effectiveExpenseCategoryForTop = StandardCategories.isStandardExpenseCategory(standardCategory) ? standardCategory : "其他支出";
                                    expenseByCategoryByWeek.computeIfAbsent(weekIdentifier, k -> new HashMap<>())
                                            .put(effectiveExpenseCategoryForTop, expenseByCategoryByWeek.get(weekIdentifier).getOrDefault(effectiveExpenseCategoryForTop, 0.0) + t.getPaymentAmount());
                                }
                            }
                        }
                    }
                } catch (Exception e) {
                    System.err.println("Error loading transactions for user " + user.getUsername() + " from " + userFilePath + ". Skipping this user's data for statistics.");
                    e.printStackTrace();
                    // Continue processing other users
                }
            } else {
                System.out.println("User " + user.getUsername() + " has no transaction file path configured. Skipping for statistics.");
            }
        }
        System.out.println("Completed aggregation across all users by week.");


        // 5. Consolidate aggregated data into SummaryStatistic objects
        List<SummaryStatistic> calculatedStatistics = new ArrayList<>();
        DateTimeFormatter timestampFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String timestamp = LocalDateTime.now().format(timestampFormatter);

        // Iterate through all week identifiers found
        Set<String> allWeeks = new HashSet<>();
        allWeeks.addAll(totalIncomeByWeek.keySet());
        allWeeks.addAll(totalExpenseByWeek.keySet());
        allWeeks.addAll(usersByWeek.keySet());
        allWeeks.addAll(expenseByCategoryByWeek.keySet());

        List<String> sortedWeekIdentifiers = allWeeks.stream().sorted().collect(Collectors.toList());

        for (String weekIdentifier : sortedWeekIdentifiers) {
            double totalIncome = totalIncomeByWeek.getOrDefault(weekIdentifier, 0.0);
            double totalExpense = totalExpenseByWeek.getOrDefault(weekIdentifier, 0.0);
            int numberOfUsers = usersByWeek.getOrDefault(weekIdentifier, Collections.emptySet()).size();

            // Find top expense category for this week
            Map<String, Double> weeklyExpenseByCategory = expenseByCategoryByWeek.getOrDefault(weekIdentifier, Collections.emptyMap());
            String topExpenseCategory = "无支出";
            double topExpenseCategoryAmount = 0.0;

            Optional<Map.Entry<String, Double>> maxEntry = weeklyExpenseByCategory.entrySet().stream()
                    .max(Map.Entry.comparingByValue());

            if (maxEntry.isPresent()) {
                topExpenseCategory = maxEntry.get().getKey();
                topExpenseCategoryAmount = maxEntry.get().getValue();
            }

            calculatedStatistics.add(new SummaryStatistic(
                    weekIdentifier,
                    totalIncome,
                    totalExpense,
                    topExpenseCategory,
                    topExpenseCategoryAmount,
                    numberOfUsers,
                    timestamp // Timestamp is when the stats were generated, not per week
            ));
        }
        System.out.println("Created " + calculatedStatistics.size() + " SummaryStatistic objects.");


        // 6. Load existing statistics
        List<SummaryStatistic> existingStatistics = getAllSummaryStatistics();
        System.out.println("Loaded " + existingStatistics.size() + " existing summary statistics.");

        // 7. Merge existing and newly calculated statistics (overwrite new weeks, keep old)
        Map<String, SummaryStatistic> finalStatisticsMap = new HashMap<>();
        for(SummaryStatistic stat : existingStatistics) {
            finalStatisticsMap.put(stat.getWeekIdentifier(), stat);
        }
        for(SummaryStatistic stat : calculatedStatistics) {
            finalStatisticsMap.put(stat.getWeekIdentifier(), stat); // New calculation replaces old for the week
        }

        // 8. Sort merged statistics by week identifier (chronologically)
        List<SummaryStatistic> finalStatistics = finalStatisticsMap.values().stream()
                .sorted(Comparator.comparing(SummaryStatistic::getWeekIdentifier))
                .collect(Collectors.toList());

        // 9. Save the final list
        summaryStatisticDao.writeAllStatistics(summaryFilePath, finalStatistics);
        System.out.println("Weekly summary statistics generated and saved successfully to " + summaryFilePath);
    }


}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\Impl\TransactionServiceImpl.java`:

```java
package Service.Impl;

import Constants.StandardCategories;
import DAO.TransactionDao; // Import the interface
import DAO.Impl.CsvTransactionDao; // Import the implementation
import Service.TransactionService;
import Utils.CacheManager; // Import the new CacheManager
import model.MonthlySummary;
import model.Transaction;

import javax.swing.*;
import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.YearMonth;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors; // Needed for search

// Remove static field
// public static CsvTransactionDao csvTransactionDao;

// Remove direct CacheUtil instance
// public final CacheUtil<String, List<Transaction>, Exception> cache;

public class TransactionServiceImpl implements TransactionService {

    private final String currentUserTransactionFilePath; // Store the user's file path
    // TransactionDao instance needed to load data if cache misses
    private final TransactionDao transactionDao;

    /**
     * Constructor now accepts the user's transaction file path.
     *
     * @param currentUserTransactionFilePath The file path for the current user's transactions.
     */
    public TransactionServiceImpl(String currentUserTransactionFilePath) {
        this.currentUserTransactionFilePath = currentUserTransactionFilePath;
        // Create a DAO instance for this service instance.
        this.transactionDao = new CsvTransactionDao(); // One DAO instance per service instance
        System.out.println("TransactionServiceImpl initialized for file: " + currentUserTransactionFilePath);
        // Cache is managed by CacheManager, not directly by this instance.
    }

    @Override // Implement the new interface method
    public List<Transaction> getAllTransactions() throws Exception {
        // Simply call the internal method that uses the cache
        return getAllTransactionsForCurrentUser();
    }

    /**
     * Imports transactions from a given CSV file path into the current user's transactions.
     * Reads the import file, merges with existing data, and saves back.
     *
     * @param userFilePath The file path for the current user's transactions (target).
     * @param importFilePath The file path of the CSV to import from (source).
     * @return The number of transactions successfully imported.
     * @throws Exception If an error occurs during reading, parsing, or saving.
     */
    @Override // Implement the new interface method
    public int importTransactionsFromCsv(String userFilePath, String importFilePath) throws Exception {
        System.out.println("Starting import from " + importFilePath + " to user file " + userFilePath);
        List<Transaction> existingTransactions;
        List<Transaction> transactionsToImport;

        try {
            // 1. Load existing transactions for the current user (from cache/file)
            // Use the method that uses the CacheManager
            existingTransactions = getAllTransactions(); // Already uses CacheManager

            // 2. Read and parse transactions from the import file
            // Use the DAO's loadFromCSV method with the import file path
            // Need a *separate* DAO instance or method call that targets the import file
            TransactionDao importDao = new CsvTransactionDao(); // Create a temporary DAO for reading the import file
            transactionsToImport = importDao.loadFromCSV(importFilePath); // Load from the selected file
            System.out.println("Read " + transactionsToImport.size() + " transactions from import file.");

        } catch (IOException e) {
            System.err.println("Error loading files during import process.");
            e.printStackTrace();
            throw new Exception("读取交易数据失败！", e); // Wrap and re-throw
        }

        // 3. Merge imported transactions with existing ones
        // Simple merge: add all imported transactions.
        // Handle potential duplicates: check if order number exists.
        // If order numbers are not guaranteed unique in imported file or against existing,
        // consider generating new unique IDs for imported items if their ON is empty or conflicts.
        List<Transaction> mergedTransactions = new ArrayList<>(existingTransactions);
        int importedCount = 0;

        for (Transaction importedTx : transactionsToImport) {
            // Basic Check: Ensure imported transaction has an order number or generate one
            if (importedTx.getOrderNumber() == null || importedTx.getOrderNumber().trim().isEmpty()) {
                // Generate a unique ID for transactions without one
                String uniqueId = "IMPORT_" + UUID.randomUUID().toString();
                importedTx.setOrderNumber(uniqueId);
                System.out.println("Generated unique order number for imported transaction: " + uniqueId);
            } else {
                // Check for potential duplicate order number against existing transactions
                boolean duplicate = existingTransactions.stream()
                        .anyMatch(t -> t.getOrderNumber().trim().equals(importedTx.getOrderNumber().trim()));
                if (duplicate) {
                    System.err.println("Skipping imported transaction due to duplicate order number: " + importedTx.getOrderNumber());
                    // Decide: skip, overwrite, or generate new ID. Skipping for now.
                    JOptionPane.showMessageDialog(null, "发现重复交易单号: " + importedTx.getOrderNumber() + ", 已跳过。", "导入警告", JOptionPane.WARNING_MESSAGE);
                    continue; // Skip this duplicate transaction
                }
            }

            // Add the transaction to the merged list
            mergedTransactions.add(importedTx);
            importedCount++;
        }
        System.out.println("Merged transactions. Total after merge: " + mergedTransactions.size() + ". Successfully imported count: " + importedCount);


        // 4. Save the merged list back to the current user's file
        try {
            // Use the DAO instance associated with this service (which knows the user's file implicitly via CacheManager interactions, but writeAllStatistics needs the path explicitly)
            // The transactionDao field is initialized as CsvTransactionDao, which has writeAllStatistics.
            transactionDao.writeTransactionsToCSV(userFilePath, mergedTransactions);
            System.out.println("Saved merged transactions to user file: " + userFilePath);

            // 5. Invalidate or update the cache for the current user's file
            // Invalidation is simpler: forces CacheManager to reload from the updated file next time.
            CacheManager.invalidateTransactionCache(userFilePath);
            System.out.println("Cache invalidated for user file: " + userFilePath);


        } catch (IOException e) {
            System.err.println("Error saving merged transactions after import.");
            e.printStackTrace();
            // Consider leaving the original file untouched on save failure
            throw new Exception("保存导入的交易数据失败！", e); // Wrap and re-throw
        }

        System.out.println("Import process finished.");
        return importedCount; // Return the count of transactions actually added
    }

    /**
     * Gets all transactions for the current user from the cache (loading if necessary).
     * Made protected or public if needed by subclasses, but private is fine for now.
     * @return List of transactions.
     * @throws Exception If an error occurs during loading.
     */
    private List<Transaction> getAllTransactionsForCurrentUser() throws Exception { // Kept as private or change if needed
        // Get transactions using the CacheManager for the current user's file
        return CacheManager.getTransactions(currentUserTransactionFilePath, transactionDao);
    }


//    /**
//     * Gets all transactions for the current user from the cache (loading if necessary).
//     *
//     * @return List of transactions.
//     * @throws Exception If an error occurs during loading.
//     */
//    private List<Transaction> getAllTransactionsForCurrentUser() throws Exception {
//        // Get transactions using the CacheManager for the current user's file
//        return CacheManager.getTransactions(currentUserTransactionFilePath, transactionDao);
//    }


    /**
     * Add transaction for the current user.
     *
     * @param transaction The new transaction to add.
     */
    @Override
    public void addTransaction(Transaction transaction) throws IOException {
        // Set transaction time to current time if not already set
        if (transaction.getTransactionTime() == null || transaction.getTransactionTime().isEmpty()) {
            LocalDateTime now = LocalDateTime.now();
            // Using a flexible format, match parseDateTime in AITransactionService
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
            String currentTime = now.format(formatter);
            transaction.setTransactionTime(currentTime);
        }

        try {
            // Call DAO layer to add transaction to the user's specific file
            transactionDao.addTransaction(currentUserTransactionFilePath, transaction);

            // After adding, invalidate the cache for this user's file
            // Or, ideally, reload the data and put the new list into the cache.
            // Invalidation is simpler for now, forcing a reload on next get.
            CacheManager.invalidateTransactionCache(currentUserTransactionFilePath);
            System.out.println("Transaction added and cache invalidated for " + currentUserTransactionFilePath);

        } catch (IOException e) {
            System.err.println("Error adding transaction for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e; // Re-throw
        }
    }

    /**
     * Change transaction information for the current user.
     *
     * @param updatedTransaction The transaction object with updated information.
     */
    @Override
    public void changeTransaction(Transaction updatedTransaction) throws Exception {
        try {
            // Load existing transactions (from cache/file)
            List<Transaction> allTransactions = getAllTransactionsForCurrentUser();

            // Find and update the target transaction in the list
            boolean foundAndUpdatedInMemory = false;
            List<Transaction> updatedList = new ArrayList<>(allTransactions.size()); // Create a new list or modify in place
            for (Transaction t : allTransactions) {
                if (t.getOrderNumber().trim().equals(updatedTransaction.getOrderNumber().trim())) {
                    // Found the transaction, apply updates
                    updateTransactionFields(t, updatedTransaction); // Helper method to apply updates
                    updatedList.add(t); // Add the modified transaction
                    foundAndUpdatedInMemory = true;
                    System.out.println("Transaction with order number " + updatedTransaction.getOrderNumber() + " found and updated in memory.");
                } else {
                    updatedList.add(t); // Add unchanged transactions
                }
            }


            if (!foundAndUpdatedInMemory) {
                throw new IllegalArgumentException("未找到交易单号: " + updatedTransaction.getOrderNumber() + " 在文件 " + currentUserTransactionFilePath + " 中");
            }

            // Write the entire updated list back to the CSV file
            transactionDao.writeTransactionsToCSV(currentUserTransactionFilePath, updatedList);
            System.out.println("Updated transaction with order number " + updatedTransaction.getOrderNumber() + " and wrote back to file.");

            // Update the cache with the modified list
            CacheManager.putTransactions(currentUserTransactionFilePath, updatedList, transactionDao);
            System.out.println("Cache updated with the modified transaction list for " + currentUserTransactionFilePath);

        } catch (IOException e) {
            System.err.println("Error changing transaction for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e;
        } catch (Exception e) { // Catch exception from getAllTransactionsForCurrentUser
            System.err.println("Error loading transactions for change operation: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e;
        }
    }

    /**
     * Helper method: Updates non-empty fields from source to target.
     */
    private void updateTransactionFields(Transaction target, Transaction source) {
        // Assuming orderNumber is the key and shouldn't be updated this way
        // Add checks for null and empty strings before updating
        if (source.getTransactionTime() != null && !source.getTransactionTime().trim().isEmpty()) {
            target.setTransactionTime(source.getTransactionTime().trim());
        }
        if (source.getTransactionType() != null && !source.getTransactionType().trim().isEmpty()) {
            target.setTransactionType(source.getTransactionType().trim());
        }
        if (source.getCounterparty() != null && !source.getCounterparty().trim().isEmpty()) {
            target.setCounterparty(source.getCounterparty().trim());
        }
        if (source.getCommodity() != null && !source.getCommodity().trim().isEmpty()) {
            target.setCommodity(source.getCommodity().trim());
        }
        // Handle InOut specifically if it's from a ComboBox with predefined options
        if (source.getInOut() != null && !source.getInOut().trim().isEmpty()) {
            String inOut = source.getInOut().trim();
            if (inOut.equals("收入") || inOut.equals("支出") || inOut.equals("支") || inOut.equals("收")) { // Be flexible with input
                target.setInOut(inOut);
            } else {
                System.err.println("Warning: Invalid value for 收/支: " + source.getInOut() + ". Keeping original.");
                // Optionally throw an IllegalArgumentException
            }
        }
        // Handle paymentAmount - 0.0 might be a valid amount, check if it was explicitly set
        // A better approach for primitive types is to check if the source object
        // represents a "partial update" and how unset primitives are marked.
        // For simplicity here, let's assume 0.0 *is* a valid amount that can be set.
        // If you need to differentiate "not set" from "set to 0.0", the source object
        // would need flags or use wrapper types (Double) and check for null.
        // Let's refine this: Only update if the source amount is NOT 0.0, or if the source object signals it's a full update.
        // Assuming the UI passes a new Transaction object where primitive 0.0 means 'not updated'.
        // This is a common pattern but needs careful handling.
        // If the UI explicitly allows setting 0.0, this logic needs adjustment.
        // For now, let's assume 0.0 is treated as 'no update' UNLESS the original transaction amount was also 0.0.
        // A safer way: If the user edited the amount field in the dialog, we *should* update it, even to 0.0.
        // The MenuUI's editRow extracts values into fields, so we can assume the value from fields[5].getText()
        // represents the user's intended new value. The Double.parseDouble already happened in MenuUI.
        // So, if the source object has a non-zero amount, update. What if the user wants to set it to 0?
        // The current dialog doesn't distinguish. Let's assume for now that any double value from the dialog
        // should be applied. This might need refinement based on UI behavior.
        target.setPaymentAmount(source.getPaymentAmount()); // Simply update the amount


        if (source.getPaymentMethod() != null && !source.getPaymentMethod().trim().isEmpty()) {
            target.setPaymentMethod(source.getPaymentMethod().trim());
        }
        if (source.getCurrentStatus() != null && !source.getCurrentStatus().trim().isEmpty()) {
            target.setCurrentStatus(source.getCurrentStatus().trim());
        }
        // OrderNumber is typically the key, updating it is risky and often disallowed.
        // If allowed, need to ensure uniqueness and handle file operations carefully.
        // Let's assume OrderNumber should NOT be changed via this method.
        // if (source.getOrderNumber() != null && !source.getOrderNumber().trim().isEmpty()) {
        //     target.setOrderNumber(source.getOrderNumber().trim()); // Potential issue if new ON conflicts
        // }
        if (source.getMerchantNumber() != null && !source.getMerchantNumber().trim().isEmpty()) {
            target.setMerchantNumber(source.getMerchantNumber().trim());
        }
        if (source.getRemarks() != null && !source.getRemarks().trim().isEmpty()) {
            target.setRemarks(source.getRemarks().trim());
        }
        System.out.println("Applied updates to transaction: " + target.getOrderNumber());
    }


    /**
     * Delete transaction for the current user by order number.
     *
     * @param orderNumber The unique order number of the transaction to delete.
     * @return true if deletion was successful.
     * @throws Exception If an error occurs or transaction is not found.
     */
    @Override
    public boolean deleteTransaction(String orderNumber) throws Exception {
        try {
            // Call DAO layer to delete transaction from the user's specific file
            boolean deleted = transactionDao.deleteTransaction(currentUserTransactionFilePath, orderNumber);

            if (deleted) {
                // After deleting, invalidate the cache for this user's file
                CacheManager.invalidateTransactionCache(currentUserTransactionFilePath);
                System.out.println("Transaction with order number " + orderNumber + " deleted and cache invalidated for " + currentUserTransactionFilePath);
            } else {
                // If DAO returns false, it means the order number was not found.
                System.out.println("Transaction with order number " + orderNumber + " not found for deletion in " + currentUserTransactionFilePath);
            }
            return deleted; // Return true if deletion occurred, false if not found

        } catch (IOException e) {
            System.err.println("Error deleting transaction for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e; // Re-throw
        }
        // No need for explicit "未找到交易单号" exception here if DAO returns false,
        // MenuUI can check the boolean result and show a message.
    }

    /**
     * Search transactions for the current user based on criteria.
     *
     * @param searchCriteria The Transaction object containing search criteria.
     * @return List of matched transactions.
     */
    @Override
    public List<Transaction> searchTransaction(Transaction searchCriteria) {
        try {
            // 1. Get all transactions for the current user (from cache/file)
            List<Transaction> allTransactions = getAllTransactionsForCurrentUser();
            System.out.println("Searching through " + allTransactions.size() + " transactions for user " + currentUserTransactionFilePath);


            // 2. Filter transactions based on criteria
            // Use stream().filter() for conciseness and potential parallelism (though unlikely needed here)
            List<Transaction> matched = allTransactions.stream()
                    .filter(t -> matchesCriteria(t, searchCriteria))
                    .collect(Collectors.toList());
            System.out.println("Found " + matched.size() + " matching transactions.");


            // 3. Sort matched transactions by time, newest first
            matched.sort((t1, t2) -> {
                // Safely parse and compare dates, fall back to string comparison if parsing fails
                LocalDateTime time1 = parseDateTimeSafe(t1.getTransactionTime());
                LocalDateTime time2 = parseDateTimeSafe(t2.getTransactionTime());

                if (time1 != null && time2 != null) {
                    return time2.compareTo(time1); // Newest first
                } else if (time1 == null && time2 == null) {
                    return 0; // Both unparseable, treat as equal
                } else if (time1 == null) {
                    return 1; // Unparseable times come later
                } else { // time2 == null
                    return -1; // Unparseable times come later
                }
            });
            System.out.println("Matched transactions sorted.");

            return matched;
        } catch (Exception e) { // Catch exception from getAllTransactionsForCurrentUser
            System.err.println("Error during search operation for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            // Depending on UI, you might want to return an empty list or propagate the exception
            // For search, returning empty list and logging error is often user-friendly.
            return List.of();
        }
    }

    /**
     * Helper method: Checks if a single transaction matches the search criteria.
     */
    private boolean matchesCriteria(Transaction transaction, Transaction criteria) {
        // Criteria fields are implicitly ANDed. Null/empty criteria fields match everything.
        return containsIgnoreCase(transaction.getTransactionTime(), criteria.getTransactionTime())
                && containsIgnoreCase(transaction.getTransactionType(), criteria.getTransactionType())
                && containsIgnoreCase(transaction.getCounterparty(), criteria.getCounterparty())
                && containsIgnoreCase(transaction.getCommodity(), criteria.getCommodity())
                && matchesInOutCriteria(transaction.getInOut(), criteria.getInOut()) // Specific check for In/Out
                && containsIgnoreCase(transaction.getPaymentMethod(), criteria.getPaymentMethod());
        // Note: paymentAmount is not used as a search criterion in MenuUI's search panel currently.
        // If needed, add logic here, e.g., checking if criteria.getPaymentAmount() is set
        // and if transaction.getPaymentAmount() falls within a range or matches exactly.
    }

    /**
     * Helper method: Fuzzy match string, ignoring case and trimming whitespace.
     * An empty/null target criteria matches everything.
     */
    private boolean containsIgnoreCase(String source, String target) {
        if (target == null || target.trim().isEmpty()) {
            return true; // Empty criteria matches everything
        }
        if (source == null) {
            return false; // Source is null, cannot contain non-empty target
        }
        return source.trim().toLowerCase().contains(target.trim().toLowerCase());
    }

    /**
     * Helper method: Matches In/Out criteria. Handles cases like "收入" vs "收", "支出" vs "支".
     * An empty/null target criteria matches everything.
     */
    private boolean matchesInOutCriteria(String source, String target) {
        if (target == null || target.trim().isEmpty()) {
            return true; // Empty criteria matches everything
        }
        if (source == null) {
            return false; // Source is null
        }
        String sourceTrimmed = source.trim();
        String targetTrimmed = target.trim();

        if (targetTrimmed.equalsIgnoreCase("收入") || targetTrimmed.equalsIgnoreCase("收")) {
            return sourceTrimmed.equalsIgnoreCase("收入") || sourceTrimmed.equalsIgnoreCase("收");
        }
        if (targetTrimmed.equalsIgnoreCase("支出") || targetTrimmed.equalsIgnoreCase("支")) {
            return sourceTrimmed.equalsIgnoreCase("支出") || sourceTrimmed.equalsIgnoreCase("支");
        }
        // If target is something else, do a simple contains check
        return sourceTrimmed.toLowerCase().contains(targetTrimmed.toLowerCase());
    }


    /**
     * Helper method: Safely parses a time string into LocalDateTime.
     * Returns null if parsing fails.
     * Should match the formats used in AITransactionService.parseDateTime.
     */
    private LocalDateTime parseDateTimeSafe(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // 中文空格等统一清理
        timeStr = timeStr.trim().replaceAll("\\s+", " ");

        // If only date is present, append 00:00
        if (timeStr.matches("\\d{4}/\\d{1,2}/\\d{1,2}")) {
            timeStr += " 00:00";
        } else if (timeStr.matches("\\d{4}-\\d{1,2}-\\d{1,2}")) {
            timeStr += " 00:00:00"; // Assuming yyyy-MM-dd uses seconds format
        }


        // Try parsing with multiple formats
        List<String> patterns = List.of(
                "yyyy/M/d H:mm", "yyyy/M/d HH:mm",
                "yyyy/MM/d H:mm", "yyyy/MM/d HH:mm",
                "yyyy/M/dd H:mm", "yyyy/M/dd HH:mm",
                "yyyy/MM/dd H:mm", "yyyy/MM/dd HH:mm",
                "yyyy/MM/dd HH:mm:ss", // Added seconds format
                "yyyy-MM-dd HH:mm:ss", // Added dash format
                "yyyy/MM/dd" // Added date only format (already handled by adding 00:00)
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDateTime.parse(timeStr, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern and try the next
            }
        }
        System.err.println("Failed to parse date string: " + timeStr);
        return null; // Return null if no pattern matches
    }

    /**
     * Aggregates transactions for the current user by month and standard category.
     *
     * @return A map where keys are month identifiers (e.g., "YYYY-MM") and values are MonthlySummary objects.
     * @throws Exception If an error occurs during data retrieval.
     */
    @Override // Implement the new interface method
    public Map<String, MonthlySummary> getMonthlyTransactionSummary() throws Exception {
        System.out.println("Generating monthly transaction summary for user file: " + currentUserTransactionFilePath);
        List<Transaction> allTransactions;
        try {
            // 1. Get all transactions for the current user (from cache/file)
            allTransactions = getAllTransactions(); // Uses CacheManager
            System.out.println("Retrieved " + allTransactions.size() + " transactions for summary.");

        } catch (Exception e) {
            System.err.println("Error retrieving transactions for summary generation.");
            e.printStackTrace();
            throw new Exception("获取交易数据失败！", e);
        }

        // 2. Aggregate transactions by month and category
        Map<String, MonthlySummary> monthlySummaries = new HashMap<>();
        DateTimeFormatter monthFormatter = DateTimeFormatter.ofPattern("yyyy-MM"); // Format for month identifier


        for (Transaction t : allTransactions) {
            if (t.getTransactionTime() == null || t.getTransactionTime().trim().isEmpty()) {
                System.err.println("Skipping transaction with no time for summary aggregation: " + t.getOrderNumber());
                continue; // Skip transactions with no time
            }

            // Safely parse the transaction date to get the month
            LocalDate date = parseDateFromTransactionTimeSafe(t.getTransactionTime()); // Use a robust date parser
            if (date == null) {
                System.err.println("Skipping transaction with unparseable date for summary aggregation: " + t.getTransactionTime() + " - " + t.getOrderNumber());
                continue; // Skip transactions with invalid date
            }

            // Get month identifier (e.g., "2025-03")
            String monthIdentifier = YearMonth.from(date).format(monthFormatter);

            // Get or create the MonthlySummary object for this month
            monthlySummaries.putIfAbsent(monthIdentifier, new MonthlySummary(monthIdentifier));
            MonthlySummary currentMonthSummary = monthlySummaries.get(monthIdentifier);

            // Add transaction amount to the summary based on type (Income/Expense)
            if (t.getInOut() != null) {
                String inOut = t.getInOut().trim();
                if (inOut.equals("收入") || inOut.equals("收")) {
                    currentMonthSummary.addIncome(t.getPaymentAmount());
                } else if (inOut.equals("支出") || inOut.equals("支")) {
                    // Get the standard category for the expense
                    String rawType = t.getTransactionType();
                    // Use the helper to map to a standard category, defaulting to "其他支出" if no direct standard match
                    String standardCategory = StandardCategories.getStandardCategory(rawType);
                    // For aggregation, we might want to map any non-standard expense type to "其他支出"
                    String effectiveExpenseCategoryForSummary = StandardCategories.isStandardExpenseCategory(standardCategory) ? standardCategory : "其他支出";

                    currentMonthSummary.addExpense(t.getPaymentAmount(), effectiveExpenseCategoryForSummary);
                }
                // Ignore special types (like Transfer, Red Packet) for simple income/expense summary, or handle them separately if needed
            }
        }
        System.out.println("Generated summary for " + monthlySummaries.size() + " months.");

        return monthlySummaries; // Return the map of monthly summaries
    }

    // Helper method to parse date from transaction time string safely
    // This should be consistent across all services/DAOs that parse dates.
    // Let's use a consistent, robust parser.
    // This method is similar to parseDateTimeSafe in this class and parseDateFromTransactionTime in SummaryStatisticService.
    // Consider extracting this to a shared Util class if many places need it.
    // For now, keep a consistent copy.
    private LocalDate parseDateFromTransactionTimeSafe(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // Clean whitespace and replace potential hyphens with slashes if the expected format is slash-separated
        String datePart = timeStr.split(" ")[0]; // Get the date part

        datePart = datePart.trim().replace('-', '/').replaceAll("\\s+", "");


        // Try parsing with multiple slash formats
        List<String> patterns = List.of(
                "yyyy/M/d", "yyyy/MM/d", "yyyy/M/dd", "yyyy/MM/dd",
                "yyyy-MM-dd" // Add dash format just in case
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDate.parse(datePart, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern
            }
        }
        System.err.println("TransactionServiceImpl: Failed to parse date part '" + datePart + "' from transaction time: " + timeStr);
        return null; // Return null if no pattern matches
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\TransactionService.java`:

```java
package Service;

import model.MonthlySummary;
import model.Transaction;

import java.io.IOException;
import java.util.List;
import java.util.Map;

public interface TransactionService {

    /**
     * Gets all transactions for the current user.
     * @return List of all transactions.
     * @throws Exception If data retrieval fails (e.g., IO error, cache issue).
     */
    List<Transaction> getAllTransactions() throws Exception; // Added this method


    /**
     * 新增交易
     * @param transaction
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * 修改交易
     * @param transaction
     * @throws Exception If modification fails.
     */
    void changeTransaction(Transaction transaction) throws Exception;

    /**
     * 根据订单号删除交易
     * @param orderNumber
     * @return true if deletion was successful, false if transaction not found.
     * @throws Exception If deletion fails (e.g., IO error).
     */
    boolean deleteTransaction(String orderNumber) throws Exception; // Changed return type to boolean

    /**
     * 根据用户输入信息查询交易
     * @param transaction Search criteria.
     * @return List of matched transactions.
     */
    List<Transaction> searchTransaction(Transaction transaction);

    /**
     * Imports transactions from a given CSV file path into the current user's transactions.
     *
     * @param userFilePath The file path for the current user's transactions (target).
     * @param importFilePath The file path of the CSV to import from (source).
     * @return The number of transactions successfully imported.
     * @throws Exception If an error occurs during reading, parsing, or saving.
     */
    int importTransactionsFromCsv(String userFilePath, String importFilePath) throws Exception; // Added this method


    /**
     * Aggregates transactions for the current user by month and standard category.
     *
     * @return A map where keys are month identifiers (e.g., "YYYY-MM") and values are MonthlySummary objects.
     * @throws Exception If an error occurs during data retrieval.
     */
    Map<String, MonthlySummary> getMonthlyTransactionSummary() throws Exception; // Added this method
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\User\UserService.java`:

```java
package Service.User; // Changed package

import DAO.UserDao;
import model.User;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class UserService {
    private final UserDao userDao;
    private final Map<String, User> userCache = new HashMap<>(); // Cache users in memory

    public UserService(UserDao userDao) {
        this.userDao = userDao;
        loadUsers(); // Load users when the service is initialized
    }

    private void loadUsers() {
        try {
            List<User> users = userDao.getAllUsers();
            userCache.clear(); // Clear previous cache
            for (User user : users) {
                userCache.put(user.getUsername(), user);
            }
            System.out.println("Loaded " + userCache.size() + " users into cache.");
        } catch (IOException e) {
            System.err.println("Failed to load users from data source.");
            e.printStackTrace();
            // Depending on requirements, you might want to exit or handle this more gracefully
            // For now, we'll allow the app to run with an empty user list, though login will fail.
        }
    }

    /**
     * Authenticates a user.
     *
     * @param username The username.
     * @param password The password.
     * @return The authenticated User object if successful, null otherwise.
     */
    public User authenticate(String username, String password) {
        if (username == null || username.trim().isEmpty() || password == null || password.trim().isEmpty()) {
            return null;
        }

        User user = userCache.get(username.trim());
        if (user != null && user.getPassword().equals(password.trim())) { // Simple password check
            System.out.println("Authentication successful for user: " + username);
            return user; // Authentication successful, return the User object
        }
        System.out.println("Authentication failed for username: " + username);
        return null; // Authentication failed
    }

    /**
     * Retrieves a user by username from the cache.
     * @param username The username.
     * @return The User object or null if not found.
     */
    public User getUserByUsername(String username) {
        if (username == null || username.trim().isEmpty()) {
            return null;
        }
        return userCache.get(username.trim());
    }


    // Add other user management methods if needed (e.g., registerUser, deleteUser)
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\deepseek\ChatCompletionsExample.java`:

```java
package Service.deepseek;

import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;
import okhttp3.ConnectionPool;
import okhttp3.Dispatcher;
import org.apache.commons.lang.StringUtils;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
public class ChatCompletionsExample {
    static String apiKey = System.getenv("ARK_API_KEY");
    static ConnectionPool connectionPool = new ConnectionPool(5, 1, TimeUnit.SECONDS);
    static Dispatcher dispatcher = new Dispatcher();
    // The output time of the reasoning model is relatively long. Please increase the timeout period.//
    static ArkService service = ArkService.builder().timeout(Duration.ofSeconds(1800)).connectTimeout(Duration.ofSeconds(20)).dispatcher(dispatcher).connectionPool(connectionPool).baseUrl("https://ark.cn-beijing.volces.com/api/v3").apiKey(apiKey).build();

//    public static void main(String[] args) {
//        System.out.println(" [Recommended]----- streaming request -----");
//        final List<ChatMessage> streamMessages = new ArrayList<>();
//        final ChatMessage streamUserMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("请回答15.11和15.9哪个大？").build();
//        streamMessages.add(streamUserMessage);
//        ChatCompletionRequest streamChatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(streamMessages)
//                .build();
//        service.streamChatCompletion(streamChatCompletionRequest)
//                .doOnError(Throwable::printStackTrace)
//                .blockingForEach(
//                        delta -> {
//                            if (!delta.getChoices().isEmpty()) {
//                                if (StringUtils.isNotEmpty(delta.getChoices().get(0).getMessage().getReasoningContent())) {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getReasoningContent());
//                                } else {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getContent());
//                                }
//                            }
//                        }
//                );
//        System.out.println(" ----- standard request -----");
//        final List<ChatMessage> messages = new ArrayList<>();
//        final ChatMessage userMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("常见的十字花科植物有哪些？").build();
//        messages.add(userMessage);
//        ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(messages)
//                .build();
//        service.createChatCompletion(chatCompletionRequest).getChoices().forEach(
//                choice -> {
//                    System.out.println(choice.getMessage().getReasoningContent());
//                    System.out.println(choice.getMessage().getContent());
//                }
//        );
//        // shutdown service after all requests is finished
//        service.shutdownExecutor();
//    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Utils\CacheManager.java`:

```java
package Utils;

import Constants.CaffeineKeys;
import DAO.Impl.CsvTransactionDao; // Assuming CsvTransactionDao is in DAO.Impl
import DAO.TransactionDao; // Assuming TransactionDao interface is in DAO
import model.Transaction;
import com.github.benmanes.caffeine.cache.Cache; // Use general Cache interface
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.LoadingCache;

import java.io.IOException;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

/**
 * Manages Caffeine caches for different transaction data files (per user).
 * Uses the file path as the cache key.
 */
public class CacheManager {

    // Use a map to hold caches, keyed by file path
    // The value is the Caffeine LoadingCache for that specific file path
    private static final ConcurrentHashMap<String, LoadingCache<String, List<Transaction>>> fileCaches = new ConcurrentHashMap<>();

    // Define default cache parameters
    private static final int DEFAULT_MAX_SIZE = 1; // Only cache one instance (the list of transactions) per file
    private static final long DEFAULT_EXPIRE_AFTER_WRITE_MINUTES = 10; // Cache entry expires after 10 minutes
    private static final long DEFAULT_REFRESH_AFTER_WRITE_MINUTES = 1; // Refresh entry after 1 minute

    // Private constructor to prevent instantiation
    private CacheManager() {}

    /**
     * Gets or creates a LoadingCache for the specified transaction file path.
     * The cache loads List<Transaction> from the file using TransactionDao.
     *
     * @param filePath The path to the user's transaction CSV file.
     * @param transactionDao The TransactionDao instance to use for loading.
     * @return The LoadingCache instance for the given file path.
     */
    public static LoadingCache<String, List<Transaction>> getTransactionCache(String filePath, TransactionDao transactionDao) {
        // Use computeIfAbsent to get or create the cache atomically
        return fileCaches.computeIfAbsent(filePath, key -> {
            System.out.println("CacheManager: Creating new cache for file: " + filePath);
            // Create a new LoadingCache for this specific file path
            return Caffeine.newBuilder()
                    .maximumSize(DEFAULT_MAX_SIZE)
                    .expireAfterWrite(DEFAULT_EXPIRE_AFTER_WRITE_MINUTES, TimeUnit.MINUTES)
                    .refreshAfterWrite(DEFAULT_REFRESH_AFTER_WRITE_MINUTES, TimeUnit.MINUTES)
                    // Define the loader function: how to load data when cache is missed or refreshed
                    .build(cacheKey -> {
                        System.out.println("CacheManager: Loading transactions from file: " + filePath + " (Cache Miss/Refresh)");
                        try {
                            // The cacheKey here will likely be a constant like "transactions"
                            // We use the outer filePath variable to load from the correct file
                            return transactionDao.loadFromCSV(filePath);
                        } catch (IOException e) {
                            System.err.println("CacheManager: Error loading data for file " + filePath);
                            e.printStackTrace();
                            throw new RuntimeException("Error loading transactions from " + filePath, e); // Wrap IOException in RuntimeException for Caffeine loader
                        }
                    });
        });
    }

    /**
     * Invalidates the cache for a specific transaction file path.
     * @param filePath The path to the user's transaction CSV file.
     */
    public static void invalidateTransactionCache(String filePath) {
        LoadingCache<String, List<Transaction>> cache = fileCaches.get(filePath);
        if (cache != null) {
            System.out.println("CacheManager: Invalidating cache for file: " + filePath);
            // The cache key for List<Transaction> is likely a constant like "transactions"
            cache.invalidate(CaffeineKeys.TRANSACTION_CAFFEINE_KEY); // Invalidate the entry storing the transaction list
        }
        // Optionally, remove the cache itself if the file is no longer needed
        // fileCaches.remove(filePath); // Might do this on user logout, etc.
    }

    /**
     * Gets the transaction list from the cache for the specified file path.
     * Loads data if not present or expired. Handles exceptions thrown by the loader.
     *
     * @param filePath The path to the user's transaction CSV file.
     * @param transactionDao The TransactionDao instance to use for loading if cache misses.
     * @return The list of transactions.
     * @throws Exception If an error occurs during loading (e.g., IOException).
     */
    public static List<Transaction> getTransactions(String filePath, TransactionDao transactionDao) throws Exception {
        LoadingCache<String, List<Transaction>> cache = getTransactionCache(filePath, transactionDao);
        // The cache key for the list of transactions from a specific file is a constant.
        // This constant key maps to the *entire list* of transactions for that file.
        return cache.get(CaffeineKeys.TRANSACTION_CAFFEINE_KEY);
    }

    /**
     * Manually puts a list of transactions into the cache for a specific file path.
     * This is useful after a write operation (add, delete, update) to refresh the cache.
     *
     * @param filePath The path to the user's transaction CSV file.
     * @param transactions The updated list of transactions.
     * @param transactionDao The TransactionDao instance (needed to get/create cache if not exists).
     */
    public static void putTransactions(String filePath, List<Transaction> transactions, TransactionDao transactionDao) {
        LoadingCache<String, List<Transaction>> cache = getTransactionCache(filePath, transactionDao);
        cache.put(CaffeineKeys.TRANSACTION_CAFFEINE_KEY, transactions);
        System.out.println("CacheManager: Manually updated cache for file: " + filePath);
    }

    /**
     * Shutdown any resources if necessary (though Caffeine typically manages its threads).
     */
    public static void shutdown() {
        // Caffeine cache doesn't require explicit shutdown in most cases
        // If using custom executors, they might need shutdown.
        System.out.println("CacheManager: Shutdown completed.");
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Utils\CacheUtil.java`:

```java
package Utils;

import com.github.benmanes.caffeine.cache.*;

import java.util.concurrent.TimeUnit;
import java.util.function.Function;

import com.github.benmanes.caffeine.cache.Caffeine;

/**
 * 通用缓存工具类（支持泛型和异常传播）
 * @param <K> 键类型
 * @param <V> 值类型
 * @param <E> 异常类型（如 IOException）
 */
public class CacheUtil<K, V, E extends Exception> {
    private final LoadingCache<K, V> cache;

    public CacheUtil(Function<K, V> loader,
                     int maxSize,
                     long expireAfterWrite,
                     long refreshAfterWrite) {

        this.cache = Caffeine.newBuilder()
                .maximumSize(maxSize)
                .expireAfterWrite(expireAfterWrite, TimeUnit.MINUTES)
                .refreshAfterWrite(refreshAfterWrite, TimeUnit.MINUTES)
                .build(loader::apply); // 关键修改：使用build(loader)创建LoadingCache
    }

    /**
     * 获取缓存值
     */
    public V get(K key) {
        return cache.get(key);
    }

    /**
     * 手动更新缓存
     */
    public void put(K key, V value) {
        cache.put(key, value);
    }

    /**
     * 手动移除缓存
     */
    public void invalidate(K key) {
        cache.invalidate(key);
    }
}



```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\model\MonthlySummary.java`:

```java
package model;

import java.util.HashMap;
import java.util.Map;

// Represents a summary of transactions for a specific month
public class MonthlySummary {
    private String monthIdentifier; // e.g., "2025-03"
    private double totalIncome;
    private double totalExpense;
    // Map from standard expense category to total amount spent in that category
    private Map<String, Double> expenseByCategory;

    public MonthlySummary(String monthIdentifier) {
        this.monthIdentifier = monthIdentifier;
        this.totalIncome = 0.0;
        this.totalExpense = 0.0;
        this.expenseByCategory = new HashMap<>();
    }

    // Getters
    public String getMonthIdentifier() {
        return monthIdentifier;
    }

    public double getTotalIncome() {
        return totalIncome;
    }

    public double getTotalExpense() {
        return totalExpense;
    }

    public Map<String, Double> getExpenseByCategory() {
        return expenseByCategory;
    }

    // Methods to add transaction amounts
    public void addIncome(double amount) {
        this.totalIncome += amount;
    }

    public void addExpense(double amount, String standardCategory) {
        this.totalExpense += amount;
        // Aggregate by standard category
        expenseByCategory.put(standardCategory, expenseByCategory.getOrDefault(standardCategory, 0.0) + amount);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Month: ").append(monthIdentifier).append("\n");
        sb.append("  Total Income: ").append(String.format("%.2f", totalIncome)).append("元\n");
        sb.append("  Total Expense: ").append(String.format("%.2f", totalExpense)).append("元\n");
        sb.append("  Expenses by Category:\n");
        if (expenseByCategory.isEmpty()) {
            sb.append("    (None)\n");
        } else {
            // Sort categories alphabetically for consistent output
            expenseByCategory.entrySet().stream()
                    .sorted(Map.Entry.comparingByKey())
                    .forEach(entry ->
                            sb.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                    );
        }
        return sb.toString();
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\model\SummaryStatistic.java`:

```java
package model;

// Represents a summary statistic for a specific week across all users
public class SummaryStatistic {
    private String weekIdentifier; // e.g., "2025-W14"
    private double totalIncomeAllUsers;
    private double totalExpenseAllUsers;
    private String topExpenseCategory; // e.g., "餐饮"
    private double topExpenseCategoryAmount; // Amount spent in the top category
    private int numberOfUsersWithTransactions; // Number of users who had any transaction this week
    private String timestampGenerated; // When this statistic record was created

    // Constructors
    public SummaryStatistic() {
    }

    public SummaryStatistic(String weekIdentifier, double totalIncomeAllUsers, double totalExpenseAllUsers, String topExpenseCategory, double topExpenseCategoryAmount, int numberOfUsersWithTransactions, String timestampGenerated) {
        this.weekIdentifier = weekIdentifier;
        this.totalIncomeAllUsers = totalIncomeAllUsers;
        this.totalExpenseAllUsers = totalExpenseAllUsers;
        this.topExpenseCategory = topExpenseCategory;
        this.topExpenseCategoryAmount = topExpenseCategoryAmount;
        this.numberOfUsersWithTransactions = numberOfUsersWithTransactions;
        this.timestampGenerated = timestampGenerated;
    }

    // Getters
    public String getWeekIdentifier() {
        return weekIdentifier;
    }

    public double getTotalIncomeAllUsers() {
        return totalIncomeAllUsers;
    }

    public double getTotalExpenseAllUsers() {
        return totalExpenseAllUsers;
    }

    public String getTopExpenseCategory() {
        return topExpenseCategory;
    }

    public double getTopExpenseCategoryAmount() {
        return topExpenseCategoryAmount;
    }

    public int getNumberOfUsersWithTransactions() {
        return numberOfUsersWithTransactions;
    }

    public String getTimestampGenerated() {
        return timestampGenerated;
    }

    // Setters (if needed for creation/population)
    public void setWeekIdentifier(String weekIdentifier) {
        this.weekIdentifier = weekIdentifier;
    }

    public void setTotalIncomeAllUsers(double totalIncomeAllUsers) {
        this.totalIncomeAllUsers = totalIncomeAllUsers;
    }

    public void setTotalExpenseAllUsers(double totalExpenseAllUsers) {
        this.totalExpenseAllUsers = totalExpenseAllUsers;
    }

    public void setTopExpenseCategory(String topExpenseCategory) {
        this.topExpenseCategory = topExpenseCategory;
    }

    public void setTopExpenseCategoryAmount(double topExpenseCategoryAmount) {
        this.topExpenseCategoryAmount = topExpenseCategoryAmount;
    }

    public void setNumberOfUsersWithTransactions(int numberOfUsersWithTransactions) {
        this.numberOfUsersWithTransactions = numberOfUsersWithTransactions;
    }

    public void setTimestampGenerated(String timestampGenerated) {
        this.timestampGenerated = timestampGenerated;
    }

    @Override
    public String toString() {
        return "SummaryStatistic{" +
                "weekIdentifier='" + weekIdentifier + '\'' +
                ", totalIncomeAllUsers=" + totalIncomeAllUsers +
                ", totalExpenseAllUsers=" + totalExpenseAllUsers +
                ", topExpenseCategory='" + topExpenseCategory + '\'' +
                ", topExpenseCategoryAmount=" + topExpenseCategoryAmount +
                ", numberOfUsersWithTransactions=" + numberOfUsersWithTransactions +
                ", timestampGenerated='" + timestampGenerated + '\'' +
                '}';
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\model\Transaction.java`:

```java
package model;
//Transaction time, transaction type, transaction counterparty,
// commodity receipt/payment amount (yuan), payment method, current status,
// transaction order number, merchant order number, remarks
public class Transaction {
    private String transactionTime;
    private String transactionType;
    private String counterparty;
    private String commodity;
    private String inOut;
    private double paymentAmount;
    private String paymentMethod;
    private String currentStatus;
    private String orderNumber;
    private String merchantNumber;
    private String remarks;

    public Transaction() {
    }

    public Transaction(String transactionTime, String transactionType, String counterparty, String commodity, String inOut, double paymentAmount, String paymentMethod, String currentStatus, String orderNumber, String merchantNumber, String remarks) {
        this.transactionTime = transactionTime;
        this.transactionType = transactionType;
        this.counterparty = counterparty;
        this.commodity = commodity;
        this.inOut = inOut;
        this.paymentAmount = paymentAmount;
        this.paymentMethod = paymentMethod;
        this.currentStatus = currentStatus;
        this.orderNumber = orderNumber;
        this.merchantNumber = merchantNumber;
        this.remarks = remarks;
    }

    public String getInOut() {
        return inOut;
    }

    public void setInOut(String inOut) {
        this.inOut = inOut;
    }

    public void setTransactionTime(String transactionTime) {
        this.transactionTime = transactionTime;
    }

    public void setTransactionType(String transactionType) {
        this.transactionType = transactionType;
    }

    public void setCounterparty(String counterparty) {
        this.counterparty = counterparty;
    }

    public void setCommodity(String commodity) {
        this.commodity = commodity;
    }

    public void setPaymentAmount(double paymentAmount) {
        this.paymentAmount = paymentAmount;
    }

    public void setPaymentMethod(String paymentMethod) {
        this.paymentMethod = paymentMethod;
    }

    public void setCurrentStatus(String currentStatus) {
        this.currentStatus = currentStatus;
    }

    public void setOrderNumber(String orderNumbe) {
        this.orderNumber = orderNumbe;
    }

    public void setMerchantNumber(String merchantNumber) {
        this.merchantNumber = merchantNumber;
    }

    public void setRemarks(String remarks) {
        this.remarks = remarks;
    }

    public String getTransactionTime() {
        return transactionTime;
    }

    public String getTransactionType() {
        return transactionType;
    }

    public String getCounterparty() {
        return counterparty;
    }

    public String getCommodity() {
        return commodity;
    }

    public double getPaymentAmount() {
        return paymentAmount;
    }

    public String getPaymentMethod() {
        return paymentMethod;
    }

    public String getCurrentStatus() {
        return currentStatus;
    }

    public String getOrderNumber() {
        return orderNumber;
    }

    public String getMerchantNumber() {
        return merchantNumber;
    }

    public String getRemarks() {
        return remarks;
    }
}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\model\User.java`:

```java
package model;

// 用户模型类
public class User {
    private String username;
    private String password;
    private String role; // e.g., "user", "admin"
    private String transactionFilePath; // Path to the user's transaction CSV file

    // Constructors
    public User() {
    }

    public User(String username, String password, String role, String transactionFilePath) {
        this.username = username;
        this.password = password;
        this.role = role;
        this.transactionFilePath = transactionFilePath;
    }

    // Getters and Setters
    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }

    public String getTransactionFilePath() {
        return transactionFilePath;
    }

    public void setTransactionFilePath(String transactionFilePath) {
        this.transactionFilePath = transactionFilePath;
    }

    @Override
    public String toString() {
        return "User{" +
                "username='" + username + '\'' +
                ", role='" + role + '\'' +
                ", transactionFilePath='" + transactionFilePath + '\'' +
                '}';
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\resources\CSVForm\stats\summary_statistics.csv`:

```csv
week_identifier,total_income_all_users,total_expense_all_users,top_expense_category,top_expense_category_amount,number_of_users_with_transactions,timestamp_generated
2022-W37,0.0,5000.0,其他支出,5000.0,1,2025-05-22 23:34:23
2025-W09,10000.0,20000.0,无支出,0.0,3,2025-05-22 23:34:23
2025-W10,0.0,751.5,其他支出,751.5,3,2025-05-22 23:34:23
2025-W11,0.0,257.25,餐饮,107.25,3,2025-05-22 23:34:23
2025-W12,0.0,15000.0,其他支出,10000.0,3,2025-05-22 23:34:23

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\resources\CSVForm\transactions\admin_transactions.csv`:

```csv
交易时间,交易类型,交易对方,商品,收/支,金额(元),支付方式,当前状态,交易单号,商户单号,备注
2025/03/01 09:00:00,工资,公司A,三月工资,收入,¥10000.00,银行卡,已入账,SALARY_MAR_A,PAYROLL_A_001,本月基本工资
2025/03/05 14:30:00,购物,超市B,食品杂货,支出,¥250.50,支付宝,已完成,SHOP_B_001,ALIPAY_12345,周末采购
2025/03/15 11:00:00,餐饮,餐厅C,午餐外卖,支出,¥35.75,美团支付,已完成,MEAL_C_001,MEITUAN_11223,工作日午餐
2025/03/20 16:00:00,金融服务,股票账户,购入股票,支出,¥5000.00,美团支付,已完成,INVEST_STOCK_001,BANK_99887,长期投资
2022/09/10 16:00:00,投资,股票账户,购入股票,支出,¥5000.00,同花顺,未完成,INVEST_STOCK_002,BANK_99887,短线投资
2025/03/10 10:00:00,转账,用户1,报销午餐,支出,¥50.00,微信支付,已完成,TRANSFER_U1_001,WECHAT_56789,归还午餐费

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\resources\CSVForm\transactions\user1_transactions.csv`:

```csv
交易时间,交易类型,交易对方,商品,收/支,金额(元),支付方式,当前状态,交易单号,商户单号,备注
2025/03/01 09:00:00,工资,公司A,三月工资,支出,¥10000.00,银行卡,已入账,SALARY_MAR_A,PAYROLL_A_001,本月基本工资
2025/03/05 14:30:00,购物,超市B,食品杂货,支出,¥250.50,支付宝,已完成,SHOP_B_001,ALIPAY_12345,周末采购
2025/03/10 10:00:00,转账,用户1,报销午餐,支出,¥50.00,微信支付,已完成,TRANSFER_U1_001,WECHAT_56789,归还午餐费
2025/03/15 11:00:00,餐饮,餐厅C,午餐外卖,支出,¥35.75,美团支付,已完成,MEAL_C_001,MEITUAN_11223,工作日午餐
2025/03/20 16:00:00,投资,股票账户,购入股票,支出,¥5000.00,银行转账,已完成,INVEST_STOCK_001,BANK_99887,长期投资

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\resources\CSVForm\transactions\user2_transactions.csv`:

```csv
交易时间,交易类型,交易对方,商品,收/支,金额(元),支付方式,当前状态,交易单号,商户单号,备注
2025/03/01 09:00:00,工资,公司A,三月工资,支出,¥10000.00,银行卡,已入账,SALARY_MAR_A,PAYROLL_A_001,本月基本工资
2025/03/05 14:30:00,购物,超市B,食品杂货,支出,¥250.50,支付宝,已完成,SHOP_B_001,ALIPAY_12345,周末采购
2025/03/10 10:00:00,转账,用户1,报销午餐,支出,¥50.00,微信支付,已完成,TRANSFER_U1_001,WECHAT_56789,归还午餐费
2025/03/15 11:00:00,餐饮,餐厅C,午餐外卖,支出,¥35.75,美团支付,已完成,MEAL_C_001,MEITUAN_11223,工作日午餐
2025/03/20 16:00:00,投资,股票账户,购入股票,支出,¥5000.00,银行转账,已完成,INVEST_STOCK_001,BANK_99887,长期投资
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\resources\CSVForm\users\users.csv`:

```csv
username,password,role,transaction_csv_path
admin,admin123,admin,Ai Bill Application/src/main/resources/CSVForm/transactions/admin_transactions.csv
user1,pass123,user,Ai Bill Application/src/main/resources/CSVForm/transactions/user1_transactions.csv
user2,securepwd,user,Ai Bill Application/src/main/resources/CSVForm/transactions/user2_transactions.csv

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\resources\config.properties`:

```properties
# config.properties
#csv.path=Ai Bill Application/src/main/resources/CSVForm/0001.csv
csv.path=Ai Bill Application/src/main/resources/CSVForm/transactions/admin_transactions.csv
csv.users_path=Ai Bill Application/src/main/resources/CSVForm/users/users.csv
csv.summary_path=Ai Bill Application/src/main/resources/CSVForm/stats/summary_statistics.csv
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\ControllerTest\AITest.java`:

```java
package ControllerTest;

import Controller.HistogramPanelContainer;
import org.junit.Test;

import javax.swing.*;
import java.awt.*;

public class AITest {

    @Test
    public void testHistogramPanel() throws Exception {
        EventQueue.invokeAndWait(() -> {
            JFrame frame = new JFrame("数据分析界面 - 测试");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });




        // 保持窗口显示一段时间，防止测试结束时窗口立即关闭
        Thread.sleep(5000);
    }

}




```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\ControllerTest\MenuUITest.java`:

```java
package ControllerTest;

import model.User;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.io.IOException;
import Controller.MenuUI;

import Service.Impl.TransactionServiceImpl;

import DAO.Impl.CsvTransactionDao;

public class MenuUITest {

    private MenuUI menuUI;

    @BeforeEach
    public void setUp() {
//        menuUI = new MenuUI(new User());

        // 手动初始化 TransactionServiceImpl 的 csvTransactionDao
//        TransactionServiceImpl.csvTransactionDao = new CsvTransactionDao();
    }

    @Test
    public void testSearchFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取输入字段和搜索按钮
        JTextField transactionTimeField = findTextField(inputPanel, 0);
        JTextField transactionTypeField = findTextField(inputPanel, 1);
        JTextField counterpartyField = findTextField(inputPanel, 2);
        JTextField commodityField = findTextField(inputPanel, 3);
        JComboBox<String> inOutComboBox = findComboBox(inputPanel);
        JTextField paymentMethodField = findTextField(inputPanel, 4);
        JButton searchButton = findButton(inputPanel,"Search");

        assertNotNull(transactionTimeField, "交易时间输入字段不应为空");
        assertNotNull(transactionTypeField, "交易类型输入字段不应为空");
        assertNotNull(counterpartyField, "交易对方输入字段不应为空");
        assertNotNull(commodityField, "商品输入字段不应为空");
        assertNotNull(inOutComboBox, "收/支下拉框不应为空");
        assertNotNull(paymentMethodField, "支付方式输入字段不应为空");
        assertNotNull(searchButton, "搜索按钮不应为空");

        // 设置搜索条件
        transactionTimeField.setText("2025/3/14 11:48"); // 交易时间
        transactionTypeField.setText("商户消费");       // 交易类型
        counterpartyField.setText("物美WUMART");         // 交易对方
        commodityField.setText("扫码支付");            // 商品
        inOutComboBox.setSelectedItem("支出");     // 收/支
        paymentMethodField.setText("零钱");    // 支付方式

        // 模拟点击搜索按钮
        searchButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证搜索结果是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);

            // 验证每一行数据是否符合搜索条件
            assertTrue(rowTransactionTime.contains("2025/3/14 11:48"), "交易时间应符合搜索条件");
            assertTrue(rowTransactionType.contains("商户消费"), "交易类型应符合搜索条件");
            assertTrue(rowCounterparty.contains("物美WUMART"), "交易对方应符合搜索条件");
            assertTrue(rowCommodity.contains("扫码支付"), "商品应符合搜索条件");
            assertTrue(rowInOut.contains("支出"), "收/支应符合搜索条件");
            assertTrue(rowPaymentMethod.contains("零钱"), "支付方式应符合搜索条件");
        }
    }

    @Test
    public void testDeleteFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 获取初始行数
        int initialRowCount = tableModel.getRowCount();

        // 模拟删除第一行
        menuUI.deleteRow(0);

        // 验证行数是否减少
        assertEquals(initialRowCount - 1, tableModel.getRowCount(), "删除后行数应减少");

        // 验证删除后的数据是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            assertNotEquals("2025/3/14 11:48", rowTransactionTime, "删除的行不应再出现在表格中");
        }
    }

    @Test
    public void testEditFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 模拟编辑第一行
        menuUI.editRow(0);

        // 验证编辑后的数据是否正确
        String editedTransactionTime = (String) tableModel.getValueAt(0, 0);
        String editedTransactionType = (String) tableModel.getValueAt(0, 1);
        String editedCounterparty = (String) tableModel.getValueAt(0, 2);
        String editedCommodity = (String) tableModel.getValueAt(0, 3);
        String editedInOut = (String) tableModel.getValueAt(0, 4);
        String editedPaymentMethod = (String) tableModel.getValueAt(0, 6);

        // 验证编辑后的数据是否符合预期
        assertNotNull(editedTransactionTime, "编辑后的交易时间不应为空");
        assertNotNull(editedTransactionType, "编辑后的交易类型不应为空");
        assertNotNull(editedCounterparty, "编辑后的交易对方不应为空");
        assertNotNull(editedCommodity, "编辑后的商品不应为空");
        assertNotNull(editedInOut, "编辑后的收/支不应为空");
        assertNotNull(editedPaymentMethod, "编辑后的支付方式不应为空");
    }

    @Test
    public void testAddFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取 Add 按钮
        JButton addButton = findButton(inputPanel, "Add");
        assertNotNull(addButton, "Add 按钮不应为空");

        // 模拟点击 Add 按钮
        addButton.doClick();

        // 获取对话框
        Window[] windows = Window.getWindows();
        JDialog addDialog = null;
        for (Window window : windows) {
            if (window instanceof JDialog && "添加交易".equals(((JDialog) window).getTitle())) {
                addDialog = (JDialog) window;
                break;
            }
        }
        assertNotNull(addDialog, "添加交易的对话框应弹出");

        // 获取对话框中的输入字段
        JTextField transactionTimeField = findTextField(addDialog.getContentPane(), 0);
        JTextField transactionTypeField = findTextField(addDialog.getContentPane(), 1);
        JTextField counterpartyField = findTextField(addDialog.getContentPane(), 2);
        JTextField commodityField = findTextField(addDialog.getContentPane(), 3);
        JComboBox<String> inOutComboBox = findComboBox(addDialog.getContentPane());
        JTextField paymentAmountField = findTextField(addDialog.getContentPane(), 4);
        JTextField paymentMethodField = findTextField(addDialog.getContentPane(), 5);
        JTextField currentStatusField = findTextField(addDialog.getContentPane(), 6);
        JTextField orderNumberField = findTextField(addDialog.getContentPane(), 7);
        JTextField merchantNumberField = findTextField(addDialog.getContentPane(), 8);
        JTextField remarksField = findTextField(addDialog.getContentPane(), 9);

        // 设置新交易的输入值
        transactionTimeField.setText("2025/3/15 12:00"); // 交易时间
        transactionTypeField.setText("转账");            // 交易类型
        counterpartyField.setText("张三");               // 交易对方
        commodityField.setText("转账");                 // 商品
        inOutComboBox.setSelectedItem("支出");          // 收/支
        paymentAmountField.setText("100.0");            // 金额(元)
        paymentMethodField.setText("银行卡");           // 支付方式
        currentStatusField.setText("已完成");           // 当前状态
        orderNumberField.setText("123456789");          // 交易单号
        merchantNumberField.setText("987654321");       // 商户单号
        remarksField.setText("测试备注");               // 备注

        // 获取确认按钮
        JButton confirmButton = findButton(addDialog.getContentPane(), "确认");
        assertNotNull(confirmButton, "确认按钮不应为空");

        // 模拟点击确认按钮
        confirmButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证新交易是否添加到表格中
        boolean isTransactionAdded = false;
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentAmount = (String) tableModel.getValueAt(i, 5);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);
            String rowCurrentStatus = (String) tableModel.getValueAt(i, 7);
            String rowOrderNumber = (String) tableModel.getValueAt(i, 8);
            String rowMerchantNumber = (String) tableModel.getValueAt(i, 9);
            String rowRemarks = (String) tableModel.getValueAt(i, 10);

            if (rowTransactionTime.equals("2025/3/15 12:00") &&
                    rowTransactionType.equals("转账") &&
                    rowCounterparty.equals("张三") &&
                    rowCommodity.equals("转账") &&
                    rowInOut.equals("支出") &&
                    rowPaymentAmount.equals("100.0") &&
                    rowPaymentMethod.equals("银行卡") &&
                    rowCurrentStatus.equals("已完成") &&
                    rowOrderNumber.equals("123456789") &&
                    rowMerchantNumber.equals("987654321") &&
                    rowRemarks.equals("测试备注")) {
                isTransactionAdded = true;
                break;
            }
        }

        // 验证新交易是否成功添加
        assertTrue(isTransactionAdded, "新交易应成功添加到表格中");
    }

    /**
     * 显示界面以便手动验证
     *
     * @param panel 要显示的面板
     */
    private void showUI(JPanel panel) {
        JFrame frame = new JFrame("MenuUI Test");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(1200, 600);
        frame.add(panel);
        frame.setVisible(true);

        // 保持界面显示一段时间（5秒）
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        frame.dispose(); // 关闭界面
    }

    /**
     * 查找输入面板
     *
     * @param mainPanel 主面板
     * @return 输入面板
     */
    private JPanel findInputPanel(JPanel mainPanel) {
        // 获取右边的面板
        Component[] components = mainPanel.getComponents();
        JPanel rightPanel = null;
        for (Component component : components) {
            if (component instanceof JPanel && ((JPanel) component).getComponentCount() > 0) {
                rightPanel = (JPanel) component;
                break;
            }
        }

        if (rightPanel != null) {
            // 在右边面板中查找输入面板
            for (Component component : rightPanel.getComponents()) {
                if (component instanceof JPanel) {
                    JPanel panel = (JPanel) component;
                    System.out.println("Panel found: " + panel.getName()); // 打印面板名称
                    if (panel.getComponentCount() > 0 && panel.getComponent(0) instanceof JLabel) {
                        return panel; // 输入面板通常包含 JLabel
                    }
                }
            }
        }
        return null;
    }

    /**
     * 查找输入字段
     *
     * @param container     输入面板
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0;
        for (Component component : container.getComponents()) {
            if (component instanceof JTextField) {
                if (count == index) {
                    return (JTextField) component;
                }
                count++;
            }
        }
        return null;
    }


    /**
     * 查找下拉框
     *
     * @param container 输入面板
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) {
            if (component instanceof JComboBox) {
                return (JComboBox<String>) component;
            }
        }
        return null;
    }

    /**
     * 查找按钮
     *
     * @param panel 输入面板
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container  容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    private JButton findButton(Container container, String buttonText) {
        for (Component component : container.getComponents()) {
            if (component instanceof JButton) {
                JButton button = (JButton) component;
                if (button.getText().equals(buttonText)) {
                    return button;
                }
            }
        }
        return null;
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\DAOTest\CsvTransactionDaoTest.java`:

```java
package DAOTest;

import DAO.Impl.CsvTransactionDao;
import model.Transaction;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static Constants.ConfigConstants.CSV_PATH;
import static org.junit.Assert.*;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;


class CsvTransactionDaoTest {
    private static final String TEST_ADMIN_CSV_PATH = "Ai Bill Application/src/test/resources/CSVForm/transactions/admin_transactions.csv"; //

    // 测试文件路径（根据实际结构调整）
    private static final String TEST_CSV_PATH = CSV_PATH;
    private static CsvTransactionDao dao;

    @Test
    void testLoadFromCSV_ValidFile_ReturnsTransactions() throws Exception {
        // Given
        CsvTransactionDao dao = new CsvTransactionDao();

        // When
        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);

        // 验证第一条记录的字段
        for (int i = 0; i < transactions.size(); i++) {
            System.out.println(transactions.get(i).getRemarks());
            System.out.println(transactions.get(i).getCommodity());
        }


    }
    @Test
    void testAddTransaction() throws IOException {
        dao=new CsvTransactionDao();
        Transaction newTx = new Transaction(
                "2025-03-09 10:00",
                "转账",
                "小明",
                "书籍",
                "支",
                99.99,
                "微信",
                "已完成",
                "TX123456",
                "M789012",
                "");

        dao.addTransaction("src/test/resources/001.csv", newTx);

        List<Transaction> transactions = dao.loadFromCSV(TEST_CSV_PATH);

    }

    @BeforeEach
        // This runs before each test method
    void setUp() {
        // Initialize DAO before each test
        dao = new CsvTransactionDao();
        // Ensure the test file exists - maybe create it programmatically here for reliable testing
        // or rely on it being present in src/test/resources and copied to classpath
    }

    @Test
    void testLoadAdminCSV() throws IOException {
        System.out.println("Attempting to load test CSV: " + TEST_ADMIN_CSV_PATH);
        Path csvPath = Paths.get(TEST_ADMIN_CSV_PATH);
        assertTrue("Test CSV file should exist at " + TEST_ADMIN_CSV_PATH, Files.exists(csvPath));
        assertTrue("Test CSV file should not be empty.", Files.size(csvPath) > 0);


        // When loading the specific admin CSV
        List<Transaction> transactions = dao.loadFromCSV(TEST_ADMIN_CSV_PATH);

        // Then assert that loading was successful and data is present
        assertNotNull(transactions.toString(), "Loaded transactions list should not be null");
        assertFalse("Loaded transactions list should not be empty", transactions.isEmpty());
        assertEquals(String.valueOf(5), transactions.size(), "Should load 5 transaction records"); // Assuming 5 rows plus header

        // Optional: Verify content of a specific row
        Transaction firstTx = transactions.get(0);
        assertEquals("公司A", firstTx.getCounterparty());
        assertEquals("三月工资", firstTx.getCommodity());
        assertEquals(10000.00, firstTx.getPaymentAmount(), 0.01); // Use delta for double comparison
    }

    // Add other tests like testAddTransaction, testDeleteTransaction, testChangeInformation etc.
    // Ensure these tests also use the correct file paths and verify file content changes.
    // For modification/deletion tests, you might need to create a temporary CSV file
    // or use a file specifically for testing that can be modified without affecting other tests.

    // Example of a helper method to create a test CSV file programmatically
    // This is more reliable than relying on manual copying/pasting for tests.
    private void createTestCsvFile(String filePath, List<Transaction> transactions) throws IOException {
        Path path = Paths.get(filePath);
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }
        // Delete old file if it exists
        if (Files.exists(path)) {
            Files.delete(path);
        }

        String[] headers = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"};
        try (BufferedWriter writer = Files.newBufferedWriter(path, StandardCharsets.UTF_8);
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(headers).withTrim())) {

            for (Transaction t : transactions) {
                csvPrinter.printRecord(
                        t.getTransactionTime(),
                        t.getTransactionType(),
                        t.getCounterparty(),
                        t.getCommodity(),
                        t.getInOut(),
                        String.format("¥%.2f", t.getPaymentAmount()),
                        t.getPaymentMethod(),
                        t.getCurrentStatus(),
                        t.getOrderNumber(),
                        t.getMerchantNumber(),
                        t.getRemarks()
                );
            }
        }
    }

    @Test
    void testAddTransactionToFile() throws IOException {
        // Create a temporary test file path or use a dedicated test file name
        String tempFilePath = "Ai Bill Application/src/main/resources/CSVForm/transactions/test_add.csv";
        // Create an empty or initial test file
        createTestCsvFile(tempFilePath, List.of()); // Start with an empty file

        CsvTransactionDao testDao = new CsvTransactionDao(); // Or reuse the instance from BeforeEach if path is managed

        Transaction newTx = new Transaction(
                "2025/04/11 08:00:00", "测试类型", "测试对方", "测试商品", "收入",
                123.45, "测试方式", "测试状态", "TEST001", "MERCHANT001", "测试备注"
        );

        // Add the transaction
        testDao.addTransaction(tempFilePath, newTx);

        // Load the file back and verify
        List<Transaction> transactions = testDao.loadFromCSV(tempFilePath);

        assertNotNull(transactions);
        assertEquals(1, transactions.size());
        Transaction addedTx = transactions.get(0);
        assertEquals("TEST001", addedTx.getOrderNumber());
        assertEquals(123.45, addedTx.getPaymentAmount(), 0.01);

        // Clean up the test file (optional but good practice)
        Files.deleteIfExists(Paths.get(tempFilePath));
    }

    @Test
    void testDeleteTransaction() throws IOException {
        dao=new CsvTransactionDao();

        dao.deleteTransaction("CSV_RELATIVE_PATH", "4200057899202502250932735481");

        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);
    }
//    @Test
//    void testChangeInfo() throws IOException{
//        dao=new CsvTransactionDao();
//        dao.changeInformation("TX123456","remarks","测试修改信息",TEST_CSV_PATH);
//        dao.changeInformation("TX123456","paymentAmount","116156",TEST_CSV_PATH);
//    }

}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\Service\AIAnalyzerThreadTest.java`:

```java
package Service;



import Service.AIservice.AIAnalyzerThread;
import org.junit.jupiter.api.Test;

public class AIAnalyzerThreadTest {

//    @Test
//    public void testRunAIAnalyzerThread() throws InterruptedException {
//        String userRequest = "请帮我分析最近的交易收支情况";
//        String filePath = "src/test/resources/sample_transactions.csv";
//        String startTimeStr = "2025/03/20";
//        String endTimeStr = "";
//
//        // 启动线程
//        Thread thread = new Thread(new AIAnalyzerThread(userRequest, filePath, startTimeStr, endTimeStr));
//        thread.start();
//
//        // 等待线程执行完成
//        thread.join();
//    }
}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\Service\AIserviceTest.java`:

```java
package Service;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

public class AIserviceTest {

    @Test
    public void testAnalyzeTransactions() {
        AITransactionService service = new AITransactionService();

        String userRequest = "请帮我分析这个月的收支情况";
        String filePath = "src/test/resources/sample_transactions.csv";

        String result = service.analyzeTransactions(userRequest, filePath,"2025/03/20","");

        assertNotNull(result, "AI分析结果不能为空");
        System.out.println("AI分析结果: " + result);
    }


}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\Service\AiFunctionTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.Test;
import Service.AIservice.AITransactionService;

import java.io.IOException;
import java.util.List;

public class AiFunctionTest {

    @Test
    public void testAnalyzeTransactions() throws IOException {

        String filePath = "src/test/resources/sample_transactions.csv";
        CsvTransactionDao transactionDao = new CsvTransactionDao();

        List<Transaction> transactions = transactionDao.loadFromCSV(filePath);

        // 实例化服务类
        AITransactionService service = new AITransactionService();

        // 调用合并格式化函数
        List<String> result = service.formatTransactions(transactions,"2025/03/29","2025/04/10");

        // 输出结果
        result.forEach(System.out::println);
    }




}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\Service\CacheTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import model.Transaction;
import org.junit.jupiter.api.Test;

import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;

public class CacheTest {

//    TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());
//
//    @Test
//    void DeleteCache(){
//        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;
//        cache.invalidate(TRANSACTION_CAFFEINE_KEY);
//    }

}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\Service\CollegeStudentNeedsTest.java`:

```java
//package Service;
//
//import Service.AIservice.ColledgeStudentThread;
//import Service.AIservice.CollegeStudentNeeds;
//import org.junit.jupiter.api.*;
//
//import java.io.IOException;
//import java.net.URISyntaxException;
//import java.net.URL;
//import java.nio.file.Files;
//import java.nio.file.Path;
//import java.nio.file.Paths;
//import java.util.Arrays;
//
//import static org.junit.jupiter.api.Assertions.*;
//
//// No @ExtendWith needed as we are not using Mockito extensions
//class CollegeStudentNeedsTest {
//
//
//
//    private CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
//    private static final String TEST_CSV_FILENAME = "src/test/resources/001.csv";
//    @Test
//    public void testGenerateBudget() throws IOException, InterruptedException {
//        Thread t=new Thread( new ColledgeStudentThread(TEST_CSV_FILENAME));
//        t.start();
//        t.join();
////        collegeStudentNeeds.generateBudget(TEST_CSV_FILENAME);
//    }
//    @Test
//    public void testParseStringToDouble(){
//        String s="asdas[369.39,1090.1]das";
//        double[] arr=collegeStudentNeeds.parseDoubleArrayFromString(s);
//        System.out.println(arr[0]+" "+arr[1]);
//    }
//
//
//}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\Service\TransactionServiceTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import model.Transaction;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.io.IOException;
import java.util.List;

class TransactionServiceTest {
    private TransactionService transactionService;

    @BeforeEach
    void setUp() {
//        // 初始化 DAO 和 Service
//        CsvTransactionDao csvTransactionDao = new CsvTransactionDao();
//        transactionService = new TransactionServiceImpl(csvTransactionDao);
    }

    @Test
    void testAddTransaction() throws IOException {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );

        // 执行添加操作
        transactionService.addTransaction(transaction);

        // 验证是否添加成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertFalse(transactions.isEmpty());
        assertEquals("T123456789", transactions.get(0).getOrderNumber());
    }

    @Test
    void testChangeTransaction() throws Exception {
        // 准备测试数据
        Transaction originalTransaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(originalTransaction);

        // 准备更新数据
        Transaction updatedTransaction = new Transaction(
                null, "充值", null, null, null, 0.0, "微信支付", null, "T123456789", null, "更新备注"
        );

        // 执行更新操作
        transactionService.changeTransaction(updatedTransaction);

        // 验证是否更新成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertEquals("充值", transactions.get(0).getTransactionType());
        assertEquals("微信支付", transactions.get(0).getPaymentMethod());
        assertEquals("更新备注", transactions.get(0).getRemarks());
    }

    @Test
    void testDeleteTransaction() throws Exception {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(transaction);

        // 执行删除操作
        boolean result = transactionService.deleteTransaction("T123456789");

        // 验证是否删除成功
        assertTrue(result);
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertTrue(transactions.isEmpty());
    }

    @Test
    void testSearchTransaction() throws IOException {

        // 设置搜索条件
        Transaction searchCriteria = new Transaction();
        searchCriteria.setCounterparty("支付宝");

        // 执行搜索操作
        List<Transaction> result = transactionService.searchTransaction(searchCriteria);

        // 验证搜索结果
        result.forEach(res -> System.out.println(res.getCommodity()));
    }


}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\resources\CSVForm\transactions\admin_transactions.csv`:

```csv
交易时间,交易类型,交易对方,商品,收/支,金额(元),支付方式,当前状态,交易单号,商户单号,备注
2025/03/01 09:00:00,工资,公司A,"三月工资",收入,"¥10000.00",银行卡,已入账,SALARY_MAR_A,PAYROLL_A_001,"本月基本工资"
2025/03/05 14:30:00,购物,超市B,"食品杂货",支出,"¥250.50",支付宝,已完成,SHOP_B_001,ALIPAY_12345,"周末采购"
2025/03/10 10:00:00,转账,用户1,"报销午餐",支出,"¥50.00",微信支付,已完成,TRANSFER_U1_001,WECHAT_56789,"归还午餐费"
2025/03/15 11:00:00,餐饮,餐厅C,"午餐外卖",支出,"¥35.75",美团支付,已完成,MEAL_C_001,MEITUAN_11223,"工作日午餐"
2025/03/20 16:00:00,投资,股票账户,"购入股票",支出,"¥5000.00",银行转账,已完成,INVEST_STOCK_001,BANK_99887,"长期投资"
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\resources\CSVForm\users\users.csv`:

```csv
username,password,role,transaction_csv_path
admin,admin123,admin,Ai Bill Application/src/main/resources/CSVForm/transactions/admin_transactions.csv
user1,pass123,user,Ai Bill Application/src/main/resources/CSVForm/transactions/user1_transactions.csv
user2,securepwd,user,Ai Bill Application/src/main/resources/CSVForm/transactions/user2_transactions.csv

```

`软工/Ai-Bill-Application-Group21\Ai-Bill-Application-Prompt.txt`:

```txt
Project Path: Ai-Bill-Application-Group21

Source Tree:

```txt
Ai-Bill-Application-Group21
└── Ai Bill Application
    ├── HistogramPanelContainer.java
    └── src
        ├── main
        │   └── java
        │       ├── Constants
        │       │   ├── CaffeineKeys.java
        │       │   └── ConfigConstants.java
        │       ├── Controller
        │       │   ├── ButtonEditor.java
        │       │   ├── ButtonRenderer.java
        │       │   ├── HistogramExample.java
        │       │   ├── HistogramPanelContainer.java
        │       │   └── MenuUI.java
        │       ├── DAO
        │       │   ├── CsvTransactionDao.java
        │       │   └── TransactionDao.java
        │       ├── Interceptor
        │       │   └── Login
        │       │       ├── LoginDialog.java
        │       │       └── UserService.java
        │       ├── Main.java
        │       ├── Service
        │       │   ├── AIservice
        │       │   │   ├── AIAnalyzerThread.java
        │       │   │   ├── AITransactionService.java
        │       │   │   ├── ColledgeStudentThread.java
        │       │   │   └── CollegeStudentNeeds.java
        │       │   ├── Impl
        │       │   │   └── TransactionServiceImpl.java
        │       │   ├── TransactionService.java
        │       │   └── deepseek
        │       │       └── ChatCompletionsExample.java
        │       ├── Utils
        │       │   └── CacheUtil.java
        │       └── model
        │           └── Transaction.java
        └── test
            └── java
                ├── ControllerTest
                │   ├── AITest.java
                │   └── MenuUITest.java
                ├── DAOTest
                │   └── CsvTransactionDaoTest.java
                └── Service
                    ├── AIAnalyzerThreadTest.java
                    ├── AIserviceTest.java
                    ├── AiFunctionTest.java
                    ├── CacheTest.java
                    ├── CollegeStudentNeedsTest.java
                    └── TransactionServiceTest.java

```

`Ai-Bill-Application-Group21/Ai Bill Application\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Constants\CaffeineKeys.java`:

```java
package Constants;

public class CaffeineKeys {
    public static final String TRANSACTION_CAFFEINE_KEY = "transactions";

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Constants\ConfigConstants.java`:

```java
package Constants;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

/**
 * 配置常量类（线程安全初始化）
 */
public final class ConfigConstants {
    // 私有构造防止实例化
    private ConfigConstants() {}

    /**
     * transactionCSV路径加载逻辑
     */
    // CSV路径常量
    public static final String CSV_PATH;
    // 静态初始化块（类加载时执行）
    static {
        Properties prop = new Properties();
        try (InputStream input = ConfigConstants.class.getClassLoader()
                .getResourceAsStream("config.properties")) {

            prop.load(input);
            CSV_PATH = prop.getProperty("csv.path");
        } catch (IOException e) {
            throw new RuntimeException("加载配置文件失败", e); // 转换为运行时异常
        }
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\ButtonEditor.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.TableCellEditor;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

class ButtonEditor extends AbstractCellEditor implements TableCellEditor {
    private final JPanel panel = new JPanel(new BorderLayout()); // 使用 BorderLayout
    private final JButton button = new JButton();
    private int rowIndex;
    private final MenuUI menuUI;

    public ButtonEditor(MenuUI menuUI) {
        this.menuUI = menuUI;

        // 设置按钮样式
        button.setFocusPainted(false); // 移除按钮的焦点边框
        button.setPreferredSize(new Dimension(80, 30)); // 设置按钮的固定尺寸

        // 添加按钮到面板
        panel.add(button, BorderLayout.CENTER);

        // 为按钮添加事件监听器
        button.addActionListener(e -> {
            System.out.println("按钮点击事件触发: " + button.getText());
            fireEditingStopped(); // 停止编辑
            String buttonText = button.getText();
            if ("Modify".equals(buttonText)) {
                menuUI.editRow(rowIndex); // 调用 MenuUI 的 editRow 方法
            } else if ("Delete".equals(buttonText)) {
                int confirm = JOptionPane.showConfirmDialog(panel, "确定要删除此行吗？", "确认删除", JOptionPane.YES_NO_OPTION);
                if (confirm == JOptionPane.YES_OPTION) {
                    menuUI.deleteRow(rowIndex); // 调用 MenuUI 的 deleteRow 方法
                }
            }
        });
    }

    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
        this.rowIndex = row; // 更新当前行索引
        button.setText(value != null ? value.toString() : ""); // 根据单元格的值设置按钮文本
        return panel;
    }

    @Override
    public Object getCellEditorValue() {
        return button.getText(); // 返回按钮的当前文本
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\ButtonRenderer.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import java.awt.*;

class ButtonRenderer extends DefaultTableCellRenderer {
    private final JPanel panel = new JPanel(new BorderLayout()); // 使用 BorderLayout
    private final JButton button = new JButton();

    public ButtonRenderer() {
        button.setFocusPainted(false); // 移除按钮的焦点边框
        button.setPreferredSize(new Dimension(80, 30)); // 设置按钮的固定尺寸
        panel.add(button, BorderLayout.CENTER); // 将按钮添加到面板中心
    }

    @Override
    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
        // 根据单元格的值设置按钮文本
        button.setText(value != null ? value.toString() : "");
        return panel;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\HistogramExample.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;
import java.util.HashMap;
import java.util.Random;

// 数据生成类
class DataGenerator {
    public static int[] generateData(int numberOfDataPoints, int maxValue) {
        Random random = new Random();
        int[] data = new int[numberOfDataPoints];
        for (int i = 0; i < numberOfDataPoints; i++) {
            data[i] = random.nextInt(maxValue);
        }
        return data;
    }
}

// 直方图计算类
class Histogram {
    private int binSize;
    private int[] data;

    public Histogram(int[] data, int binSize) {
        this.data = data;
        this.binSize = binSize;
    }

    public HashMap<Integer, Integer> computeFrequency() {
        HashMap<Integer, Integer> frequencyMap = new HashMap<>();
        for (int number : data) {
            int bin = number / binSize;
            frequencyMap.put(bin, frequencyMap.getOrDefault(bin, 0) + 1);
        }
        return frequencyMap;
    }
}

// 直方图 GUI 绘制类
class HistogramPanel extends JPanel {
    HashMap<Integer, Integer> frequencyMap;

    public HistogramPanel() {
        this.frequencyMap = new HashMap<>();
    }

    public void updateData(HashMap<Integer, Integer> frequencyMap) {
        this.frequencyMap = frequencyMap;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        int barWidth = 40;
        int gap = 10;
        int maxFrequency = frequencyMap.values().stream().mapToInt(v -> v).max().orElse(1);

        int index = 0;
        for (Integer key : frequencyMap.keySet()) {
            int height = (int) ((frequencyMap.get(key) / (double) maxFrequency) * getHeight());
            g.setColor(Color.BLUE);
            g.fillRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.setColor(Color.BLACK);
            g.drawRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.drawString("Bin " + key, index * (barWidth + gap) + 5, getHeight() - 5);
            index++;
        }
    }
}


// 主窗口类
public class HistogramExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("数据分析界面");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\MenuUI.java`:

```java
package Controller;

import Constants.ConfigConstants;
import DAO.Impl.CsvTransactionDao;

import Service.Impl.TransactionServiceImpl;

import Service.Impl.TransactionServiceImpl;

import Utils.CacheUtil;
import model.Transaction;

import javax.swing.*;
import java.awt.*;
import java.io.IOException;
import java.util.List;
import java.util.Vector;
import javax.swing.table.DefaultTableModel;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class MenuUI {
    private static final String FILE_PATH = CSV_PATH;
    private static DefaultTableModel tableModel;
    private static Vector<Vector<String>> allData = new Vector<>();
    private static TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());
    private JTable table;  // 把table定义为静态字段
    private HistogramPanelContainer histogramPanelContainer; // 添加 HistogramPanelContainer 实例
    private JPanel rightPanel; // 右边的面板，用于显示搜索和表格界面或 AI 界面
    private CardLayout cardLayout; // 用于管理界面切换的布局

    public MenuUI(){
        String[] columnNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注", "Modify", "Delete"};
        tableModel = new DefaultTableModel(columnNames, 0);
        table = new JTable(tableModel);

        histogramPanelContainer = new HistogramPanelContainer(); // 初始化 HistogramPanelContainer
        cardLayout = new CardLayout(); // 初始化 CardLayout
        rightPanel = new JPanel(cardLayout); // 初始化 rightPanel
    }

    public JPanel createMainPanel() {
        // 主面板，使用 BorderLayout
        JPanel mainPanel = new JPanel(new BorderLayout());

        // 左边的面板，包含 Menu 和 AI 按钮
        JPanel leftPanel = createLeftPanel();
        mainPanel.add(leftPanel, BorderLayout.WEST);

        // 右边的面板，用于显示搜索和表格界面或 AI 界面
        setupRightPanel();
        mainPanel.add(rightPanel, BorderLayout.CENTER);

        return mainPanel;
    }

    // 创建左边的面板，包含 Menu 和 AI 按钮
    private JPanel createLeftPanel() {
        JPanel leftPanel = new JPanel(new GridLayout(2, 1));
        JButton menuButton = new JButton("Menu");
        JButton aiButton = new JButton("AI");

        leftPanel.add(menuButton);
        leftPanel.add(aiButton);

        // 为 Menu 按钮添加 ActionListener
        menuButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Table"); // 切换到表格界面
        });

        // 为 AI 按钮添加 ActionListener
        aiButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Histogram"); // 切换到直方图界面
        });

        return leftPanel;
    }

    // 设置右边的面板，包含搜索和表格界面或 AI 界面
    private void setupRightPanel() {
        // 创建搜索和表格的面板
        JPanel tablePanel = createTablePanel();

        // 将表格面板和直方图面板添加到 rightPanel
        rightPanel.add(tablePanel, "Table");
        rightPanel.add(histogramPanelContainer, "Histogram");
    }

    // 创建搜索和表格的面板
    private JPanel createTablePanel() {
        JPanel tablePanel = new JPanel(new BorderLayout());

        // 创建输入面板
        JPanel inputPanel = createInputPanel();
        tablePanel.add(inputPanel, BorderLayout.NORTH);

        // 创建表格的滚动面板
        JScrollPane tableScrollPane = new JScrollPane(table);
        tableScrollPane.setPreferredSize(new Dimension(1000, 250));
        table.setRowHeight(30); // 设置表格的行高

        tablePanel.add(tableScrollPane, BorderLayout.CENTER);

        // 为 Modify 列设置渲染器和编辑器
        table.getColumnModel().getColumn(11).setCellRenderer(new ButtonRenderer());
        table.getColumnModel().getColumn(11).setCellEditor(new ButtonEditor(this));

        // 为 Delete 列设置渲染器和编辑器
        table.getColumnModel().getColumn(12).setCellRenderer(new ButtonRenderer());
        table.getColumnModel().getColumn(12).setCellEditor(new ButtonEditor(this));

        // 加载 CSV 数据
        loadCSVData(FILE_PATH);

        return tablePanel;
    }

    // 创建输入面板
    private JPanel createInputPanel() {
        JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));

        // 创建输入字段
        JTextField transactionTimeField = new JTextField(10); // 交易时间输入框
        JTextField transactionTypeField = new JTextField(10); // 交易类型输入框
        JTextField counterpartyField = new JTextField(10);    // 交易对方输入框
        JTextField commodityField = new JTextField(10);      // 商品输入框
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"}); // 收/支下拉框
        JTextField paymentMethodField = new JTextField(10);  // 支付方式输入框

        // 添加标签和输入字段到输入面板
        inputPanel.add(new JLabel("交易时间:"));
        inputPanel.add(transactionTimeField);
        inputPanel.add(new JLabel("交易类型:"));
        inputPanel.add(transactionTypeField);
        inputPanel.add(new JLabel("交易对方:"));
        inputPanel.add(counterpartyField);
        inputPanel.add(new JLabel("商品:"));
        inputPanel.add(commodityField);
        inputPanel.add(new JLabel("收/支:"));
        inputPanel.add(inOutComboBox);
        inputPanel.add(new JLabel("支付方式:"));
        inputPanel.add(paymentMethodField);

        // 创建 Search 和 Add 按钮
        JButton searchButton = new JButton("Search");
        JButton addButton = new JButton("Add");

        // 将按钮添加到输入面板
        inputPanel.add(searchButton);
        inputPanel.add(addButton);

        // 为 Search 按钮添加 ActionListener
        searchButton.addActionListener(e -> {
            // 获取输入字段的值
            searchData(
                    transactionTimeField.getText().trim(),
                    transactionTypeField.getText().trim(),
                    counterpartyField.getText().trim(),
                    commodityField.getText().trim(),
                    (String) inOutComboBox.getSelectedItem(),
                    paymentMethodField.getText().trim()
            );
        });

        // 为 Add 按钮添加 ActionListener
        addButton.addActionListener(e -> {
            // 弹出对话框，输入交易信息
            showAddTransactionDialog();
        });

        return inputPanel;
    }

    // 弹出对话框，输入交易信息
    private void showAddTransactionDialog() {
        // 创建对话框
        JDialog addDialog = new JDialog();
        addDialog.setTitle("添加交易");
        addDialog.setLayout(new GridLayout(12, 2)); // 11 个字段 + 1 个按钮行

        // 创建输入字段
        JTextField transactionTimeField = new JTextField();
        JTextField transactionTypeField = new JTextField();
        JTextField counterpartyField = new JTextField();
        JTextField commodityField = new JTextField();
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"});
        JTextField paymentAmountField = new JTextField();
        JTextField paymentMethodField = new JTextField();
        JTextField currentStatusField = new JTextField();
        JTextField orderNumberField = new JTextField();
        JTextField merchantNumberField = new JTextField();
        JTextField remarksField = new JTextField();

        // 添加标签和输入字段到对话框
        addDialog.add(new JLabel("交易时间:"));
        addDialog.add(transactionTimeField);
        addDialog.add(new JLabel("交易类型:"));
        addDialog.add(transactionTypeField);
        addDialog.add(new JLabel("交易对方:"));
        addDialog.add(counterpartyField);
        addDialog.add(new JLabel("商品:"));
        addDialog.add(commodityField);
        addDialog.add(new JLabel("收/支:"));
        addDialog.add(inOutComboBox);
        addDialog.add(new JLabel("金额(元):"));
        addDialog.add(paymentAmountField);
        addDialog.add(new JLabel("支付方式:"));
        addDialog.add(paymentMethodField);
        addDialog.add(new JLabel("当前状态:"));
        addDialog.add(currentStatusField);
        addDialog.add(new JLabel("交易单号:"));
        addDialog.add(orderNumberField);
        addDialog.add(new JLabel("商户单号:"));
        addDialog.add(merchantNumberField);
        addDialog.add(new JLabel("备注:"));
        addDialog.add(remarksField);

        // 添加确认按钮
        JButton confirmButton = new JButton("确认");
        confirmButton.addActionListener(e -> {
            // 获取输入字段的值，若为空则设置为默认值
            String transactionTime = emptyIfNull(transactionTimeField.getText().trim());
            String transactionType = emptyIfNull(transactionTypeField.getText().trim());
            String counterparty = emptyIfNull(counterpartyField.getText().trim());
            String commodity = emptyIfNull(commodityField.getText().trim());
            String inOut = (String) inOutComboBox.getSelectedItem();
            String paymentAmountText = paymentAmountField.getText().trim();
            double paymentAmount = paymentAmountText.isEmpty() ? 0.0 : Double.parseDouble(paymentAmountText); // 处理空字符串
            String paymentMethod = emptyIfNull(paymentMethodField.getText().trim());
            String currentStatus = emptyIfNull(currentStatusField.getText().trim());
            String orderNumber = emptyIfNull(orderNumberField.getText().trim());
            String merchantNumber = emptyIfNull(merchantNumberField.getText().trim());
            String remarks = emptyIfNull(remarksField.getText().trim());

            // 创建 Transaction 对象
            Transaction newTransaction = new Transaction(
                    transactionTime,
                    transactionType,
                    counterparty,
                    commodity,
                    inOut,
                    paymentAmount,
                    paymentMethod,
                    currentStatus,
                    orderNumber,
                    merchantNumber,
                    remarks
            );

            try {
                // 调用 TransactionServiceImpl 的 addTransaction 方法
                transactionService.addTransaction(newTransaction);

                // 重新加载 CSV 数据以更新表格
                loadCSVData(TRANSACTION_CAFFEINE_KEY);

                // 关闭对话框
                addDialog.dispose();

                JOptionPane.showMessageDialog(null, "交易添加成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(null, "交易添加失败！", "错误", JOptionPane.ERROR_MESSAGE);
            }
        });

        addDialog.add(confirmButton);

        // 设置对话框大小并显示
        addDialog.setSize(400, 300);
        addDialog.setModal(true); // 设置为模态对话框
        addDialog.setVisible(true);
    }

    // 加载 CSV 数据
    public void loadCSVData(String caffeineKey) {
        allData.clear();
        tableModel.setRowCount(0);

        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;

//        CsvTransactionDao csvTransactionDao = new CsvTransactionDao();

        List<Transaction> transactions = cache.get(caffeineKey);
        for (Transaction transaction : transactions) {
            Vector<String> row = createRowFromTransaction(transaction);
            allData.add(row);
            tableModel.addRow(row);
        }
    }

    // 搜索数据
    public void searchData(String query1, String query2, String query3, String query4, String query6, String query5) {
        tableModel.setRowCount(0);
        Transaction searchCriteria = new Transaction(query1, query2, query3, query4, query6, 0, query5, "", "", "", "");

        try {
            List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);
            for (Transaction transaction : transactions) {
                Vector<String> row = createRowFromTransaction(transaction);
                tableModel.addRow(row);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(null, "查询失败！", "错误", JOptionPane.ERROR_MESSAGE);
        }
    }

    // 从 Transaction 对象创建表格行
    private Vector<String> createRowFromTransaction(Transaction transaction) {
        Vector<String> row = new Vector<>();
        row.add(transaction.getTransactionTime());
        row.add(transaction.getTransactionType());
        row.add(transaction.getCounterparty());
        row.add(transaction.getCommodity());
        row.add(transaction.getInOut());
        row.add(String.valueOf(transaction.getPaymentAmount()));
        row.add(transaction.getPaymentMethod());
        row.add(transaction.getCurrentStatus());
        row.add(transaction.getOrderNumber());
        row.add(transaction.getMerchantNumber());
        row.add(transaction.getRemarks());
        row.add("Modify"); // Modify 按钮
        row.add("Delete"); // 添加 Delete 按钮
        return row;
    }

    // 删除行
    public void deleteRow(int rowIndex) {
        if (rowIndex >= 0 && rowIndex < allData.size()) {
            String orderNumber = allData.get(rowIndex).get(8).trim();
            System.out.println("尝试删除的交易单号: " + orderNumber); // 打印交易单号

            try {
                if (transactionService.deleteTransaction(orderNumber)) {
                    allData.remove(rowIndex);
                    tableModel.removeRow(rowIndex);
                    JOptionPane.showMessageDialog(null, "删除成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                } else {
                    JOptionPane.showMessageDialog(null, "删除失败：未找到对应的交易单号", "错误", JOptionPane.ERROR_MESSAGE);
                }
            } catch (IOException ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(null, "删除失败！", "错误", JOptionPane.ERROR_MESSAGE);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    // 编辑行
    public void editRow(int rowIndex) {
        System.out.println("编辑行: " + rowIndex);
        if (rowIndex >= 0 && rowIndex < allData.size()) {
            Vector<String> rowData = allData.get(rowIndex);

            // 创建一个面板用于显示编辑字段
            JPanel panel = new JPanel(new GridLayout(rowData.size() - 2, 2)); // 排除最后两列

            // 创建字段数组，用于存储用户输入的值
            JTextField[] fields = new JTextField[rowData.size() - 2]; // 排除最后两列

            // 遍历 rowData，跳过最后两列（"Modify" 和 "Delete"）
            for (int i = 0; i < rowData.size() - 2; i++) {
                panel.add(new JLabel(tableModel.getColumnName(i))); // 添加列名标签
                fields[i] = new JTextField(rowData .get(i)); // 添加输入字段
                panel.add(fields[i]);
            }

            // 弹出对话框，让用户修改数据
            int result = JOptionPane.showConfirmDialog(null, panel, "修改交易信息", JOptionPane.OK_CANCEL_OPTION);
            if (result == JOptionPane.OK_OPTION) {
                // 用户点击了确认按钮，更新交易信息
                Transaction transaction = new Transaction(
                        fields[0].getText().trim(), // 交易时间
                        fields[1].getText().trim(), // 交易类型
                        fields[2].getText().trim(), // 交易对方
                        fields[3].getText().trim(), // 商品
                        fields[4].getText().trim(), // 收/支
                        Double.parseDouble(fields[5].getText().trim()), // 金额(元)
                        fields[6].getText().trim(), // 支付方式
                        fields[7].getText().trim(), // 当前状态
                        fields[8].getText().trim(), // 交易单号
                        fields[9].getText().trim(), // 商户单号
                        fields[10].getText().trim() // 备注
                );

                try {
                    // 调用 TransactionServiceImpl 的 changeTransaction 方法更新交易
                    transactionService.changeTransaction(transaction);

                    // 重新加载 CSV 数据以更新表格
                    loadCSVData(TRANSACTION_CAFFEINE_KEY);

                    JOptionPane.showMessageDialog(null, "修改成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                } catch (Exception ex) {
                    ex.printStackTrace();
                    JOptionPane.showMessageDialog(null, "修改失败！", "错误", JOptionPane.ERROR_MESSAGE);
                }
            }
        }
    }

    /**
     * 查找对话框中的输入字段
     *
     * @param dialog 对话框
     * @param index  输入字段的索引
     * @return 输入字段
     */
    /**
     * 查找容器中的输入字段
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0;
        for (Component component : container.getComponents()) {
            if (component instanceof JTextField) {
                if (count == index) {
                    return (JTextField) component;
                }
                count++;
            }
        }
        return null;
    }

    /**
     * 查找对话框中的下拉框
     *
     * @param dialog 对话框
     * @return 下拉框
     */
    /**
     * 查找容器中的下拉框
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) {
            if (component instanceof JComboBox) {
                return (JComboBox<String>) component;
            }
        }
        return null;
    }

    /**
     * 如果字段为 null，则返回空文本
     *
     * @param value 字段值
     * @return 非 null 的字段值
     */
    private String emptyIfNull(String value) {
        return value == null ? "" : value;
    }

    // 添加此方法以便测试时可以获取table
    public JTable getTable() {
        return table;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\DAO\CsvTransactionDao.java`:

```java
package DAO;

import Constants.ConfigConstants;
import model.Transaction;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static Constants.ConfigConstants.CSV_PATH;

public class CsvTransactionDao implements TransactionDao {
    //避免每次都调用loadFromCSV() 方法
    private List<Transaction> transactions;
    private boolean isLoad= false;
//HEAD 交易时间	交易类型	交易对方	商品	收/支	金额(元)	支付方式	当前状态	交易单号	商户单号	备注
    //
    @Override
    public List<Transaction> loadFromCSV(String filePath) throws IOException {
        try (
                Reader reader = new InputStreamReader(
                        new BOMInputStream(Files.newInputStream(Paths.get(filePath))),
                        StandardCharsets.UTF_8)) {
            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()    //根据首行的内容设置为表格的头
                    .withIgnoreHeaderCase(false)  // 禁用忽略大小写
                    .withTrim(false);             // 禁用自动trim（防止意外空格问题）

            try (CSVParser csvParser = new CSVParser(reader, format)) {

                List<Transaction> transactions = new ArrayList<>();
                for (CSVRecord record : csvParser) {
                    Transaction transaction = parseRecord(record);
                    transactions.add(transaction);
                }
                reader.close();
                this.transactions = transactions;
                this.isLoad=true;
                return transactions;
            }
        }
    }


    private Transaction parseRecord(CSVRecord record) {
        return new Transaction(
                record.get("交易时间"),
                record.get("交易类型"),
                record.get("交易对方"),
                record.get("商品"),
                record.get("收/支"),
                Double.parseDouble(record.get("金额(元)").substring(1)),
                record.get("支付方式"),
                record.get("当前状态"),
                record.get("交易单号"),
                record.get("商户单号"),
                record.get("备注")
        );
    }

    // 根据交易单号删除交易记录
    public boolean deleteTransaction(String filePath, String orderNumber) throws IOException {
        if(!isLoad){ loadFromCSV(filePath);}

        List<Transaction> updatedTransactions = transactions.stream()
                .filter(t -> !t.getOrderNumber().trim().equals(orderNumber))
                .collect(Collectors.toList());

        if (transactions.size() == updatedTransactions.size()) {
            return false;
        }

        writeTransactionsToCSV(filePath, updatedTransactions);
        return true;
    }

    // 添加交易
    public void addTransaction(String filePath, Transaction newTransaction) throws IOException {
        boolean fileExists = Files.exists(Paths.get(filePath)) && Files.size(Paths.get(filePath)) > 0;

        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(filePath), StandardOpenOption.CREATE, StandardOpenOption.APPEND);
             CSVPrinter csvPrinter = new CSVPrinter(writer, fileExists ? getCsvFormatWithoutHeader() : getCsvFormatWithHeader(filePath))) {

            csvPrinter.printRecord(
                    newTransaction.getTransactionTime(),
                    newTransaction.getTransactionType(),
                    newTransaction.getCounterparty(),
                    newTransaction.getCommodity(),
                    newTransaction.getInOut(),
                    "¥" + newTransaction.getPaymentAmount(),
                    newTransaction.getPaymentMethod(),
                    newTransaction.getCurrentStatus(),
                    newTransaction.getOrderNumber(),
                    newTransaction.getMerchantNumber(),
                    newTransaction.getRemarks()
            );

            csvPrinter.flush();
        }
    }

    // 统一写回 CSV
    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
        // 1. 创建临时文件（确保与原文件同目录）
        File targetFile = new File(filePath);
        File tempFile = File.createTempFile("transaction_temp", ".csv", targetFile.getParentFile());

        // 2. 写入数据到临时文件（使用 try-with-resources 确保资源释放）
        try (BufferedWriter writer = Files.newBufferedWriter(tempFile.toPath());
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(
                     "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"))) {

            for (Transaction t : transactions) {
                csvPrinter.printRecord(
                        t.getTransactionTime(),
                        t.getTransactionType(),
                        t.getCounterparty(),
                        t.getCommodity(),
                        t.getInOut(),
                        "¥" + t.getPaymentAmount(),
                        t.getPaymentMethod(),
                        t.getCurrentStatus(),
                        t.getOrderNumber(),
                        t.getMerchantNumber(),
                        t.getRemarks()
                );
            }
            csvPrinter.flush(); // 强制刷盘
        } catch (IOException e) {
            tempFile.delete(); // 失败时删除临时文件
            throw e;
        }

        // 3. 原子性替换原文件
        Path source = tempFile.toPath();
        Path target = Paths.get(filePath);
        try {
            Files.move(source, target, StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            System.err.println("移动失败原因: " + e.getMessage());
        }
    }

//    // 统一写回 CSV
//    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
//        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(filePath));
//             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(
//                     "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注")))  {
//
//            for (Transaction t : transactions) {
//                csvPrinter.printRecord(
//                        t.getTransactionTime(),
//                        t.getTransactionType(),
//                        t.getCounterparty(),
//                        t.getCommodity(),
//                        t.getInOut(),
//                        "¥" + t.getPaymentAmount(),
//                        t.getPaymentMethod(),
//                        t.getCurrentStatus(),
//                        t.getOrderNumber(),
//                        t.getMerchantNumber(),
//                        t.getRemarks()
//                );
//            }
//        }
//    }

    // 获取 CSV 格式（包含表头）
    private CSVFormat getCsvFormatWithHeader(String filePath) throws IOException {
        try (BufferedReader reader = Files.newBufferedReader(Paths.get(filePath))) {
            String headerLine = reader.readLine();
            if (headerLine == null || headerLine.trim().isEmpty()) {
                // 如果文件为空或不存在，返回默认表头
                return CSVFormat.DEFAULT.withHeader(
                        "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"
                );
            }
            return CSVFormat.DEFAULT.withHeader(headerLine.split(",")).withTrim();
        }
    }

    // 获取 CSV 格式（不包含表头）
    private CSVFormat getCsvFormatWithoutHeader() {
        return CSVFormat.DEFAULT.withTrim();
    }

    public boolean changeInformation(String orderNumber, String head, String value,String path) throws IOException{
        if(isLoad==false){ loadFromCSV(path);}
        for (int i = 0; i < transactions.size(); i++) {
            if(transactions.get(i).getOrderNumber().trim().equals(orderNumber)){
                Transaction newTransaction=transactions.get(i);
                switch (head){
                    case "transactionTime" :{
                        newTransaction.setTransactionTime(value);
                        break;}
                    case "transactionType" :{
                        newTransaction.setTransactionType(value);
                        break;
                    }
                    case "counterparty" :{
                        newTransaction.setCounterparty(value);
                        break;
                    } case "commodity" :{
                        newTransaction.setCommodity(value);
                        break;
                    } case "inOut" :{
                        newTransaction.setInOut(value);
                        break;
                    } case "paymentAmount" :{
                        newTransaction.setPaymentAmount(Double.parseDouble(value));
                        break;
                    } case "paymentMethod" :{
                        newTransaction.setPaymentMethod(value);
                        break;
                    } case "currentStatus" :{
                        newTransaction.setCurrentStatus(value);
                        break;
                    } case "orderNumber" :{
                        newTransaction.setOrderNumber(value);
                        break;
                    } case "merchantNumber" :{
                        newTransaction.setMerchantNumber(value);
                        break;
                    } case "remarks" :{
                        newTransaction.setRemarks(value);
                        break;
                    } default:{
                        System.err.println("error head");
                    }
                }

                boolean flag=deleteTransaction(path,transactions.get(i).getOrderNumber());
                if(flag) {
                    addTransaction(path,newTransaction);
                    System.out.println("success to delete");
                }
                else System.err.println("failed to delete");
            }
        }
        return true;
    }

    @Override
    public List<Transaction> getAllTransactions() throws IOException {
        return List.of();
    }

    @Override
    public void addTransaction(Transaction transaction) throws IOException {

    }

    @Override
    public boolean deleteTransaction(String orderNumber) throws IOException {
        return false;
    }

    @Override
    public boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException {
        return false;
    }

    @Override
    public Transaction getTransactionByOrderNumber(String orderNumber) throws IOException {
        return null;
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\DAO\TransactionDao.java`:

```java
package DAO;

import model.Transaction;

import java.io.IOException;
import java.util.List;

/**
 * Interface for Data Access Object (DAO) operations related to Transactions.
 * Defines the contract for loading, adding, deleting, and updating transaction data.
 */
public interface
TransactionDao {

    //HEAD 交易时间	交易类型	交易对方	商品	收/支	金额(元)	支付方式	当前状态	交易单号	商户单号	备注
        //
    List<Transaction> loadFromCSV(String filePath) throws IOException;

    /**
     * Loads all transactions from the configured data source.
     *
     * @return A list of all transactions.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<Transaction> getAllTransactions() throws IOException;

    /**
     * Adds a new transaction to the data source.
     *
     * @param transaction The new transaction to add.
     * @throws IOException If an I/O error occurs during saving.
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * Deletes a transaction identified by its order number.
     *
     * @param orderNumber The unique order number of the transaction to delete.
     * @return true if a transaction was found and deleted, false otherwise.
     * @throws IOException If an I/O error occurs during loading or saving.
     */
    boolean deleteTransaction(String orderNumber) throws IOException;

    /**
     * Updates a specific field of an existing transaction identified by its order number.
     *
     * @param orderNumber The unique order number of the transaction to update.
     * @param fieldName   The name of the field to update (e.g., "transactionType", "paymentAmount").
     * @param newValue    The new value for the specified field.
     * @return true if the transaction was found and updated, false otherwise.
     * @throws IOException             If an I/O error occurs during loading or saving.
     * @throws NumberFormatException   If updating 'paymentAmount' and newValue is not a valid double.
     * @throws IllegalArgumentException If the fieldName is invalid.
     */
    boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException;

    /**
     * Retrieves a transaction by its unique order number.
     * (Optional but often useful)
     *
     * @param orderNumber The unique order number.
     * @return The Transaction object if found, null otherwise.
     * @throws IOException If an I/O error occurs during loading.
     */
    Transaction getTransactionByOrderNumber(String orderNumber) throws IOException;

}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Interceptor\Login\LoginDialog.java`:

```java
package Interceptor.Login;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class LoginDialog extends JDialog {
    private boolean loginSuccessful = false;
    private JTextField usernameField;
    private JPasswordField passwordField;
    private UserService userService = new UserService();

    public LoginDialog() {
        setTitle("用户登录");
        setLayout(new GridLayout(3, 2));
        setModal(true);
        setSize(300, 150);

        // 输入组件
        usernameField = new JTextField();
        passwordField = new JPasswordField();
        JButton loginButton = new JButton("登录");
        JButton cancelButton = new JButton("取消");

        // 添加组件
        add(new JLabel("用户名:"));
        add(usernameField);
        add(new JLabel("密码:"));
        add(passwordField);
        add(loginButton);
        add(cancelButton);

        // 登录按钮逻辑
        loginButton.addActionListener(e -> {
            String username = usernameField.getText().trim();
            String password = new String(passwordField.getPassword()).trim();

            if (userService.authenticate(username, password)) {
                loginSuccessful = true;
                dispose(); // 关闭对话框
            } else {
                JOptionPane.showMessageDialog(
                        this,
                        "用户名或密码错误！",
                        "登录失败",
                        JOptionPane.ERROR_MESSAGE
                );
                clearFields(); // 登录失败后清空文本框
            }
        });

        // 取消按钮逻辑
        cancelButton.addActionListener(e -> {
            dispose();
            System.exit(0);
        });

        setLocationRelativeTo(null); // 居中显示
    }

    // 清空文本框的方法
    private void clearFields() {
        usernameField.setText("");
        passwordField.setText("");
        usernameField.requestFocus(); // 焦点回到用户名输入框
    }

    public boolean isLoginSuccessful() {
        return loginSuccessful;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Interceptor\Login\UserService.java`:

```java
package Interceptor.Login;

import java.util.HashMap;
import java.util.Map;

public class UserService {
    // 模拟用户数据库（用户名 -> 密码哈希值）
    private static final Map<String, String> userDatabase = new HashMap<>();

    public UserService() {
        // 初始化测试用户（密码为 "admin123" 的 SHA-256 哈希）
        userDatabase.put("admin", "admin123");
    }

    public boolean authenticate(String username, String password) {
        if (username.isEmpty() || password.isEmpty()) return false;
        String storedHash = userDatabase.get(username);
        return password.equals(storedHash);
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Main.java`:

```java
import javax.swing.*;

import Controller.MenuUI;
import DAO.Impl.CsvTransactionDao;
import Interceptor.Login.LoginDialog;
import Service.Impl.TransactionServiceImpl;

public class Main {
    public static void main(String[] args) {
        // 初始化服务（依赖注入）
        TransactionServiceImpl.csvTransactionDao = new CsvTransactionDao();

        // 在事件调度线程中启动 GUI（Swing 规范）
        SwingUtilities.invokeLater(() -> {
            // 1. 显示登录对话框
            LoginDialog loginDialog = new LoginDialog();
            loginDialog.setVisible(true);

            // 2. 登录成功后再显示主界面
            if (loginDialog.isLoginSuccessful()) {
                MenuUI menuUI = new MenuUI();
                JPanel mainPanel = menuUI.createMainPanel();
                showMainUI(mainPanel);
            } else {
                System.exit(0); // 登录失败退出
            }
        });
    }

    /**
     * 显示主界面窗口
     */
    private static void showMainUI(JPanel panel) {
        JFrame frame = new JFrame("交易管理系统");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(1200, 600);
        frame.setLocationRelativeTo(null); // 窗口居中
        frame.add(panel);
        frame.setVisible(true);
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\AIAnalyzerThread.java`:

```java
package Service.AIservice;

public class AIAnalyzerThread implements Runnable {
    private final String userRequest;
    private final String filePath;
    private final String startTimeStr;
    private final String endTimeStr;

    public AIAnalyzerThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        this.userRequest = userRequest;
        this.filePath = filePath;
        this.startTimeStr = startTimeStr;
        this.endTimeStr = endTimeStr;
    }

    @Override
    public void run() {
        String result = new AITransactionService().analyzeTransactions(userRequest, filePath, startTimeStr, endTimeStr);
        System.out.println("AI分析结果: " + result);
        // TODO: 如果是UI程序，可用 SwingUtilities.invokeLater() 更新UI组件
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\AITransactionService.java`:

```java
package Service.AIservice;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Constants.ConfigConstants;
import DAO.Impl.CsvTransactionDao;
import Utils.CacheUtil;
import model.Transaction;
import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;

import java.io.IOException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;
import java.util.concurrent.*;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class AITransactionService {
    private static final String API_KEY = System.getenv("ARK_API_KEY");
    private static final ArkService service = ArkService.builder()
            .timeout(Duration.ofSeconds(1800))
            .connectTimeout(Duration.ofSeconds(20))
            .baseUrl("https://ark.cn-beijing.volces.com/api/v3")
            .apiKey(API_KEY)
            .build();

    private final CsvTransactionDao transactionDao = new CsvTransactionDao();

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    private final CacheUtil<String, List<Transaction>, Exception> cache;
    /**
     * 重构构造器初始化Caffeine
     */
    public AITransactionService()  {
        // 1. 注入Dao层接口
        TransactionServiceImpl.csvTransactionDao = transactionDao;
        // 2. 初始化CacheUtil
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return transactionDao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );
    }

    public String analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        try {
            List<Transaction> transactions = cache.get(TRANSACTION_CAFFEINE_KEY);
            List<String> transactionDetails = formatTransactions(transactions, startTimeStr, endTimeStr);

            String aiPrompt = userRequest + "\n" + "以下是我的账单信息：\n" + String.join("\n", transactionDetails);
            return askAi(aiPrompt);
        } catch (Exception e) {
            e.printStackTrace();
            return "AI分析失败: " + e.getMessage();
        }
    }


    //private List<String> formatTransactions(List<Transaction> transactions) {
        //return transactions.stream().map(t -> String.format(
               // "交易时间: %s, 商品: %s, 收/支: %s, 金额: %.2f元",
               // t.getTransactionTime(),
               // t.getCommodity(),
               // t.getInOut(),
               // t.getPaymentAmount()
        //)).collect(Collectors.toList());
    //}

    public List<String> formatTransactions(List<Transaction> transactions, String startTimeStr, String endTimeStr) {
        LocalDateTime startTime = parseDateTime(startTimeStr);
        LocalDateTime endTime = (endTimeStr == null || endTimeStr.isEmpty())
                ? LocalDateTime.now()
                : parseDateTime(endTimeStr);

        if (startTime == null) {
            throw new IllegalArgumentException("起始时间格式不正确");
        }

        List<Transaction> filtered = transactions.stream()
                .filter(t -> {
                    LocalDateTime tTime = parseDateTime(t.getTransactionTime());
                    return tTime != null && !tTime.isBefore(startTime) && !tTime.isAfter(endTime);
                })
                .collect(Collectors.toList());

        Map<String, double[]> grouped = new HashMap<>();
        for (Transaction t : filtered) {
            String counterparty = t.getCounterparty();
            double amount = t.getInOut().equals("支出") ? -t.getPaymentAmount() : t.getPaymentAmount();
            grouped.putIfAbsent(counterparty, new double[]{0.0, 0});
            grouped.get(counterparty)[0] += amount;
            grouped.get(counterparty)[1] += 1;
        }

        List<String> results = grouped.entrySet().stream()
                .map(e -> {
                    String cp = e.getKey();
                    double net = e.getValue()[0];
                    int count = (int) e.getValue()[1];
                    String inOut = net >= 0 ? "收入" : "支出";
                    return String.format("交易对方: %s, 收/支: %s, 金额: %.2f元，交易次数: %d",
                            cp, inOut, Math.abs(net), count);
                })
                .collect(Collectors.toList());

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm");
        results.add(String.format("交易时间范围：%s - %s",
                formatter.format(startTime), formatter.format(endTime)));

        return results.isEmpty() ? List.of("该时间段内没有交易记录。") : results;
    }




    //private LocalDateTime parseDateTime(String timeStr) {
        // 你可以按实际情况支持不同格式，比如 yyyy/MM/dd HH:mm 或 yyyy-MM-dd HH:mm:ss
        //List<String> patterns = Arrays.asList("yyyy/MM/dd HH:mm","yyyy/MM/dd H:mm", "yyyy/M/dd H:mm","yyyy/M/dd HH:mm","yyyy/M/d H:mm","yyyy/M/d HH:mm","yyyy-MM-dd HH:mm:ss", "yyyy/MM/dd");

        //for (String pattern : patterns) {
            //try {
                //DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                //return LocalDateTime.parse(timeStr, formatter);
            //} catch (Exception ignored) {}
        //}
        //return null;
    //}
        private LocalDateTime parseDateTime(String timeStr) {
            if (timeStr == null || timeStr.trim().isEmpty()) return null;

            // 中文空格等统一清理
            timeStr = timeStr.trim().replaceAll("\\s+", " ");

            // 如果只有日期，补 00:00
            if (timeStr.matches("\\d{4}/\\d{1,2}/\\d{1,2}")) {
                timeStr += " 00:00";
            }

            // 多种时间格式尝试解析
            List<String> patterns = Arrays.asList(
                    "yyyy/M/d H:mm", "yyyy/M/d HH:mm",
                    "yyyy/MM/d H:mm", "yyyy/MM/d HH:mm",
                    "yyyy/M/dd H:mm", "yyyy/M/dd HH:mm",
                    "yyyy/MM/dd H:mm", "yyyy/MM/dd HH:mm",
                    "yyyy-MM-dd HH:mm:ss",
                    "yyyy/MM/dd"
            );

            for (String pattern : patterns) {
                try {
                    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                    return LocalDateTime.parse(timeStr, formatter);
                } catch (Exception ignored) {}
            }

            return null;
        }






    public String askAi(String prompt) {
        try {
            List<ChatMessage> messages = List.of(
                    ChatMessage.builder().role(ChatMessageRole.USER).content(prompt).build()
            );

            ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
                    .model("ep-20250308174053-7pbkq")
                    .messages(messages)
                    .build();

            return (String) service.createChatCompletion(chatCompletionRequest)
                    .getChoices().get(0).getMessage().getContent();
        } catch (Exception e) {
            e.printStackTrace();
            return "AI请求失败: " + e.getMessage();
        }
    }

    public void runAiInThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            String result = analyzeTransactions(userRequest, filePath,startTimeStr, endTimeStr);
            System.out.println("AI分析结果: " + result);
        });
        executor.shutdown();
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\ColledgeStudentThread.java`:

```java
package Service.AIservice;

import java.io.IOException;

public class ColledgeStudentThread implements Runnable{
//    private final int userRequest;
    private final String filePath;
    public String budgetRange;
    public ColledgeStudentThread( String filePath) {
//        this.userRequest = userRequest;
        this.filePath = filePath;
    }

    @Override
    public void run(){
        CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
        try {
            collegeStudentNeeds.generateBudget(filePath);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\CollegeStudentNeeds.java`:

```java
package Service.AIservice;

import Constants.ConfigConstants;
import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import model.Transaction;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class CollegeStudentNeeds {
    private final String requestBudge="我是一名预算有限的大学生，请根据下面我给出的花费，帮助我给下周预算范围，必须以[最低预算，最高预算],的方式给出回答，不能有多余的回复。";
    private final String requestTips="我是一名预算有限的大学生，请给我推荐一些省钱方法。";

    private final String requestRecognition="下面我将给你一些账单的信息，请推测这个账单是什么方面的消费: ";
    CsvTransactionDao dao;

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    private final CacheUtil<String, List<Transaction>, Exception> cache;

    public CollegeStudentNeeds() {
        TransactionServiceImpl.csvTransactionDao = dao;
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return dao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );

    }
    public String RecognizeTransaction(Transaction transaction){
        StringBuilder sb=new StringBuilder();
        sb.append("交易类型:").append(transaction.getTransactionType()+",").append("交易对方").append(transaction.getCounterparty()+",")
                .append("商品:").append(transaction.getCommodity()+",").append("收/支:").append(transaction.getInOut()+",")
                        .append("金额(元):").append(transaction.getPaymentAmount()+",").append("支付方式").append(transaction.getPaymentMethod()+",").append("备注:").append(transaction.getRemarks());
        return  new AITransactionService().askAi(requestRecognition+sb.toString());
    }

    public String generateTipsForSaving(){
        return  new AITransactionService().askAi(requestTips);
    }
    //按周统计已有的支出，依靠ai得到下周的预算
    public double[] generateBudget(String path) throws IOException {
        List<Transaction> transactions=cache.get(TRANSACTION_CAFFEINE_KEY);

        int size=transactions.size();
        if(size==0||size==1) return new double[]{-1,-1};
        int count=1;
        int base=0;
        int index=0;//指示首个适合当基准的时间点
        for (index = 0; index < size; index++) {
            int data=convertDateToNumber(transactions.get(index).getTransactionTime().split(" ")[0]);
            if(data>0){
                base=data;
                break;
            }
        }
        List<Double> list=new ArrayList<>();
        double weekConsumption=0;
        for (int i = 0; i < size; i++) {
            int data=convertDateToNumber(transactions.get(i).getTransactionTime().split(" ")[0]);
            if(data<0) continue;
            if((base-data>=0&&base-data<7)&&transactions.get(i).getInOut().equals("支出")){
                weekConsumption+=transactions.get(i).getPaymentAmount();
            }else if(base-data>=7){
                base=data;
                list.add(weekConsumption);
                count++;
                weekConsumption=0;
                if(transactions.get(i).getInOut().equals("支出")){
                    weekConsumption+=transactions.get(i).getPaymentAmount();
                }
            }
        }
        StringBuilder stringBuilder=new StringBuilder();
        for (int i = 0; i < count-1; i++) {
            stringBuilder.append("第");
            stringBuilder.append(i);
            stringBuilder.append("周:花费");
            stringBuilder.append(list.get(i));
            stringBuilder.append("元;");
        }
        String answer=new AITransactionService().askAi(requestBudge+stringBuilder.toString());
        System.out.println(answer);
        double[] ret=new double[2];
        ret=parseDoubleArrayFromString(answer);
        return ret;
    }

    private int convertDateToNumber(String date) {
        // format yyyy/MM/dd
        String[] parts = date.split("/");
        if (parts.length != 3) {
            return -1; // Invalid date format
        }
        try {
            int year = Integer.parseInt(parts[0]);
            int month = Integer.parseInt(parts[1]);
            int day = Integer.parseInt(parts[2]);
            int days = day;
            int[] daysInMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // Days in each month
            if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
                daysInMonth[2] = 29; // February has 29 days in a leap year
            }
            for (int i = 1; i < month; i++) {
                days += daysInMonth[i];
            }
            return year * 365 + (year / 4 - year / 100 + year / 400) + days;
        } catch (NumberFormatException e) {
            return -1;
        }
    }
    public double[] parseDoubleArrayFromString(String input) {
        int length=input.length();
        int l=0,rightindex=input.length();
        // 1. 去除首尾括号
        for (int i = 0; i < length; i++) {
            if(input.charAt(i)<58&&input.charAt(i)>47){
                l=i;
                break;
            }
        }
        for (int r =length-1 ; r >0; r--) {
            if(input.charAt(r)<58&&input.charAt(r)>47){
                rightindex=r;
                break;
            }
        }
        String content = input.substring(l, rightindex+1 ); // 获取 "1.1, 11.0" 或 " 2.5 ,3.14 , -0.5 "

        // 2. 按逗号分割
        String[] numberStrings1 = content.split("，"); // 得到 ["1.1", " 11.0"] 或 [" 2.5 ", "3.14 ", " -0.5 "]
        String[] numberStrings2 = content.split(","); // 得到 ["1.1", " 11.0"] 或 [" 2.5 ", "3.14 ", " -0.5 "]
        String[] numberStrings= numberStrings1.length> numberStrings2.length?numberStrings1:numberStrings2;
//        System.out.println(numberStrings[0]);
//        System.out.println(numberStrings[1]);
        // 3. & 4. 遍历、清理、解析并存储
        List<Double> numberList = new ArrayList<>();
        try {
            for (String numStr : numberStrings) {
                String trimmedStr = numStr.trim(); // 去除首尾空格
                if (!trimmedStr.isEmpty()) { // 避免分割后产生空字符串（例如 "[1.1, , 2.2]"）
                    numberList.add(Double.parseDouble(trimmedStr)); // 解析为 double
                }
            }
        } catch (NumberFormatException e) {
            System.err.println("错误：字符串无法解析为 double 类型。");
            return null; // 或者抛出异常
        }

        // 将 List<Double> 转换为 double[]
        double[] result = new double[numberList.size()];
        for (int i = 0; i < numberList.size(); i++) {
            result[i] = numberList.get(i);
        }
        return result;
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\Impl\TransactionServiceImpl.java`:

```java
package Service.Impl;

import Constants.ConfigConstants;
import DAO.Impl.CsvTransactionDao;
import Service.TransactionService;
import Utils.CacheUtil;
import model.Transaction;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class TransactionServiceImpl implements TransactionService {
    public static CsvTransactionDao csvTransactionDao;

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    public final CacheUtil<String, List<Transaction>, Exception> cache;

    /**
     * 通过构造函数注入路径和csvTransactionDao
     * @param csvTransactionDao
     * @throws IOException
     */
    public TransactionServiceImpl(CsvTransactionDao csvTransactionDao)  {
        // 1. 注入Dao层接口
        TransactionServiceImpl.csvTransactionDao = csvTransactionDao;
        // 2. 初始化CacheUtil
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return csvTransactionDao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );
    }

    /**
     * 从transactions缓存中读取transactions如果没有则从csv文件中找
     * @return
     * @throws IOException
     */
    private List<Transaction> getAllTransactions() throws Exception {
        return cache.get(TRANSACTION_CAFFEINE_KEY);
    }


    /**
     * 新增交易
     * @param transaction
     */
    @Override
    public void addTransaction(Transaction transaction) throws IOException {
        // 设置交易时间为当前时间
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
        String currentTime = now.format(formatter);
        transaction.setTransactionTime(currentTime);

        // 调用 DAO 层方法添加交易
        csvTransactionDao.addTransaction(CSV_PATH, transaction);
    }

    @Override
    public void changeTransaction(Transaction updatedTransaction) throws Exception {
        // 1. 加载所有交易记录 先加载 caffeine存储的缓存
        List<Transaction> allTransactions = getAllTransactions();

        // 2. 查找并修改目标交易
        boolean found = false;
        for (int i = 0; i < allTransactions.size(); i++) {
            Transaction t = allTransactions.get(i);
            // 根据交易单号匹配记录（唯一标识）
            if (t.getOrderNumber().equals(updatedTransaction.getOrderNumber())) {
                // 3. 更新非空字段
                updateTransactionFields(t, updatedTransaction);
                found = true;
                break;
            }
        }
        if (!found) {
            throw new IllegalArgumentException("未找到交易单号: " + updatedTransaction.getOrderNumber());
        }
        // 使用事务将写后数据写回csv文件
        csvTransactionDao.writeTransactionsToCSV(CSV_PATH, allTransactions);
        // 修改后使缓存失效 （删缓存）
        cache.invalidate("transactions");
    }

    /**
     *  辅助方法：更新非空字段
     * @param target
     * @param source
     */
    private void updateTransactionFields(Transaction target, Transaction source) {
        if (source.getTransactionTime() != null && !source.getTransactionTime().isEmpty()) {
            target.setTransactionTime(source.getTransactionTime());
        }
        if (source.getTransactionType() != null && !source.getTransactionType().isEmpty()) {
            target.setTransactionType(source.getTransactionType());
        }
        if (source.getCounterparty() != null && !source.getCounterparty().isEmpty()) {
            target.setCounterparty(source.getCounterparty());
        }
        if (source.getCommodity() != null && !source.getCommodity().isEmpty()) {
            target.setCommodity(source.getCommodity());
        }
        if (source.getInOut() != null && !source.getInOut().isEmpty()) {
            target.setInOut(source.getInOut());
        }
        if (source.getPaymentAmount() != 0.0) { // 假设金额为0表示未修改
            target.setPaymentAmount(source.getPaymentAmount());
        }
        if (source.getPaymentMethod() != null && !source.getPaymentMethod().isEmpty()) {
            target.setPaymentMethod(source.getPaymentMethod());
        }
        if (source.getCurrentStatus() != null && !source.getCurrentStatus().isEmpty()) {
            target.setCurrentStatus(source.getCurrentStatus());
        }
        if (source.getMerchantNumber() != null && !source.getMerchantNumber().isEmpty()) {
            target.setMerchantNumber(source.getMerchantNumber());
        }
        if (source.getRemarks() != null && !source.getRemarks().isEmpty()) {
            target.setRemarks(source.getRemarks());
        }
    }

    /**
     * 根据订单号删除交易 (若成功则返回true)
     * @param orderNumber
     */
    @Override
    public boolean deleteTransaction(String orderNumber) throws Exception {
        boolean result = csvTransactionDao.deleteTransaction(CSV_PATH, orderNumber);
        if (!result) {
            throw new Exception("未找到交易单号: " + orderNumber); // 或记录日志
        }
        cache.invalidate("transactions");
        return result;
    }

    /**
     * 按照查询条件查询交易信息
     * @param searchCriteria
     * @return
     */
    @Override
    public List<Transaction> searchTransaction(Transaction searchCriteria) {
        try {
            // 1. 读取所有交易记录 首先读取caffeine
            List<Transaction> allTransactions = getAllTransactions();

            // 2. 动态模糊匹配
            List<Transaction> matched = new ArrayList<>();
            for (Transaction t : allTransactions) {
                if (matchesCriteria(t, searchCriteria)) {
                    matched.add(t);
                }
            }

            // 3. 按交易时间倒序排序
            matched.sort((t1, t2) -> compareTransactionTime(t2.getTransactionTime(), t1.getTransactionTime()));

            return matched;
        } catch (IOException e) {
            e.printStackTrace();
            return List.of(); // 实际应用中应处理异常
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * 辅助方法:判断单个交易记录是否匹配条件
     * @param transaction
     * @param criteria
     * @return
     */
    private boolean matchesCriteria(Transaction transaction, Transaction criteria) {
        return (criteria.getTransactionTime() == null || containsIgnoreCase(transaction.getTransactionTime(), criteria.getTransactionTime()))
                && (criteria.getTransactionType() == null || containsIgnoreCase(transaction.getTransactionType(), criteria.getTransactionType()))
                && (criteria.getCounterparty() == null || containsIgnoreCase(transaction.getCounterparty(), criteria.getCounterparty()))
                && (criteria.getCommodity() == null || containsIgnoreCase(transaction.getCommodity(), criteria.getCommodity()))
                && (criteria.getInOut() == null || containsIgnoreCase(transaction.getInOut(), criteria.getInOut()))
                && (criteria.getPaymentMethod() == null || containsIgnoreCase(transaction.getPaymentMethod(), criteria.getPaymentMethod()));
    }

    /**
     * 辅助方法：字符串模糊匹配（空条件视为匹配）
     * @param source
     * @param target
     * @return
     */
    private boolean containsIgnoreCase(String source, String target) {
        if (target == null || target.trim().isEmpty()) return true; // 空条件不参与筛选
        if (source == null) return false;
        return source.toLowerCase().contains(target.toLowerCase().trim());
    }

    /**
     * 辅助方法：安全的时间比较（处理 null 值）
     * @param time1
     * @param time2
     * @return
     */
    private int compareTransactionTime(String time1, String time2) {
        if (time1 == null && time2 == null) return 0;
        if (time1 == null) return -1;
        if (time2 == null) return 1;
        return time2.compareTo(time1); // 倒序排序
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\TransactionService.java`:

```java
package Service;

import model.Transaction;

import java.io.IOException;
import java.util.List;

public interface TransactionService {

    /**
     * 新增交易
     * @param transaction
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * 修改交易
     * @param transaction
     */
    void changeTransaction(Transaction transaction) throws Exception;

    /**
     * 根据订单号删除交易
     * @param orderNumber
     */
    boolean deleteTransaction(String orderNumber) throws Exception;

    /**
     * 根据用户输入信息查询交易
     * @param transaction
     * @return
     */
    List<Transaction> searchTransaction(Transaction transaction);

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\deepseek\ChatCompletionsExample.java`:

```java
package Service.deepseek;

import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;
import okhttp3.ConnectionPool;
import okhttp3.Dispatcher;
import org.apache.commons.lang.StringUtils;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
public class ChatCompletionsExample {
    static String apiKey = System.getenv("ARK_API_KEY");
    static ConnectionPool connectionPool = new ConnectionPool(5, 1, TimeUnit.SECONDS);
    static Dispatcher dispatcher = new Dispatcher();
    // The output time of the reasoning model is relatively long. Please increase the timeout period.//
    static ArkService service = ArkService.builder().timeout(Duration.ofSeconds(1800)).connectTimeout(Duration.ofSeconds(20)).dispatcher(dispatcher).connectionPool(connectionPool).baseUrl("https://ark.cn-beijing.volces.com/api/v3").apiKey(apiKey).build();

//    public static void main(String[] args) {
//        System.out.println(" [Recommended]----- streaming request -----");
//        final List<ChatMessage> streamMessages = new ArrayList<>();
//        final ChatMessage streamUserMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("请回答15.11和15.9哪个大？").build();
//        streamMessages.add(streamUserMessage);
//        ChatCompletionRequest streamChatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(streamMessages)
//                .build();
//        service.streamChatCompletion(streamChatCompletionRequest)
//                .doOnError(Throwable::printStackTrace)
//                .blockingForEach(
//                        delta -> {
//                            if (!delta.getChoices().isEmpty()) {
//                                if (StringUtils.isNotEmpty(delta.getChoices().get(0).getMessage().getReasoningContent())) {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getReasoningContent());
//                                } else {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getContent());
//                                }
//                            }
//                        }
//                );
//        System.out.println(" ----- standard request -----");
//        final List<ChatMessage> messages = new ArrayList<>();
//        final ChatMessage userMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("常见的十字花科植物有哪些？").build();
//        messages.add(userMessage);
//        ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(messages)
//                .build();
//        service.createChatCompletion(chatCompletionRequest).getChoices().forEach(
//                choice -> {
//                    System.out.println(choice.getMessage().getReasoningContent());
//                    System.out.println(choice.getMessage().getContent());
//                }
//        );
//        // shutdown service after all requests is finished
//        service.shutdownExecutor();
//    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Utils\CacheUtil.java`:

```java
package Utils;

import com.github.benmanes.caffeine.cache.*;

import java.util.concurrent.TimeUnit;
import java.util.function.Function;

import com.github.benmanes.caffeine.cache.Caffeine;

/**
 * 通用缓存工具类（支持泛型和异常传播）
 * @param <K> 键类型
 * @param <V> 值类型
 * @param <E> 异常类型（如 IOException）
 */
public class CacheUtil<K, V, E extends Exception> {
    private final LoadingCache<K, V> cache;

    public CacheUtil(Function<K, V> loader,
                     int maxSize,
                     long expireAfterWrite,
                     long refreshAfterWrite) {

        this.cache = Caffeine.newBuilder()
                .maximumSize(maxSize)
                .expireAfterWrite(expireAfterWrite, TimeUnit.MINUTES)
                .refreshAfterWrite(refreshAfterWrite, TimeUnit.MINUTES)
                .build(loader::apply); // 关键修改：使用build(loader)创建LoadingCache
    }

    /**
     * 获取缓存值
     */
    public V get(K key) {
        return cache.get(key);
    }

    /**
     * 手动更新缓存
     */
    public void put(K key, V value) {
        cache.put(key, value);
    }

    /**
     * 手动移除缓存
     */
    public void invalidate(K key) {
        cache.invalidate(key);
    }
}



```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\model\Transaction.java`:

```java
package model;
//Transaction time, transaction type, transaction counterparty,
// commodity receipt/payment amount (yuan), payment method, current status,
// transaction order number, merchant order number, remarks
public class Transaction {
    private String transactionTime;
    private String transactionType;
    private String counterparty;
    private String commodity;
    private String inOut;
    private double paymentAmount;
    private String paymentMethod;
    private String currentStatus;
    private String orderNumber;
    private String merchantNumber;
    private String remarks;

    public Transaction() {
    }

    public Transaction(String transactionTime, String transactionType, String counterparty, String commodity, String inOut, double paymentAmount, String paymentMethod, String currentStatus, String orderNumber, String merchantNumber, String remarks) {
        this.transactionTime = transactionTime;
        this.transactionType = transactionType;
        this.counterparty = counterparty;
        this.commodity = commodity;
        this.inOut = inOut;
        this.paymentAmount = paymentAmount;
        this.paymentMethod = paymentMethod;
        this.currentStatus = currentStatus;
        this.orderNumber = orderNumber;
        this.merchantNumber = merchantNumber;
        this.remarks = remarks;
    }

    public String getInOut() {
        return inOut;
    }

    public void setInOut(String inOut) {
        this.inOut = inOut;
    }

    public void setTransactionTime(String transactionTime) {
        this.transactionTime = transactionTime;
    }

    public void setTransactionType(String transactionType) {
        this.transactionType = transactionType;
    }

    public void setCounterparty(String counterparty) {
        this.counterparty = counterparty;
    }

    public void setCommodity(String commodity) {
        this.commodity = commodity;
    }

    public void setPaymentAmount(double paymentAmount) {
        this.paymentAmount = paymentAmount;
    }

    public void setPaymentMethod(String paymentMethod) {
        this.paymentMethod = paymentMethod;
    }

    public void setCurrentStatus(String currentStatus) {
        this.currentStatus = currentStatus;
    }

    public void setOrderNumber(String orderNumbe) {
        this.orderNumber = orderNumbe;
    }

    public void setMerchantNumber(String merchantNumber) {
        this.merchantNumber = merchantNumber;
    }

    public void setRemarks(String remarks) {
        this.remarks = remarks;
    }

    public String getTransactionTime() {
        return transactionTime;
    }

    public String getTransactionType() {
        return transactionType;
    }

    public String getCounterparty() {
        return counterparty;
    }

    public String getCommodity() {
        return commodity;
    }

    public double getPaymentAmount() {
        return paymentAmount;
    }

    public String getPaymentMethod() {
        return paymentMethod;
    }

    public String getCurrentStatus() {
        return currentStatus;
    }

    public String getOrderNumber() {
        return orderNumber;
    }

    public String getMerchantNumber() {
        return merchantNumber;
    }

    public String getRemarks() {
        return remarks;
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\ControllerTest\AITest.java`:

```java
package ControllerTest;

import Controller.HistogramPanelContainer;
import org.junit.Test;

import javax.swing.*;
import java.awt.*;

public class AITest {

    @Test
    public void testHistogramPanel() throws Exception {
        EventQueue.invokeAndWait(() -> {
            JFrame frame = new JFrame("数据分析界面 - 测试");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });




        // 保持窗口显示一段时间，防止测试结束时窗口立即关闭
        Thread.sleep(5000);
    }

}




```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\ControllerTest\MenuUITest.java`:

```java
package ControllerTest;

import Controller.HistogramExample;
import Controller.HistogramPanelContainer;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.io.IOException;
import Controller.MenuUI;

import Service.Impl.TransactionServiceImpl;

import Service.Impl.TransactionServiceImpl;

import DAO.Impl.CsvTransactionDao;

public class MenuUITest {

    private MenuUI menuUI;

    @BeforeEach
    public void setUp() {
        menuUI = new MenuUI();

        // 手动初始化 TransactionServiceImpl 的 csvTransactionDao
        TransactionServiceImpl.csvTransactionDao = new CsvTransactionDao();
    }

    @Test
    public void testSearchFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取输入字段和搜索按钮
        JTextField transactionTimeField = findTextField(inputPanel, 0);
        JTextField transactionTypeField = findTextField(inputPanel, 1);
        JTextField counterpartyField = findTextField(inputPanel, 2);
        JTextField commodityField = findTextField(inputPanel, 3);
        JComboBox<String> inOutComboBox = findComboBox(inputPanel);
        JTextField paymentMethodField = findTextField(inputPanel, 4);
        JButton searchButton = findButton(inputPanel,"Search");

        assertNotNull(transactionTimeField, "交易时间输入字段不应为空");
        assertNotNull(transactionTypeField, "交易类型输入字段不应为空");
        assertNotNull(counterpartyField, "交易对方输入字段不应为空");
        assertNotNull(commodityField, "商品输入字段不应为空");
        assertNotNull(inOutComboBox, "收/支下拉框不应为空");
        assertNotNull(paymentMethodField, "支付方式输入字段不应为空");
        assertNotNull(searchButton, "搜索按钮不应为空");

        // 设置搜索条件
        transactionTimeField.setText("2025/3/14 11:48"); // 交易时间
        transactionTypeField.setText("商户消费");       // 交易类型
        counterpartyField.setText("物美WUMART");         // 交易对方
        commodityField.setText("扫码支付");            // 商品
        inOutComboBox.setSelectedItem("支出");     // 收/支
        paymentMethodField.setText("零钱");    // 支付方式

        // 模拟点击搜索按钮
        searchButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证搜索结果是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);

            // 验证每一行数据是否符合搜索条件
            assertTrue(rowTransactionTime.contains("2025/3/14 11:48"), "交易时间应符合搜索条件");
            assertTrue(rowTransactionType.contains("商户消费"), "交易类型应符合搜索条件");
            assertTrue(rowCounterparty.contains("物美WUMART"), "交易对方应符合搜索条件");
            assertTrue(rowCommodity.contains("扫码支付"), "商品应符合搜索条件");
            assertTrue(rowInOut.contains("支出"), "收/支应符合搜索条件");
            assertTrue(rowPaymentMethod.contains("零钱"), "支付方式应符合搜索条件");
        }
    }

    @Test
    public void testDeleteFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 获取初始行数
        int initialRowCount = tableModel.getRowCount();

        // 模拟删除第一行
        menuUI.deleteRow(0);

        // 验证行数是否减少
        assertEquals(initialRowCount - 1, tableModel.getRowCount(), "删除后行数应减少");

        // 验证删除后的数据是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            assertNotEquals("2025/3/14 11:48", rowTransactionTime, "删除的行不应再出现在表格中");
        }
    }

    @Test
    public void testEditFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 模拟编辑第一行
        menuUI.editRow(0);

        // 验证编辑后的数据是否正确
        String editedTransactionTime = (String) tableModel.getValueAt(0, 0);
        String editedTransactionType = (String) tableModel.getValueAt(0, 1);
        String editedCounterparty = (String) tableModel.getValueAt(0, 2);
        String editedCommodity = (String) tableModel.getValueAt(0, 3);
        String editedInOut = (String) tableModel.getValueAt(0, 4);
        String editedPaymentMethod = (String) tableModel.getValueAt(0, 6);

        // 验证编辑后的数据是否符合预期
        assertNotNull(editedTransactionTime, "编辑后的交易时间不应为空");
        assertNotNull(editedTransactionType, "编辑后的交易类型不应为空");
        assertNotNull(editedCounterparty, "编辑后的交易对方不应为空");
        assertNotNull(editedCommodity, "编辑后的商品不应为空");
        assertNotNull(editedInOut, "编辑后的收/支不应为空");
        assertNotNull(editedPaymentMethod, "编辑后的支付方式不应为空");
    }

    @Test
    public void testAddFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取 Add 按钮
        JButton addButton = findButton(inputPanel, "Add");
        assertNotNull(addButton, "Add 按钮不应为空");

        // 模拟点击 Add 按钮
        addButton.doClick();

        // 获取对话框
        Window[] windows = Window.getWindows();
        JDialog addDialog = null;
        for (Window window : windows) {
            if (window instanceof JDialog && "添加交易".equals(((JDialog) window).getTitle())) {
                addDialog = (JDialog) window;
                break;
            }
        }
        assertNotNull(addDialog, "添加交易的对话框应弹出");

        // 获取对话框中的输入字段
        JTextField transactionTimeField = findTextField(addDialog.getContentPane(), 0);
        JTextField transactionTypeField = findTextField(addDialog.getContentPane(), 1);
        JTextField counterpartyField = findTextField(addDialog.getContentPane(), 2);
        JTextField commodityField = findTextField(addDialog.getContentPane(), 3);
        JComboBox<String> inOutComboBox = findComboBox(addDialog.getContentPane());
        JTextField paymentAmountField = findTextField(addDialog.getContentPane(), 4);
        JTextField paymentMethodField = findTextField(addDialog.getContentPane(), 5);
        JTextField currentStatusField = findTextField(addDialog.getContentPane(), 6);
        JTextField orderNumberField = findTextField(addDialog.getContentPane(), 7);
        JTextField merchantNumberField = findTextField(addDialog.getContentPane(), 8);
        JTextField remarksField = findTextField(addDialog.getContentPane(), 9);

        // 设置新交易的输入值
        transactionTimeField.setText("2025/3/15 12:00"); // 交易时间
        transactionTypeField.setText("转账");            // 交易类型
        counterpartyField.setText("张三");               // 交易对方
        commodityField.setText("转账");                 // 商品
        inOutComboBox.setSelectedItem("支出");          // 收/支
        paymentAmountField.setText("100.0");            // 金额(元)
        paymentMethodField.setText("银行卡");           // 支付方式
        currentStatusField.setText("已完成");           // 当前状态
        orderNumberField.setText("123456789");          // 交易单号
        merchantNumberField.setText("987654321");       // 商户单号
        remarksField.setText("测试备注");               // 备注

        // 获取确认按钮
        JButton confirmButton = findButton(addDialog.getContentPane(), "确认");
        assertNotNull(confirmButton, "确认按钮不应为空");

        // 模拟点击确认按钮
        confirmButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证新交易是否添加到表格中
        boolean isTransactionAdded = false;
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentAmount = (String) tableModel.getValueAt(i, 5);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);
            String rowCurrentStatus = (String) tableModel.getValueAt(i, 7);
            String rowOrderNumber = (String) tableModel.getValueAt(i, 8);
            String rowMerchantNumber = (String) tableModel.getValueAt(i, 9);
            String rowRemarks = (String) tableModel.getValueAt(i, 10);

            if (rowTransactionTime.equals("2025/3/15 12:00") &&
                    rowTransactionType.equals("转账") &&
                    rowCounterparty.equals("张三") &&
                    rowCommodity.equals("转账") &&
                    rowInOut.equals("支出") &&
                    rowPaymentAmount.equals("100.0") &&
                    rowPaymentMethod.equals("银行卡") &&
                    rowCurrentStatus.equals("已完成") &&
                    rowOrderNumber.equals("123456789") &&
                    rowMerchantNumber.equals("987654321") &&
                    rowRemarks.equals("测试备注")) {
                isTransactionAdded = true;
                break;
            }
        }

        // 验证新交易是否成功添加
        assertTrue(isTransactionAdded, "新交易应成功添加到表格中");
    }

    /**
     * 显示界面以便手动验证
     *
     * @param panel 要显示的面板
     */
    private void showUI(JPanel panel) {
        JFrame frame = new JFrame("MenuUI Test");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(1200, 600);
        frame.add(panel);
        frame.setVisible(true);

        // 保持界面显示一段时间（5秒）
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        frame.dispose(); // 关闭界面
    }

    /**
     * 查找输入面板
     *
     * @param mainPanel 主面板
     * @return 输入面板
     */
    private JPanel findInputPanel(JPanel mainPanel) {
        // 获取右边的面板
        Component[] components = mainPanel.getComponents();
        JPanel rightPanel = null;
        for (Component component : components) {
            if (component instanceof JPanel && ((JPanel) component).getComponentCount() > 0) {
                rightPanel = (JPanel) component;
                break;
            }
        }

        if (rightPanel != null) {
            // 在右边面板中查找输入面板
            for (Component component : rightPanel.getComponents()) {
                if (component instanceof JPanel) {
                    JPanel panel = (JPanel) component;
                    System.out.println("Panel found: " + panel.getName()); // 打印面板名称
                    if (panel.getComponentCount() > 0 && panel.getComponent(0) instanceof JLabel) {
                        return panel; // 输入面板通常包含 JLabel
                    }
                }
            }
        }
        return null;
    }

    /**
     * 查找输入字段
     *
     * @param container     输入面板
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0;
        for (Component component : container.getComponents()) {
            if (component instanceof JTextField) {
                if (count == index) {
                    return (JTextField) component;
                }
                count++;
            }
        }
        return null;
    }


    /**
     * 查找下拉框
     *
     * @param container 输入面板
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) {
            if (component instanceof JComboBox) {
                return (JComboBox<String>) component;
            }
        }
        return null;
    }

    /**
     * 查找按钮
     *
     * @param panel 输入面板
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container  容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    private JButton findButton(Container container, String buttonText) {
        for (Component component : container.getComponents()) {
            if (component instanceof JButton) {
                JButton button = (JButton) component;
                if (button.getText().equals(buttonText)) {
                    return button;
                }
            }
        }
        return null;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\DAOTest\CsvTransactionDaoTest.java`:

```java
package DAOTest;

import DAO.Impl.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static Constants.ConfigConstants.CSV_PATH;
import static org.assertj.core.api.Assertions.*;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

class CsvTransactionDaoTest {
    // 测试文件路径（根据实际结构调整）
    private static final String TEST_CSV_PATH = CSV_PATH;
    private static CsvTransactionDao dao;

    @Test
    void testLoadFromCSV_ValidFile_ReturnsTransactions() throws Exception {
        // Given
        CsvTransactionDao dao = new CsvTransactionDao();

        // When
        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);

        // 验证第一条记录的字段
        for (int i = 0; i < transactions.size(); i++) {
            System.out.println(transactions.get(i).getRemarks());
            System.out.println(transactions.get(i).getCommodity());
        }


    }
    @Test
    void testAddTransaction() throws IOException {
        dao=new CsvTransactionDao();
        Transaction newTx = new Transaction(
                "2025-03-09 10:00",
                "转账",
                "小明",
                "书籍",
                "支",
                99.99,
                "微信",
                "已完成",
                "TX123456",
                "M789012",
                "");

        dao.addTransaction("src/test/resources/001.csv", newTx);

        List<Transaction> transactions = dao.loadFromCSV(TEST_CSV_PATH);

    }

    @Test
    void testDeleteTransaction() throws IOException {
        dao=new CsvTransactionDao();

        dao.deleteTransaction("CSV_RELATIVE_PATH", "4200057899202502250932735481");

        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);
    }
    @Test
    void testChangeInfo() throws IOException{
        dao=new CsvTransactionDao();
        dao.changeInformation("TX123456","remarks","测试修改信息",TEST_CSV_PATH);
        dao.changeInformation("TX123456","paymentAmount","116156",TEST_CSV_PATH);
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\AIAnalyzerThreadTest.java`:

```java
package Service;



import Service.AIservice.AIAnalyzerThread;
import org.junit.jupiter.api.Test;

public class AIAnalyzerThreadTest {

    @Test
    public void testRunAIAnalyzerThread() throws InterruptedException {
        String userRequest = "请帮我分析最近的交易收支情况";
        String filePath = "src/test/resources/sample_transactions.csv";
        String startTimeStr = "2025/03/20";
        String endTimeStr = "";

        // 启动线程
        Thread thread = new Thread(new AIAnalyzerThread(userRequest, filePath, startTimeStr, endTimeStr));
        thread.start();

        // 等待线程执行完成
        thread.join();
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\AIserviceTest.java`:

```java
package Service;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

public class AIserviceTest {

    @Test
    public void testAnalyzeTransactions() {
        AITransactionService service = new AITransactionService();

        String userRequest = "请帮我分析这个月的收支情况";
        String filePath = "src/test/resources/sample_transactions.csv";

        String result = service.analyzeTransactions(userRequest, filePath,"2025/03/20","");

        assertNotNull(result, "AI分析结果不能为空");
        System.out.println("AI分析结果: " + result);
    }


}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\AiFunctionTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

import java.io.IOException;
import java.util.List;

public class AiFunctionTest {

    @Test
    public void testAnalyzeTransactions() throws IOException {

        String filePath = "src/test/resources/sample_transactions.csv";
        CsvTransactionDao transactionDao = new CsvTransactionDao();

        List<Transaction> transactions = transactionDao.loadFromCSV(filePath);

        // 实例化服务类
        AITransactionService service = new AITransactionService();

        // 调用合并格式化函数
        List<String> result = service.formatTransactions(transactions,"2025/03/29","2025/04/10");

        // 输出结果
        result.forEach(System.out::println);
    }




}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\CacheTest.java`:

```java
package Service;

import Constants.CaffeineKeys;
import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import com.github.benmanes.caffeine.cache.Caffeine;
import model.Transaction;
import org.junit.jupiter.api.Test;

import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;

public class CacheTest {

    TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());

    @Test
    void DeleteCache(){
        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;
        cache.invalidate(TRANSACTION_CAFFEINE_KEY);
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\CollegeStudentNeedsTest.java`:

```java
package Service;

import Service.AIservice.ColledgeStudentThread;
import Service.AIservice.CollegeStudentNeeds;
import org.junit.jupiter.api.*;

import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.*;

// No @ExtendWith needed as we are not using Mockito extensions
class CollegeStudentNeedsTest {



    private CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
    private static final String TEST_CSV_FILENAME = "src/test/resources/001.csv";
    @Test
    public void testGenerateBudget() throws IOException, InterruptedException {
        Thread t=new Thread( new ColledgeStudentThread(TEST_CSV_FILENAME));
        t.start();
        t.join();
//        collegeStudentNeeds.generateBudget(TEST_CSV_FILENAME);
    }
    @Test
    public void testParseStringToDouble(){
        String s="asdas[369.39,1090.1]das";
        double[] arr=collegeStudentNeeds.parseDoubleArrayFromString(s);
        System.out.println(arr[0]+" "+arr[1]);
    }


}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\TransactionServiceTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import model.Transaction;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.io.IOException;
import java.util.List;

class TransactionServiceTest {
    private TransactionService transactionService;

    @BeforeEach
    void setUp() {
        // 初始化 DAO 和 Service
        CsvTransactionDao csvTransactionDao = new CsvTransactionDao();
        transactionService = new TransactionServiceImpl(csvTransactionDao);
    }

    @Test
    void testAddTransaction() throws IOException {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );

        // 执行添加操作
        transactionService.addTransaction(transaction);

        // 验证是否添加成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertFalse(transactions.isEmpty());
        assertEquals("T123456789", transactions.get(0).getOrderNumber());
    }

    @Test
    void testChangeTransaction() throws Exception {
        // 准备测试数据
        Transaction originalTransaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(originalTransaction);

        // 准备更新数据
        Transaction updatedTransaction = new Transaction(
                null, "充值", null, null, null, 0.0, "微信支付", null, "T123456789", null, "更新备注"
        );

        // 执行更新操作
        transactionService.changeTransaction(updatedTransaction);

        // 验证是否更新成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertEquals("充值", transactions.get(0).getTransactionType());
        assertEquals("微信支付", transactions.get(0).getPaymentMethod());
        assertEquals("更新备注", transactions.get(0).getRemarks());
    }

    @Test
    void testDeleteTransaction() throws Exception {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(transaction);

        // 执行删除操作
        boolean result = transactionService.deleteTransaction("T123456789");

        // 验证是否删除成功
        assertTrue(result);
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertTrue(transactions.isEmpty());
    }

    @Test
    void testSearchTransaction() throws IOException {

        // 设置搜索条件
        Transaction searchCriteria = new Transaction();
        searchCriteria.setCounterparty("支付宝");

        // 执行搜索操作
        List<Transaction> result = transactionService.searchTransaction(searchCriteria);

        // 验证搜索结果
        result.forEach(res -> System.out.println(res.getCommodity()));
    }


}
```
```

`软工/Ai-Bill-Application-Group21\README.md`:

```md
## Project Overview
This module is a transaction record management 
system in the Service layer of the project that connects 
with the Dao layer that provides CRUD (Create, Read, Update
, Delete) functionality and data processing for
transaction data. Core features include transaction 
creation, modification, deletion, and flexible querying,
all accessible through standardized interfaces.

## Structure and Function
Swing GUI (Controller) <- Service <- DAO <-data(CSV/JSON)<-model

##  Model 

### Overview

This Java class, located in the `model` package, serves 
as a Plain Old Java Object (POJO) or data model to 
represent a single financial transaction record. It 
encapsulates all the standard details associated with 
a transaction, such as its time, type, amount, parties 
involved, status, and unique identifiers.

This class is typically used in conjunction with Data 
Access Objects (DAOs) like `TransactionDao` and
`CsvTransactionDao` to load, save, and manipulate 
transaction data from a persistent store (e.g., a CSV 
file or database).

### Package

`model`

### Fields

The `Transaction` class contains the following fields:

* `transactionTime` (String): The date and time when the transaction occurred (e.g., "2023-10-27 15:30:00").
* `transactionType` (String): The category or type of the transaction (e.g., "在线支付" - Online Payment, "转账" - Transfer, "退款" - Refund).
* `counterparty` (String): The name or identifier of the other party involved in the transaction.
* `commodity` (String): A description of the goods, service, or reason for the transaction (e.g., "Coffee", "Salary", "Online Course Fee").
* `inOut` (String): Indicates the direction of the money flow relative to the account holder. Typically:
* `paymentAmount` (double): The monetary value of the transaction. The currency unit (e.g., Yuan) is implied by the context where this class is used (often indicated by header names like "金额(元)" in associated CSV files).
* `paymentMethod` (String): The method used for the payment (e.g., "支付宝" - Alipay, "微信支付" - WeChat Pay, "银行卡" - Bank Card, "现金" - Cash).
* `currentStatus` (String): The current processing status of the transaction (e.g., "交易成功" - Transaction Successful, "等待付款" - Awaiting Payment, "已关闭" - Closed, "退款成功" - Refund Successful).
* `orderNumber` (String): A unique identifier assigned to this specific transaction instance by the payment system or application. Often used as a primary key.
* `merchantNumber` (String): An order number or identifier associated with the merchant's system, often provided for reconciliation purposes. May be empty or null if not applicable.
* `remarks` (String): An optional field for any additional notes, comments, or user-provided descriptions about the transaction.

### Constructors

* **`public Transaction()`**
    * Default no-argument constructor. Creates an empty `Transaction` object with all fields initialized to their default values (null for String, 0.0 for double).

* **`public Transaction(String transactionTime, String transactionType, ..., String remarks)`**
    * Parameterized constructor that accepts values for all fields. Allows for quick instantiation of a fully populated `Transaction` object.

### Methods

The class provides standard public **getter** (`get...()`) and **setter** (`set...()`) methods for all its private fields. These methods allow controlled access and modification of the transaction's attributes from other parts of the application.

* `getTransactionTime()` / `setTransactionTime(String time)`
* `getTransactionType()` / `setTransactionType(String type)`
* `getCounterparty()` / `setCounterparty(String counterparty)`
* `getCommodity()` / `setCommodity(String commodity)`
* `getInOut()` / `setInOut(String inOut)`
* `getPaymentAmount()` / `setPaymentAmount(double amount)`
* `getPaymentMethod()` / `setPaymentMethod(String method)`
* `getCurrentStatus()` / `setCurrentStatus(String status)`
* `getOrderNumber()` / `setOrderNumber(String orderNumber)`
* `getMerchantNumber()` / `setMerchantNumber(String merchantNumber)`
* `getRemarks()` / `setRemarks(String remarks)`

 
### Service (Business logic)
- Responsibilities:
Transaction CRUD operations, calling the DAO layer to read and write local files,
User-defined classification logic (e.g. modifying transaction categories)
  (3) Operations:

Add Transaction:

Transaction t = new Transaction();
// Set field values
service.addTransaction(t);

Modify Transaction:

Transaction update = new Transaction();
update.setOrderNumber("ORD123");
// Set fields to update
service.changeTransaction(update);

Query Transactions:

Transaction criteria = new Transaction();
criteria.setCounterparty("Alipay");
List<Transaction> results = service.searchTransaction(criteria);
Code structure
   Directory Layout:
   src/main/java/
   └── Service/
   ├── Impl/
   │   └── TransactionServiceImpl.java  # Service implementation
   └── TransactionService.java          # Service interface
   TransactionService.java:
   Defines the service interface with business-agnostic method signatures, enforcing decoupling 
   between business logic and implementation details.
   TransactionServiceImpl.java:
   Implements the concrete business logic while depending only on the interface-defined contract, maintaining loose coupling with the data access layer through dependency injection.


- AIService (Intelligent Analytics) Responsibilities: Generate budget recommendations based
on historical data, and detect cost-cutting recommendations for seasonal spending in China
(e.g. Spring Festival) (e.g. marking high-frequency small spending)


- **`AITransactionService`**

The central class that performs the full AI-driven transaction analysis. It:

- Loads transaction data from a CSV file via `CsvTransactionDao`.
- Filters transactions by user-specified time range (`startTimeStr`, `endTimeStr`).
- Aggregates data by counterparty (income/spending, transaction counts).
- Formats the result into concise summaries sent to the AI.
- Sends user questions and formatted data to the Volcengine Ark AI API.
- Returns a response within **400 characters** for efficient display.

Key methods:
- `analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr)`
  → Returns an AI-generated analysis result string.
- `runAiInThread(...)`
  → Runs the AI logic in a background thread (single-threaded executor).
- `formatTransactions(...)`
  → Groups transactions and summarizes them by counterparty and time range.
- `parseDateTime(...)`
  → Supports flexible input formats like `yyyy/MM/dd`, `yyyy/MM/dd HH:mm`, and more. - **`AIAnalyzerThread`** A `Runnable` implementation for threading scenarios (especially GUI usage). It calls `AITransactionService.analyzeTransactions(...)` and prints the result. UI developers can replace the console output with GUI updates using `SwingUtilities.invokeLater()`. --- ### Tests (`test/java/Service/AIservice/`) - **`AIserviceTest`** Unit tests for `AITransactionService`, verifying: - Correct loading and filtering of transactions. - Accurate AI response generation and formatting. - Graceful handling of edge cases (e.g., no transactions in range, invalid time formats). - **`AIAnalyzerThreadTest`** Validates threading logic: - Ensures `AIAnalyzerThread` executes `Runnable` correctly. - Demonstrates clean and concurrent AI analysis flow. - Simulates integration with a GUI environment. - **`AiFunctionTest`** Utility-level tests: - Ensures proper CSV parsing and data transformation. - Verifies output formatting before sending to the AI. - Tests various time formats and edge case behaviors

## DAO (File Storage)
- Responsibilities: Save transaction data in CSV or JSON format and provide interfaces for adding,
  deleting, and modifying in-memory data
### CsvTransactionDao Class

#### Package

`DAO`

#### Dependencies

* **`model.Transaction`**: The data model class representing a single transaction.
* **`DAO.TransactionDao`**: The interface this class is intended to implement (though the implementation is incomplete).
* **Apache Commons CSV (`org.apache.commons.csv.*`)**: Used for robust parsing and writing of CSV data.
* **Apache Commons IO (`org.apache.commons.io.input.BOMInputStream`)**: Used specifically to handle potential Byte Order Marks (BOM) often found in UTF-8 encoded files, particularly those edited in Windows.
* **Java Standard Libraries**: `java.io.*`, `java.nio.*`.

#### Key Features & Implementation Details

* **CSV Loading (`loadFromCSV`)**:
  * Reads data from a specified CSV file path.
  * Expects UTF-8 encoding.
  * Handles potential Byte Order Mark (BOM) at the beginning of the file.
  * Uses the first row of the CSV as the header to map columns to `Transaction` fields. Assumes specific header names (e.g., "交易时间", "交易类型", "金额(元)").
  * Parses transaction records into a `List<Transaction>`.
  * Includes basic caching using an internal `transactions` list and an `isLoad` flag to avoid redundant file reads within the same instance lifecycle (unless forced by methods like `deleteTransaction` or `changeInformation`).
* **Record Parsing (`parseRecord`)**:
  * Converts a `CSVRecord` object (from Apache Commons CSV) into a `Transaction` object.
  * Specifically handles the "金额(元)" (Amount) field by removing the leading "¥" symbol before parsing it as a `double`.
* **Adding Transactions (`addTransaction(String filePath, Transaction newTransaction)`)**:
  * **Appends** a new transaction record to the *end* of the specified CSV file.
  * Creates the file if it doesn't exist.
  * Writes the header row only if the file is new or was empty.
  * Formats the payment amount by prepending "¥".
* **Deleting Transactions (`deleteTransaction(String filePath, String orderNumber)`)**:
  * Loads data from the file if not already cached.
  * Filters the cached list to remove the transaction matching the given `orderNumber`.
  * **Overwrites** the *entire* original CSV file with the filtered list using `writeTransactionsToCSV`.
  * Returns `true` if a transaction was removed, `false` otherwise.
* **Updating Transactions (`changeInformation`)**:
  * Loads data if not already cached.
  * Finds the transaction by `orderNumber`.
  * Modifies the specified field (`head`) of the found transaction object in memory.
  * **Crucially, it attempts the update by first *deleting* the original record (using `deleteTransaction`, which overwrites the file) and then *adding* the modified record (using `addTransaction`, which appends to the file).** This logic is inefficient and potentially problematic due to the conflicting file write strategies (overwrite vs. append).
  * Error handling for invalid `head` parameters prints to `System.err`. The method often returns `true` even if the underlying delete/add fails.
* **CSV Writing (`writeTransactionsToCSV`)**:
  * Helper method used by `deleteTransaction`.
  * Writes a given `List<Transaction>` to the specified file path, **overwriting** any existing content.
  * Writes a standard header row.
  * Formats the payment amount by prepending "¥".

#### Important Issues & Considerations

1.  **Incomplete `TransactionDao` Implementation**: The methods declared in the `TransactionDao` interface (`getAllTransactions`, `addTransaction(Transaction)`, `deleteTransaction(String)`, `updateTransaction`, `getTransactionByOrderNumber`) are present but contain only placeholder/stub code. The actual working logic uses separate methods that require the `filePath` to be passed explicitly each time. **This class, in its current state, does not correctly function as a `TransactionDao` implementation.**
2.  **Inconsistent File Writing Strategy**: `addTransaction` *appends* to the file, while `deleteTransaction` and `writeTransactionsToCSV` (used by `deleteTransaction` and `changeInformation`) *overwrite* the entire file. This inconsistency can lead to unexpected behavior, especially within the `changeInformation` method.
3.  **Inefficient Updates/Deletes**: Rewriting the entire CSV file for every single deletion or modification (`changeInformation`) is highly inefficient, especially for large transaction files.
4.  **Flawed Update Logic (`changeInformation`)**: The delete-then-add approach for updates is problematic due to the inconsistent write strategies and potential race conditions or partial failures. The modified record will likely appear at the *end* of the file, not its original position.
5.  **Basic Caching**: The caching mechanism (`isLoad` flag) is simple and does not account for external modifications to the CSV file during the application's runtime.
6.  **Hardcoded Dependencies**: The code relies on specific header names (in Chinese) and the "¥" currency symbol format within the CSV data. Changes to the CSV format would require code modifications.

#### Usage Example (Using Functional Methods)

```java
import DAO.Impl.CsvTransactionDao; // Assuming TransactionDao interface exists but is not used directly here due to stub methods
import model.Transaction;
import java.io.IOException;
import java.util.List;

public class CsvDataManager {

    public static void main(String[] args) {
        // NOTE: Using the class directly, not via the TransactionDao interface
        // because the interface methods are not fully implemented.
        CsvTransactionDao csvDao = new CsvTransactionDao();
        String csvFilePath = "path/to/your/transactions.csv"; // <--- Specify your file path

        try {
            // --- Load Data ---
            System.out.println("Loading transactions...");
            List<Transaction> transactions = csvDao.loadFromCSV(csvFilePath);
            System.out.println("Loaded " + transactions.size() + " transactions.");
            // Display first transaction if available
            if (!transactions.isEmpty()) {
                 System.out.println("First transaction order number: " + transactions.get(0).getOrderNumber());
            }

            // --- Add a New Transaction (Appends) ---
            Transaction newTx = new Transaction(
                 "2025-04-20 08:14:00", "Test Add", "Counterparty", "Item", "支",
                 10.0, "支付宝", "交易成功", "NEW_ORDER_123", "MERCH_456", "Test via DAO add"
            );
            System.out.println("\nAdding new transaction (append): " + newTx.getOrderNumber());
            // csvDao.addTransaction(csvFilePath, newTx); // Uncomment to actually add
            System.out.println("Transaction potentially added.");

            // --- Delete a Transaction (Overwrites File) ---
            String orderToDelete = "SOME_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number from your file
            System.out.println("\nAttempting to delete transaction: " + orderToDelete);
            // boolean deleted = csvDao.deleteTransaction(csvFilePath, orderToDelete); // Uncomment to actually delete
            // if (deleted) {
            //     System.out.println("Transaction deleted successfully (File rewritten).");
            // } else {
            //     System.out.println("Transaction not found for deletion.");
            // }

            // --- Change Information (Overwrites then Appends - Use with Caution) ---
             String orderToChange = "ANOTHER_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number
             String fieldToChange = "remarks";
             String newValue = "Updated remark via changeInformation";
             System.out.println("\nAttempting to change info for: " + orderToChange);
             // boolean changed = csvDao.changeInformation(orderToChange, fieldToChange, newValue, csvFilePath); // Uncomment with caution
             // System.out.println("Change operation attempted (File rewritten and appended). Result: " + changed);


        } catch (IOException e) {
            System.err.println("Error interacting with CSV file: " + e.getMessage());
            e.printStackTrace();
        } catch (NumberFormatException e) {
            System.err.println("Error parsing amount in CSV: " + e.getMessage());
        }
    }
}
```

## Controller (Swing GUI)

Responsibilities: Manage user interface components (buttons, tables, text boxes) to listen for 
events (clicks, inputs) and call service layer methods to update the interface data display

## attention
encoding with UTF-8

```

`软工/Ai-Bill-Application-Group21\README.txt`:

```txt
## Project Overview

This module is a transaction record management 
system in the Service layer of the project that connects 
with the Dao layer that provides CRUD (Create, Read, Update
, Delete) functionality and data processing for
transaction data. Core features include transaction 
creation, modification, deletion, and flexible querying,
all accessible through standardized interfaces.

## Structure and Function

Swing GUI (Controller) <- Service <- DAO <-data(CSV/JSON)<-model

##  Model 

### Overview

This Java class, located in the `model` package, serves 
as a Plain Old Java Object (POJO) or data model to 
represent a single financial transaction record. It 
encapsulates all the standard details associated with 
a transaction, such as its time, type, amount, parties 
involved, status, and unique identifiers.

This class is typically used in conjunction with Data 
Access Objects (DAOs) like `TransactionDao` and
`CsvTransactionDao` to load, save, and manipulate 
transaction data from a persistent store (e.g., a CSV 
file or database).

### Package

`model`

### Fields

The `Transaction` class contains the following fields:

* `transactionTime` (String): The date and time when the transaction occurred (e.g., "2023-10-27 15:30:00").
* `transactionType` (String): The category or type of the transaction (e.g., "在线支付" - Online Payment, "转账" - Transfer, "退款" - Refund).
* `counterparty` (String): The name or identifier of the other party involved in the transaction.
* `commodity` (String): A description of the goods, service, or reason for the transaction (e.g., "Coffee", "Salary", "Online Course Fee").
* `inOut` (String): Indicates the direction of the money flow relative to the account holder. Typically:
* `paymentAmount` (double): The monetary value of the transaction. The currency unit (e.g., Yuan) is implied by the context where this class is used (often indicated by header names like "金额(元)" in associated CSV files).
* `paymentMethod` (String): The method used for the payment (e.g., "支付宝" - Alipay, "微信支付" - WeChat Pay, "银行卡" - Bank Card, "现金" - Cash).
* `currentStatus` (String): The current processing status of the transaction (e.g., "交易成功" - Transaction Successful, "等待付款" - Awaiting Payment, "已关闭" - Closed, "退款成功" - Refund Successful).
* `orderNumber` (String): A unique identifier assigned to this specific transaction instance by the payment system or application. Often used as a primary key.
* `merchantNumber` (String): An order number or identifier associated with the merchant's system, often provided for reconciliation purposes. May be empty or null if not applicable.
* `remarks` (String): An optional field for any additional notes, comments, or user-provided descriptions about the transaction.

### Constructors

* **`public Transaction()`**
  * Default no-argument constructor. Creates an empty `Transaction` object with all fields initialized to their default values (null for String, 0.0 for double).

* **`public Transaction(String transactionTime, String transactionType, ..., String remarks)`**
  * Parameterized constructor that accepts values for all fields. Allows for quick instantiation of a fully populated `Transaction` object.

### Methods

The class provides standard public **getter** (`get...()`) and **setter** (`set...()`) methods for all its private fields. These methods allow controlled access and modification of the transaction's attributes from other parts of the application.

* `getTransactionTime()` / `setTransactionTime(String time)`
* `getTransactionType()` / `setTransactionType(String type)`
* `getCounterparty()` / `setCounterparty(String counterparty)`
* `getCommodity()` / `setCommodity(String commodity)`
* `getInOut()` / `setInOut(String inOut)`
* `getPaymentAmount()` / `setPaymentAmount(double amount)`
* `getPaymentMethod()` / `setPaymentMethod(String method)`
* `getCurrentStatus()` / `setCurrentStatus(String status)`
* `getOrderNumber()` / `setOrderNumber(String orderNumber)`
* `getMerchantNumber()` / `setMerchantNumber(String merchantNumber)`
* `getRemarks()` / `setRemarks(String remarks)`


### Service (Business logic)

- Responsibilities:
  Transaction CRUD operations, calling the DAO layer to read and write local files,
  User-defined classification logic (e.g. modifying transaction categories)
  (3) Operations:

Add Transaction:

Transaction t = new Transaction();
// Set field values
service.addTransaction(t);

Modify Transaction:

Transaction update = new Transaction();
update.setOrderNumber("ORD123");
// Set fields to update
service.changeTransaction(update);

Query Transactions:

Transaction criteria = new Transaction();
criteria.setCounterparty("Alipay");
List<Transaction> results = service.searchTransaction(criteria);
Code structure
   Directory Layout:
   src/main/java/
   └── Service/
   ├── Impl/
   │   └── TransactionServiceImpl.java  # Service implementation
   └── TransactionService.java          # Service interface
   TransactionService.java:
   Defines the service interface with business-agnostic method signatures, enforcing decoupling 
   between business logic and implementation details.
   TransactionServiceImpl.java:
   Implements the concrete business logic while depending only on the interface-defined contract, maintaining loose coupling with the data access layer through dependency injection.


- AIService (Intelligent Analytics) Responsibilities: Generate budget recommendations based
  on historical data, and detect cost-cutting recommendations for seasonal spending in China
  (e.g. Spring Festival) (e.g. marking high-frequency small spending)


- **`AITransactionService`**

The central class that performs the full AI-driven transaction analysis. It:

- Loads transaction data from a CSV file via `CsvTransactionDao`.
- Filters transactions by user-specified time range (`startTimeStr`, `endTimeStr`).
- Aggregates data by counterparty (income/spending, transaction counts).
- Formats the result into concise summaries sent to the AI.
- Sends user questions and formatted data to the Volcengine Ark AI API.
- Returns a response within **400 characters** for efficient display.

Key methods:

- `analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr)`
  → Returns an AI-generated analysis result string.
- `runAiInThread(...)`
  → Runs the AI logic in a background thread (single-threaded executor).
- `formatTransactions(...)`
  → Groups transactions and summarizes them by counterparty and time range.
- `parseDateTime(...)`
  → Supports flexible input formats like `yyyy/MM/dd`, `yyyy/MM/dd HH:mm`, and more. - **`AIAnalyzerThread`** A `Runnable` implementation for threading scenarios (especially GUI usage). It calls `AITransactionService.analyzeTransactions(...)` and prints the result. UI developers can replace the console output with GUI updates using `SwingUtilities.invokeLater()`. --- ### Tests (`test/java/Service/AIservice/`) - **`AIserviceTest`** Unit tests for `AITransactionService`, verifying: - Correct loading and filtering of transactions. - Accurate AI response generation and formatting. - Graceful handling of edge cases (e.g., no transactions in range, invalid time formats). - **`AIAnalyzerThreadTest`** Validates threading logic: - Ensures `AIAnalyzerThread` executes `Runnable` correctly. - Demonstrates clean and concurrent AI analysis flow. - Simulates integration with a GUI environment. - **`AiFunctionTest`** Utility-level tests: - Ensures proper CSV parsing and data transformation. - Verifies output formatting before sending to the AI. - Tests various time formats and edge case behaviors

## DAO (File Storage)

- Responsibilities: Save transaction data in CSV or JSON format and provide interfaces for adding,
  deleting, and modifying in-memory data

### CsvTransactionDao Class

#### Package

`DAO`

#### Dependencies

* **`model.Transaction`**: The data model class representing a single transaction.
* **`DAO.TransactionDao`**: The interface this class is intended to implement (though the implementation is incomplete).
* **Apache Commons CSV (`org.apache.commons.csv.*`)**: Used for robust parsing and writing of CSV data.
* **Apache Commons IO (`org.apache.commons.io.input.BOMInputStream`)**: Used specifically to handle potential Byte Order Marks (BOM) often found in UTF-8 encoded files, particularly those edited in Windows.
* **Java Standard Libraries**: `java.io.*`, `java.nio.*`.

#### Key Features & Implementation Details

* **CSV Loading (`loadFromCSV`)**:
  * Reads data from a specified CSV file path.
  * Expects UTF-8 encoding.
  * Handles potential Byte Order Mark (BOM) at the beginning of the file.
  * Uses the first row of the CSV as the header to map columns to `Transaction` fields. Assumes specific header names (e.g., "交易时间", "交易类型", "金额(元)").
  * Parses transaction records into a `List<Transaction>`.
  * Includes basic caching using an internal `transactions` list and an `isLoad` flag to avoid redundant file reads within the same instance lifecycle (unless forced by methods like `deleteTransaction` or `changeInformation`).
* **Record Parsing (`parseRecord`)**:
  * Converts a `CSVRecord` object (from Apache Commons CSV) into a `Transaction` object.
  * Specifically handles the "金额(元)" (Amount) field by removing the leading "¥" symbol before parsing it as a `double`.
* **Adding Transactions (`addTransaction(String filePath, Transaction newTransaction)`)**:
  * **Appends** a new transaction record to the *end* of the specified CSV file.
  * Creates the file if it doesn't exist.
  * Writes the header row only if the file is new or was empty.
  * Formats the payment amount by prepending "¥".
* **Deleting Transactions (`deleteTransaction(String filePath, String orderNumber)`)**:
  * Loads data from the file if not already cached.
  * Filters the cached list to remove the transaction matching the given `orderNumber`.
  * **Overwrites** the *entire* original CSV file with the filtered list using `writeTransactionsToCSV`.
  * Returns `true` if a transaction was removed, `false` otherwise.
* **Updating Transactions (`changeInformation`)**:
  * Loads data if not already cached.
  * Finds the transaction by `orderNumber`.
  * Modifies the specified field (`head`) of the found transaction object in memory.
  * **Crucially, it attempts the update by first *deleting* the original record (using `deleteTransaction`, which overwrites the file) and then *adding* the modified record (using `addTransaction`, which appends to the file).** This logic is inefficient and potentially problematic due to the conflicting file write strategies (overwrite vs. append).
  * Error handling for invalid `head` parameters prints to `System.err`. The method often returns `true` even if the underlying delete/add fails.
* **CSV Writing (`writeTransactionsToCSV`)**:
  * Helper method used by `deleteTransaction`.
  * Writes a given `List<Transaction>` to the specified file path, **overwriting** any existing content.
  * Writes a standard header row.
  * Formats the payment amount by prepending "¥".

#### Important Issues & Considerations

1.  **Incomplete `TransactionDao` Implementation**: The methods declared in the `TransactionDao` interface (`getAllTransactions`, `addTransaction(Transaction)`, `deleteTransaction(String)`, `updateTransaction`, `getTransactionByOrderNumber`) are present but contain only placeholder/stub code. The actual working logic uses separate methods that require the `filePath` to be passed explicitly each time. **This class, in its current state, does not correctly function as a `TransactionDao` implementation.**
2.  **Inconsistent File Writing Strategy**: `addTransaction` *appends* to the file, while `deleteTransaction` and `writeTransactionsToCSV` (used by `deleteTransaction` and `changeInformation`) *overwrite* the entire file. This inconsistency can lead to unexpected behavior, especially within the `changeInformation` method.
3.  **Inefficient Updates/Deletes**: Rewriting the entire CSV file for every single deletion or modification (`changeInformation`) is highly inefficient, especially for large transaction files.
4.  **Flawed Update Logic (`changeInformation`)**: The delete-then-add approach for updates is problematic due to the inconsistent write strategies and potential race conditions or partial failures. The modified record will likely appear at the *end* of the file, not its original position.
5.  **Basic Caching**: The caching mechanism (`isLoad` flag) is simple and does not account for external modifications to the CSV file during the application's runtime.
6.  **Hardcoded Dependencies**: The code relies on specific header names (in Chinese) and the "¥" currency symbol format within the CSV data. Changes to the CSV format would require code modifications.

#### Usage Example (Using Functional Methods)

```java
import DAO.Impl.CsvTransactionDao; // Assuming TransactionDao interface exists but is not used directly here due to stub methods
import model.Transaction;
import java.io.IOException;
import java.util.List;

public class CsvDataManager {

    public static void main(String[] args) {
        // NOTE: Using the class directly, not via the TransactionDao interface
        // because the interface methods are not fully implemented.
        CsvTransactionDao csvDao = new CsvTransactionDao();
        String csvFilePath = "path/to/your/transactions.csv"; // <--- Specify your file path

        try {
            // --- Load Data ---
            System.out.println("Loading transactions...");
            List<Transaction> transactions = csvDao.loadFromCSV(csvFilePath);
            System.out.println("Loaded " + transactions.size() + " transactions.");
            // Display first transaction if available
            if (!transactions.isEmpty()) {
                 System.out.println("First transaction order number: " + transactions.get(0).getOrderNumber());
            }

            // --- Add a New Transaction (Appends) ---
            Transaction newTx = new Transaction(
                 "2025-04-20 08:14:00", "Test Add", "Counterparty", "Item", "支",
                 10.0, "支付宝", "交易成功", "NEW_ORDER_123", "MERCH_456", "Test via DAO add"
            );
            System.out.println("\nAdding new transaction (append): " + newTx.getOrderNumber());
            // csvDao.addTransaction(csvFilePath, newTx); // Uncomment to actually add
            System.out.println("Transaction potentially added.");

            // --- Delete a Transaction (Overwrites File) ---
            String orderToDelete = "SOME_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number from your file
            System.out.println("\nAttempting to delete transaction: " + orderToDelete);
            // boolean deleted = csvDao.deleteTransaction(csvFilePath, orderToDelete); // Uncomment to actually delete
            // if (deleted) {
            //     System.out.println("Transaction deleted successfully (File rewritten).");
            // } else {
            //     System.out.println("Transaction not found for deletion.");
            // }

            // --- Change Information (Overwrites then Appends - Use with Caution) ---
             String orderToChange = "ANOTHER_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number
             String fieldToChange = "remarks";
             String newValue = "Updated remark via changeInformation";
             System.out.println("\nAttempting to change info for: " + orderToChange);
             // boolean changed = csvDao.changeInformation(orderToChange, fieldToChange, newValue, csvFilePath); // Uncomment with caution
             // System.out.println("Change operation attempted (File rewritten and appended). Result: " + changed);


        } catch (IOException e) {
            System.err.println("Error interacting with CSV file: " + e.getMessage());
            e.printStackTrace();
        } catch (NumberFormatException e) {
            System.err.println("Error parsing amount in CSV: " + e.getMessage());
        }
    }
}
```

## Controller (Swing GUI)

Responsibilities: Manage user interface components (buttons, tables, text boxes) to listen for 
events (clicks, inputs) and call service layer methods to update the interface data display

## attention

encoding with UTF-8
```

`软工/Ai-Bill-Application-Group21\项目要求.txt`:

```txt
1. General Information 
In the next few weeks, your team will be required to develop a software application that 
will serve as a smart personal finance manager that helps users track expenses, set 
savings goals, and analyses spending habits using AI. Agile methods should be applied 
in all activities, from requirements through analysis/design, implementation, and testing. 
Iterations should be planned, and outcomes should be submitted. 
There are no restrictions on what you can include in the final product, and the given 
specification contains only high-level abstract requirements. It should be noted that 
determining the software requirements is one of the most important and complex phases 
in any development project. You should apply requirement-finding techniques and Agile 
methods to identify the actual requirements at an appropriate level. Most importantly, you 
need to prioritize the features that are implemented in accordance with both ease of 
implementation and meeting requirements. As in real software, you should define the 
project scope properly. Keep your design SIMPLE. Bear in mind that there is no absolute 
right answer – your solution may be perfectly appropriate.

2. Project Specification 
2.1 Basic Requirements 
Managing personal finances effectively is crucial in today’s digital economy, where 
transactions occur across multiple platforms like WeChat Pay, Alipay, and traditional 
banking. Many individuals struggle with tracking expenses, categorizing spending, and 
setting realistic budgets. An AI-powered personal finance tracker simplifies financial 
management by automatically classifying transactions, detecting spending patterns, and 
offering personalized savings recommendations. However, AI is not perfect – users must 
manually review to ensure accuracy. By integrating AI with manual validation, this 
software helps users make informed financial decisions while adapting to regional 
spending habits and economic conditions, improving financial literacy and budgeting 
skills. Here are some suggested functions to assist you in getting started. Suggested 
features can include the following, but not limited to: 
• Manual & Automated Data Entry: End users may input transactions manually or 
import structured CSV files from banking/financial apps. 
• Expense Categorisation (AI + Manual Correction): AI classifies transactions into 
categories (e.g., groceries, rent, entertainment), but end users can verify & correct 
misclassifications. 
• Spending Insights & Predictions: AI suggests monthly budgets, savings goals, and 
cost-cutting recommendations based on spending behaviour. 
• Local Financial Context: Customisable to China-specific budgeting habits, for 
example detects seasonal spending habits, such as higher expenses during Chinese 
New Year. 
A full prototype of the application should be produced. It is not required to implement the 
full working code for all functions in the prototype, however your team should implement 
core functions of your choice. 

2.2 Other Requirements 
• The software must be developed using Java as a stand-alone application running 
on computers. A simple graphic user interface (GUI) should be used. The recent 
Java Edition should be used. Do NOT build a Web-based application or Phone 
App. 
• All input and output data should be in simple text file format. You may use plain 
text (txt), CSV, JSON, or XML. Do NOT use a database. 
• Basic restrictions and error checking must be considered. 
• Your design must be flexible and extensible to adapt to future changes, e.g. 
modify existing features and add new features. When doing so, you should be 
able to reuse the existing components and make the least impact on the existing 
code. 
Page 2 of 8 
Your tasks are to define detailed requirements, design, develop and test the above software 
using Agile methods. Feel free to design the software as long as it satisfies the basic 
requirements, define the SCOPE properly.  

2.3 AI-Assisted Development 
To prevent over-reliance on AI, 
the following constraints apply: 
• Live Data Collection: AI cannot generate user-specific data patterns – you must 
gather real data. 请给出相应的数据搜集渠道（但是我们已经设计好了csv表，相应字段也设计了）
• Manual Data Cleaning and Validation: AI assistance is allowed, but the team must 
need to manually check for missing information, inconsistency, and inappropriate 
categorisation, etc. 
• Context-Specific Constraints: AI may struggle with domain-specific rules – you 
must implement real-world constraints (e.g. AI may count a WeChat Red Packet as a 
personal income where it is in fact a gift money and not a regular income.) 
• Oral Spot-Check: During the vivas, you will need to answer questions like “Why did 
AI make this recommendation?”, “How did you modify AI’s solution?”, etc, to 
demonstrate your understanding.
```

`软工/Submission\Labs\lab5\lab5.iml`:

```iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="GENERAL_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="module-library">
      <library name="JUnit4">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/junit/junit/4.13.1/junit-4.13.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="JUnit5.8.1">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter/5.8.1/junit-jupiter-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-api/5.8.1/junit-jupiter-api-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/opentest4j/opentest4j/1.2.0/opentest4j-1.2.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-commons/1.8.1/junit-platform-commons-1.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-params/5.8.1/junit-jupiter-params-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-engine/5.8.1/junit-jupiter-engine-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-engine/1.8.1/junit-platform-engine-1.8.1.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
  </component>
</module>
```

`软工/Submission\Labs\lab5\out\production\lab5\lab5.iml`:

```iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="GENERAL_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="module-library">
      <library name="JUnit4">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/junit/junit/4.13.1/junit-4.13.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="JUnit5.8.1">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter/5.8.1/junit-jupiter-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-api/5.8.1/junit-jupiter-api-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/opentest4j/opentest4j/1.2.0/opentest4j-1.2.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-commons/1.8.1/junit-platform-commons-1.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-params/5.8.1/junit-jupiter-params-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-engine/5.8.1/junit-jupiter-engine-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-engine/1.8.1/junit-platform-engine-1.8.1.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
  </component>
</module>
```

`软工/Submission\Labs\lab5\src\main\java\DegreeClassifier.java`:

```java
package src.main.java;

public class DegreeClassifier {
    /**
     * Classifies a degree based on the average mark.
     *
     * @param averageMark The average mark of the degree.
     * @return The classification of the degree.
     */
    public String classify(double averageMark) {
        if (averageMark >= 70) {
            return "First-Class";
        } else if (averageMark >= 60) {
            return "Upper Second-Class";
        } else if (averageMark >= 50) {
            return "Lower Second-Class";
        } else if (averageMark >= 40) {
            return "Third-Class";
        } else {
            return "Non-Honours";
        }
    }
}
```

`软工/Submission\Labs\lab5\src\test\java\DegreeClassifierTest.java`:

```java
package src.test.java;

import org.junit.jupiter.api.Test;
import src.main.java.DegreeClassifier;

import static org.junit.jupiter.api.Assertions.*;

public class DegreeClassifierTest {
    // We can see that all the test examples ran successfully !
    @Test
    public void testFirstClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("First-Class", classifier.classify(85));
    }

    @Test
    public void testUpperSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Upper Second-Class", classifier.classify(65));
    }

    @Test
    public void testLowerSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Lower Second-Class", classifier.classify(55));
    }

    @Test
    public void testThirdClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Third-Class", classifier.classify(45));
    }

    @Test
    public void testNonHonours() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Non-Honours", classifier.classify(35));
    }
}
```

`软工/Submission\Labs\lab6\lab6.iml`:

```iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="GENERAL_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="module-library">
      <library name="JUnit4">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/junit/junit/4.13.1/junit-4.13.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="JUnit5.8.1">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter/5.8.1/junit-jupiter-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-api/5.8.1/junit-jupiter-api-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/opentest4j/opentest4j/1.2.0/opentest4j-1.2.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-commons/1.8.1/junit-platform-commons-1.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-params/5.8.1/junit-jupiter-params-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-engine/5.8.1/junit-jupiter-engine-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-engine/1.8.1/junit-platform-engine-1.8.1.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="testng">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/testng/testng/7.1.0/testng-7.1.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/com/beust/jcommander/1.72/jcommander-1.72.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/com/google/inject/guice/4.1.0/guice-4.1.0-no_aop.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/javax/inject/javax.inject/1/javax.inject-1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/aopalliance/aopalliance/1.0/aopalliance-1.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/com/google/guava/guava/19.0/guava-19.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/yaml/snakeyaml/1.21/snakeyaml-1.21.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
  </component>
</module>
```

`软工/Submission\Labs\lab6\out\production\lab6\lab6.iml`:

```iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="GENERAL_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="module-library">
      <library name="JUnit4">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/junit/junit/4.13.1/junit-4.13.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="JUnit5.8.1">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter/5.8.1/junit-jupiter-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-api/5.8.1/junit-jupiter-api-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/opentest4j/opentest4j/1.2.0/opentest4j-1.2.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-commons/1.8.1/junit-platform-commons-1.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-params/5.8.1/junit-jupiter-params-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-engine/5.8.1/junit-jupiter-engine-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-engine/1.8.1/junit-platform-engine-1.8.1.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="testng">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/testng/testng/7.1.0/testng-7.1.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/com/beust/jcommander/1.72/jcommander-1.72.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/com/google/inject/guice/4.1.0/guice-4.1.0-no_aop.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/javax/inject/javax.inject/1/javax.inject-1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/aopalliance/aopalliance/1.0/aopalliance-1.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/com/google/guava/guava/19.0/guava-19.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/yaml/snakeyaml/1.21/snakeyaml-1.21.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
  </component>
</module>
```

`软工/Submission\Labs\lab6\src\main\java\DegreeClassifier.java`:

```java
package src.main.java;


/**
 * First Mutation
 */
//public class DegreeClassifier {
//    public String classify(double averageMark) {
//        if (averageMark > 70) { // Turn >= into >
//            return "First-Class";
//        } else if (averageMark >= 60) {
//            return "Upper Second-Class";
//        } else if (averageMark >= 50) {
//            return "Lower Second-Class";
//        } else if (averageMark >= 40) {
//            return "Third-Class";
//        } else {
//            return "Non-Honours";
//        }
//    }
//}

/**
 * Second Mutation Now we run the 2nd mutation test
 */
//public class DegreeClassifier {
//    public String classify(double averageMark) {
//        if (averageMark >= 70) {
//            return "First-Class";
//        } else if (averageMark > 60) { // Turn >= into > this time we change this
//            return "Upper Second-Class";
//        } else if (averageMark >= 50) {
//            return "Lower Second-Class";
//        } else if (averageMark >= 40) {
//            return "Third-Class";
//        } else {
//            return "Non-Honours";
//        }
//    }
//}

/**
 * Third Mutation last mutation test
 */
public class DegreeClassifier {
    public String classify(double averageMark) {
        if (averageMark >= 70) {
            return "First-Class";
        } else if (averageMark >= 60) {
            return "Upper Second-Class";
        } else if (averageMark >= 50) {
            return "Lower Second-Class";
        } else if (averageMark >= 40) {
            return "Second-Class"; // Modify the return value this time we directly change the return value
        } else {
            return "Non-Honours";
        }
    }
}

// That's it, all the mutation tests have been run
```

`软工/Submission\Labs\lab6\src\test\java\DegreeClassifierTest.java`:

```java
package src.test.java;

import org.junit.jupiter.api.Test;
import src.main.java.DegreeClassifier;

import static org.junit.jupiter.api.Assertions.*;

public class DegreeClassifierTest {
    // First Test no problem
    @Test
    public void testFirstClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("First-Class", classifier.classify(85));
    }



    /**
     * First Mutation Test, this test, problem occurred because >= was turned into >
     */
    @Test
    public void testFirstClassBoundary() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("First-Class", classifier.classify(70.0));
    }

    @Test
    public void testUpperSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Upper Second-Class", classifier.classify(65));
    }

    /**
     * Second Mutation Test second mutation test has problem because >= was turned into > aslo
     */
    @Test
    public void testUpperSecondClassBoundary() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Upper Second-Class", classifier.classify(60.0));
    }

    @Test
    public void testLowerSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Lower Second-Class", classifier.classify(55));
    }

    /**
     * Third Mutation Test
     */
    @Test
    public void testThirdClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Third-Class", classifier.classify(45)); // score >= 40 but honor is "Second-class" it should be wrong
    }

    @Test
    public void testNonHonours() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Non-Honours", classifier.classify(35));
    }
}
```

`软工/Submission\Submission(Test & Production)\Production\DegreeClassifierLab5.java`:

```java
package src.main.java;

public class DegreeClassifier {
    /**
     * Classifies a degree based on the average mark.
     *
     * @param averageMark The average mark of the degree.
     * @return The classification of the degree.
     */
    public String classify(double averageMark) {
        if (averageMark >= 70) {
            return "First-Class";
        } else if (averageMark >= 60) {
            return "Upper Second-Class";
        } else if (averageMark >= 50) {
            return "Lower Second-Class";
        } else if (averageMark >= 40) {
            return "Third-Class";
        } else {
            return "Non-Honours";
        }
    }
}
```

`软工/Submission\Submission(Test & Production)\Production\DegreeClassifierLab6.java`:

```java
package src.main.java;


/**
 * First Mutation
 */
//public class DegreeClassifier {
//    public String classify(double averageMark) {
//        if (averageMark > 70) { // Turn >= into >
//            return "First-Class";
//        } else if (averageMark >= 60) {
//            return "Upper Second-Class";
//        } else if (averageMark >= 50) {
//            return "Lower Second-Class";
//        } else if (averageMark >= 40) {
//            return "Third-Class";
//        } else {
//            return "Non-Honours";
//        }
//    }
//}

/**
 * Second Mutation Now we run the 2nd mutation test
 */
//public class DegreeClassifier {
//    public String classify(double averageMark) {
//        if (averageMark >= 70) {
//            return "First-Class";
//        } else if (averageMark > 60) { // Turn >= into > this time we change this
//            return "Upper Second-Class";
//        } else if (averageMark >= 50) {
//            return "Lower Second-Class";
//        } else if (averageMark >= 40) {
//            return "Third-Class";
//        } else {
//            return "Non-Honours";
//        }
//    }
//}

/**
 * Third Mutation last mutation test
 */
public class DegreeClassifier {
    public String classify(double averageMark) {
        if (averageMark >= 70) {
            return "First-Class";
        } else if (averageMark >= 60) {
            return "Upper Second-Class";
        } else if (averageMark >= 50) {
            return "Lower Second-Class";
        } else if (averageMark >= 40) {
            return "Second-Class"; // Modify the return value this time we directly change the return value
        } else {
            return "Non-Honours";
        }
    }
}

// That's it, all the mutation tests have been run
```

`软工/Submission\Submission(Test & Production)\Test\DegreeClassifierTestLab5.java`:

```java
package src.test.java;

import org.junit.jupiter.api.Test;
import src.main.java.DegreeClassifier;

import static org.junit.jupiter.api.Assertions.*;

public class DegreeClassifierTest {
    // We can see that all the test examples ran successfully !
    @Test
    public void testFirstClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("First-Class", classifier.classify(85));
    }

    @Test
    public void testUpperSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Upper Second-Class", classifier.classify(65));
    }

    @Test
    public void testLowerSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Lower Second-Class", classifier.classify(55));
    }

    @Test
    public void testThirdClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Third-Class", classifier.classify(45));
    }

    @Test
    public void testNonHonours() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Non-Honours", classifier.classify(35));
    }
}
```

`软工/Submission\Submission(Test & Production)\Test\DegreeClassifierTestLab6.java`:

```java
package src.test.java;

import org.junit.jupiter.api.Test;
import src.main.java.DegreeClassifier;

import static org.junit.jupiter.api.Assertions.*;

public class DegreeClassifierTest {
    // First Test no problem
    @Test
    public void testFirstClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("First-Class", classifier.classify(85));
    }



    /**
     * First Mutation Test, this test, problem occurred because >= was turned into >
     */
    @Test
    public void testFirstClassBoundary() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("First-Class", classifier.classify(70.0));
    }

    @Test
    public void testUpperSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Upper Second-Class", classifier.classify(65));
    }

    /**
     * Second Mutation Test second mutation test has problem because >= was turned into > aslo
     */
    @Test
    public void testUpperSecondClassBoundary() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Upper Second-Class", classifier.classify(60.0));
    }

    @Test
    public void testLowerSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Lower Second-Class", classifier.classify(55));
    }

    /**
     * Third Mutation Test
     */
    @Test
    public void testThirdClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Third-Class", classifier.classify(45)); // score >= 40 but honor is "Second-class" it should be wrong
    }

    @Test
    public void testNonHonours() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Non-Honours", classifier.classify(35));
    }
}
```

`软工/大代码\MenuUI-post.txt`:

```txt
 package Controller;

 import Constants.ConfigConstants;
 // Remove import DAO.CsvTransactionDao;

 import Service.Impl.TransactionServiceImpl;
 import Service.TransactionService;
 import Utils.CacheManager;
 import model.Transaction;
 import model.User;

 import javax.swing.*;
 import java.awt.*;
 import java.io.IOException;
 import java.util.List;
 import java.util.Vector; // Still used for table row data structure
 import javax.swing.table.DefaultTableModel;

 // Remove static imports related to CSV_PATH

 public class MenuUI {
     private final User currentUser;
     private final TransactionService transactionService;

     // Make tableModel an instance field
     private DefaultTableModel tableModel;
     // Remove the static or instance allData field: private Vector<Vector<String>> allData = new Vector<>();

     // Add instance fields for search input components (for Question 2 & 3)
     private JTextField searchTransactionTimeField;
     private JTextField searchTransactionTypeField;
     private JTextField searchCounterpartyField;
     private JTextField searchCommodityField;
     private JComboBox<String> searchInOutComboBox;
     private JTextField searchPaymentMethodField;
     private JButton searchButton; // Keep reference to the search button

     private JTable table;
     private HistogramPanelContainer histogramPanelContainer;
     private JPanel rightPanel;
     private CardLayout cardLayout;

     // Constructor now accepts the authenticated User and their TransactionService instance
     public MenuUI(User authenticatedUser, TransactionService transactionService){
         this.currentUser = authenticatedUser;
         this.transactionService = transactionService; // Inject the user-specific service

         // Initialize table model (now non-static)
         String[] columnNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注", "Modify", "Delete"};
         this.tableModel = new DefaultTableModel(columnNames, 0);
         this.table = new JTable(this.tableModel);

         this.histogramPanelContainer = new HistogramPanelContainer();
         this.cardLayout = new CardLayout();
         this.rightPanel = new JPanel(this.cardLayout);

         // DEBUG: Print user info
         System.out.println("MenuUI initialized for user: " + currentUser.getUsername());
         System.out.println("Using transaction file: " + currentUser.getTransactionFilePath());

         // Data loading will be called in createMainPanel() after UI setup
     }

     public JPanel createMainPanel() {
         // Main panel, use BorderLayout
         JPanel mainPanel = new JPanel(new BorderLayout());

         // Left panel with Menu and AI buttons
         JPanel leftPanel = createLeftPanel();
         mainPanel.add(leftPanel, BorderLayout.WEST);

         // Right panel for table or AI view
         setupRightPanel();
         mainPanel.add(rightPanel, BorderLayout.CENTER);

         // Load the user's data and display initial view (only income)
         loadCSVDataForCurrentUser("收入"); // Load and display only income initially

         return mainPanel;
     }

     // Method to load CSV data for the current user with optional initial filter
     // This replaces the old loadCSVDataForCurrentUser() method
     public void loadCSVDataForCurrentUser(String initialInOutFilter) {
         this.tableModel.setRowCount(0); // Clear the table model

         try {
             // Get all transactions for the current user using the injected service
             List<Transaction> transactions = transactionService.getAllTransactions();
             System.out.println("Loaded total " + transactions.size() + " transactions from service for user " + currentUser.getUsername());

             // Filter transactions based on the initialInOutFilter
             List<Transaction> filteredTransactions = new java.util.ArrayList<>();
             if (initialInOutFilter == null || initialInOutFilter.trim().isEmpty()) {
                  // If no filter specified, add all transactions
                  filteredTransactions.addAll(transactions);
             } else {
                  // Filter by the specified 收/支 type
                  String filter = initialInOutFilter.trim();
                  filteredTransactions = transactions.stream()
                          .filter(t -> t.getInOut() != null && (t.getInOut().equalsIgnoreCase(filter) ||
                                  (filter.equalsIgnoreCase("收入") && t.getInOut().equalsIgnoreCase("收")) ||
                                  (filter.equalsIgnoreCase("支出") && t.getInOut().equalsIgnoreCase("支")) ))
                          .collect(java.util.stream.Collectors.toList());
             }


             // Add filtered transactions to the table model
             for (Transaction transaction : filteredTransactions) {
                 Vector<String> row = createRowFromTransaction(transaction);
                 this.tableModel.addRow(row);
             }
             System.out.println("Displayed " + filteredTransactions.size() + " transactions in the table.");

         } catch (Exception e) {
             e.printStackTrace();
             JOptionPane.showMessageDialog(null, "加载用户交易数据失败！", "错误", JOptionPane.ERROR_MESSAGE);
         }
     }

     // Method to create the left panel (Menu/AI buttons) - no changes needed here
     private JPanel createLeftPanel() { /* ... existing code ... */ return null; }

     // Method to set up the right panel (Table/Histogram) - no changes needed here
     private void setupRightPanel() { /* ... existing code ... */ }

     // Method to create the table panel - update button editors/renderers to use 'this' MenuUI instance
     private JPanel createTablePanel() {
         JPanel tablePanel = new JPanel(new BorderLayout());

         JPanel inputPanel = createInputPanel(); // This method now initializes search fields
         tablePanel.add(inputPanel, BorderLayout.NORTH);

         JScrollPane tableScrollPane = new JScrollPane(this.table);
         tableScrollPane.setPreferredSize(new Dimension(1000, 250));
         this.table.setRowHeight(30);

         tablePanel.add(tableScrollPane, BorderLayout.CENTER);

         // Set cell renderers and editors - pass 'this' MenuUI instance
         this.table.getColumnModel().getColumn(11).setCellRenderer(new ButtonRenderer());
         this.table.getColumnModel().getColumn(11).setCellEditor(new ButtonEditor(this));

         this.table.getColumnModel().getColumn(12).setCellRenderer(new ButtonRenderer());
         this.table.getColumnModel().getColumn(12).setCellEditor(new ButtonEditor(this));

         // Data loading is now called in createMainPanel()

         return tablePanel;
     }

     // Method to create input panel - Capture references to search fields and button (for Question 2 & 3)
     private JPanel createInputPanel() {
         JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));

         // Create input fields and capture references
         searchTransactionTimeField = new JTextField(10); // 交易时间输入框
         searchTransactionTypeField = new JTextField(10); // 交易类型输入框
         searchCounterpartyField = new JTextField(10);    // 交易对方输入框
         searchCommodityField = new JTextField(10);      // 商品输入框
         searchInOutComboBox = new JComboBox<>(new String[]{"", "收入", "支出"}); // Add empty option for "any"
         searchPaymentMethodField = new JTextField(10);  // 支付方式输入框

         // Add labels and input fields
         inputPanel.add(new JLabel("交易时间:"));
         inputPanel.add(searchTransactionTimeField);
         inputPanel.add(new JLabel("交易类型:"));
         inputPanel.add(searchTransactionTypeField);
         inputPanel.add(new JLabel("交易对方:"));
         inputPanel.add(searchCounterpartyField);
         inputPanel.add(new JLabel("商品:"));
         inputPanel.add(searchCommodityField);
         inputPanel.add(new JLabel("收/支:"));
         inputPanel.add(searchInOutComboBox);
         inputPanel.add(new JLabel("支付方式:"));
         inputPanel.add(searchPaymentMethodField);

         // Create Search and Add buttons and capture reference to search button
         searchButton = new JButton("Search");
         JButton addButton = new JButton("Add");

         // Add buttons
         inputPanel.add(searchButton);
         inputPanel.add(addButton);

         // Add ActionListener for Search button
         searchButton.addActionListener(e -> {
             // Call searchData with current values from the input fields
             searchData(
                     searchTransactionTimeField.getText().trim(),
                     searchTransactionTypeField.getText().trim(),
                     searchCounterpartyField.getText().trim(),
                     searchCommodityField.getText().trim(),
                     (String) searchInOutComboBox.getSelectedItem(),
                     searchPaymentMethodField.getText().trim()
             );
         });

         // Add ActionListener for Add button
         addButton.addActionListener(e -> {
             showAddTransactionDialog();
         });

         return inputPanel;
     }

     // Method to show add transaction dialog - update to use injected service
     private void showAddTransactionDialog() {
         // ... existing code to create dialog and fields ...
         JDialog addDialog = new JDialog();
         addDialog.setTitle("添加交易");
         addDialog.setLayout(new GridLayout(12, 2));

         JTextField transactionTimeField = new JTextField();
         JTextField transactionTypeField = new JTextField();
         JTextField counterpartyField = new JTextField();
         JTextField commodityField = new JTextField();
         JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"}); // Or maybe allow empty for "other"?
         JTextField paymentAmountField = new JTextField();
         JTextField paymentMethodField = new JTextField();
         JTextField currentStatusField = new JTextField();
         JTextField orderNumberField = new JTextField();
         JTextField merchantNumberField = new JTextField();
         JTextField remarksField = new JTextField();

         addDialog.add(new JLabel("交易时间:")); addDialog.add(transactionTimeField);
         addDialog.add(new JLabel("交易类型:")); addDialog.add(transactionTypeField);
         addDialog.add(new JLabel("交易对方:")); addDialog.add(counterpartyField);
         addDialog.add(new JLabel("商品:")); addDialog.add(commodityField);
         addDialog.add(new JLabel("收/支:")); addDialog.add(inOutComboBox);
         addDialog.add(new JLabel("金额(元):")); addDialog.add(paymentAmountField);
         addDialog.add(new JLabel("支付方式:")); addDialog.add(paymentMethodField);
         addDialog.add(new JLabel("当前状态:")); addDialog.add(currentStatusField);
         addDialog.add(new JLabel("交易单号:")); addDialog.add(orderNumberField);
         addDialog.add(new JLabel("商户单号:")); addDialog.add(merchantNumberField);
         addDialog.add(new JLabel("备注:")); addDialog.add(remarksField);


         // Add confirm button
         JButton confirmButton = new JButton("确认");
         confirmButton.addActionListener(e -> {
             String paymentAmountText = paymentAmountField.getText().trim();
             double paymentAmount = 0.0;
             if (!paymentAmountText.isEmpty()) {
                 try {
                      paymentAmount = Double.parseDouble(paymentAmountText);
                 } catch (NumberFormatException ex) {
                      JOptionPane.showMessageDialog(addDialog, "金额格式不正确！请输入数字。", "输入错误", JOptionPane.ERROR_MESSAGE);
                      return;
                 }
             }

             Transaction newTransaction = new Transaction(
                     emptyIfNull(transactionTimeField.getText().trim()),
                     emptyIfNull(transactionTypeField.getText().trim()),
                     emptyIfNull(counterpartyField.getText().trim()),
                     emptyIfNull(commodityField.getText().trim()),
                     (String) inOutComboBox.getSelectedItem(),
                     paymentAmount,
                     emptyIfNull(paymentMethodField.getText().trim()),
                     emptyIfNull(currentStatusField.getText().trim()),
                     emptyIfNull(orderNumberField.getText().trim()), // Ensure order number is provided
                     emptyIfNull(merchantNumberField.getText().trim()),
                     emptyIfNull(remarksField.getText().trim())
             );

             if (newTransaction.getOrderNumber().isEmpty()) {
                  JOptionPane.showMessageDialog(addDialog, "交易单号不能为空！", "输入错误", JOptionPane.ERROR_MESSAGE);
                  return;
             }

             try {
                 transactionService.addTransaction(newTransaction);

                 // After adding, decide what to display.
                 // Option 1: Reload the default (income only) view:
                 // loadCSVDataForCurrentUser("收入");
                 // Option 2: Reload all data:
                 // loadCSVDataForCurrentUser("");
                 // Option 3: Reload the *current* search/filter view (more complex, requires storing current criteria)
                 // Let's choose Option 2 for simplicity - show all data after adding a new transaction.
                 // The user can then filter if needed.
                 loadCSVDataForCurrentUser(""); // Load all data after adding

                 // Also clear search fields after adding
                 clearSearchFields();


                 addDialog.dispose();
                 JOptionPane.showMessageDialog(null, "交易添加成功！", "提示", JOptionPane.INFORMATION_MESSAGE);

             } catch (IOException ex) {
                 ex.printStackTrace();
                 JOptionPane.showMessageDialog(null, "交易添加失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
             }
         });

         addDialog.add(confirmButton);
         addDialog.setSize(400, 300);
         addDialog.setModal(true);
         addDialog.setVisible(true);
     }


     // Method to search data - update to clear tableModel only (remove allData usage)
     public void searchData(String query1, String query2, String query3, String query4, String query6, String query5) { // Renamed query params for clarity
         System.out.println("Searching with criteria: time='" + query1 + "', type='" + query2 + "', counterparty='" + query3 + "', commodity='" + query4 + "', inOut='" + query6 + "', paymentMethod='" + query5 + "'");
         this.tableModel.setRowCount(0); // Clear the table model

         // Create search criteria Transaction object
         Transaction searchCriteria = new Transaction(
                 query1, query2, query3, query4, query6,
                 0, // paymentAmount not used in search criteria from UI
                 query5,
                 "", "", "", ""
         );

         try {
             // Use the injected transactionService instance
             List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);
             System.out.println("Search results count: " + transactions.size());
             for (Transaction transaction : transactions) {
                 Vector<String> row = createRowFromTransaction(transaction);
                 this.tableModel.addRow(row);
             }

         } catch (Exception ex) {
             ex.printStackTrace();
             JOptionPane.showMessageDialog(null, "查询失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
         }
     }

     // Method to create table row from Transaction object - no changes needed here
     private Vector<String> createRowFromTransaction(Transaction transaction) {
         Vector<String> row = new Vector<>();
         row.add(emptyIfNull(transaction.getTransactionTime()));
         row.add(emptyIfNull(transaction.getTransactionType()));
         row.add(emptyIfNull(transaction.getCounterparty()));
         row.add(emptyIfNull(transaction.getCommodity()));
         row.add(emptyIfNull(transaction.getInOut()));
         row.add(String.valueOf(transaction.getPaymentAmount())); // Keep as String for table
         row.add(emptyIfNull(transaction.getPaymentMethod()));
         row.add(emptyIfNull(transaction.getCurrentStatus()));
         row.add(emptyIfNull(transaction.getOrderNumber()));
         row.add(emptyIfNull(transaction.getMerchantNumber()));
         row.add(emptyIfNull(transaction.getRemarks()));
         row.add("Modify"); // Modify button text
         row.add("Delete"); // Delete button text
         return row;
     }


     // Method to delete row - get data from tableModel (remove allData usage)
     public void deleteRow(int rowIndex) {
         System.out.println("尝试删除行: " + rowIndex + " for user " + currentUser.getUsername());
         if (rowIndex >= 0 && rowIndex < this.tableModel.getRowCount()) { // Use tableModel row count

             // Get the order number directly from the displayed table row
             String orderNumber = (String) this.tableModel.getValueAt(rowIndex, 8); // OrderNumber is at index 8
             if (orderNumber == null || orderNumber.trim().isEmpty()) {
                  JOptionPane.showMessageDialog(null, "无法删除：交易单号为空！", "错误", JOptionPane.ERROR_MESSAGE);
                  System.err.println("Attempted to delete row " + rowIndex + " but order number is null or empty.");
                  return; // Cannot delete without an order number
             }
             orderNumber = orderNumber.trim();
             System.out.println("Deleting transaction with order number: " + orderNumber);

             try {
                 // Use the injected transactionService instance
                 boolean deleted = transactionService.deleteTransaction(orderNumber);

                 if (deleted) {
                     // Data is removed from CSV and cache invalidated by service.
                     // Update the UI model directly by removing the row.
                     this.tableModel.removeRow(rowIndex); // Remove the row from the displayed table


                     JOptionPane.showMessageDialog(null, "删除成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                     System.out.println("Deleted row " + rowIndex + " with order number " + orderNumber + " from UI.");

                     // After delete, refresh the view. Let's reload the *current* search/filter view.
                     // Get the current search criteria from the UI fields and re-apply search.
                     triggerCurrentSearch();

                 } else {
                     // This case means the service said it wasn't deleted (likely not found)
                     JOptionPane.showMessageDialog(null, "删除失败：未找到对应的交易单号 " + orderNumber, "错误", JOptionPane.ERROR_MESSAGE);
                     System.err.println("Delete failed: order number " + orderNumber + " not found by service.");
                 }
             } catch (Exception ex) {
                 ex.printStackTrace();
                 JOptionPane.showMessageDialog(null, "删除失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
                 System.err.println("Error during deletion for order number " + orderNumber);
             }
         } else {
              System.err.println("Attempted to delete row with invalid index: " + rowIndex + ". Table row count: " + this.tableModel.getRowCount());
         }
     }

     // Method to edit row - get data from tableModel and update display after edit (remove allData usage)
     public void editRow(int rowIndex) {
         System.out.println("编辑行: " + rowIndex + " for user " + currentUser.getUsername());
         if (rowIndex >= 0 && rowIndex < this.tableModel.getRowCount()) { // Use tableModel row count

             // Get the data for the displayed row directly from the table model
             Vector<String> rowData = new Vector<>();
             // Get data for all columns that correspond to Transaction fields (up to index 10)
             for (int i = 0; i <= 10; i++) { // Columns 0 to 10 are Transaction fields
                 Object value = this.tableModel.getValueAt(rowIndex, i);
                 rowData.add(value != null ? value.toString() : "");
             }
             System.out.println("Retrieved row data from table model for editing: " + rowData);

             // Get the original order number, which is the key for update
             String originalOrderNumber = rowData.get(8).trim(); // Index 8 is OrderNumber
              if (originalOrderNumber.isEmpty()) {
                 JOptionPane.showMessageDialog(null, "无法编辑：交易单号为空！", "错误", JOptionPane.ERROR_MESSAGE);
                 System.err.println("Attempted to edit row " + rowIndex + " but order number is empty.");
                 return; // Cannot edit without an order number
              }


             // Create a panel for edit fields
             JPanel panel = new JPanel(new GridLayout(11, 2)); // 11 Transaction fields

             // Create fields array, populate panel and fields
             JTextField[] fields = new JTextField[11]; // 11 fields for Transaction data
             String[] fieldNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"};

             for (int i = 0; i < fieldNames.length; i++) {
                 panel.add(new JLabel(fieldNames[i] + ":")); // Add label
                 fields[i] = new JTextField(rowData.get(i)); // Set field value from row data
                 panel.add(fields[i]);
             }

             // Disable editing the order number field if it's the primary key and shouldn't be changed
             // If you decide OrderNumber is immutable via edit:
             fields[8].setEditable(false); // Disable editing OrderNumber field


             // Show the dialog
             int result = JOptionPane.showConfirmDialog(null, panel, "修改交易信息 (订单号: " + originalOrderNumber + ")", JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

             if (result == JOptionPane.OK_OPTION) {
                 // User clicked OK, get updated values from fields

                 // Handle paymentAmount parsing carefully
                 double paymentAmount = safeParseDouble(fields[5].getText().trim()); // 金额(元)

                 // Create a Transaction object with updated values
                 // Use the original order number as the key for the update operation
                 Transaction updatedTransaction = new Transaction(
                         fields[0].getText().trim(), // 交易时间
                         fields[1].getText().trim(), // 交易类型
                         fields[2].getText().trim(), // 交易对方
                         fields[3].getText().trim(), // 商品
                         fields[4].getText().trim(), // 收/支
                         paymentAmount,
                         fields[6].getText().trim(), // 支付方式
                         fields[7].getText().trim(), // 当前状态
                         originalOrderNumber, // Use the ORIGINAL order number as the identifier for update
                         fields[9].getText().trim(), // 商户单号
                         fields[10].getText().trim() // 备注
                 );

                 try {
                     // Use the injected transactionService instance to change the transaction
                     transactionService.changeTransaction(updatedTransaction);

                     // *** IMPORTANT CHANGE FOR QUESTION 2 ***
                     // After successful edit, update the search fields and trigger search
                     System.out.println("Edit successful. Preparing to refresh display filtered by InOut: " + updatedTransaction.getInOut());
                     // Clear all search text fields
                     clearSearchFields();
                     // Set the InOut dropdown to the updated value
                     searchInOutComboBox.setSelectedItem(updatedTransaction.getInOut());
                     // Trigger the search based on the updated criteria
                     triggerCurrentSearch();


                     JOptionPane.showMessageDialog(null, "修改成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                     System.out.println("Edited row " + rowIndex + " for order number " + originalOrderNumber + " and refreshed display.");

                 } catch (IllegalArgumentException e) {
                     JOptionPane.showMessageDialog(null, "修改失败！\n" + e.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
                     e.printStackTrace();
                 } catch (Exception ex) {
                     ex.printStackTrace();
                     JOptionPane.showMessageDialog(null, "修改失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
                     System.err.println("Error during editing for order number " + originalOrderNumber);
                 }
             } else {
                  System.out.println("Edit dialog cancelled.");
             }
         } else {
              System.err.println("Attempted to edit row with invalid index: " + rowIndex + ". Table row count: " + this.tableModel.getRowCount());
         }
     }

     // Helper method to safely parse double, return 0.0 on error
     private double safeParseDouble(String value) {
         if (value == null || value.trim().isEmpty()) {
             return 0.0;
         }
         try {
             return Double.parseDouble(value.trim());
         } catch (NumberFormatException e) {
             System.err.println("Failed to parse double from string: '" + value + "'");
             // Consider showing a warning message to the user here
             return 0.0;
         }
     }

      // Helper method to clear all search input fields
     private void clearSearchFields() {
         searchTransactionTimeField.setText("");
         searchTransactionTypeField.setText("");
         searchCounterpartyField.setText("");
         searchCommodityField.setText("");
         searchInOutComboBox.setSelectedItem(""); // Set to the empty option
         searchPaymentMethodField.setText("");
          System.out.println("Cleared search fields.");
     }

      // Helper method to trigger search based on current search field values
      private void triggerCurrentSearch() {
         searchData(
                 searchTransactionTimeField.getText().trim(),
                 searchTransactionTypeField.getText().trim(),
                 searchCounterpartyField.getText().trim(),
                 searchCommodityField.getText().trim(),
                 (String) searchInOutComboBox.getSelectedItem(),
                 searchPaymentMethodField.getText().trim()
         );
          System.out.println("Triggered search with current field values.");
      }


     /**
      * If field is null, return empty string.
      * @param value Field value
      * @return Non-null field value
      */
     private String emptyIfNull(String value) {
         return value == null ? "" : value;
     }

     // Keep getTable() for testing
     public JTable getTable() {
         return table;
     }
 }
```

`软工/大代码\MenuUI-pre.txt`:

```txt
package Controller;

import Constants.ConfigConstants; // [cite: 240]
// Remove import DAO.CsvTransactionDao; // No longer directly initialized here // [cite: 240]

import Service.Impl.TransactionServiceImpl; // [cite: 240]
// Import the specific implementation // [cite: 241]
import Service.TransactionService; // [cite: 241]
// Import the interface as well // [cite: 242]
import Utils.CacheManager; // [cite: 242]
// Might be needed if UI directly invalidates cache (less ideal) // [cite: 243]
import model.Transaction; // [cite: 243]
import model.User; // [cite: 243]
import javax.swing.*; // [cite: 244]
import java.awt.*; // [cite: 244]
import java.io.IOException; // [cite: 244]
import java.util.List; // [cite: 244]
import java.util.Vector; // [cite: 244]
import javax.swing.table.DefaultTableModel; // [cite: 244]
// Remove static imports related to CSV_PATH // [cite: 245]
// import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY; // [cite: 245]
// import static Constants.ConfigConstants.CSV_PATH; // [cite: 245]

public class MenuUI {
    private final User currentUser; // [cite: 246]
    // private final String currentUserTransactionFilePath; // Can get this from currentUser // [cite: 247]

    // Make tableModel and allData instance fields, not static // [cite: 247]
    private DefaultTableModel tableModel; // [cite: 247]
    private Vector<Vector<String>> allData = new Vector<>(); // Non-static data // [cite: 248]

    // Make transactionService an instance field // [cite: 248]
    private final TransactionService transactionService; // [cite: 248]
    private JTable table; // [cite: 249]
    private HistogramPanelContainer histogramPanelContainer; // [cite: 249]
    private JPanel rightPanel; // [cite: 249]
    private CardLayout cardLayout; // [cite: 249]

    // Constructor now accepts the authenticated User and their TransactionService instance // [cite: 250]
    public MenuUI(User authenticatedUser, TransactionService transactionService){
        this.currentUser = authenticatedUser; // [cite: 250]
        this.transactionService = transactionService; // Inject the user-specific service // [cite: 251]

        // Initialize table model (now non-static) // [cite: 251]
        String[] columnNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注", "Modify", "Delete"}; // [cite: 251]
        this.tableModel = new DefaultTableModel(columnNames, 0); // Use 'this' for instance field // [cite: 252]
        this.table = new JTable(this.tableModel); // [cite: 252]
        // Use 'this' // [cite: 253]

        this.histogramPanelContainer = new HistogramPanelContainer(); // [cite: 253]
        // Use 'this' // [cite: 254]
        this.cardLayout = new CardLayout(); // [cite: 254]
        // Use 'this' // [cite: 255]
        this.rightPanel = new JPanel(this.cardLayout); // [cite: 255]
        // Use 'this' // [cite: 256]

        // DEBUG: Print user info // [cite: 256]
        System.out.println("MenuUI initialized for user: " + currentUser.getUsername()); // [cite: 256]
        System.out.println("Using transaction file: " + currentUser.getTransactionFilePath()); // [cite: 257]

        // The rest of the UI setup...
    }

    public JPanel createMainPanel() {
        // Main panel, using BorderLayout // [cite: 257]
        JPanel mainPanel = new JPanel(new BorderLayout()); // [cite: 258]
        // Left panel with Menu and AI buttons // [cite: 258]
        JPanel leftPanel = createLeftPanel(); // [cite: 258]
        mainPanel.add(leftPanel, BorderLayout.WEST); // [cite: 259]

        // Right panel for table or AI view // [cite: 259]
        setupRightPanel(); // [cite: 259]
        mainPanel.add(rightPanel, BorderLayout.CENTER); // [cite: 260]

        // *** IMPORTANT CHANGE *** // [cite: 260]
        // After the UI components are created and the panel is added, // [cite: 260]
        // load the user's data. // [cite: 261]
        // This happens once when the main panel is created/displayed. // [cite: 261]
        loadCSVDataForCurrentUser(); // [cite: 261]
        // Call the loading method here // [cite: 262]

        return mainPanel; // [cite: 262]
    }

    // Method to load CSV data for the current user // [cite: 263]
    // This replaces the old loadCSVData(String caffeineKey) method // [cite: 263]
    public void loadCSVDataForCurrentUser() {
        this.allData.clear(); // [cite: 263]
        // Use 'this' for instance field // [cite: 264]
        this.tableModel.setRowCount(0); // [cite: 264]
        // Use 'this' // [cite: 265]

        try {
            // Get all transactions for the current user using the injected service // [cite: 265]
            // Note: TransactionServiceImpl's getAllTransactionsForCurrentUser is private. // [cite: 266]
            // We need a public method in TransactionService to get all data for the UI. // [cite: 267]
            // Let's add one to TransactionService interface. // [cite: 267]
            // For now, assuming we can get all via search with empty criteria. // [cite: 268]
            // Or, better, add a public getAllTransactions() method to the service interface. // [cite: 268]
            // Let's add `List<Transaction> getAllTransactions()` to TransactionService. // [cite: 269]
            // And implement it in TransactionServiceImpl using `getAllTransactionsForCurrentUser()`. // [cite: 269]

            List<Transaction> transactions = transactionService.getAllTransactions(); // [cite: 269]
            // Call the new public method // [cite: 270]

            for (Transaction transaction : transactions) {
                Vector<String> row = createRowFromTransaction(transaction); // [cite: 270]
                this.allData.add(row); // Use 'this' // [cite: 271]
                this.tableModel.addRow(row); // [cite: 271]
                // Use 'this' // [cite: 272]
            }
            System.out.println("Loaded " + transactions.size() + " transactions into table for user " + currentUser.getUsername()); // [cite: 272]
        } catch (Exception e) {
            e.printStackTrace(); // [cite: 273]
            JOptionPane.showMessageDialog(null, "加载用户交易数据失败！", "错误", JOptionPane.ERROR_MESSAGE); // [cite: 274]
        }
    }

    // Method to create the left panel (Menu/AI buttons) - no changes needed here // [cite: 274]
    private JPanel createLeftPanel() {
        JPanel leftPanel = new JPanel(new GridLayout(2, 1)); // [cite: 384]
        JButton menuButton = new JButton("Menu"); // [cite: 385]
        JButton aiButton = new JButton("AI"); // [cite: 385]

        leftPanel.add(menuButton); // [cite: 385]
        leftPanel.add(aiButton); // [cite: 386]
        // 为 Menu 按钮添加 ActionListener // [cite: 386]
        menuButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Table"); // 切换到表格界面 // [cite: 386]
        });
        // 为 AI 按钮添加 ActionListener // [cite: 387]
        aiButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Histogram"); // 切换到直方图界面 // [cite: 387]
        });
        return leftPanel; // [cite: 388]
    }

    // Method to set up the right panel (Table/Histogram) - no changes needed here // [cite: 275]
    private void setupRightPanel() {
        // 创建搜索和表格的面板 // [cite: 388]
        JPanel tablePanel = createTablePanel(); // [cite: 389]
        // 将表格面板和直方图面板添加到 rightPanel // [cite: 389]
        rightPanel.add(tablePanel, "Table"); // [cite: 389]
        rightPanel.add(histogramPanelContainer, "Histogram"); // [cite: 390]
    }

    // Method to create the table // [cite: 275]
    // panel - update button editors/renderers to use 'this' MenuUI instance // [cite: 275]
    private JPanel createTablePanel() {
        JPanel tablePanel = new JPanel(new BorderLayout()); // [cite: 276]
        JPanel inputPanel = createInputPanel(); // [cite: 276]
        tablePanel.add(inputPanel, BorderLayout.NORTH); // [cite: 277]

        JScrollPane tableScrollPane = new JScrollPane(this.table); // [cite: 277]
        // Use 'this' // [cite: 277]
        tableScrollPane.setPreferredSize(new Dimension(1000, 250)); // [cite: 277]
        this.table.setRowHeight(30); // [cite: 278]
        // Use 'this' // [cite: 278]

        tablePanel.add(tableScrollPane, BorderLayout.CENTER); // [cite: 279]
        // Set cell renderers and editors - pass 'this' MenuUI instance // [cite: 279]
        this.table.getColumnModel().getColumn(11).setCellRenderer(new ButtonRenderer()); // [cite: 279]
        this.table.getColumnModel().getColumn(11).setCellEditor(new ButtonEditor(this)); // Pass 'this' // [cite: 280]

        this.table.getColumnModel().getColumn(12).setCellRenderer(new ButtonRenderer()); // [cite: 280]
        this.table.getColumnModel().getColumn(12).setCellEditor(new ButtonEditor(this)); // Pass 'this' // [cite: 281]

        // Data loading is now called in createMainPanel()

        return tablePanel; // [cite: 282]
    }

    // Method to create input panel - no changes needed here // [cite: 282]
    private JPanel createInputPanel() {
        JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10)); // [cite: 394]
        // 创建输入字段 // [cite: 395]
        JTextField transactionTimeField = new JTextField(10); // [cite: 395]
        // 交易时间输入框 // [cite: 396]
        JTextField transactionTypeField = new JTextField(10); // [cite: 396]
        // 交易类型输入框 // [cite: 397]
        JTextField counterpartyField = new JTextField(10); // [cite: 397]
        // 交易对方输入框 // [cite: 398]
        JTextField commodityField = new JTextField(10); // [cite: 398]
        // 商品输入框 // [cite: 399]
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"}); // [cite: 399]
        // 收/支下拉框 // [cite: 400]
        JTextField paymentMethodField = new JTextField(10); // [cite: 400]
        // 支付方式输入框 // [cite: 401]

        // 添加标签和输入字段到输入面板 // [cite: 401]
        inputPanel.add(new JLabel("交易时间:")); // [cite: 402]
        inputPanel.add(transactionTimeField); // [cite: 402]
        inputPanel.add(new JLabel("交易类型:")); // [cite: 402]
        inputPanel.add(transactionTypeField); // [cite: 402]
        inputPanel.add(new JLabel("交易对方:")); // [cite: 402]
        inputPanel.add(counterpartyField); // [cite: 402]
        inputPanel.add(new JLabel("商品:")); // [cite: 403]
        inputPanel.add(commodityField); // [cite: 403]
        inputPanel.add(new JLabel("收/支:")); // [cite: 403]
        inputPanel.add(inOutComboBox); // [cite: 403]
        inputPanel.add(new JLabel("支付方式:")); // [cite: 403]
        inputPanel.add(paymentMethodField); // [cite: 403]
        // 创建 Search 和 Add 按钮 // [cite: 403]
        JButton searchButton = new JButton("Search"); // [cite: 404]
        JButton addButton = new JButton("Add"); // [cite: 404]

        // 将按钮添加到输入面板 // [cite: 404]
        inputPanel.add(searchButton); // [cite: 404]
        inputPanel.add(addButton); // [cite: 405]
        // 为 Search 按钮添加 ActionListener // [cite: 405]
        searchButton.addActionListener(e -> {
            // 获取输入字段的值 // [cite: 405]
            searchData(
                    transactionTimeField.getText().trim(), // [cite: 406]
                    transactionTypeField.getText().trim(), // [cite: 406]
                    counterpartyField.getText().trim(), // [cite: 406]
                    commodityField.getText().trim(), // [cite: 406]
                    (String) inOutComboBox.getSelectedItem(), // [cite: 406]
                    paymentMethodField.getText().trim() // [cite: 406]
            );
        });
        // 为 Add 按钮添加 ActionListener // [cite: 407]
        addButton.addActionListener(e -> {
            // 弹出对话框，输入交易信息 // [cite: 407]
            showAddTransactionDialog(); // [cite: 407]
        });
        return inputPanel; // [cite: 408]
    }

    // Method to show add transaction dialog - update to use injected service // [cite: 282]
    private void showAddTransactionDialog() {
        JDialog addDialog = new JDialog(); // [cite: 283]
        addDialog.setTitle("添加交易"); // [cite: 283]
        addDialog.setLayout(new GridLayout(12, 2)); // 11 fields + 1 button row // [cite: 283]
        // ... create fields ...
        // Add labels and fields...

        // Create input fields for the dialog
        JTextField transactionTimeField = new JTextField(); // [cite: 409]
        JTextField transactionTypeField = new JTextField(); // [cite: 410]
        JTextField counterpartyField = new JTextField(); // [cite: 410]
        JTextField commodityField = new JTextField(); // [cite: 410]
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"}); // [cite: 411]
        JTextField paymentAmountField = new JTextField(); // [cite: 411]
        JTextField paymentMethodField = new JTextField(); // [cite: 411]
        JTextField currentStatusField = new JTextField(); // [cite: 412]
        JTextField orderNumberField = new JTextField(); // [cite: 412]
        JTextField merchantNumberField = new JTextField(); // [cite: 412]
        JTextField remarksField = new JTextField(); // [cite: 412]

        // Add labels and input fields to the dialog // [cite: 413]
        addDialog.add(new JLabel("交易时间:")); // [cite: 413]
        addDialog.add(transactionTimeField); // [cite: 413]
        addDialog.add(new JLabel("交易类型:")); // [cite: 413]
        addDialog.add(transactionTypeField); // [cite: 413]
        addDialog.add(new JLabel("交易对方:")); // [cite: 413]
        addDialog.add(counterpartyField); // [cite: 413]
        addDialog.add(new JLabel("商品:")); // [cite: 414]
        addDialog.add(commodityField); // [cite: 414]
        addDialog.add(new JLabel("收/支:")); // [cite: 414]
        addDialog.add(inOutComboBox); // [cite: 414]
        addDialog.add(new JLabel("金额(元):")); // [cite: 414]
        addDialog.add(paymentAmountField); // [cite: 414]
        addDialog.add(new JLabel("支付方式:")); // [cite: 414]
        addDialog.add(paymentMethodField); // [cite: 414]
        addDialog.add(new JLabel("当前状态:")); // [cite: 415]
        addDialog.add(currentStatusField); // [cite: 415]
        addDialog.add(new JLabel("交易单号:")); // [cite: 415]
        addDialog.add(orderNumberField); // [cite: 415]
        addDialog.add(new JLabel("商户单号:")); // [cite: 415]
        addDialog.add(merchantNumberField); // [cite: 415]
        addDialog.add(new JLabel("备注:")); // [cite: 415]
        addDialog.add(remarksField); // [cite: 415]

        // Add confirm button // [cite: 284]
        JButton confirmButton = new JButton("确认"); // [cite: 284]
        confirmButton.addActionListener(e -> {
            // ... get field values ...
            String paymentAmountText = paymentAmountField.getText().trim(); // [cite: 284]
            double paymentAmount = 0.0; // Default to 0.0 // [cite: 284]
            if (!paymentAmountText.isEmpty()) { // [cite: 284]
                try { // [cite: 285]
                    paymentAmount = Double.parseDouble(paymentAmountText); // [cite: 285]
                } catch (NumberFormatException ex) {
                    JOptionPane.showMessageDialog(addDialog, "金额格式不正确！请输入数字。", "输入错误", JOptionPane.ERROR_MESSAGE); // [cite: 285]
                    return; // Stop processing if amount is invalid // [cite: 286]
                }
            }

            // Create Transaction object // [cite: 286]
            Transaction newTransaction = new Transaction( // [cite: 287]
                    emptyIfNull(transactionTimeField.getText().trim()), // [cite: 287]
                    emptyIfNull(transactionTypeField.getText().trim()), // [cite: 287]
                    emptyIfNull(counterpartyField.getText().trim()), // [cite: 288]
                    emptyIfNull(commodityField.getText().trim()), // [cite: 288]
                    (String) inOutComboBox.getSelectedItem(), // [cite: 288]
                    paymentAmount, // [cite: 288]
                    emptyIfNull(paymentMethodField.getText().trim()), // [cite: 289]
                    emptyIfNull(currentStatusField.getText().trim()), // [cite: 289]
                    emptyIfNull(orderNumberField.getText().trim()), // Ensure order number is provided if it's the key // [cite: 289]
                    emptyIfNull(merchantNumberField.getText().trim()), // [cite: 289]
                    emptyIfNull(remarksField.getText().trim()) // [cite: 290]
            );
            // Basic validation for order number if it's the primary key // [cite: 290]
            if (newTransaction.getOrderNumber().isEmpty()) { // [cite: 290]
                JOptionPane.showMessageDialog(addDialog, "交易单号不能为空！", "输入错误", JOptionPane.ERROR_MESSAGE); // [cite: 291]
                return; // Stop if order number is missing // [cite: 291]
            }

            try {
                // Use the injected transactionService instance // [cite: 291]
                transactionService.addTransaction(newTransaction); // [cite: 292]
                // Reload CSV data to update the table for the current user // [cite: 292]
                loadCSVDataForCurrentUser(); // [cite: 292]
                // Reload data after add // [cite: 293]

                addDialog.dispose(); // [cite: 293]
                JOptionPane.showMessageDialog(null, "交易添加成功！", "提示", JOptionPane.INFORMATION_MESSAGE); // [cite: 294]
            } catch (IOException ex) {
                ex.printStackTrace(); // [cite: 294]
                JOptionPane.showMessageDialog(null, "交易添加失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE); // [cite: 295]
            }
        });
        // ... add components to dialog ...
        addDialog.add(confirmButton); // [cite: 296]
        // Set dialog size and visibility
        addDialog.setSize(400, 300); // [cite: 426]
        addDialog.setModal(true); // [cite: 426]
        // Set as modal dialog // [cite: 427]
        addDialog.setVisible(true); // [cite: 427]
    }


    // Method to search data - update to use injected service // [cite: 297]
    public void searchData(String query1, String query2, String query3, String query4, String query6, String query5) {
        this.tableModel.setRowCount(0); // [cite: 297]
        // Use 'this' // [cite: 298]
        // Create search criteria Transaction object // [cite: 298]
        Transaction searchCriteria = new Transaction(
                query1, query2, query3, query4, query6, // [cite: 298]
                0, // paymentAmount is not used in search criteria based on MenuUI input fields // [cite: 299]
                query5, // [cite: 299]
                "", "", "", "" // [cite: 299]
        );
        try { // [cite: 300]
            // Use the injected transactionService instance // [cite: 300]
            List<Transaction> transactions = transactionService.searchTransaction(searchCriteria); // [cite: 300]
            for (Transaction transaction : transactions) {
                Vector<String> row = createRowFromTransaction(transaction); // [cite: 301]
                this.tableModel.addRow(row); // Use 'this' // [cite: 302]
            }
            System.out.println("Search completed. Displaying " + transactions.size() + " results."); // [cite: 302]
        } catch (Exception ex) { // searchTransaction can throw Exception from cache loading // [cite: 303]
            ex.printStackTrace(); // [cite: 303]
            JOptionPane.showMessageDialog(null, "查询失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE); // [cite: 304]
        }
    }

    // Method to create table row from Transaction object - no changes needed here // [cite: 304]
    private Vector<String> createRowFromTransaction(Transaction transaction) {
        Vector<String> row = new Vector<>(); // [cite: 436]
        row.add(transaction.getTransactionTime()); // [cite: 437]
        row.add(transaction.getTransactionType()); // [cite: 437]
        row.add(transaction.getCounterparty()); // [cite: 437]
        row.add(transaction.getCommodity()); // [cite: 437]
        row.add(transaction.getInOut()); // [cite: 437]
        row.add(String.valueOf(transaction.getPaymentAmount())); // [cite: 437]
        row.add(transaction.getPaymentMethod()); // [cite: 437]
        row.add(transaction.getCurrentStatus()); // [cite: 438]
        row.add(transaction.getOrderNumber()); // [cite: 438]
        row.add(transaction.getMerchantNumber()); // [cite: 438]
        row.add(transaction.getRemarks()); // [cite: 438]
        row.add("Modify"); // [cite: 438]
        // Modify 按钮 // [cite: 438]
        row.add("Delete"); // [cite: 439]
        // 添加 Delete 按钮 // [cite: 439]
        return row; // [cite: 440]
    }

    // Method to delete row - update to use injected service // [cite: 304]
    public void deleteRow(int rowIndex) {
        if (rowIndex >= 0 && rowIndex < this.allData.size()) { // Use 'this' for allData // [cite: 305]
            String orderNumber = this.allData.get(rowIndex).get(8).trim(); // [cite: 305]
            // Use 'this' // [cite: 306]
            System.out.println("尝试删除的交易单号: " + orderNumber + " for user " + currentUser.getUsername()); // [cite: 306]
            try {
                // Use the injected transactionService instance // [cite: 307]
                boolean deleted = transactionService.deleteTransaction(orderNumber); // [cite: 307]
                if (deleted) { // [cite: 308]
                    // Data is removed from CSV and cache invalidated by service. // [cite: 308]
                    // Now update the UI model. // [cite: 309]
                    // Removing directly from allData and tableModel is acceptable here // [cite: 309]
                    // as loadCSVDataForCurrentUser() reloads from the single source of truth (cache/file). // [cite: 310]
                    // However, if allData is meant to be the in-memory representation used by search, // [cite: 310]
                    // it should be updated consistently. // [cite: 311]
                    // For simplicity and consistency with reloading, let's just reload the UI data. // [cite: 311]
                    loadCSVDataForCurrentUser(); // [cite: 311]
                    // Reload data after delete // [cite: 312]
                    // Alternatively, remove from allData and tableModel directly if allData is kept in sync. // [cite: 312]
                    // this.allData.remove(rowIndex); // If keeping allData perfectly in sync // [cite: 313]
                    // this.tableModel.removeRow(rowIndex); // [cite: 314]
                    // If keeping tableModel perfectly in sync // [cite: 314]


                    JOptionPane.showMessageDialog(null, "删除成功！", "提示", JOptionPane.INFORMATION_MESSAGE); // [cite: 314]
                    System.out.println("Deleted row " + rowIndex + " with order number " + orderNumber); // [cite: 315]
                } else {
                    // This case should be handled by the service throwing an exception or returning false. // [cite: 316]
                    JOptionPane.showMessageDialog(null, "删除失败：未找到对应的交易单号 " + orderNumber, "错误", JOptionPane.ERROR_MESSAGE); // [cite: 317]
                    System.err.println("Delete failed: order number " + orderNumber + " not found."); // [cite: 317]
                }
            } catch (Exception ex) { // deleteTransaction can throw Exception // [cite: 318]
                ex.printStackTrace(); // [cite: 318]
                JOptionPane.showMessageDialog(null, "删除失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE); // [cite: 319]
                System.err.println("Error during deletion for order number " + orderNumber); // [cite: 319]
            }
        } else {
            System.err.println("Attempted to delete row with invalid index: " + rowIndex); // [cite: 320]
        }
    }

    // Method to edit row - update to use injected service // [cite: 321]
    public void editRow(int rowIndex) {
        System.out.println("编辑行: " + rowIndex + " for user " + currentUser.getUsername()); // [cite: 321]
        if (rowIndex >= 0 && rowIndex < this.allData.size()) { // Use 'this' for allData // [cite: 322]
            Vector<String> rowData = new Vector<>(this.allData.get(rowIndex)); // [cite: 322]
            // Use 'this', create a copy // [cite: 323]


            // Create a panel for edit fields // [cite: 323]
            JPanel panel = new JPanel(new GridLayout(rowData.size() - 2, 2)); // [cite: 324]
            // Exclude last two columns ("Modify", "Delete") // [cite: 324]

            // Create fields array // [cite: 324]
            JTextField[] fields = new JTextField[rowData.size() - 2]; // [cite: 325]
            // Populate panel and fields from rowData, skipping last two columns // [cite: 325]
            for (int i = 0; i < rowData.size() - 2; i++) {
                panel.add(new JLabel(this.tableModel.getColumnName(i))); // [cite: 325]
                // Use 'this' // [cite: 326]
                fields[i] = new JTextField(rowData.get(i)); // [cite: 326]
                panel.add(fields[i]); // [cite: 327]
            }

            // Get the original order number, which is the key // [cite: 327]
            String originalOrderNumber = rowData.get(8).trim(); // [cite: 327]
            // Index 8 is OrderNumber // [cite: 328]


            // Show the dialog // [cite: 328]
            int result = JOptionPane.showConfirmDialog(null, panel, "修改交易信息 (订单号: " + originalOrderNumber + ")", JOptionPane.OK_CANCEL_OPTION); // [cite: 329]
            if (result == JOptionPane.OK_OPTION) {
                // User clicked OK, get updated values from fields // [cite: 329]

                // Create a Transaction object with updated values // [cite: 329]
                // Use the original order number as the key for the update operation // [cite: 330]
                Transaction updatedTransaction = new Transaction( // [cite: 330]
                        fields[0].getText().trim(), // 交易时间 // [cite: 330]
                        fields[1].getText().trim(), // 交易类型 // [cite: 331]
                        fields[2].getText().trim(), // 交易对方 // [cite: 331]
                        fields[3].getText().trim(), // 商品 // [cite: 331]
                        fields[4].getText().trim(), // 收/支 // [cite: 332]
                        // Handle paymentAmount parsing carefully // [cite: 332]
                        safeParseDouble(fields[5].getText().trim()), // 金额(元) - Use helper for parsing // [cite: 332]
                        fields[6].getText().trim(), // 支付方式 // [cite: 333]
                        fields[7].getText().trim(), // 当前状态 // [cite: 333]
                        originalOrderNumber, // Use the ORIGINAL order number as the identifier // [cite: 333]
                        fields[9].getText().trim(), // 商户单号 // [cite: 334]
                        fields[10].getText().trim() // 备注 // [cite: 334]
                );
                // Validate key fields if necessary (e.g., ensure OrderNumber wasn't changed in dialog implicitly) // [cite: 335]
                // If OrderNumber was editable, you'd need to handle the change, which is complex. // [cite: 336]
                // Assuming OrderNumber field in dialog is just for display/reference, or its change is handled separately. // [cite: 336]
                // If you want to allow changing OrderNumber, the updateTransaction logic in DAO needs adjustment // [cite: 337]
                // to delete the old and add with the new ON, which is tricky. // [cite: 337]
                // Let's assume OrderNumber is the stable key for updates. // [cite: 338]
                String dialogOrderNumber = fields[8].getText().trim(); // [cite: 338]
                if (!dialogOrderNumber.equals(originalOrderNumber)) { // [cite: 339]
                    System.err.println("Warning: Order number changed in edit dialog from '" + originalOrderNumber + "' to '" + dialogOrderNumber + "'. Using original ON for update."); // [cite: 339]
                    // Or handle this as an error: JOptionPane.showMessageDialog(null, "交易单号不允许修改！", "错误", JOptionPane.ERROR_MESSAGE); return; // [cite: 340]
                }
                // Ensure the updatedTransaction object uses the originalOrderNumber // [cite: 341]
                updatedTransaction.setOrderNumber(originalOrderNumber); // [cite: 341]
                try {
                    // Use the injected transactionService instance // [cite: 342]
                    transactionService.changeTransaction(updatedTransaction); // [cite: 342]
                    // Reload CSV data to update the table for the current user // [cite: 343]
                    loadCSVDataForCurrentUser(); // [cite: 343]
                    // Reload data after edit // [cite: 344]

                    JOptionPane.showMessageDialog(null, "修改成功！", "提示", JOptionPane.INFORMATION_MESSAGE); // [cite: 344]
                    System.out.println("Edited row " + rowIndex + " for order number " + originalOrderNumber); // [cite: 345]
                } catch (IllegalArgumentException e) {
                    // Catch specific exceptions from service, e.g., transaction not found // [cite: 346]
                    JOptionPane.showMessageDialog(null, "修改失败！\n" + e.getMessage(), "错误", JOptionPane.ERROR_MESSAGE); // [cite: 347]
                    e.printStackTrace(); // [cite: 347]
                }
                catch (Exception ex) { // Catch other exceptions from service // [cite: 347]
                    ex.printStackTrace(); // [cite: 348]
                    JOptionPane.showMessageDialog(null, "修改失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE); // [cite: 348]
                    System.err.println("Error during editing for order number " + originalOrderNumber); // [cite: 349]
                }
            }
        } else {
            System.err.println("Attempted to edit row with invalid index: " + rowIndex); // [cite: 350]
        }
    }

    // Helper method to safely parse double, return 0.0 on error // [cite: 350]
    private double safeParseDouble(String value) {
        if (value == null || value.trim().isEmpty()) { // [cite: 351]
            return 0.0; // [cite: 351]
        }
        try {
            return Double.parseDouble(value.trim()); // [cite: 352]
        } catch (NumberFormatException e) {
            System.err.println("Failed to parse double from string: '" + value + "'"); // [cite: 352]
            return 0.0; // Or handle as error // [cite: 353]
        }
    }

    // Keep helper methods like findTextField, findComboBox, emptyIfNull // [cite: 353]
    // Note: findTextField, findComboBox might be less reliable if dialog structure changes. // [cite: 354]
    // Consider making dialogs their own classes that return a Transaction object. // [cite: 354]
    /**
     * If field is null, return empty string. // [cite: 355]
     * @param value Field value // [cite: 356]
     * @return Non-null field value // [cite: 356]
     */
    private String emptyIfNull(String value) {
        return value == null ? "" : value; // [cite: 357]
    }

    // Keep getTable() for testing // [cite: 357]
    public JTable getTable() {
        return table; // [cite: 358]
    }

    // The findTextField and findComboBox methods that were in pre.txt but missing in post.txt
    /**
     * 查找容器中的输入字段
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0; // [cite: 469]
        for (Component component : container.getComponents()) { // [cite: 470]
            if (component instanceof JTextField) { // [cite: 470]
                if (count == index) { // [cite: 470]
                    return (JTextField) component; // [cite: 471]
                }
                count++; // [cite: 472]
            }
        }
        return null; // [cite: 473]
    }

    /**
     * 查找容器中的下拉框
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) { // [cite: 474]
            if (component instanceof JComboBox) { // [cite: 474]
                return (JComboBox<String>) component; // [cite: 475]
            }
        }
        return null; // [cite: 476]
    }
}
```