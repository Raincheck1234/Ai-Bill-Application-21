Project Path: Ai-Bill-Application-Group211

Source Tree:

```txt
新建 WinRAR ZIP 压缩文件(2)
├── Ai-Bill-Application-Group211
│   ├── AITestt.java
│   ├── Ai Bill Application
│   │   ├── HistogramPanelContainer.java
│   │   ├── pom.xml
│   │   └── src
│   │       ├── main
│   │       │   ├── java
│   │       │   │   ├── Constants
│   │       │   │   │   ├── CaffeineKeys.java
│   │       │   │   │   ├── ConfigConstants.java
│   │       │   │   │   └── StandardCategories.java
│   │       │   │   ├── Controller
│   │       │   │   │   ├── ButtonEditor.java
│   │       │   │   │   ├── ButtonRenderer.java
│   │       │   │   │   ├── HistogramExample.java
│   │       │   │   │   ├── HistogramPanelContainer.java
│   │       │   │   │   ├── MenuUI.java
│   │       │   │   │   └── VisualizationPanel.java
│   │       │   │   ├── DAO
│   │       │   │   │   ├── Impl
│   │       │   │   │   │   ├── CsvSummaryStatisticDao.java
│   │       │   │   │   │   ├── CsvTransactionDao.java
│   │       │   │   │   │   └── CsvUserDao.java
│   │       │   │   │   ├── SummaryStatisticDao.java
│   │       │   │   │   ├── TransactionDao.java
│   │       │   │   │   └── UserDao.java
│   │       │   │   ├── Interceptor
│   │       │   │   │   └── Login
│   │       │   │   │       └── LoginDialog.java
│   │       │   │   ├── Main.java
│   │       │   │   ├── Service
│   │       │   │   │   ├── AIservice
│   │       │   │   │   │   ├── AIAnalyzerThread.java
│   │       │   │   │   │   ├── AITransactionService.java
│   │       │   │   │   │   ├── ColledgeStudentThread.java
│   │       │   │   │   │   └── CollegeStudentNeeds.java
│   │       │   │   │   ├── Impl
│   │       │   │   │   │   ├── SummaryStatisticService.java
│   │       │   │   │   │   └── TransactionServiceImpl.java
│   │       │   │   │   ├── TransactionService.java
│   │       │   │   │   ├── User
│   │       │   │   │   │   └── UserService.java
│   │       │   │   │   └── deepseek
│   │       │   │   │       └── ChatCompletionsExample.java
│   │       │   │   ├── Utils
│   │       │   │   │   ├── CacheManager.java
│   │       │   │   │   └── CacheUtil.java
│   │       │   │   └── model
│   │       │   │       ├── MonthlySummary.java
│   │       │   │       ├── SummaryStatistic.java
│   │       │   │       ├── Transaction.java
│   │       │   │       └── User.java
│   │       │   └── resources
│   │       │       ├── CSVForm
│   │       │       │   ├── stats
│   │       │       │   │   └── summary_statistics.csv
│   │       │       │   ├── transactions
│   │       │       │   │   ├── admin_transactions.csv
│   │       │       │   │   ├── user1_transactions.csv
│   │       │       │   │   └── user2_transactions.csv
│   │       │       │   └── users
│   │       │       │       └── users.csv
│   │       │       └── config.properties
│   │       └── test
│   │           ├── java
│   │           │   ├── Controller
│   │           │   │   ├── ButtonEditorTest.java
│   │           │   │   ├── ButtonRendererTest.java
│   │           │   │   ├── HistogramPanelContainerTest.java
│   │           │   │   ├── MenuUITest.java
│   │           │   │   └── VisualizationPanelTest.java
│   │           │   ├── DAO
│   │           │   │   └── Impl
│   │           │   │       ├── CsvSummaryStatisticDaoTest.java
│   │           │   │       ├── CsvTransactionDaoTest.java
│   │           │   │       └── CsvUserDaoTest.java
│   │           │   ├── DAOTest
│   │           │   │   └── CsvTransactionDaoTest.java
│   │           │   ├── Service
│   │           │   │   ├── AIAnalyzerThreadTest.java
│   │           │   │   ├── AIservice
│   │           │   │   │   ├── AIAnalyzerThreadTest.java
│   │           │   │   │   ├── AITransactionServiceTest.java
│   │           │   │   │   ├── ColledgeStudentThreadTest.java
│   │           │   │   │   └── CollegeStudentNeedsTest.java
│   │           │   │   ├── AIserviceTest.java
│   │           │   │   ├── AiFunctionTest.java
│   │           │   │   ├── CacheTest.java
│   │           │   │   ├── CollegeStudentNeedsTest.java
│   │           │   │   ├── Impl
│   │           │   │   │   ├── SummaryStatisticServiceTest.java
│   │           │   │   │   └── TransactionServiceImplTest.java
│   │           │   │   ├── TransactionServiceTest.java
│   │           │   │   └── User
│   │           │   │       └── UserServiceTest.java
│   │           │   └── Utils
│   │           │       └── CacheManagerTest.java
│   │           └── resources
│   │               ├── CSVForm
│   │               │   ├── stats
│   │               │   │   └── summary_statistics.csv
│   │               │   ├── transactions
│   │               │   │   ├── admin_transactions.csv
│   │               │   │   ├── user1_transactions.csv
│   │               │   │   └── user2_transactions.csv
│   │               │   └── users
│   │               │       └── users.csv
│   │               └── config.properties
│   ├── Ai-Bill-Application-Prompt.txt
│   ├── Ai-Bill-Application-Prompt_2.txt
│   ├── HistogramPanelContainer.java
│   ├── Individual Contribution.docx
│   ├── Individual Contribution.txt
│   ├── README.md
│   ├── README.txt
│   ├── img.png
│   ├── 开发文档.docx
│   └── 项目要求.txt
└── Ai-Bill-Application-Group211 - 副本
    ├── AITestt.java
    ├── Ai Bill Application
    │   ├── HistogramPanelContainer.java
    │   ├── pom.xml
    │   └── src
    │       ├── main
    │       │   ├── java
    │       │   │   ├── Constants
    │       │   │   │   ├── CaffeineKeys.java
    │       │   │   │   ├── ConfigConstants.java
    │       │   │   │   └── StandardCategories.java
    │       │   │   ├── Controller
    │       │   │   │   ├── ButtonEditor.java
    │       │   │   │   ├── ButtonRenderer.java
    │       │   │   │   ├── HistogramExample.java
    │       │   │   │   ├── HistogramPanelContainer.java
    │       │   │   │   ├── MenuUI.java
    │       │   │   │   └── VisualizationPanel.java
    │       │   │   ├── DAO
    │       │   │   │   ├── Impl
    │       │   │   │   │   ├── CsvSummaryStatisticDao.java
    │       │   │   │   │   ├── CsvTransactionDao.java
    │       │   │   │   │   └── CsvUserDao.java
    │       │   │   │   ├── SummaryStatisticDao.java
    │       │   │   │   ├── TransactionDao.java
    │       │   │   │   └── UserDao.java
    │       │   │   ├── Interceptor
    │       │   │   │   └── Login
    │       │   │   │       └── LoginDialog.java
    │       │   │   ├── Main.java
    │       │   │   ├── Service
    │       │   │   │   ├── AIservice
    │       │   │   │   │   ├── AIAnalyzerThread.java
    │       │   │   │   │   ├── AITransactionService.java
    │       │   │   │   │   ├── ColledgeStudentThread.java
    │       │   │   │   │   └── CollegeStudentNeeds.java
    │       │   │   │   ├── Impl
    │       │   │   │   │   ├── SummaryStatisticService.java
    │       │   │   │   │   └── TransactionServiceImpl.java
    │       │   │   │   ├── TransactionService.java
    │       │   │   │   ├── User
    │       │   │   │   │   └── UserService.java
    │       │   │   │   └── deepseek
    │       │   │   │       └── ChatCompletionsExample.java
    │       │   │   ├── Utils
    │       │   │   │   ├── CacheManager.java
    │       │   │   │   └── CacheUtil.java
    │       │   │   └── model
    │       │   │       ├── MonthlySummary.java
    │       │   │       ├── SummaryStatistic.java
    │       │   │       ├── Transaction.java
    │       │   │       └── User.java
    │       │   └── resources
    │       │       ├── CSVForm
    │       │       │   ├── stats
    │       │       │   │   └── summary_statistics.csv
    │       │       │   ├── transactions
    │       │       │   │   ├── admin_transactions.csv
    │       │       │   │   ├── user1_transactions.csv
    │       │       │   │   └── user2_transactions.csv
    │       │       │   └── users
    │       │       │       └── users.csv
    │       │       └── config.properties
    │       └── test
    │           ├── java
    │           │   ├── Controller
    │           │   │   ├── ButtonEditorTest.java
    │           │   │   ├── ButtonRendererTest.java
    │           │   │   ├── HistogramPanelContainerTest.java
    │           │   │   ├── MenuUITest.java
    │           │   │   └── VisualizationPanelTest.java
    │           │   ├── DAO
    │           │   │   └── Impl
    │           │   │       ├── CsvSummaryStatisticDaoTest.java
    │           │   │       ├── CsvTransactionDaoTest.java
    │           │   │       └── CsvUserDaoTest.java
    │           │   ├── DAOTest
    │           │   │   └── CsvTransactionDaoTest.java
    │           │   ├── Service
    │           │   │   ├── AIAnalyzerThreadTest.java
    │           │   │   ├── AIservice
    │           │   │   │   ├── AIAnalyzerThreadTest.java
    │           │   │   │   ├── AITransactionServiceTest.java
    │           │   │   │   ├── ColledgeStudentThreadTest.java
    │           │   │   │   └── CollegeStudentNeedsTest.java
    │           │   │   ├── AIserviceTest.java
    │           │   │   ├── AiFunctionTest.java
    │           │   │   ├── CacheTest.java
    │           │   │   ├── CollegeStudentNeedsTest.java
    │           │   │   ├── Impl
    │           │   │   │   ├── SummaryStatisticServiceTest.java
    │           │   │   │   └── TransactionServiceImplTest.java
    │           │   │   ├── TransactionServiceTest.java
    │           │   │   └── User
    │           │   │       └── UserServiceTest.java
    │           │   └── Utils
    │           │       └── CacheManagerTest.java
    │           └── resources
    │               ├── CSVForm
    │               │   ├── stats
    │               │   │   └── summary_statistics.csv
    │               │   ├── transactions
    │               │   │   ├── admin_transactions.csv
    │               │   │   ├── user1_transactions.csv
    │               │   │   └── user2_transactions.csv
    │               │   └── users
    │               │       └── users.csv
    │               └── config.properties
    ├── Ai-Bill-Application-Prompt.txt
    ├── Ai-Bill-Application-Prompt_2.txt
    ├── HistogramPanelContainer.java
    ├── Individual Contribution.docx
    ├── Individual Contribution.txt
    ├── README.md
    ├── README.txt
    ├── img.png
    ├── 开发文档.docx
    └── 项目要求.txt

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\AITestt.java`:

```java
package ControllerTest;

import Controller.HistogramPanelContainer;

import javax.swing.*;

public class AITestt {
    public static void main(String[] args) {
        // 设置外观为系统默认
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (Exception e) {
            e.printStackTrace();
        }

        // 创建窗口
        JFrame frame = new JFrame("Histogram Panel 测试");
        HistogramPanelContainer container = new HistogramPanelContainer();

        // 使用 SwingUtilities.invokeAndWait 来确保 UI 线程安全
        SwingUtilities.invokeLater(() -> {
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(1000, 600);
            frame.setContentPane(container);
            frame.setVisible(true);

            // 模拟调用 AI 结果（这里你可以改成真实的文件路径和参数）
            container.analyzeTransactionsInBackground(
                    "请分析交易中的异常模式",
                    "data/transactions.csv",  // 确保路径存在或替换为你实际的测试路径
                    "2022-01-01",
                    "2023-01-01"
            );
        });

        // 你可以适当的加入等待时间来保证后台线程有足够的时间完成
        try {
            Thread.sleep(3000);  // 等待 3 秒钟，以确保后台任务执行完毕（根据实际情况调整时间）
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>Ai-bill</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>com.formdev</groupId>
            <artifactId>flatlaf</artifactId>
            <version>3.6</version>
        </dependency>
        <dependency>
            <groupId>org.knowm.xchart</groupId>
            <artifactId>xchart</artifactId>
            <version>3.8.4</version> <!-- Use the latest version -->
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.2</version>
            <scope>test</scope>
        </dependency>

        <!-- CSV 解析核心库 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-csv</artifactId>
            <version>1.10.0</version>
        </dependency>

        <!-- 文件操作工具 -->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>2.15.1</version>
        </dependency>

        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>5.10.0</version>
            <scope>test</scope>
        </dependency>

        <!-- 断言增强库 -->
        <dependency>
            <groupId>org.assertj</groupId>
            <artifactId>assertj-core</artifactId>
            <version>3.24.2</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.volcengine</groupId>
            <artifactId>volcengine-java-sdk-ark-runtime</artifactId>
            <version>LATEST</version>
        </dependency>
        <dependency>
            <groupId>javax.annotation</groupId>
            <artifactId>javax.annotation-api</artifactId>
            <version>1.3.2</version>
        </dependency>
        <!-- pom.xml -->



        <!-- JSON 处理 -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.15.2</version>
        </dependency>

        <!--        caffeine缓存中间件-->
        <dependency>
            <groupId>com.github.ben-manes.caffeine</groupId>
            <artifactId>caffeine</artifactId>
            <version>3.1.8</version> <!-- 使用最新版本 -->
        </dependency>

    </dependencies>

</project>
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Constants\CaffeineKeys.java`:

```java
package Constants;

public class CaffeineKeys {
    public static final String TRANSACTION_CAFFEINE_KEY = "transactions";

}

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Constants\ConfigConstants.java`:

```java
package Constants;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

/**
 * Configuration Constants Class (Thread-safe initialization)
 */
public final class ConfigConstants {
    private ConfigConstants() {} // Private constructor to prevent instantiation

    // CSV Path Constants
    public static final String CSV_PATH; // Original, may still be referenced in old code
    public static final String USERS_CSV_PATH; // User CSV path
    public static final String SUMMARY_CSV_PATH; // Added summary statistics CSV path


    // Static initialization block (executes when the class is loaded)
    static {
        Properties prop = new Properties();
        try (InputStream input = ConfigConstants.class.getClassLoader()
                .getResourceAsStream("config.properties")) {

            if (input == null) {
                throw new RuntimeException("Configuration file config.properties not found in classpath");
            }

            prop.load(input);

            CSV_PATH = prop.getProperty("csv.path");
            USERS_CSV_PATH = prop.getProperty("csv.users_path");
            SUMMARY_CSV_PATH = prop.getProperty("csv.summary_path"); // Read summary statistics CSV path


            // Basic validation
            if (USERS_CSV_PATH == null || USERS_CSV_PATH.trim().isEmpty()) {
                throw new RuntimeException("'csv.users_path' not found or is empty in config.properties.");
            }
            if (SUMMARY_CSV_PATH == null || SUMMARY_CSV_PATH.trim().isEmpty()) {
                throw new RuntimeException("'csv.summary_path' not found or is empty in config.properties.");
            }

        } catch (IOException e) {
            throw new RuntimeException("Failed to load configuration file", e); // Convert to runtime exception
        }
        System.out.println("Loaded USERS_CSV_PATH: " + USERS_CSV_PATH);
        System.out.println("Loaded SUMMARY_CSV_PATH: " + SUMMARY_CSV_PATH);
        if (CSV_PATH != null) System.out.println("Loaded CSV_PATH: " + CSV_PATH); // Optional print
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Constants\StandardCategories.java`:

```java
package Constants;

import java.util.List;
import java.util.ArrayList;
import java.util.Collections; // For immutable lists
import java.util.stream.Collectors;

public final class StandardCategories {
    private StandardCategories() {} // Prevent instantiation

    // Standard Expense Categories for analysis and filtering
    public static final List<String> EXPENSE_CATEGORIES = Collections.unmodifiableList(List.of(
            "Dining",
            "Groceries",
            "Clothing",
            "Daily Necessities",
            "Transportation",
            "Entertainment",
            "Housing",
            "Communication",
            "Education",
            "Medical",
            "Financial Services",
            "Other Expenses"      //  General catch-all for expenses
    ));

    // Standard Income Categories
    public static final List<String> INCOME_CATEGORIES = Collections.unmodifiableList(List.of(
            "Salary",
            "Part-time Income",
            "Investment Income",
            "Other Income"        //  General catch-all for income
    ));

    // Special Transaction Types (may not be strictly 'expense' or 'income' in analysis)
    public static final List<String> SPECIAL_TYPES = Collections.unmodifiableList(List.of(
            "Transfer",           //  Transfers between accounts or people
            "Red Packet"          //  WeChat/Alipay Red Packets - often social, not regular income/expense
            // Add other special types as needed, e.g., Refund, Credit Card Repayment
    ));

    /**
     * Generates a comma-separated string of all standard categories for AI prompts.
     * @return String like "Dining,Groceries,Clothing,..."
     */
    public static String getAllCategoriesString() {
        return ALL_KNOWN_TYPES.stream()
                .collect(Collectors.joining(","));
    }

    // All Known Transaction Types (combination of all the above + potentially user-defined ones initially)
    // This list might be used for dropdowns in UI, etc.
    public static final List<String> ALL_KNOWN_TYPES;

    static {
        List<String> allTypesMutable = new ArrayList<>();
        allTypesMutable.addAll(EXPENSE_CATEGORIES);
        allTypesMutable.addAll(INCOME_CATEGORIES);
        allTypesMutable.addAll(SPECIAL_TYPES);
        ALL_KNOWN_TYPES = Collections.unmodifiableList(allTypesMutable);
    }


    /**
     * Helper method to check if a transaction type is a standard expense category.
     * Handles potential variations like "支" vs "支出".
     */
    public static boolean isStandardExpenseCategory(String type) {
        if (type == null) return false;
        String trimmedType = type.trim();
        // First, check if it's directly in the list
        if (EXPENSE_CATEGORIES.contains(trimmedType)) {
            return true;
        }
        // Handle common aliases/variations if necessary, e.g., "交通费" -> "交通"
        // This might require a mapping logic if aliases are common and not handled by AI mapping.
        return false; // For now, strict check
    }

    /**
     * Helper method to get the standardized category for a given transaction type string.
     * This is where mapping from potentially messy user input or AI output to standard categories happens.
     * For now, a simple direct match is used. In the future, this could use AI recognition results
     * or manual mapping rules.
     * @param rawType The transaction type string from data.
     * @return The matched standard category, or the original rawType if no standard match, or "Unknown" for null/empty.
     */
    public static String getStandardCategory(String rawType) {
        if (rawType == null || rawType.trim().isEmpty()) {
            return "Unknown"; // Unknown category
        }
        String trimmedType = rawType.trim();
        // Check if it matches any standard category (case-insensitive might be better)
        // Let's do a simple case-sensitive check for now against the predefined lists.
        if (ALL_KNOWN_TYPES.contains(trimmedType)) {
            return trimmedType; // Direct match
        }

        // Future Improvement: Implement smarter mapping here, potentially using AI suggestions
        // or a configuration file for mapping common user inputs to standard categories.


        return trimmedType; // If no standard match, return the original type.
        // We might want a dedicated "Other" if it doesn't fit any *known* type.
    }

    /**
     * Helper method to check if a transaction type is a standard income category.
     */
    public static boolean isStandardIncomeCategory(String type) {
        if (type == null) return false;
        return INCOME_CATEGORIES.contains(type.trim());
    }

    /**
     * Helper method to check if a transaction type is a special type.
     */
    public static boolean isSpecialType(String type) {
        if (type == null) return false;
        return SPECIAL_TYPES.contains(type.trim());
    }


}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Controller\ButtonEditor.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.TableCellEditor;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

class ButtonEditor extends AbstractCellEditor implements TableCellEditor {
    private final JPanel panel = new JPanel(new BorderLayout()); // Use BorderLayout
    private final JButton button = new JButton();
    private int rowIndex;
    private final MenuUI menuUI;

    public ButtonEditor(MenuUI menuUI) {
        this.menuUI = menuUI;

        // Set button style
        button.setFocusPainted(false); // Remove focus border from button
        button.setPreferredSize(new Dimension(80, 30)); // Set fixed size for the button

        // Add button to panel
        panel.add(button, BorderLayout.CENTER);

        // Add action listener to the button
        button.addActionListener(e -> {
            System.out.println("Button click event triggered: " + button.getText()); // "按钮点击事件触发: "
            fireEditingStopped(); // Stop editing
            String buttonText = button.getText();
            if ("Modify".equals(buttonText)) {
                menuUI.editRow(rowIndex); // Call MenuUI's editRow method
            } else if ("Delete".equals(buttonText)) {
                int confirm = JOptionPane.showConfirmDialog(panel, "Are you sure you want to delete this row?", "Confirm Delete", JOptionPane.YES_NO_OPTION); // "Are you sure you want to delete this row?", "Confirm deletion"
                if (confirm == JOptionPane.YES_OPTION) {
                    menuUI.deleteRow(rowIndex); // Call MenuUI's deleteRow method
                }
            }
        });
    }

    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
        this.rowIndex = row; // Update current row index
        button.setText(value != null ? value.toString() : ""); // Set button text based on cell value
        return panel;
    }

    @Override
    public Object getCellEditorValue() {
        return button.getText(); // Return the current text of the button
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Controller\ButtonRenderer.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import java.awt.*;

class ButtonRenderer extends DefaultTableCellRenderer {
    private final JPanel panel = new JPanel(new BorderLayout()); // Use BorderLayout
    private final JButton button = new JButton();

    public ButtonRenderer() {
        button.setFocusPainted(false); // Remove focus border from button
        button.setPreferredSize(new Dimension(80, 30)); // Set fixed size for the button
        panel.add(button, BorderLayout.CENTER); // Add button to the panel center
    }

    @Override
    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
        // Set button text based on cell value
        button.setText(value != null ? value.toString() : "");
        return panel;
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Controller\HistogramExample.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;
import java.util.HashMap;
import java.util.Random;

// Data Generation Class
class DataGenerator {
    public static int[] generateData(int numberOfDataPoints, int maxValue) {
        Random random = new Random();
        int[] data = new int[numberOfDataPoints];
        for (int i = 0; i < numberOfDataPoints; i++) {
            data[i] = random.nextInt(maxValue);
        }
        return data;
    }
}

// Histogram Calculation Class
class Histogram {
    private int binSize;
    private int[] data;

    public Histogram(int[] data, int binSize) {
        this.data = data;
        this.binSize = binSize;
    }

    public HashMap<Integer, Integer> computeFrequency() {
        HashMap<Integer, Integer> frequencyMap = new HashMap<>();
        for (int number : data) {
            int bin = number / binSize;
            frequencyMap.put(bin, frequencyMap.getOrDefault(bin, 0) + 1);
        }
        return frequencyMap;
    }
}

// Histogram GUI Drawing Class
class HistogramPanel extends JPanel {
    HashMap<Integer, Integer> frequencyMap;

    public HistogramPanel() {
        this.frequencyMap = new HashMap<>();
    }

    public void updateData(HashMap<Integer, Integer> frequencyMap) {
        this.frequencyMap = frequencyMap;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        int barWidth = 40;
        int gap = 10;
        int maxFrequency = frequencyMap.values().stream().mapToInt(v -> v).max().orElse(1);

        int index = 0;
        for (Integer key : frequencyMap.keySet()) {
            int height = (int) ((frequencyMap.get(key) / (double) maxFrequency) * getHeight());
            g.setColor(Color.BLUE);
            g.fillRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.setColor(Color.BLACK);
            g.drawRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.drawString("Bin " + key, index * (barWidth + gap) + 5, getHeight() - 5);
            index++;
        }
    }
}


// Main Window Class
public class HistogramExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("Data Analysis Interface"); // "数据分析界面"
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            // Assuming HistogramPanelContainer is defined elsewhere or if it's a typo and should be HistogramPanel
            // If HistogramPanelContainer is a separate class, its content is not provided for translation.
            // For now, I'll assume it might be a placeholder for HistogramPanel or a similar container.
            // If HistogramPanel itself is to be added:
            // HistogramPanel histogramPanel = new HistogramPanel();
            // // Example data for histogram (if not loaded through a container)
            // int[] data = DataGenerator.generateData(100, 100);
            // Histogram histogram = new Histogram(data, 10);
            // histogramPanel.updateData(histogram.computeFrequency());
            // frame.add(histogramPanel);
            // If HistogramPanelContainer is a real class, its name implies it contains HistogramPanel.
            // The user will need to provide that class if its internal strings/comments need translation.
            frame.add(new HistogramPanelContainer()); // This line remains, assuming HistogramPanelContainer exists
            frame.setVisible(true);
        });
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Controller\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// Histogram Panel Container
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("Show Histogram");
        JButton btnShowText1 = new JButton("Show Text 1");
        JButton btnShowText2 = new JButton("Show Text 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("Microsoft YaHei", Font.PLAIN, 18)); // "微软雅黑" (Microsoft YaHei is a common font name)
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("This is a very long text..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Controller\MenuUI.java`:

```java
package Controller;

import Constants.StandardCategories; // Import StandardCategories if needed in UI
import Service.AIservice.AITransactionService; // Import AI services
import Service.AIservice.CollegeStudentNeeds;
import Service.Impl.SummaryStatisticService; // Import SummaryStatisticService
import Service.TransactionService;
import model.SummaryStatistic; // Import SummaryStatistic
import model.Transaction;
import model.User;
// import Constants.StandardCategories; // Already imported above

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.io.IOException;
import java.util.List;
import java.util.Vector;
import java.util.Comparator; // For sorting stats display
import java.util.stream.Collectors; // Added for loadCSVDataForCurrentUser

public class MenuUI extends JPanel { // Extend JPanel for easier use in Main (optional but common)

    private final User currentUser;
    private final TransactionService transactionService;
    private final SummaryStatisticService summaryStatisticService;
    private final AITransactionService aiTransactionService;
    private final CollegeStudentNeeds collegeStudentNeeds;

    private DefaultTableModel tableModel;

    // Fields for search input components
    private JTextField searchTransactionTimeField;
    private JTextField searchTransactionTypeField;
    private JTextField searchCounterpartyField;
    private JTextField searchCommodityField;
    private JComboBox<String> searchInOutComboBox;
    private JTextField searchPaymentMethodField;
    private JButton searchButton;

    private JTable table;
    // REMOVED: private HistogramPanelContainer histogramPanelContainer; // No longer needed

    private JPanel rightPanel;
    private CardLayout cardLayout;

    // UI components for AI panel (existing)
    private JTextArea aiResultArea;
    private JTextField aiStartTimeField;
    private JTextField aiEndTimeField;
    private JButton aiAnalyzeButton;
    private JButton aiBudgetButton;
    private JButton aiTipsButton;
    private JButton aiPersonalSummaryButton;
    private JButton aiSavingsGoalsButton;
    private JButton aiPersonalSavingTipsButton;


    // UI components for Admin Stats panel (existing)
    private JTextArea adminStatsArea;
    private JButton generateStatsButton;
    private JButton refreshDisplayButton;

    // New panel for Visualization
    private VisualizationPanel visualizationPanel; // Add instance field


    // Constructor now accepts all necessary service instances (same as before)
    public MenuUI(User authenticatedUser, TransactionService transactionService,
                  SummaryStatisticService summaryStatisticService,
                  AITransactionService aiTransactionService,
                  CollegeStudentNeeds collegeStudentNeeds) {

        this.currentUser = authenticatedUser;
        this.transactionService = transactionService;
        this.summaryStatisticService = summaryStatisticService;
        this.aiTransactionService = aiTransactionService;
        this.collegeStudentNeeds = collegeStudentNeeds;

        // Initialize table model (same as before)
        String[] columnNames = {"Transaction Time", "Transaction Type", "Counterparty", "Commodity", "In/Out", "Amount(CNY)", "Payment Method", "Current Status", "Order Number", "Merchant Number", "Remarks", "Modify", "Delete"};
        this.tableModel = new DefaultTableModel(columnNames, 0);
        this.table = new JTable(this.tableModel);

        // Initialize the main panel layout (same as before)
        setLayout(new BorderLayout());

        // Add the left panel (will be modified)
        add(createLeftPanel(), BorderLayout.WEST);

        // Add the right panel (will be modified)
        setupRightPanel();
        add(rightPanel, BorderLayout.CENTER);

        // Initial data load is done in createMainPanel (same as before)
        // loadCSVDataForCurrentUser("Income");

        System.out.println("MenuUI initialized for user: " + currentUser.getUsername() + " (" + currentUser.getRole() + ")");
    }

    public JPanel createMainPanel() {
        // MenuUI itself is the main panel, just add the initial data
        loadCSVDataForCurrentUser(""); // Load and display all data initially, or a default like "Income"
        return this; // Return itself
    }


    // Method to load CSV data for the current user with optional initial filter
    // Same logic as before
    public void loadCSVDataForCurrentUser(String initialInOutFilter) {
        this.tableModel.setRowCount(0); // Clear the table model

        try {
            List<Transaction> transactions = transactionService.getAllTransactions();
            System.out.println("Loaded total " + transactions.size() + " transactions from service for user " + currentUser.getUsername());

            List<Transaction> filteredTransactions = new java.util.ArrayList<>();
            if (initialInOutFilter == null || initialInOutFilter.trim().isEmpty()) {
                filteredTransactions.addAll(transactions);
            } else {
                String filter = initialInOutFilter.trim();
                // Assuming "Income" maps to "收" and "Expense" maps to "支" or their English equivalents if data uses that.
                // The UI might use "Income"/"Expense", while data might use "收"/"支" or "In"/"Out".
                // This filter needs to be robust to these variations.
                filteredTransactions = transactions.stream()
                        .filter(t -> t.getInOut() != null && (t.getInOut().equalsIgnoreCase(filter) ||
                                (filter.equalsIgnoreCase("Income") && (t.getInOut().equalsIgnoreCase("收") || t.getInOut().equalsIgnoreCase("In"))) ||
                                (filter.equalsIgnoreCase("Expense") && (t.getInOut().equalsIgnoreCase("支") || t.getInOut().equalsIgnoreCase("Out"))) ))
                        .collect(Collectors.toList());
            }

            for (Transaction transaction : filteredTransactions) {
                Vector<String> row = createRowFromTransaction(transaction);
                this.tableModel.addRow(row);
            }
            System.out.println("Displayed " + filteredTransactions.size() + " transactions in the table.");

        } catch (Exception e) {
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, "Failed to load user transaction data!", "Error", JOptionPane.ERROR_MESSAGE);
        }
    }

    // Method to create the left panel (Menu/AI/Admin/Visualization buttons) - MODIFIED
    private JPanel createLeftPanel() {
        JPanel leftPanel = new JPanel();
        leftPanel.setLayout(new BoxLayout(leftPanel, BoxLayout.Y_AXIS));
        leftPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        JButton menuButton = new JButton("Transaction List"); // "交易列表"
        JButton aiButton = new JButton("AI Analysis");       // "AI分析"
        JButton adminButton = new JButton("Admin Stats");     // "管理员统计"
        JButton visualizationButton = new JButton("Visualization"); // "可视化"

        // Set consistent size for buttons
        Dimension buttonSize = new Dimension(150, 40);
        menuButton.setMaximumSize(buttonSize);
        aiButton.setMaximumSize(buttonSize);
        adminButton.setMaximumSize(buttonSize);
        visualizationButton.setMaximumSize(buttonSize);


        menuButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        aiButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        adminButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        visualizationButton.setAlignmentX(Component.CENTER_ALIGNMENT);


        leftPanel.add(menuButton);
        leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        leftPanel.add(aiButton);
        leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));

        // Add Admin button only if the user is admin (same as before)
        if ("admin".equalsIgnoreCase(currentUser.getRole())) {
            leftPanel.add(adminButton);
            leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        }

        // Add Visualization button (visible for all users)
        leftPanel.add(visualizationButton);
        leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));


        // Add action listeners (existing for Menu, AI, Admin)
        menuButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Table");
            loadCSVDataForCurrentUser("Income"); // Load "Income" by default or "" for all
        });

        aiButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "AI");
        });

        if ("admin".equalsIgnoreCase(currentUser.getRole())) {
            adminButton.addActionListener(e -> {
                cardLayout.show(rightPanel, "AdminStats");
                displaySummaryStatistics(); // Refresh stats display when switching
            });
        }

        // Add action listener for Visualization button - NEW
        visualizationButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Visualization"); // Switch to visualization view
            if (visualizationPanel != null) { // Ensure panel is initialized
                visualizationPanel.refreshPanelData(); // Call refresh method
            }
        });


        leftPanel.add(Box.createVerticalGlue());

        return leftPanel;
    }

    // Method to set up the right panel, adding different views - MODIFIED
    private void setupRightPanel() {
        this.cardLayout = new CardLayout();
        this.rightPanel = new JPanel(this.cardLayout);

        // Create and add different panels (views)
        JPanel tablePanel = createTablePanel(); // Table view
        JPanel aiPanel = createAIPanel(); // AI view
        JPanel adminStatsPanel = createAdminStatsPanel(); // Admin stats view
        this.visualizationPanel = new VisualizationPanel(this.transactionService);


        rightPanel.add(tablePanel, "Table");
        rightPanel.add(aiPanel, "AI");
        if ("admin".equalsIgnoreCase(currentUser.getRole())) {
            rightPanel.add(adminStatsPanel, "AdminStats");
        }
        rightPanel.add(visualizationPanel, "Visualization");


        // Set the initially visible card (Table view)
        cardLayout.show(rightPanel, "Table");
    }

    // Method to create the table panel - same as before
    private JPanel createTablePanel() {
        JPanel tablePanel = new JPanel(new BorderLayout());

        JPanel inputPanel = createInputPanel();
        tablePanel.add(inputPanel, BorderLayout.NORTH);

        JScrollPane tableScrollPane = new JScrollPane(this.table);
        tableScrollPane.setPreferredSize(new Dimension(1000, 250));
        this.table.setFillsViewportHeight(true);
        this.table.setRowHeight(30);

        tablePanel.add(tableScrollPane, BorderLayout.CENTER);

        // Set cell renderers and editors
        this.table.getColumnModel().getColumn(11).setCellRenderer(new ButtonRenderer());
        this.table.getColumnModel().getColumn(11).setCellEditor(new ButtonEditor(this));

        this.table.getColumnModel().getColumn(12).setCellRenderer(new ButtonRenderer());
        this.table.getColumnModel().getColumn(12).setCellEditor(new ButtonEditor(this));

        return tablePanel;
    }

    // Inside MenuUI class
    private JPanel createInputPanel() {
        JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));

        searchTransactionTimeField = new JTextField(10);
        searchTransactionTypeField = new JTextField(10);
        searchCounterpartyField = new JTextField(10);
        searchCommodityField = new JTextField(10);
        searchInOutComboBox = new JComboBox<>(new String[]{"", "Income", "Expense"}); // "Income", "Expense"
        searchPaymentMethodField = new JTextField(10);

        inputPanel.add(new JLabel("Transaction Time:")); inputPanel.add(searchTransactionTimeField);
        inputPanel.add(new JLabel("Transaction Type:")); inputPanel.add(searchTransactionTypeField);
        inputPanel.add(new JLabel("Counterparty:")); inputPanel.add(searchCounterpartyField);
        inputPanel.add(new JLabel("Commodity:")); inputPanel.add(searchCommodityField);
        inputPanel.add(new JLabel("In/Out:")); inputPanel.add(searchInOutComboBox);
        inputPanel.add(new JLabel("Payment Method:")); inputPanel.add(searchPaymentMethodField);

        searchButton = new JButton("Search");
        JButton addButton = new JButton("Add");
        JButton importButton = new JButton("Import CSV"); // "Import CSV"

        inputPanel.add(searchButton);
        inputPanel.add(addButton);
        inputPanel.add(importButton);

        searchButton.addActionListener(e -> triggerCurrentSearch());
        addButton.addActionListener(e -> showAddTransactionDialog());

        importButton.addActionListener(e -> {
            showImportDialog();
        });

        return inputPanel;
    }

    // Inside MenuUI class
    private void showImportDialog() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Select CSV file to import");
        fileChooser.setFileFilter(new javax.swing.filechooser.FileNameExtensionFilter("CSV Files (*.csv)", "csv"));

        int userSelection = fileChooser.showOpenDialog(this);

        if (userSelection == JFileChooser.APPROVE_OPTION) {
            java.io.File fileToImport = fileChooser.getSelectedFile();
            String filePath = fileToImport.getAbsolutePath();
            System.out.println("User selected file for import: " + filePath);

            new Thread(() -> {
                String message;
                try {
                    int importedCount = transactionService.importTransactionsFromCsv(currentUser.getTransactionFilePath(), filePath);
                    message = "Successfully imported " + importedCount + " transaction records.";
                    System.out.println(message);

                    String finalMessage = message;
                    SwingUtilities.invokeLater(() -> {
                        loadCSVDataForCurrentUser("");
                        clearSearchFields();
                        JOptionPane.showMessageDialog(this, finalMessage, "Import Successful", JOptionPane.INFORMATION_MESSAGE);
                    });

                } catch (Exception ex) {
                    message = "Import failed!\n" + ex.getMessage();
                    System.err.println("CSV Import failed: " + ex.getMessage());
                    ex.printStackTrace();
                    String finalMessage1 = message;
                    SwingUtilities.invokeLater(() -> {
                        JOptionPane.showMessageDialog(this, finalMessage1, "Import Error", JOptionPane.ERROR_MESSAGE);
                    });
                }
            }).start();
        } else {
            System.out.println("User cancelled file selection.");
        }
    }

    // Inside MenuUI class, showAddTransactionDialog method
    private void showAddTransactionDialog() {
        JDialog addDialog = new JDialog();
        addDialog.setTitle("Add Transaction"); // "Add Transaction"
        JPanel dialogPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.insets = new Insets(5, 5, 5, 5);

        JTextField transactionTimeField = new JTextField(15);
        JTextField transactionTypeField = new JTextField(15);
        JButton aiSuggestButton = new JButton("AI Category Suggestion"); // "AI Category Suggestion"

        JTextField counterpartyField = new JTextField(15);
        JTextField commodityField = new JTextField(15);
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"Income", "Expense"}); // "Income", "Expense"
        JTextField paymentAmountField = new JTextField(15);
        JTextField paymentMethodField = new JTextField(15);
        JTextField currentStatusField = new JTextField(15);
        JTextField orderNumberField = new JTextField(15);
        JTextField merchantNumberField = new JTextField(15);
        JTextField remarksField = new JTextField(15);


        gbc.gridx = 0; gbc.gridy = 0; dialogPanel.add(new JLabel("Transaction Time:"), gbc);
        gbc.gridx = 1; gbc.gridy = 0; gbc.gridwidth = 2; dialogPanel.add(transactionTimeField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 1; dialogPanel.add(new JLabel("Transaction Type:"), gbc);
        gbc.gridx = 1; gbc.gridy = 1; gbc.weightx = 1.0; dialogPanel.add(transactionTypeField, gbc);
        gbc.gridx = 2; gbc.gridy = 1; gbc.weightx = 0.0; dialogPanel.add(aiSuggestButton, gbc);

        gbc.gridx = 0; gbc.gridy = 2; gbc.gridwidth = 1; dialogPanel.add(new JLabel("Counterparty:"), gbc);
        gbc.gridx = 1; gbc.gridy = 2; gbc.gridwidth = 2; dialogPanel.add(counterpartyField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 3; gbc.gridwidth = 1; dialogPanel.add(new JLabel("Commodity:"), gbc);
        gbc.gridx = 1; gbc.gridy = 3; gbc.gridwidth = 2; dialogPanel.add(commodityField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 4; gbc.gridwidth = 1; dialogPanel.add(new JLabel("In/Out:"), gbc);
        gbc.gridx = 1; gbc.gridy = 4; gbc.gridwidth = 2; dialogPanel.add(inOutComboBox, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 5; gbc.gridwidth = 1; dialogPanel.add(new JLabel("Amount(CNY):"), gbc);
        gbc.gridx = 1; gbc.gridy = 5; gbc.gridwidth = 2; dialogPanel.add(paymentAmountField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 6; gbc.gridwidth = 1; dialogPanel.add(new JLabel("Payment Method:"), gbc);
        gbc.gridx = 1; gbc.gridy = 6; gbc.gridwidth = 2; dialogPanel.add(paymentMethodField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 7; gbc.gridwidth = 1; dialogPanel.add(new JLabel("Current Status:"), gbc);
        gbc.gridx = 1; gbc.gridy = 7; gbc.gridwidth = 2; dialogPanel.add(currentStatusField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 8; gbc.gridwidth = 1; dialogPanel.add(new JLabel("Order Number:"));
        gbc.gridx = 1; gbc.gridy = 8; gbc.gridwidth = 2; dialogPanel.add(orderNumberField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 9; gbc.gridwidth = 1; dialogPanel.add(new JLabel("Merchant Number:"));
        gbc.gridx = 1; gbc.gridy = 9; gbc.gridwidth = 2; dialogPanel.add(merchantNumberField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 10; gbc.gridwidth = 1; dialogPanel.add(new JLabel("Remarks:"));
        gbc.gridx = 1; gbc.gridy = 10; gbc.gridwidth = 2; dialogPanel.add(remarksField, gbc); gbc.gridwidth = 1;

        JDialog waitingDialog = new JDialog(addDialog, "Please wait", true); // "Please wait"
        waitingDialog.setLayout(new FlowLayout());
        waitingDialog.add(new JLabel("Getting AI category suggestion...")); // "Getting AI category suggestion..."
        waitingDialog.setSize(250, 100);
        waitingDialog.setResizable(false);

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        JButton confirmButton = new JButton("Confirm"); // "Confirm"
        JButton cancelButton = new JButton("Cancel");   // "Cancel"
        buttonPanel.add(confirmButton);
        buttonPanel.add(cancelButton);

        gbc.gridx = 0; gbc.gridy = 11; gbc.gridwidth = 3; gbc.anchor = GridBagConstraints.CENTER; gbc.fill = GridBagConstraints.NONE;
        dialogPanel.add(buttonPanel, gbc);

        addDialog.add(dialogPanel, BorderLayout.CENTER);

        aiSuggestButton.addActionListener(e -> {
            System.out.println("AI Suggest button clicked (EDT).");
            aiSuggestButton.setEnabled(false);
            Transaction tempTransaction = new Transaction(
                    emptyIfNull(transactionTimeField.getText().trim()),
                    emptyIfNull(transactionTypeField.getText().trim()),
                    emptyIfNull(counterpartyField.getText().trim()),
                    emptyIfNull(commodityField.getText().trim()),
                    (String) inOutComboBox.getSelectedItem(),
                    safeParseDouble(paymentAmountField.getText().trim()),
                    emptyIfNull(paymentMethodField.getText().trim()),
                    emptyIfNull(currentStatusField.getText().trim()),
                    emptyIfNull(orderNumberField.getText().trim()),
                    emptyIfNull(merchantNumberField.getText().trim()),
                    emptyIfNull(remarksField.getText().trim())
            );
            new Thread(() -> {
                System.out.println("Background thread started for AI classification...");
                String aiSuggestion = null;
                try {
                    aiSuggestion = collegeStudentNeeds.RecognizeTransaction(tempTransaction);
                    System.out.println("AI Classification returned in background thread: " + aiSuggestion);
                } catch (Exception ex) {
                    System.err.println("Error in background AI thread: " + ex.getMessage());
                    ex.printStackTrace();
                    aiSuggestion = "Error: " + ex.getMessage();
                }
                String finalSuggestion = aiSuggestion;
                SwingUtilities.invokeLater(() -> {
                    System.out.println("Updating UI on EDT from background thread.");
                    waitingDialog.setVisible(false);
                    if (finalSuggestion != null && !finalSuggestion.isEmpty() && !finalSuggestion.startsWith("Error:")) {
                        if (StandardCategories.ALL_KNOWN_TYPES.contains(finalSuggestion.trim())) {
                            transactionTypeField.setText(finalSuggestion.trim());
                        } else {
                            System.err.println("AI returned non-standard category despite prompt: " + finalSuggestion);
                            JOptionPane.showMessageDialog(addDialog, "AI returned an unexpected category format:\n" + finalSuggestion + "\nPlease enter manually.", "AI Result Anomaly", JOptionPane.WARNING_MESSAGE);
                            transactionTypeField.setText("");
                        }
                    } else if (finalSuggestion != null && finalSuggestion.startsWith("Error:")) {
                        JOptionPane.showMessageDialog(addDialog, "Failed to get AI category suggestion!\n" + finalSuggestion.substring(6), "AI Error", JOptionPane.ERROR_MESSAGE);
                        transactionTypeField.setText("");
                    }
                    else {
                        JOptionPane.showMessageDialog(addDialog, "AI could not provide a category suggestion.", "AI Tip", JOptionPane.INFORMATION_MESSAGE);
                        transactionTypeField.setText("");
                    }
                    aiSuggestButton.setEnabled(true);
                    System.out.println("UI update complete, buttons re-enabled.");
                });
            }).start();
            System.out.println("Showing waiting dialog (EDT block continues here).");
            waitingDialog.setLocationRelativeTo(addDialog);
            waitingDialog.setVisible(true);
            System.out.println("waiting dialog is now hidden (EDT unblocked).");
        });

        confirmButton.addActionListener(e -> {
            String transactionTime = emptyIfNull(transactionTimeField.getText().trim());
            String finalTransactionType = emptyIfNull(transactionTypeField.getText().trim());
            String counterparty = emptyIfNull(counterpartyField.getText().trim());
            String commodity = emptyIfNull(commodityField.getText().trim());
            String inOut = (String) inOutComboBox.getSelectedItem();
            String paymentAmountText = paymentAmountField.getText().trim();
            String paymentMethod = emptyIfNull(paymentMethodField.getText().trim());
            String currentStatus = emptyIfNull(currentStatusField.getText().trim());
            String orderNumber = emptyIfNull(orderNumberField.getText().trim());
            String merchantNumber = emptyIfNull(merchantNumberField.getText().trim());
            String remarks = emptyIfNull(remarksField.getText().trim());

            if (orderNumber.isEmpty()) {
                JOptionPane.showMessageDialog(addDialog, "Order Number cannot be empty!", "Input Error", JOptionPane.ERROR_MESSAGE);
                return;
            }
            if (finalTransactionType.isEmpty()) {
                JOptionPane.showMessageDialog(addDialog, "Transaction Type cannot be empty!", "Input Error", JOptionPane.ERROR_MESSAGE);
                return;
            }
            if (!StandardCategories.ALL_KNOWN_TYPES.contains(finalTransactionType)) {
                JOptionPane.showMessageDialog(addDialog, "Transaction type must be one of the standard categories!\nAllowed categories:\n" + StandardCategories.getAllCategoriesString(), "Input Error", JOptionPane.ERROR_MESSAGE);
                return;
            }
            double paymentAmount = 0.0;
            if (!paymentAmountText.isEmpty()) {
                try {
                    paymentAmount = Double.parseDouble(paymentAmountText);
                    if (paymentAmount < 0) {
                        JOptionPane.showMessageDialog(addDialog, "Amount cannot be negative!", "Input Error", JOptionPane.ERROR_MESSAGE);
                        return;
                    }
                } catch (NumberFormatException ex) {
                    JOptionPane.showMessageDialog(addDialog, "Amount format is incorrect! Please enter a number.", "Input Error", JOptionPane.ERROR_MESSAGE);
                    return;
                }
            }
            Transaction newTransaction = new Transaction(
                    transactionTime, finalTransactionType, counterparty, commodity, inOut,
                    paymentAmount, paymentMethod, currentStatus, orderNumber, merchantNumber, remarks
            );
            try {
                transactionService.addTransaction(newTransaction);
                loadCSVDataForCurrentUser("");
                clearSearchFields();
                addDialog.dispose();
                JOptionPane.showMessageDialog(null, "Transaction added successfully!", "Information", JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(null, "Failed to add transaction!\n" + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
            } catch (Exception ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(null, "Failed to add transaction!\n" + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
            }
        });
        cancelButton.addActionListener(e -> addDialog.dispose());
        addDialog.pack();
        addDialog.setLocationRelativeTo(this);
        addDialog.setVisible(true);
    }

    public void editRow(int rowIndex) {
        System.out.println("Editing row: " + rowIndex + " for user " + currentUser.getUsername());
        JDialog editDialog = new JDialog();
        JPanel dialogPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();

        if (rowIndex >= 0 && rowIndex < this.tableModel.getRowCount()) {
            Vector<String> rowData = new Vector<>();
            for (int i = 0; i <= 10; i++) {
                Object value = this.tableModel.getValueAt(rowIndex, i);
                rowData.add(value != null ? value.toString() : "");
            }
            System.out.println("Retrieved row data from table model for editing: " + rowData);
            String originalOrderNumber = rowData.get(8).trim();
            if (originalOrderNumber.isEmpty()) {
                JOptionPane.showMessageDialog(null, "Cannot edit: Order Number is empty!", "Error", JOptionPane.ERROR_MESSAGE);
                System.err.println("Attempted to edit row " + rowIndex + " but order number is empty.");
                return;
            }
            editDialog.setTitle("Edit Transaction (Order No: " + originalOrderNumber + ")"); // "Edit Transaction (Order No: "
            editDialog.setModal(true);
            gbc.fill = GridBagConstraints.HORIZONTAL;
            gbc.insets = new Insets(5, 5, 5, 5);
            JTextField[] fields = new JTextField[11];
            String[] fieldNames = {"Transaction Time", "Transaction Type", "Counterparty", "Commodity", "In/Out", "Amount(CNY)", "Payment Method", "Current Status", "Order Number", "Merchant Number", "Remarks"};
            JButton aiSuggestButton = new JButton("AI Category Suggestion"); // "AI Category Suggestion"

            for (int i = 0; i < fieldNames.length; i++) {
                gbc.gridx = 0; gbc.gridy = i; gbc.gridwidth = 1; gbc.weightx = 0.0; dialogPanel.add(new JLabel(fieldNames[i] + ":"), gbc);
                fields[i] = new JTextField(rowData.get(i));
                if (i == 1) {
                    gbc.gridx = 1; gbc.gridy = i; gbc.weightx = 1.0; dialogPanel.add(fields[i], gbc);
                    gbc.gridx = 2; gbc.gridy = i; gbc.weightx = 0.0; dialogPanel.add(aiSuggestButton, gbc);
                    gbc.gridwidth = 1;
                } else {
                    gbc.gridx = 1; gbc.gridy = i; gbc.gridwidth = 2; gbc.weightx = 1.0; dialogPanel.add(fields[i], gbc);
                    gbc.gridwidth = 1;
                }
            }
            fields[8].setEditable(false);

            JDialog waitingDialog = new JDialog(editDialog, "Please wait", true); // "Please wait"
            waitingDialog.setLayout(new FlowLayout());
            waitingDialog.add(new JLabel("Getting AI category suggestion...")); // "Getting AI category suggestion..."
            waitingDialog.setSize(250, 100);
            waitingDialog.setResizable(false);

            JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
            JButton confirmButton = new JButton("Confirm"); // "Confirm"
            JButton cancelButton = new JButton("Cancel");   // "Cancel"
            buttonPanel.add(confirmButton);
            buttonPanel.add(cancelButton);
            gbc.gridx = 0; gbc.gridy = fieldNames.length; gbc.gridwidth = 3; gbc.anchor = GridBagConstraints.CENTER; gbc.fill = GridBagConstraints.NONE; dialogPanel.add(buttonPanel, gbc);
            editDialog.add(dialogPanel, BorderLayout.CENTER);

            aiSuggestButton.addActionListener(e -> {
                System.out.println("AI Suggest button clicked (EDT) in edit dialog.");
                aiSuggestButton.setEnabled(false);
                Transaction tempTransaction = new Transaction(
                        fields[0].getText().trim(), fields[1].getText().trim(), fields[2].getText().trim(),
                        fields[3].getText().trim(), fields[4].getText().trim(), safeParseDouble(fields[5].getText().trim()),
                        fields[6].getText().trim(), fields[7].getText().trim(), fields[8].getText().trim(),
                        fields[9].getText().trim(), fields[10].getText().trim()
                );
                new Thread(() -> {
                    System.out.println("Background thread started for AI classification (edit dialog)...");
                    String aiSuggestion = null;
                    try {
                        aiSuggestion = collegeStudentNeeds.RecognizeTransaction(tempTransaction);
                        System.out.println("AI Classification returned in background thread (edit dialog): " + aiSuggestion);
                    } catch (Exception ex) {
                        System.err.println("Error in background AI thread (edit dialog): " + ex.getMessage());
                        ex.printStackTrace();
                        aiSuggestion = "Error: " + ex.getMessage();
                    }
                    String finalSuggestion = aiSuggestion;
                    SwingUtilities.invokeLater(() -> {
                        System.out.println("Updating UI on EDT from background thread (edit dialog).");
                        waitingDialog.setVisible(false);
                        if (finalSuggestion != null && !finalSuggestion.isEmpty() && !finalSuggestion.startsWith("Error:")) {
                            if (StandardCategories.ALL_KNOWN_TYPES.contains(finalSuggestion.trim())) {
                                fields[1].setText(finalSuggestion.trim());
                            } else {
                                System.err.println("AI returned non-standard category despite prompt: " + finalSuggestion);
                                JOptionPane.showMessageDialog(editDialog, "AI returned an unexpected category format:\n" + finalSuggestion + "\nPlease enter manually.", "AI Result Anomaly", JOptionPane.WARNING_MESSAGE);
                                fields[1].setText("");
                            }
                        } else if (finalSuggestion != null && finalSuggestion.startsWith("Error:")) {
                            JOptionPane.showMessageDialog(editDialog, "Failed to get AI category suggestion!\n" + finalSuggestion.substring(6), "AI Error", JOptionPane.ERROR_MESSAGE);
                            fields[1].setText("");
                        }
                        else {
                            JOptionPane.showMessageDialog(editDialog, "AI could not provide a category suggestion.", "AI Tip", JOptionPane.INFORMATION_MESSAGE);
                            fields[1].setText("");
                        }
                        aiSuggestButton.setEnabled(true);
                        System.out.println("UI update complete, buttons re-enabled (edit dialog).");
                    });
                }).start();
                System.out.println("Showing waiting dialog (EDT block continues here in edit dialog).");
                waitingDialog.setLocationRelativeTo(editDialog);
                waitingDialog.setVisible(true);
                System.out.println("waiting dialog is now hidden (EDT unblocked in edit dialog).");
            });

            confirmButton.addActionListener(e -> {
                String transactionTime = fields[0].getText().trim();
                String finalTransactionType = fields[1].getText().trim();
                String counterparty = fields[2].getText().trim();
                String commodity = fields[3].getText().trim();
                String inOut = fields[4].getText().trim();
                String paymentAmountText = fields[5].getText().trim();
                String paymentMethod = fields[6].getText().trim();
                String currentStatus = fields[7].getText().trim();
                String merchantNumber = fields[9].getText().trim();
                String remarks = fields[10].getText().trim();

                if (finalTransactionType.isEmpty()) {
                    JOptionPane.showMessageDialog(editDialog, "Transaction Type cannot be empty!", "Input Error", JOptionPane.ERROR_MESSAGE);
                    return;
                }
                if (!StandardCategories.ALL_KNOWN_TYPES.contains(finalTransactionType)) {
                    JOptionPane.showMessageDialog(editDialog, "Transaction type must be one of the standard categories!\nAllowed categories:\n" + StandardCategories.getAllCategoriesString(), "Input Error", JOptionPane.ERROR_MESSAGE);
                    return;
                }
                if (!inOut.equalsIgnoreCase("Income") && !inOut.equalsIgnoreCase("Expense") &&
                        !inOut.equalsIgnoreCase("In") && !inOut.equalsIgnoreCase("Out")) {
                    JOptionPane.showMessageDialog(editDialog, "In/Out field must be 'Income' or 'Expense'.", "Input Error", JOptionPane.ERROR_MESSAGE);
                    return;
                }
                double paymentAmount = 0.0;
                if (!paymentAmountText.isEmpty()) {
                    try {
                        paymentAmount = Double.parseDouble(paymentAmountText);
                        if (paymentAmount < 0) {
                            JOptionPane.showMessageDialog(editDialog, "Amount cannot be negative!", "Input Error", JOptionPane.ERROR_MESSAGE);
                            return;
                        }
                    } catch (NumberFormatException ex) {
                        JOptionPane.showMessageDialog(editDialog, "Amount format is incorrect! Please enter a number.", "Input Error", JOptionPane.ERROR_MESSAGE);
                        return;
                    }
                }
                Transaction updatedTransaction = new Transaction(
                        transactionTime, finalTransactionType, counterparty, commodity, inOut,
                        paymentAmount, paymentMethod, currentStatus, originalOrderNumber,
                        merchantNumber, remarks
                );
                try {
                    transactionService.changeTransaction(updatedTransaction);
                    System.out.println("Edit successful. Preparing to refresh display filtered by InOut: " + updatedTransaction.getInOut());
                    clearSearchFields();
                    String updatedInOut = updatedTransaction.getInOut();
                    boolean foundInOut = false;
                    for(int i=0; i < searchInOutComboBox.getItemCount(); i++) {
                        if (updatedInOut != null && updatedInOut.equals(searchInOutComboBox.getItemAt(i))) {
                            searchInOutComboBox.setSelectedItem(updatedInOut);
                            foundInOut = true;
                            break;
                        }
                    }
                    if (!foundInOut) { searchInOutComboBox.setSelectedItem(""); }
                    triggerCurrentSearch();
                    editDialog.dispose();
                    JOptionPane.showMessageDialog(null, "Update successful!", "Information", JOptionPane.INFORMATION_MESSAGE);
                    System.out.println("Edited row " + rowIndex + " for order number " + originalOrderNumber + " and refreshed display.");
                } catch (IllegalArgumentException ex) {
                    JOptionPane.showMessageDialog(editDialog, "Update failed!\n" + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
                    ex.printStackTrace();
                } catch (Exception ex) {
                    ex.printStackTrace();
                    JOptionPane.showMessageDialog(editDialog, "Update failed!\n" + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
                }
            });
            cancelButton.addActionListener(e -> editDialog.dispose());
            editDialog.pack();
            editDialog.setLocationRelativeTo(this);
            editDialog.setVisible(true);
        } else {
            System.err.println("Attempted to edit row with invalid index: " + rowIndex + ". Table row count: " + this.tableModel.getRowCount());
        }
    }

    private JPanel createAIPanel() {
        JPanel panel = new JPanel(new BorderLayout(10, 10));
        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        JPanel generalAnalysisPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));
        JTextField userRequestField = new JTextField(40);
        aiStartTimeField = new JTextField(10);
        aiEndTimeField = new JTextField(10);
        aiAnalyzeButton = new JButton("General Analysis (Raw Data)"); // "General Analysis (Raw Data)"

        generalAnalysisPanel.add(new JLabel("General Analysis Request:")); // "General Analysis Request:"
        generalAnalysisPanel.add(userRequestField);
        generalAnalysisPanel.add(new JLabel("Time Range (yyyy/MM/dd HH:mm): From:")); // "Time Range (yyyy/MM/dd HH:mm): From:"
        generalAnalysisPanel.add(aiStartTimeField);
        generalAnalysisPanel.add(new JLabel("To:")); // "To:"
        generalAnalysisPanel.add(aiAnalyzeButton);

        JPanel summaryAnalysisPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));
        aiPersonalSummaryButton = new JButton("Personal Spending Summary"); // "Personal Spending Summary"
        aiSavingsGoalsButton = new JButton("Savings Goal Suggestions");   // "Savings Goal Suggestions"
        aiPersonalSavingTipsButton = new JButton("Personalized Saving Tips"); // "Personalized Saving Tips"

        summaryAnalysisPanel.add(new JLabel("Based on Monthly Summary Analysis:")); // "Based on Monthly Summary Analysis:"
        summaryAnalysisPanel.add(aiPersonalSummaryButton);
        summaryAnalysisPanel.add(aiSavingsGoalsButton);
        summaryAnalysisPanel.add(aiPersonalSavingTipsButton);

        JPanel csButtonsPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));
        aiBudgetButton = new JButton("Budget Suggestion (Student)"); // "Budget Suggestion (Student)"
        aiTipsButton = new JButton("Saving Tips (Student)");       // "Saving Tips (Student)"
        csButtonsPanel.add(new JLabel("Student-Specific Features:")); // "Student-Specific Features:"
        csButtonsPanel.add(aiBudgetButton);
        csButtonsPanel.add(aiTipsButton);

        JPanel topControlPanel = new JPanel();
        topControlPanel.setLayout(new BoxLayout(topControlPanel, BoxLayout.Y_AXIS));
        topControlPanel.add(generalAnalysisPanel);
        topControlPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        topControlPanel.add(summaryAnalysisPanel);
        topControlPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        topControlPanel.add(csButtonsPanel);
        topControlPanel.add(Box.createRigidArea(new Dimension(0, 10)));

        panel.add(topControlPanel, BorderLayout.NORTH);
        aiResultArea = new JTextArea();
        aiResultArea.setFont(new Font("Microsoft YaHei", Font.PLAIN, 14)); // "Microsoft YaHei" is a common font name for Chinese
        aiResultArea.setLineWrap(true);
        aiResultArea.setWrapStyleWord(true);
        aiResultArea.setEditable(false);
        aiResultArea.setText("Welcome to the AI Personal Finance Analysis feature.\n\n" +
                "You can try the following operations:\n" +
                "1. Enter a general analysis request in the input field above (based on raw data, time range can be specified), then click \"General Analysis\".\n" +
                "2. Click \"Personal Spending Summary\" to get a detailed summary based on your monthly income and expenses.\n" +
                "3. Click \"Savings Goal Suggestions\" to get savings advice based on your income and expenditure situation.\n" +
                "4. Click \"Personalized Saving Tips\" to get saving advice based on your spending categories.\n" +
                "5. Student users can click \"Budget Suggestion\" and \"Saving Tips\" for exclusive advice.\n");

        JScrollPane resultScrollPane = new JScrollPane(aiResultArea);
        panel.add(resultScrollPane, BorderLayout.CENTER);

        aiPersonalSummaryButton.addActionListener(e -> {
            aiResultArea.setText("--- Generating Personal Spending Summary ---\n\nGenerating summary based on your monthly spending data, please wait...\n");
            setAIButtonsEnabled(false);
            new Thread(() -> {
                String result = aiTransactionService.generatePersonalSummary(currentUser.getTransactionFilePath());
                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- Personal Spending Summary ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        aiSavingsGoalsButton.addActionListener(e -> {
            aiResultArea.setText("--- Generating Savings Goal Suggestions ---\n\nGenerating savings goal suggestions based on your income and expenses, please wait...\n");
            setAIButtonsEnabled(false);
            new Thread(() -> {
                String result = aiTransactionService.suggestSavingsGoals(currentUser.getTransactionFilePath());
                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- Savings Goal Suggestions ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        aiPersonalSavingTipsButton.addActionListener(e -> {
            aiResultArea.setText("--- Generating Personalized Saving Tips ---\n\nGenerating saving tips based on your spending categories, please wait...\n");
            setAIButtonsEnabled(false);
            new Thread(() -> {
                String result = aiTransactionService.givePersonalSavingTips(currentUser.getTransactionFilePath());
                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- Personalized Saving Tips ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        aiAnalyzeButton.addActionListener(e -> {
            String userRequest = userRequestField.getText().trim();
            String startTimeStr = aiStartTimeField.getText().trim();
            String endTimeStr = aiEndTimeField.getText().trim();
            if (userRequest.isEmpty()) {
                JOptionPane.showMessageDialog(this, "Please enter the AI general analysis request.", "Input Tip", JOptionPane.INFORMATION_MESSAGE);
                return;
            }
            if (startTimeStr.isEmpty() && !endTimeStr.isEmpty()) {
                JOptionPane.showMessageDialog(this, "Please enter at least the start time for the analysis.", "Input Tip", JOptionPane.INFORMATION_MESSAGE);
                return;
            }
            aiResultArea.setText("--- Generating General Analysis ---\n\n" + "Performing AI general analysis, please wait...\n");
            setAIButtonsEnabled(false);
            new Thread(() -> {
                String result = aiTransactionService.analyzeTransactions(userRequest, currentUser.getTransactionFilePath(), startTimeStr, endTimeStr);
                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- General Analysis Result ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        aiBudgetButton.addActionListener(e -> {
            aiResultArea.setText("--- Generating Student Budget Suggestion ---\n\nGenerating budget suggestion based on your historical spending, please wait...\n");
            setAIButtonsEnabled(false);
            new Thread(() -> {
                String resultMessage;
                try {
                    double[] budgetRange = collegeStudentNeeds.generateBudget(currentUser.getTransactionFilePath());
                    if (budgetRange != null && budgetRange.length == 2 && budgetRange[0] != -1) {
                        resultMessage = String.format("Based on your spending records, the recommended budget range for next week is: [%.2f CNY, %.2f CNY]", budgetRange[0], budgetRange[1]);
                    } else if (budgetRange != null && budgetRange.length == 2 && budgetRange[0] == -1) {
                        resultMessage = "Not enough spending records to calculate weekly budget suggestions.";
                    }
                    else {
                        resultMessage = "Failed to generate budget suggestion, AI did not return a valid range.";
                        System.err.println("AI Budget generation failed, invalid response format.");
                    }
                } catch (Exception ex) {
                    resultMessage = "Failed to generate budget suggestion!\n" + ex.getMessage();
                    System.err.println("Error generating AI budget:");
                    ex.printStackTrace();
                }
                String finalResultMessage = resultMessage;
                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- Student Budget Suggestion ---\n\n" + finalResultMessage);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        aiTipsButton.addActionListener(e -> {
            aiResultArea.setText("--- Generating Student Saving Tips ---\n\nGenerating saving tips, please wait...\n");
            setAIButtonsEnabled(false);
            new Thread(() -> {
                String resultMessage;
                try {
                    resultMessage = collegeStudentNeeds.generateTipsForSaving(currentUser.getTransactionFilePath());
                } catch (Exception ex) {
                    resultMessage = "Failed to generate saving tips!\n" + ex.getMessage();
                    System.err.println("Error generating AI tips:");
                    ex.printStackTrace();
                }
                String finalResultMessage = resultMessage;
                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- Student Saving Tips ---\n\n" + finalResultMessage);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });
        return panel;
    }

    private void setAIButtonsEnabled(boolean enabled) {
        if (aiAnalyzeButton != null) aiAnalyzeButton.setEnabled(enabled);
        if (aiBudgetButton != null) aiBudgetButton.setEnabled(enabled);
        if (aiTipsButton != null) aiTipsButton.setEnabled(enabled);
        if (aiPersonalSummaryButton != null) aiPersonalSummaryButton.setEnabled(enabled);
        if (aiSavingsGoalsButton != null) aiSavingsGoalsButton.setEnabled(enabled);
        if (aiPersonalSavingTipsButton != null) aiPersonalSavingTipsButton.setEnabled(enabled);
    }

    private JPanel createAdminStatsPanel() {
        JPanel panel = new JPanel(new BorderLayout(10, 10));
        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        generateStatsButton = new JButton("Generate/Update Statistics"); // "Generate/Update Statistics"
        refreshDisplayButton = new JButton("Refresh Display");        // "Refresh Display"
        controlPanel.add(generateStatsButton);
        controlPanel.add(refreshDisplayButton);
        panel.add(controlPanel, BorderLayout.NORTH);
        adminStatsArea = new JTextArea();
        adminStatsArea.setFont(new Font("Microsoft YaHei", Font.PLAIN, 14)); // "Microsoft YaHei"
        adminStatsArea.setEditable(false);
        adminStatsArea.setLineWrap(true);
        adminStatsArea.setWrapStyleWord(true);
        JScrollPane scrollPane = new JScrollPane(adminStatsArea);
        panel.add(scrollPane, BorderLayout.CENTER);

        generateStatsButton.addActionListener(e -> {
            adminStatsArea.setText("Generating/Updating summary statistics, please wait...\n"); // "Generating/Updating summary statistics, please wait...\n"
            generateStatsButton.setEnabled(false);
            refreshDisplayButton.setEnabled(false);
            new Thread(() -> {
                String message;
                try {
                    summaryStatisticService.generateAndSaveWeeklyStatistics();
                    message = "Summary statistics generated/updated successfully!\nPlease click 'Refresh Display' to view the latest data."; // "Summary statistics generated/updated successfully!\nPlease click 'Refresh Display' to view the latest data."
                    System.out.println(message);
                } catch (Exception ex) {
                    message = "Failed to generate/update summary statistics!\n" + ex.getMessage(); // "Failed to generate/update summary statistics!\n"
                    System.err.println(message);
                    ex.printStackTrace();
                }
                String finalMessage = message;
                SwingUtilities.invokeLater(() -> {
                    adminStatsArea.setText(finalMessage);
                    generateStatsButton.setEnabled(true);
                    refreshDisplayButton.setEnabled(true);
                });
            }).start();
        });

        refreshDisplayButton.addActionListener(e -> {
            displaySummaryStatistics();
        });

        new Thread(() -> {
            SwingUtilities.invokeLater(() -> adminStatsArea.setText("Loading existing statistics...\n")); // "Loading existing statistics...\n"
            try {
                List<SummaryStatistic> initialStats = summaryStatisticService.getAllSummaryStatistics();
                if (!initialStats.isEmpty()) {
                    SwingUtilities.invokeLater(this::displaySummaryStatistics);
                } else {
                    SwingUtilities.invokeLater(() -> adminStatsArea.setText("No existing summary statistics found.\nPlease click the 'Generate/Update Statistics' button to generate them.")); // "No existing summary statistics found.\nPlease click the 'Generate/Update Statistics' button to generate them."
                }
            } catch (IOException ex) {
                SwingUtilities.invokeLater(() -> adminStatsArea.setText("Failed to load existing statistics!\n" + ex.getMessage())); // "Failed to load existing statistics!\n"
                ex.printStackTrace();
            }
        }).start();
        return panel;
    }

    private void displaySummaryStatistics() {
        adminStatsArea.setText("Loading summary statistics...\n"); // "Loading summary statistics...\n"
        if(generateStatsButton != null) generateStatsButton.setEnabled(false);
        if(refreshDisplayButton != null) refreshDisplayButton.setEnabled(false);

        new Thread(() -> {
            String displayContent;
            try {
                List<SummaryStatistic> stats = summaryStatisticService.getAllSummaryStatistics();
                if (stats.isEmpty()) {
                    displayContent = "No summary statistics currently available.\nPlease click the 'Generate/Update Statistics' button first."; // "No summary statistics currently available.\nPlease click the 'Generate/Update Statistics' button first."
                } else {
                    StringBuilder sb = new StringBuilder("===== Summary Statistics =====\n\n"); // "===== Summary Statistics =====\n\n"
                    stats.sort(Comparator.comparing(SummaryStatistic::getWeekIdentifier));
                    for (int i = stats.size() - 1; i >= 0; i--) {
                        SummaryStatistic stat = stats.get(i);
                        sb.append("Week Identifier: ").append(stat.getWeekIdentifier()).append("\n"); // "Week Identifier: "
                        sb.append("  Total Income: ").append(String.format("%.2f", stat.getTotalIncomeAllUsers())).append(" CNY\n"); // "  Total Income: " ... " CNY\n"
                        sb.append("  Total Expense: ").append(String.format("%.2f", stat.getTotalExpenseAllUsers())).append(" CNY\n"); // "  Total Expense: " ... " CNY\n"
                        if (stat.getTopExpenseCategoryAmount() > 0) {
                            sb.append("  Top Expense Category: ").append(stat.getTopExpenseCategory()).append(" (").append(String.format("%.2f", stat.getTopExpenseCategoryAmount())).append(" CNY)\n"); // "  Top Expense Category: " ... " CNY)\n"
                        } else {
                            sb.append("  Top Expense Category: No significant expense category\n"); // "  Top Expense Category: No significant expense category\n"
                        }
                        sb.append("  Number of Participating Users: ").append(stat.getNumberOfUsersWithTransactions()).append("\n"); // "  Number of Participating Users: "
                        sb.append("  Generated Time: ").append(stat.getTimestampGenerated()).append("\n"); // "  Generated Time: "
                        sb.append("--------------------\n");
                    }
                    displayContent = sb.toString();
                }
            } catch (IOException ex) {
                displayContent = "Failed to load summary statistics!\n" + ex.getMessage(); // "Failed to load summary statistics!\n"
                ex.printStackTrace();
            }
            String finalDisplayContent = displayContent;
            SwingUtilities.invokeLater(() -> {
                adminStatsArea.setText(finalDisplayContent);
                if(generateStatsButton != null) generateStatsButton.setEnabled(true);
                if(refreshDisplayButton != null) refreshDisplayButton.setEnabled(true);
            });
        }).start();
    }

    public void deleteRow(int rowIndex) {
        System.out.println("Attempting to delete row: " + rowIndex + " for user " + currentUser.getUsername());
        if (rowIndex >= 0 && rowIndex < this.tableModel.getRowCount()) {
            String orderNumber = (String) this.tableModel.getValueAt(rowIndex, 8);
            if (orderNumber == null || orderNumber.trim().isEmpty()) {
                JOptionPane.showMessageDialog(null, "Cannot delete: Order Number is empty!", "Error", JOptionPane.ERROR_MESSAGE);
                System.err.println("Attempted to delete row " + rowIndex + " but order number is null or empty.");
                return;
            }
            orderNumber = orderNumber.trim();
            System.out.println("Deleting transaction with order number: " + orderNumber);
            int confirm = JOptionPane.showConfirmDialog(
                    this,
                    "Are you sure you want to delete the transaction with order number '" + orderNumber + "'?", // "Are you sure you want to delete the transaction with order number '" ... "'?"
                    "Confirm Delete", // "Confirm Delete"
                    JOptionPane.YES_NO_OPTION,
                    JOptionPane.QUESTION_MESSAGE
            );
            if (confirm == JOptionPane.YES_OPTION) {
                try {
                    boolean deleted = transactionService.deleteTransaction(orderNumber);
                    if (deleted) {
                        this.tableModel.removeRow(rowIndex);
                        JOptionPane.showMessageDialog(null, "Delete successful!", "Information", JOptionPane.INFORMATION_MESSAGE); // "Delete successful!"
                        System.out.println("Deleted row " + rowIndex + " with order number " + orderNumber + " from UI.");
                        triggerCurrentSearch();
                    } else {
                        JOptionPane.showMessageDialog(null, "Delete failed: Corresponding order number " + orderNumber + " not found", "Error", JOptionPane.ERROR_MESSAGE); // "Delete failed: Corresponding order number " ... " not found"
                        System.err.println("Delete failed: order number " + orderNumber + " not found by service.");
                    }
                } catch (Exception ex) {
                    ex.printStackTrace();
                    JOptionPane.showMessageDialog(null, "Delete failed!\n" + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE); // "Delete failed!\n"
                    System.err.println("Error during deletion for order number " + orderNumber);
                }
            } else {
                System.out.println("Deletion cancelled by user for order number: " + orderNumber);
            }
        } else {
            System.err.println("Attempted to delete row with invalid index: " + rowIndex + ". Table row count: " + this.tableModel.getRowCount());
        }
    }

    private Vector<String> createRowFromTransaction(Transaction transaction) {
        Vector<String> row = new Vector<>();
        row.add(emptyIfNull(transaction.getTransactionTime()));
        row.add(emptyIfNull(transaction.getTransactionType()));
        row.add(emptyIfNull(transaction.getCounterparty()));
        row.add(emptyIfNull(transaction.getCommodity()));
        row.add(emptyIfNull(transaction.getInOut()));
        row.add(String.valueOf(transaction.getPaymentAmount()));
        row.add(emptyIfNull(transaction.getPaymentMethod()));
        row.add(emptyIfNull(transaction.getCurrentStatus()));
        row.add(emptyIfNull(transaction.getOrderNumber()));
        row.add(emptyIfNull(transaction.getMerchantNumber()));
        row.add(emptyIfNull(transaction.getRemarks()));
        row.add("Modify");
        row.add("Delete");
        return row;
    }

    public void searchData(String query1, String query2, String query3, String query4, String query6, String query5) {
        System.out.println("Searching with criteria: time='" + query1 + "', type='" + query2 + "', counterparty='" + query3 + "', commodity='" + query4 + "', inOut='" + query6 + "', paymentMethod='" + query5 + "'");
        this.tableModel.setRowCount(0);
        Transaction searchCriteria = new Transaction(
                query1, query2, query3, query4, query6,
                0,
                query5,
                "", "", "", ""
        );
        try {
            List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);
            System.out.println("Search results count: " + transactions.size());
            for (Transaction transaction : transactions) {
                Vector<String> row = createRowFromTransaction(transaction);
                this.tableModel.addRow(row);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(null, "Search failed!\n" + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE); // "Search failed!\n"
        }
    }

    private double safeParseDouble(String value) {
        if (value == null || value.trim().isEmpty()) return 0.0;
        try { return Double.parseDouble(value.trim()); }
        catch (NumberFormatException e) { System.err.println("Failed to parse double from string: '" + value + "'"); return 0.0; }
    }
    private void clearSearchFields() {
        searchTransactionTimeField.setText("");
        searchTransactionTypeField.setText("");
        searchCounterpartyField.setText("");
        searchCommodityField.setText("");
        searchInOutComboBox.setSelectedItem("");
        searchPaymentMethodField.setText("");
        System.out.println("Cleared search fields.");
    }
    private void triggerCurrentSearch() {
        searchData(
                searchTransactionTimeField.getText().trim(),
                searchTransactionTypeField.getText().trim(),
                searchCounterpartyField.getText().trim(),
                searchCommodityField.getText().trim(),
                (String) searchInOutComboBox.getSelectedItem(),
                searchPaymentMethodField.getText().trim()
        );
        System.out.println("Triggered search with current field values.");
    }
    private String emptyIfNull(String value) {
        return value == null ? "" : value;
    }
    public JTable getTable() {
        return table;
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Controller\VisualizationPanel.java`:

```java
package Controller;

import Service.TransactionService;
import model.MonthlySummary;

import java.awt.*;
import java.util.Map;
import java.util.List; // Import List
import java.util.ArrayList; // Import ArrayList
import java.util.HashMap; // Import HashMap
import java.util.Collections; // Import Collections for sorting
import java.util.Comparator; // Import Comparator

import javax.swing.*;

// Import XChart classes
import org.knowm.xchart.CategoryChart;
import org.knowm.xchart.CategoryChartBuilder;
import org.knowm.xchart.PieChart;
import org.knowm.xchart.PieChartBuilder;
import org.knowm.xchart.SwingWrapper; // Might be needed for Swing components
import org.knowm.xchart.XChartPanel; // Use XChartPanel for Swing display
import org.knowm.xchart.style.Styler.LegendPosition; // For chart styling


/**
 * Panel to display transaction data visualizations using XChart.
 */
public class VisualizationPanel extends JPanel {

    private final TransactionService transactionService;

    private JComboBox<String> monthSelector;
    private JComboBox<String> chartTypeSelector;
    private JButton generateChartButton;
    private JPanel chartDisplayPanel;

    // Define string constants for chart types to avoid magic strings in comparisons
    private static final String SELECT_CHART_TYPE_PROMPT = "Select Chart Type";
    private static final String MONTHLY_EXPENSE_PIE_CHART = "Monthly Expense Category Pie Chart";
    private static final String MONTHLY_TREND_BAR_CHART = "Monthly Income/Expense Trend Bar Chart";
    private static final String SELECT_MONTH_PROMPT = "Select Month";


    /**
     * Constructor to inject the TransactionService.
     * @param transactionService The service to retrieve user transaction data.
     */
    public VisualizationPanel(TransactionService transactionService) {
        this.transactionService = transactionService;
        setLayout(new BorderLayout(10, 10));
        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // --- Control Panel (Top) ---
        JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 5));

        chartTypeSelector = new JComboBox<>(new String[]{SELECT_CHART_TYPE_PROMPT, MONTHLY_EXPENSE_PIE_CHART, MONTHLY_TREND_BAR_CHART});
        controlPanel.add(new JLabel("Chart Type:"));
        controlPanel.add(chartTypeSelector);

        monthSelector = new JComboBox<>();
        monthSelector.setEnabled(false);
        controlPanel.add(new JLabel("Select Month:"));
        controlPanel.add(monthSelector);


        generateChartButton = new JButton("Generate Chart");
        controlPanel.add(generateChartButton);

        add(controlPanel, BorderLayout.NORTH);


        // --- Chart Display Panel (Center) ---
        chartDisplayPanel = new JPanel(new BorderLayout());
        chartDisplayPanel.setBackground(Color.WHITE);
        add(chartDisplayPanel, BorderLayout.CENTER);


        // --- Action Listeners ---
        chartTypeSelector.addActionListener(e -> {
            String selectedType = (String) chartTypeSelector.getSelectedItem();
            boolean needsMonth = MONTHLY_EXPENSE_PIE_CHART.equals(selectedType);
            monthSelector.setEnabled(needsMonth);
            // Populate months only when Pie Chart is selected
            if (needsMonth) {
                populateMonthSelector();
            } else {
                monthSelector.removeAllItems(); // Clear months if not needed
                monthSelector.addItem(SELECT_MONTH_PROMPT); // Add default item back
            }
        });

        generateChartButton.addActionListener(e -> {
            generateAndDisplayChart();
        });

        // Initial state display
        displayPlaceholderChart("Please select a chart type and necessary parameters to generate the chart.");

    }

    /**
     * Populates the month selector combo box with months from available data.
     */
    private void populateMonthSelector() {
        monthSelector.removeAllItems();
        monthSelector.addItem(SELECT_MONTH_PROMPT);

        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            if (summaries != null && !summaries.isEmpty()) {
                // Sort month identifiers chronologically
                summaries.keySet().stream().sorted().forEach(monthSelector::addItem);
            } else {
                JOptionPane.showMessageDialog(this, "No monthly transaction data found to generate charts.", "Insufficient Data", JOptionPane.INFORMATION_MESSAGE);
            }
        } catch (Exception e) {
            System.err.println("Error loading monthly summaries for month selector: " + e.getMessage());
            JOptionPane.showMessageDialog(this, "Failed to load month data!\n" + e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
        }
    }


    /**
     * Generates and displays the selected chart based on user selection using XChart.
     */
    private void generateAndDisplayChart() {
        String selectedChartType = (String) chartTypeSelector.getSelectedItem();
        String selectedMonth = (String) monthSelector.getSelectedItem();

        // Clear previous chart
        chartDisplayPanel.removeAll();
        chartDisplayPanel.revalidate();
        chartDisplayPanel.repaint();

        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            if (summaries == null || summaries.isEmpty()) {
                displayPlaceholderChart("No monthly transaction data found to generate charts.");
                return;
            }

            if (MONTHLY_EXPENSE_PIE_CHART.equals(selectedChartType)) {
                if (selectedMonth == null || selectedMonth.equals(SELECT_MONTH_PROMPT) || selectedMonth.trim().isEmpty()) {
                    JOptionPane.showMessageDialog(this, "Please select a month to view.", "Information", JOptionPane.INFORMATION_MESSAGE);
                    displayPlaceholderChart("Please select a valid month to generate the pie chart.");
                    return;
                }
                // --- Generate Pie Chart ---
                MonthlySummary selectedMonthSummary = summaries.get(selectedMonth);
                if (selectedMonthSummary == null || selectedMonthSummary.getExpenseByCategory().isEmpty()) {
                    displayPlaceholderChart(selectedMonth + " has no expense category data.");
                    return;
                }

                System.out.println("Generating Pie Chart for " + selectedMonth + "...");
                PieChart chart = new PieChartBuilder()
                        .width(chartDisplayPanel.getWidth() > 0 ? chartDisplayPanel.getWidth() : 600) // Ensure width > 0
                        .height(chartDisplayPanel.getHeight() > 0 ? chartDisplayPanel.getHeight() : 400) // Ensure height > 0
                        .title(selectedMonth + " Expense Categories")
                        .build();

                selectedMonthSummary.getExpenseByCategory().entrySet().stream()
                        .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                        .forEach(entry -> chart.addSeries(entry.getKey(), entry.getValue()));

                // Customize chart style
                chart.getStyler().setLegendPosition(LegendPosition.OutsideE);


                // Add the chart to the display panel
                XChartPanel<PieChart> chartPanel = new XChartPanel<>(chart);
                chartDisplayPanel.add(chartPanel, BorderLayout.CENTER);
                System.out.println("Pie Chart generated and displayed.");


            } else if (MONTHLY_TREND_BAR_CHART.equals(selectedChartType)) {
                // --- Generate Bar Chart (Category Chart) ---
                System.out.println("Generating Monthly Income/Expense Trend Bar Chart...");

                List<String> months = new ArrayList<>();
                List<Double> totalIncomes = new ArrayList<>();
                List<Double> totalExpenses = new ArrayList<>();

                List<String> sortedMonths = new ArrayList<>(summaries.keySet());
                Collections.sort(sortedMonths);

                for (String month : sortedMonths) {
                    MonthlySummary ms = summaries.get(month);
                    months.add(month);
                    totalIncomes.add(ms.getTotalIncome());
                    totalExpenses.add(ms.getTotalExpense());
                }

                CategoryChart chart = new CategoryChartBuilder()
                        .width(chartDisplayPanel.getWidth() > 0 ? chartDisplayPanel.getWidth() : 800) // Ensure width > 0
                        .height(chartDisplayPanel.getHeight() > 0 ? chartDisplayPanel.getHeight() : 500) // Ensure height > 0
                        .title("Monthly Income/Expense Trend")
                        .xAxisTitle("Month")
                        .yAxisTitle("Amount (CNY)")
                        .build();

                chart.addSeries("Total Income", months, totalIncomes);
                chart.addSeries("Total Expense", months, totalExpenses);

                // Customize chart style
                chart.getStyler().setLegendPosition(LegendPosition.OutsideS);
                chart.getStyler().setStacked(false);

                // Add the chart to the display panel
                XChartPanel<CategoryChart> chartPanel = new XChartPanel<>(chart);
                chartDisplayPanel.add(chartPanel, BorderLayout.CENTER);
                System.out.println("Bar Chart generated and displayed.");


            } else {
                displayPlaceholderChart("Please select a chart type and necessary parameters to generate the chart.");
            }

        } catch (Exception e) {
            System.err.println("Error generating chart: " + selectedChartType);
            e.printStackTrace();
            displayPlaceholderChart("Failed to generate chart!\n" + e.getMessage());
            JOptionPane.showMessageDialog(this, "Failed to generate chart!\n" + e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
        } finally {
            chartDisplayPanel.revalidate();
            chartDisplayPanel.repaint();
        }
    }

    /**
     * Helper method to display a placeholder message.
     */
    private void displayPlaceholderChart(String message) {
        // Clear previous content first
        chartDisplayPanel.removeAll();

        JLabel placeholderLabel = new JLabel(message, SwingConstants.CENTER);
        placeholderLabel.setFont(new Font("Microsoft YaHei", Font.PLAIN, 16)); // Using a common font name
        chartDisplayPanel.add(placeholderLabel, BorderLayout.CENTER);

        chartDisplayPanel.revalidate();
        chartDisplayPanel.repaint();
    }

    // Optional: Method to trigger initial setup when panel is displayed
    // Call this from MenuUI's ActionListener for the Visualization button
    public void refreshPanelData() {
        System.out.println("VisualizationPanel refreshPanelData called.");
        // Reset chart type selector to default on refresh
        chartTypeSelector.setSelectedItem(SELECT_CHART_TYPE_PROMPT);
        // Display initial instruction message
        displayPlaceholderChart("Please select a chart type and necessary parameters to generate the chart.");
    }

}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\DAO\Impl\CsvSummaryStatisticDao.java`:

```java
package DAO.Impl;

import DAO.SummaryStatisticDao;
import model.SummaryStatistic;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class CsvSummaryStatisticDao implements SummaryStatisticDao {

    // Define the header for the summary statistics CSV
    private static final String[] HEADERS = {
            "week_identifier", "total_income_all_users", "total_expense_all_users",
            "top_expense_category", "top_expense_category_amount",
            "number_of_users_with_transactions", "timestamp_generated"
    };

    @Override
    public List<SummaryStatistic> loadAllStatistics(String filePath) throws IOException {
        List<SummaryStatistic> statistics = new ArrayList<>();
        Path path = Paths.get(filePath);

        if (!Files.exists(path) || Files.size(path) == 0) {
            System.out.println("Summary statistics CSV file not found or is empty: " + filePath);
            return statistics;
        }

        try (Reader reader = new InputStreamReader(
                new BOMInputStream(Files.newInputStream(path)),
                StandardCharsets.UTF_8)) {

            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()
                    .withIgnoreHeaderCase(true)
                    .withTrim(true);

            try (CSVParser csvParser = new CSVParser(reader, format)) {
                Map<String, Integer> headerMap = csvParser.getHeaderMap();
                // Basic header validation
                List<String> requiredHeaders = List.of(HEADERS);
                if (headerMap == null || !headerMap.keySet().containsAll(requiredHeaders)) {
                    throw new IOException("Missing required headers in summary statistics CSV file: " + requiredHeaders +
                            " Found: " + (headerMap == null ? "null" : headerMap.keySet()));
                }

                for (CSVRecord record : csvParser) {
                    try {
                        SummaryStatistic stat = parseRecord(record);
                        if (stat != null) { // parseRecord might return null on error
                            statistics.add(stat);
                        }
                    } catch (Exception e) {
                        System.err.println("Skipping malformed summary statistic record at line " + record.getRecordNumber() + ": " + record.toString());
                        e.printStackTrace();
                    }
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading summary statistics from CSV: " + filePath);
            e.printStackTrace();
            throw e;
        }
        System.out.println("Successfully loaded " + statistics.size() + " summary statistics from " + filePath);
        return statistics;
    }

    // Helper to parse a single CSV record into a SummaryStatistic object
    private SummaryStatistic parseRecord(CSVRecord record) {
        // Defensive getting of values to prevent exceptions on missing columns
        String weekIdentifier = record.get("week_identifier");
        String totalIncomeStr = record.get("total_income_all_users");
        String totalExpenseStr = record.get("total_expense_all_users");
        String topExpenseCategory = record.get("top_expense_category");
        String topExpenseAmountStr = record.get("top_expense_category_amount");
        String numUsersStr = record.get("number_of_users_with_transactions");
        String timestampGenerated = record.get("timestamp_generated");

        // Basic validation for essential fields
        if (weekIdentifier == null || weekIdentifier.trim().isEmpty() ||
                totalIncomeStr == null || totalIncomeStr.trim().isEmpty() ||
                totalExpenseStr == null || totalExpenseStr.trim().isEmpty() ||
                numUsersStr == null || numUsersStr.trim().isEmpty() ||
                timestampGenerated == null || timestampGenerated.trim().isEmpty()) {
            System.err.println("Skipping summary record due to missing essential fields: " + record.toMap());
            return null; // Indicate parsing failed for this record
        }

        try {
            double totalIncome = Double.parseDouble(totalIncomeStr.trim());
            double totalExpense = Double.parseDouble(totalExpenseStr.trim());
            double topExpenseAmount = (topExpenseAmountStr != null && !topExpenseAmountStr.trim().isEmpty()) ? Double.parseDouble(topExpenseAmountStr.trim()) : 0.0;
            int numUsers = Integer.parseInt(numUsersStr.trim());

            return new SummaryStatistic(
                    weekIdentifier.trim(),
                    totalIncome,
                    totalExpense,
                    topExpenseCategory != null ? topExpenseCategory.trim() : "N/A", // Top category might be empty if no expenses
                    topExpenseAmount,
                    numUsers,
                    timestampGenerated.trim()
            );
        } catch (NumberFormatException e) {
            System.err.println("Skipping summary record due to number format error: " + record.toMap());
            e.printStackTrace();
            return null; // Indicate parsing failed
        }
    }


    @Override
    public void writeAllStatistics(String filePath, List<SummaryStatistic> statistics) throws IOException {
        Path path = Paths.get(filePath);
        // Ensure the directory exists
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }

        // Use a temporary file for atomic write
        File targetFile = path.toFile();
        File tempFile = File.createTempFile("summary_temp", ".csv", targetFile.getParentFile());

        try (BufferedWriter writer = Files.newBufferedWriter(tempFile.toPath(), StandardCharsets.UTF_8);
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(HEADERS).withTrim())) { // Always write header for overwrite

            for (SummaryStatistic stat : statistics) {
                csvPrinter.printRecord(
                        stat.getWeekIdentifier(),
                        stat.getTotalIncomeAllUsers(),
                        stat.getTotalExpenseAllUsers(),
                        stat.getTopExpenseCategory(),
                        stat.getTopExpenseCategoryAmount(),
                        stat.getNumberOfUsersWithTransactions(),
                        stat.getTimestampGenerated()
                );
            }
            // csvPrinter.flush(); // Auto-flushed on close
        } catch (IOException e) {
            tempFile.delete(); // Clean up temp file on failure
            System.err.println("Error writing summary statistics to temporary CSV file: " + tempFile.toPath());
            e.printStackTrace();
            throw e; // Re-throw
        }

        // Atomic replacement
        try {
            Files.move(tempFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
            System.out.println("Atomically replaced " + filePath + " with updated summary statistics.");
        } catch (IOException e) {
            System.err.println("Failed to atomically replace original summary file: " + targetFile.toPath());
            tempFile.delete(); // Clean up temp file
            e.printStackTrace();
            throw e; // Re-throw
        }
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\DAO\Impl\CsvTransactionDao.java`:

```java
package DAO.Impl; // Changed package

import Constants.ConfigConstants;
import DAO.TransactionDao; // Implement the interface
import model.Transaction;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional; // Using Optional for getTransactionByOrderNumber
import java.util.stream.Collectors;


public class CsvTransactionDao implements TransactionDao { // Implement TransactionDao interface

    @Override
    public List<Transaction> loadFromCSV(String filePath) throws IOException {
        List<Transaction> transactions = new ArrayList<>();
        Path path = Paths.get(filePath);

        if (!Files.exists(path) || Files.size(path) == 0) {
            System.out.println("CSV file not found or is empty: " + filePath);
            return transactions;
        }

        try (Reader reader = new InputStreamReader(
                new BOMInputStream(Files.newInputStream(path)),
                StandardCharsets.UTF_8)) {

            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()
                    .withIgnoreHeaderCase(true)
                    .withTrim(true);

            try (CSVParser csvParser = new CSVParser(reader, format)) {
                // Define expected English headers
                List<String> requiredHeaders = List.of(
                        "Transaction Time", "Transaction Type", "Counterparty", "Commodity", "In/Out", "Amount(CNY)",
                        "Payment Method", "Current Status", "Order Number", "Merchant Number", "Remarks"
                );

                Map<String, Integer> headerMap = csvParser.getHeaderMap();
                if (headerMap == null || !headerMap.keySet().containsAll(requiredHeaders)) {
                    throw new IOException("Missing required headers in CSV file. Expected: " + requiredHeaders +
                            " Found: " + (headerMap == null ? "No headers found by parser" : headerMap.keySet()));
                }
                System.out.println("Successfully identified headers: " + headerMap.keySet() + " in file: " + filePath);

                for (CSVRecord record : csvParser) {
                    try {
                        transactions.add(parseRecord(record));
                    } catch (Exception e) {
                        System.err.println("Skipping malformed record at line " + record.getRecordNumber() + ": " + record.toString());
                        e.printStackTrace();
                    }
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading CSV file: " + filePath);
            e.printStackTrace();
            throw e;
        }
        System.out.println("Successfully loaded " + transactions.size() + " records from " + filePath);
        return transactions;
    }

    private Transaction parseRecord(CSVRecord record) {
        // Now using English header names to get values from the record
        String amountStr = record.get("Amount(CNY)").trim();
        double paymentAmount = 0.0;
        try {
            if (amountStr.startsWith("¥") || amountStr.startsWith("$")) { // Allow for currency symbols
                amountStr = amountStr.substring(1);
            }
            paymentAmount = Double.parseDouble(amountStr);
        } catch (NumberFormatException e) {
            System.err.println("Warning: Could not parse payment amount '" + record.get("Amount(CNY)") + "' at line " + record.getRecordNumber());
        } catch (IllegalArgumentException e) {
            System.err.println("Warning: Missing 'Amount(CNY)' column or empty value at line " + record.getRecordNumber());
        }

        // Expect English values for "In/Out" from CSV or standardize them here if necessary
        // For now, assuming the CSV provides "Income" or "Expense" directly for "In/Out"
        String inOut = record.get("In/Out").trim();
        // Example standardization if CSV might still have Chinese:
        // if (inOut.equals("收入") || inOut.equals("收")) {
        //     inOut = "Income";
        // } else if (inOut.equals("支出") || inOut.equals("支")) {
        //     inOut = "Expense";
        // }

        return new Transaction(
                record.get("Transaction Time").trim(),
                record.get("Transaction Type").trim(),
                record.get("Counterparty").trim(),
                record.get("Commodity").trim(),
                inOut, // Use the processed/standardized inOut
                paymentAmount,
                record.get("Payment Method").trim(),
                record.get("Current Status").trim(),
                record.get("Order Number").trim(),
                record.get("Merchant Number").trim(),
                record.get("Remarks").trim()
        );
    }

    @Override
    public List<Transaction> getAllTransactions(String filePath) throws IOException {
        return loadFromCSV(filePath);
    }

    @Override
    public void addTransaction(String filePath, Transaction newTransaction) throws IOException {
        Path path = Paths.get(filePath);
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }
        boolean fileExists = Files.exists(path) && Files.size(path) > 0;

        // Use English headers for writing
        String[] headers = {"Transaction Time", "Transaction Type", "Counterparty", "Commodity", "In/Out", "Amount(CNY)", "Payment Method", "Current Status", "Order Number", "Merchant Number", "Remarks"};

        try (BufferedWriter writer = Files.newBufferedWriter(path, StandardCharsets.UTF_8, StandardOpenOption.CREATE, StandardOpenOption.APPEND)) {
            CSVFormat format;
            if (!fileExists) { // If file did not exist or was empty before this operation
                format = CSVFormat.DEFAULT.withHeader(headers).withTrim();
            } else {
                format = CSVFormat.DEFAULT.withTrim();
            }

            try (CSVPrinter csvPrinter = new CSVPrinter(writer, format)) {
                csvPrinter.printRecord(
                        newTransaction.getTransactionTime(),
                        newTransaction.getTransactionType(),
                        newTransaction.getCounterparty(),
                        newTransaction.getCommodity(),
                        newTransaction.getInOut(), // Expecting this to be "Income" or "Expense"
                        String.format("¥%.2f", newTransaction.getPaymentAmount()), // Or use "CNY" prefix if preferred
                        newTransaction.getPaymentMethod(),
                        newTransaction.getCurrentStatus(),
                        newTransaction.getOrderNumber(),
                        newTransaction.getMerchantNumber(),
                        newTransaction.getRemarks()
                );
            }
            System.out.println("Added transaction to " + filePath);
        } catch (IOException e) {
            System.err.println("Error adding transaction to CSV: " + filePath);
            e.printStackTrace();
            throw e;
        }
    }

    @Override
    public boolean deleteTransaction(String filePath, String orderNumber) throws IOException {
        List<Transaction> allTransactions = loadFromCSV(filePath);
        List<Transaction> updatedTransactions = allTransactions.stream()
                .filter(t -> !t.getOrderNumber().trim().equals(orderNumber.trim()))
                .collect(Collectors.toList());

        boolean deleted = allTransactions.size() > updatedTransactions.size();
        if (deleted) {
            writeTransactionsToCSV(filePath, updatedTransactions);
            System.out.println("Deleted transaction with order number " + orderNumber + " from " + filePath);
        } else {
            System.out.println("Transaction with order number " + orderNumber + " not found in " + filePath);
        }
        return deleted;
    }

    @Override
    public boolean updateTransaction(String filePath, String orderNumber, String fieldName, String newValue) throws IOException {
        List<Transaction> allTransactions = loadFromCSV(filePath);
        Optional<Transaction> transactionToUpdateOpt = allTransactions.stream()
                .filter(t -> t.getOrderNumber().trim().equals(orderNumber.trim()))
                .findFirst();

        if (!transactionToUpdateOpt.isPresent()) {
            System.out.println("Transaction with order number " + orderNumber + " not found for update in " + filePath);
            return false;
        }

        Transaction transactionToUpdate = transactionToUpdateOpt.get();
        boolean updated = false;

        // Assuming fieldName matches the English property names of Transaction class
        switch (fieldName) {
            case "transactionTime":
                transactionToUpdate.setTransactionTime(newValue);
                updated = true;
                break;
            case "transactionType":
                transactionToUpdate.setTransactionType(newValue);
                updated = true;
                break;
            case "counterparty":
                transactionToUpdate.setCounterparty(newValue);
                updated = true;
                break;
            case "commodity":
                transactionToUpdate.setCommodity(newValue);
                updated = true;
                break;
            case "inOut": // Ensure newValue is "Income" or "Expense"
                if ("Income".equalsIgnoreCase(newValue) || "Expense".equalsIgnoreCase(newValue)) {
                    transactionToUpdate.setInOut(newValue);
                    updated = true;
                } else {
                    System.err.println("Invalid value for In/Out update: " + newValue + ". Must be 'Income' or 'Expense'.");
                }
                break;
            case "paymentAmount":
                try {
                    if (newValue.startsWith("¥") || newValue.startsWith("$")) {
                        newValue = newValue.substring(1);
                    }
                    transactionToUpdate.setPaymentAmount(Double.parseDouble(newValue));
                    updated = true;
                } catch (NumberFormatException e) {
                    System.err.println("Invalid number format for paymentAmount update: " + newValue);
                    throw new NumberFormatException("Invalid number format for paymentAmount: " + newValue);
                }
                break;
            case "paymentMethod":
                transactionToUpdate.setPaymentMethod(newValue);
                updated = true;
                break;
            case "currentStatus":
                transactionToUpdate.setCurrentStatus(newValue);
                updated = true;
                break;
            case "orderNumber":
                transactionToUpdate.setOrderNumber(newValue);
                updated = true;
                break;
            case "merchantNumber":
                transactionToUpdate.setMerchantNumber(newValue);
                updated = true;
                break;
            case "remarks":
                transactionToUpdate.setRemarks(newValue);
                updated = true;
                break;
            default:
                System.err.println("Invalid field name for update: " + fieldName);
                throw new IllegalArgumentException("Invalid field name: " + fieldName);
        }

        if (updated) {
            writeTransactionsToCSV(filePath, allTransactions);
            System.out.println("Updated transaction with order number " + orderNumber + " in " + filePath + " field: " + fieldName);
        }
        return updated;
    }

    @Override
    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
        Path path = Paths.get(filePath);
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }
        File targetFile = path.toFile();
        File tempFile = File.createTempFile("transaction_temp_", ".csv", targetFile.getParentFile());

        // Use English headers for writing
        String[] headers = {"Transaction Time", "Transaction Type", "Counterparty", "Commodity", "In/Out", "Amount(CNY)", "Payment Method", "Current Status", "Order Number", "Merchant Number", "Remarks"};

        try (BufferedWriter writer = Files.newBufferedWriter(tempFile.toPath(), StandardCharsets.UTF_8);
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(headers).withTrim())) {
            for (Transaction t : transactions) {
                csvPrinter.printRecord(
                        t.getTransactionTime(),
                        t.getTransactionType(),
                        t.getCounterparty(),
                        t.getCommodity(),
                        t.getInOut(), // Expecting "Income" or "Expense"
                        String.format("¥%.2f", t.getPaymentAmount()), // Or "CNY" prefix
                        t.getPaymentMethod(),
                        t.getCurrentStatus(),
                        t.getOrderNumber(),
                        t.getMerchantNumber(),
                        t.getRemarks()
                );
            }
        } catch (IOException e) {
            if (tempFile.exists()) tempFile.delete();
            System.err.println("Error writing transactions to temporary CSV file: " + tempFile.toPath());
            e.printStackTrace();
            throw e;
        }

        try {
            Files.move(tempFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
            System.out.println("Atomically replaced " + filePath + " with updated data.");
        } catch (IOException e) {
            System.err.println("Failed to atomically replace original file: " + targetFile.toPath() + " with " + tempFile.toPath());
            if (tempFile.exists()) tempFile.delete();
            e.printStackTrace();
            throw e;
        }
    }

    @Override
    public Transaction getTransactionByOrderNumber(String filePath, String orderNumber) throws IOException {
        List<Transaction> allTransactions = loadFromCSV(filePath);
        Optional<Transaction> transactionOpt = allTransactions.stream()
                .filter(t -> t.getOrderNumber().trim().equals(orderNumber.trim()))
                .findFirst();
        return transactionOpt.orElse(null);
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\DAO\Impl\CsvUserDao.java`:

```java
package DAO.Impl;

import Constants.ConfigConstants;
import DAO.UserDao;
import model.User;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

public class CsvUserDao implements UserDao {

    private final String filePath;

    public CsvUserDao(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public List<User> getAllUsers() throws IOException {
        List<User> users = new ArrayList<>();
        // Use BOMInputStream to handle potential Byte Order Mark issues
        try (Reader reader = new InputStreamReader(
                new BOMInputStream(Files.newInputStream(Paths.get(filePath))),
                StandardCharsets.UTF_8)) {

            // Configure CSVFormat to handle headers
            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()
                    .withIgnoreHeaderCase(true) // Ignore header case for robustness
                    .withTrim(true); // Trim leading/trailing whitespace

            try (CSVParser csvParser = new CSVParser(reader, format)) {
                // Check if the required headers are present
                List<String> requiredHeaders = List.of("username", "password", "role", "transaction_csv_path");
                if (!csvParser.getHeaderMap().keySet().containsAll(requiredHeaders)) {
                    throw new IOException("Missing required headers in users CSV file: " + requiredHeaders);
                }

                for (CSVRecord record : csvParser) {
                    // Basic error handling for potentially missing fields in a row
                    String username = record.get("username");
                    String password = record.get("password");
                    String role = record.get("role");
                    String transactionFilePath = record.get("transaction_csv_path");

                    if (username == null || username.trim().isEmpty() || password == null || password.trim().isEmpty() || role == null || role.trim().isEmpty() || transactionFilePath == null || transactionFilePath.trim().isEmpty()) {
                        System.err.println("Skipping malformed user record: " + record.toMap());
                        continue; // Skip this row
                    }

                    User user = new User(username.trim(), password.trim(), role.trim(), transactionFilePath.trim());
                    users.add(user);
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading users from CSV file: " + filePath);
            e.printStackTrace();
            throw e; // Re-throw the exception after logging
        }
        return users;
    }

    // Helper method to parse a single record (optional, can be in getAllUsers)
    // private User parseRecord(CSVRecord record) { ... }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\DAO\SummaryStatisticDao.java`:

```java
package DAO;

import model.SummaryStatistic;

import java.io.IOException;
import java.util.List;

public interface SummaryStatisticDao {

    /**
     * Loads all summary statistics from the configured data source.
     * @param filePath The path to the summary statistics CSV file.
     * @return A list of all summary statistics.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<SummaryStatistic> loadAllStatistics(String filePath) throws IOException;

    /**
     * Writes a list of summary statistics to the configured data source, overwriting existing data.
     * @param filePath The path to the summary statistics CSV file.
     * @param statistics The list of statistics to write.
     * @throws IOException If an I/O error occurs during saving.
     */
    void writeAllStatistics(String filePath, List<SummaryStatistic> statistics) throws IOException;

    // Optional: Add method to get statistic by week identifier if needed
    // SummaryStatistic getStatisticByWeek(String filePath, String weekIdentifier) throws IOException;
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\DAO\TransactionDao.java`:

```java
package DAO;

import model.Transaction;

import java.io.IOException;
import java.util.List;

/**
 * Interface for Data Access Object (DAO) operations related to Transactions.
 * Defines the contract for loading, adding, deleting, and updating transaction data.
 */
public interface TransactionDao {

    // Keep loadFromCSV - used by cache loader
    List<Transaction> loadFromCSV(String filePath) throws IOException;

    /**
     * Loads all transactions from the specified data source file.
     * @param filePath The path to the user's CSV file.
     * @return A list of all transactions.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<Transaction> getAllTransactions(String filePath) throws IOException;


    /**
     * Adds a new transaction to the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param transaction The new transaction to add.
     * @throws IOException If an I/O error occurs during saving.
     */
    void addTransaction(String filePath, Transaction transaction) throws IOException;

    /**
     * Deletes a transaction identified by its order number from the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param orderNumber The unique order number of the transaction to delete.
     * @return true if a transaction was found and deleted, false otherwise.
     * @throws IOException If an I/O error occurs during loading or saving.
     */
    boolean deleteTransaction(String filePath, String orderNumber) throws IOException;

    /**
     * Updates a specific field of an existing transaction identified by its order number
     * in the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param orderNumber The unique order number of the transaction to update.
     * @param fieldName   The name of the field to update (e.g., "transactionType", "paymentAmount").
     * @param newValue    The new value for the specified field.
     * @return true if the transaction was found and updated, false otherwise.
     * @throws IOException             If an I/O error occurs during loading or saving.
     * @throws NumberFormatException   If updating 'paymentAmount' and newValue is not a valid double.
     * @throws IllegalArgumentException If the fieldName is invalid.
     */
    boolean updateTransaction(String filePath, String orderNumber, String fieldName, String newValue) throws IOException;

    /**
     * Retrieves a transaction by its unique order number from the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param orderNumber The unique order number.
     * @return The Transaction object if found, null otherwise.
     * @throws IOException If an I/O error occurs during loading.
     */
    Transaction getTransactionByOrderNumber(String filePath, String orderNumber) throws IOException;

    void writeTransactionsToCSV(String currentUserTransactionFilePath, List<Transaction> updatedList) throws IOException;

    // Remove the old methods without filePath parameter from the interface
    // List<Transaction> getAllTransactions() throws IOException; // Removed
    // void addTransaction(Transaction transaction) throws IOException; // Removed
    // boolean deleteTransaction(String orderNumber) throws IOException; // Removed
    // boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException; // Removed
    // Transaction getTransactionByOrderNumber(String orderNumber) throws IOException; // Removed
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\DAO\UserDao.java`:

```java
package DAO;

import model.User;

import java.io.IOException;
import java.util.List;

/**
 * Interface for Data Access Object (DAO) operations related to Users.
 */
public interface UserDao {

    /**
     * Loads all users from the configured data source.
     *
     * @return A list of all users.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<User> getAllUsers() throws IOException;

    // Add other user-related methods if needed later (e.g., addUser, deleteUser)
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Interceptor\Login\LoginDialog.java`:

```java
package Interceptor.Login;

import Service.User.UserService; // Import the new UserService
import model.User;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class LoginDialog extends JDialog {
    private User authenticatedUser = null; // Change from boolean flag to User object
    private JTextField usernameField;
    private JPasswordField passwordField;
    // UserService should ideally be injected, but for simplicity in LoginDialog,
    // we might initialize it here or pass it from Main. Let's pass it from Main.
    private final UserService userService;

    // Constructor now accepts UserService
    public LoginDialog(UserService userService) {
        this.userService = userService; // Inject UserService

        setTitle("User Login"); // "用户登录"
        setLayout(new GridLayout(3, 2));
        setModal(true);
        setSize(300, 150);
        setResizable(false); // Prevent resizing

        // Input components
        usernameField = new JTextField();
        passwordField = new JPasswordField();
        JButton loginButton = new JButton("Login");
        JButton cancelButton = new JButton("Cancel");

        // Add components
        add(new JLabel("Username:"));
        add(usernameField);
        add(new JLabel("Password:"));
        add(passwordField);
        add(loginButton);
        add(cancelButton);

        // Login button logic
        loginButton.addActionListener(e -> {
            String username = usernameField.getText().trim();
            String password = new String(passwordField.getPassword()).trim();

            authenticatedUser = userService.authenticate(username, password); // Use new authenticate method

            if (authenticatedUser != null) { // Check if a User object was returned
                dispose(); // Close dialog
            } else {
                JOptionPane.showMessageDialog(
                        this,
                        "Incorrect username or password!", // "Wrong username or password!"
                        "Login Failed",                    // "Login Failed"
                        JOptionPane.ERROR_MESSAGE
                );
                clearFields(); // Clear fields on failure
            }
        });

        // Cancel button logic
        cancelButton.addActionListener(e -> {
            authenticatedUser = null; // Ensure no user is set on cancel
            dispose();
            System.exit(0); // Exit application on cancel
        });

        setLocationRelativeTo(null); // Center dialog
    }

    // Method to clear input fields
    private void clearFields() {
        usernameField.setText("");
        passwordField.setText("");
        usernameField.requestFocusInWindow(); // Focus back to username field
    }

    /**
     * Shows the login dialog and returns the authenticated user upon successful login.
     * Blocking call.
     * @return The authenticated User object, or null if login failed or was cancelled.
     */
    public User showDialogAndGetResult() {
        setVisible(true); // Show the dialog (this call is blocking because modal is true)
        return authenticatedUser; // Return the result after dialog is closed
    }

    // Remove isLoginSuccessful() as we now return the User object
    // public boolean isLoginSuccessful() { return loginSuccessful; }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Main.java`:

```java
import javax.swing.*;

import Controller.MenuUI;
import DAO.Impl.CsvTransactionDao;
import DAO.Impl.CsvUserDao;
import DAO.Impl.CsvSummaryStatisticDao;
import DAO.UserDao;
import DAO.TransactionDao;
import DAO.SummaryStatisticDao;
import Interceptor.Login.LoginDialog;
import Service.Impl.TransactionServiceImpl;
import Service.Impl.SummaryStatisticService;
import Service.AIservice.AITransactionService; // Import AI Service classes
import Service.AIservice.CollegeStudentNeeds;
import Service.TransactionService;
import Service.User.UserService;
import com.formdev.flatlaf.FlatIntelliJLaf;
import model.User;
import Constants.ConfigConstants;

public class Main {
    public static void main(String[] args) {
        // Ensure ConfigConstants is loaded first
        String usersCsvPath = ConfigConstants.USERS_CSV_PATH;
        String summaryCsvPath = ConfigConstants.SUMMARY_CSV_PATH;
        System.out.println("Attempting to load users from: " + usersCsvPath);
        System.out.println("Summary statistics will be saved to: " + summaryCsvPath);


        // Initialize DAOs
        UserDao userDao = new CsvUserDao(usersCsvPath);
        TransactionDao transactionDao = new CsvTransactionDao();
        SummaryStatisticDao summaryStatisticDao = new CsvSummaryStatisticDao();


        // Initialize Services
        UserService userService = new UserService(userDao);
        // TransactionServiceImpl is initialized per user in MenuUI -> NO, initialize it here and pass it!
        // The TransactionServiceImpl instance *is* user-specific, so it's better to create it *after* login.
        // But AI Services need it *before* MenuUI is fully constructed and shows the panel.
        // Option 1: Pass TransactionService to MenuUI constructor and AI/CS services are initialized in MenuUI. (Current approach)
        // Option 2: Create AI/CS services here in Main and pass them to MenuUI. They would need the user-specific TS instance.
        // Let's stick with Option 1 for now, initializing AI/CS in MenuUI after getting TS.

        SummaryStatisticService summaryStatisticService = new SummaryStatisticService(userDao, transactionDao, summaryStatisticDao);

        try {
            UIManager.setLookAndFeel( new FlatIntelliJLaf() );
        } catch( Exception ex ) {
            System.err.println( "Failed to initialize LaF" );
        }
        // In the event dispatch thread (EDT) start GUI
        SwingUtilities.invokeLater(() -> {
            LoginDialog loginDialog = new LoginDialog(userService);
            User authenticatedUser = loginDialog.showDialogAndGetResult();

            if (authenticatedUser != null) {
                System.out.println("Logged in as: " + authenticatedUser.getUsername() + " (" + authenticatedUser.getRole() + ")");
                System.out.println("User's transaction file: " + authenticatedUser.getTransactionFilePath());

                // Initialize TransactionServiceImpl *for the logged-in user*
                TransactionService transactionServiceForCurrentUser = new TransactionServiceImpl(authenticatedUser.getTransactionFilePath());

                // Initialize AI Services *with* the user-specific TransactionService
                // This is where AI/CS services are created with their dependency injected
                AITransactionService aiTransactionService = new AITransactionService(transactionServiceForCurrentUser);
                CollegeStudentNeeds collegeStudentNeeds = new CollegeStudentNeeds(transactionServiceForCurrentUser);


                // Pass the authenticated user, their transaction service, summary statistic service, AND AI services to MenuUI
                MenuUI menuUI = new MenuUI(authenticatedUser, transactionServiceForCurrentUser, summaryStatisticService, aiTransactionService, collegeStudentNeeds); // Modify MenuUI constructor


                JFrame frame = new JFrame("Transaction Management System - " + authenticatedUser.getUsername());
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.setSize(2000, 1500);
                frame.setLocationRelativeTo(null);
                frame.add(menuUI.createMainPanel());
                frame.setVisible(true);
            } else {
                System.out.println("Login failed or cancelled. Exiting.");
                System.exit(0);
            }
        });
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Service\AIservice\AIAnalyzerThread.java`:

```java
package Service.AIservice;

// Add required imports
import Service.TransactionService; // Import if analyzeTransactions throws Exception


public class AIAnalyzerThread implements Runnable {
    private final String userRequest;
    private final String filePath; // Still needed for analyzeTransactions method signature
    private final String startTimeStr;
    private final String endTimeStr;

    // Field to hold the injected AITransactionService service instance
    private final AITransactionService aiTransactionService;


    /**
     * Constructor now accepts the AITransactionService service instance
     * and the parameters for the analysis request.
     *
     * @param aiTransactionService The AITransactionService service instance to use.
     * @param userRequest The user's natural language request.
     * @param filePath The path to the user's transaction data file.
     * @param startTimeStr The start time string for filtering.
     * @param endTimeStr The end time string for filtering.
     */
    public AIAnalyzerThread(AITransactionService aiTransactionService, String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        this.aiTransactionService = aiTransactionService; // Inject the service
        this.userRequest = userRequest;
        this.filePath = filePath; // Still needed for analyzeTransactions call
        this.startTimeStr = startTimeStr;
        this.endTimeStr = endTimeStr;
        System.out.println("AIAnalyzerThread initialized for file: " + filePath);
    }

    @Override
    public void run() {
        System.out.println("AIAnalyzerThread started for analysis request: '" + userRequest + "' on file: " + filePath);
        try {
            // Call the analyzeTransactions method on the injected service instance
            String result = aiTransactionService.analyzeTransactions(userRequest, filePath, startTimeStr, endTimeStr);

            // Print the result or handle it as needed by the test/caller that starts this thread
            System.out.println("AI analysis result from thread: " + result);

            // TODO: If this thread is used by a UI program, use SwingUtilities.invokeLater() to update a UI component with 'result'
            // This indicates this class might be intended for background tasks separate from the main UI refresh cycle handled in MenuUI.
        } catch (Exception e) { // Catch Exception as analyzeTransactions throws Exception
            System.err.println("Error during AI analysis in thread for file " + filePath + ": " + e.getMessage());
            e.printStackTrace();
            // You might want to pass this error back to the caller if it's a UI context.
        }
        System.out.println("AIAnalyzerThread finished for file: " + filePath);
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Service\AIservice\AITransactionService.java`:

```java
package Service.AIservice;

import DAO.TransactionDao;
import DAO.Impl.CsvTransactionDao;
import Service.TransactionService;
import Utils.CacheManager;
import model.MonthlySummary;
import model.Transaction;

import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;

import java.io.IOException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;
import java.util.concurrent.*;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;

public class AITransactionService {
    // Keep static ArkService as it's typically thread-safe and stateless
    private static final String API_KEY = System.getenv("ARK_API_KEY"); // Or load from config.properties
    private static final ArkService service = ArkService.builder()
            .timeout(Duration.ofSeconds(1800))
            .connectTimeout(Duration.ofSeconds(20))
            .baseUrl("https://ark.cn-beijing.volces.com/api/v3")
            .apiKey(API_KEY) // Ensure API_KEY is loaded
            .build();

    // Need access to TransactionService to get monthly summaries
    private final TransactionService transactionService; // Inject TransactionService


    /**
     * Constructor now accepts TransactionService instance.
     */
    public AITransactionService(TransactionService transactionService) {
        this.transactionService = transactionService; // Inject the service
        System.out.println("AITransactionService initialized with TransactionService.");
    }

    /**
     * Analyzes transactions from a specific user's file based on user request and time range.
     *
     * @param userRequest The user's natural language request.
     * @param filePath The path to the user's transaction CSV file.
     * @param startTimeStr The start time string for filtering.
     * @param endTimeStr The end time string for filtering.
     * @return AI analysis result as a String.
     */
    public String analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        try {
            // Get transactions for the specified file path using CacheManager
            // Need to pass a DAO instance for the CacheManager's loader if it needs to load from file.
            TransactionDao transactionDaoForLoading = new CsvTransactionDao(); // Create a DAO instance for loading
            List<Transaction> transactions = CacheManager.getTransactions(filePath, transactionDaoForLoading);
            System.out.println("AI Service: Retrieved " + transactions.size() + " transactions for file: " + filePath);


            // Format filtered transactions for the AI prompt
            List<String> transactionDetails = formatTransactions(transactions, startTimeStr, endTimeStr);
            System.out.println("AI Service: Formatted " + transactionDetails.size() + " transactions for AI.");


            // Check if any transactions were found after filtering
            if (transactionDetails.isEmpty() || (transactionDetails.size() == 1 && transactionDetails.get(0).startsWith("No transactions found within this time period"))) {
                return "No transaction records found matching the criteria within this time period, analysis cannot be performed. Please check the time and transaction data.";
            }

            String aiPrompt = userRequest + "\n" + "Here is my billing information:\n" + String.join("\n", transactionDetails);
            System.out.println("AI Service: Sending prompt to AI. Prompt length: " + aiPrompt.length());
            return askAi(aiPrompt);
        } catch (IllegalArgumentException e) {
            System.err.println("AI analysis failed due to invalid time format: " + e.getMessage());
            return "AI analysis failed: Incorrect time format. " + e.getMessage();
        }
        catch (Exception e) {
            System.err.println("AI analysis failed during data retrieval or AI call for file: " + filePath);
            e.printStackTrace();
            return "AI analysis failed: An error occurred while fetching data or calling the AI service. " + e.getMessage();
        }
    }


    // Keep formatTransactions, parseDateTime, askAi methods. Ensure parseDateTime is robust.
    // The formatTransactions method relies on parseDateTime, ensure consistency with TransactionServiceImpl's parser.

    public List<String> formatTransactions(List<Transaction> transactions, String startTimeStr, String endTimeStr) {
        LocalDateTime startTime = parseDateTime(startTimeStr);
        // If end time is empty, use current time
        LocalDateTime endTime = (endTimeStr == null || endTimeStr.trim().isEmpty())
                ? LocalDateTime.now()
                : parseDateTime(endTimeStr);

        if (startTime == null) {
            // Handle the case where start time is invalid.
            // Depending on requirements, you might throw an exception or return an error message list.
            // Throwing IllegalArgumentException is better for analyzeTransactions to catch.
            throw new IllegalArgumentException("Incorrect start time format: " + startTimeStr);
        }
        // If endTime parsing fails, treat it as current time as per original logic if endTimeStr was not empty
        if ((endTimeStr != null && !endTimeStr.trim().isEmpty()) && endTime == null) {
            throw new IllegalArgumentException("Incorrect end time format: " + endTimeStr);
        }
        // If endTimeStr was empty, endTime is already LocalDateTime.now() which is not null.

        System.out.println("Filtering transactions from " + startTime + " to " + endTime);


        List<Transaction> filtered = transactions.stream()
                .filter(t -> {
                    LocalDateTime tTime = parseDateTime(t.getTransactionTime());
                    // Include transactions exactly at startTime, exclude transactions exactly at endTime (standard range behavior [start, end))
                    // If endTime should be inclusive, change isBefore(startTime) to !isAfter(startTime) and isAfter(endTime) to !isBefore(endTime)
                    // Or use isBefore(startTime) || isAfter(endTime) and negate.
                    // Let's use !isBefore(startTime) && !isAfter(endTime) as it seems more intuitive for a date range, inclusive.
                    return tTime != null && !tTime.isBefore(startTime) && !tTime.isAfter(endTime); // Range [startTime, endTime]
                })
                .collect(Collectors.toList());
        System.out.println("Filtered down to " + filtered.size() + " transactions within range.");


        // Group by Counterparty and summarize net amount and count
        Map<String, double[]> grouped = new HashMap<>(); // double[0] = net amount, double[1] = count
        for (Transaction t : filtered) {
            String counterparty = t.getCounterparty();
            double amount = t.getPaymentAmount();
            // Assuming t.getInOut() returns "Income"/"Expense" or "In"/"Out"
            if (t.getInOut().equalsIgnoreCase("Expense") || t.getInOut().equalsIgnoreCase("Out")) {
                amount = -amount;
            } else if (!t.getInOut().equalsIgnoreCase("Income") && !t.getInOut().equalsIgnoreCase("In")) {
                System.err.println("Warning: Unknown In/Out type for transaction: " + t.getOrderNumber() + " - " + t.getInOut());
                // Decide how to handle unknown types - ignore from analysis? Treat as 0?
                continue; // Skip unknown types for aggregation
            }

            grouped.putIfAbsent(counterparty, new double[]{0.0, 0});
            grouped.get(counterparty)[0] += amount;
            grouped.get(counterparty)[1] += 1;
        }
        System.out.println("Grouped transactions by counterparty. Found " + grouped.size() + " counterparties.");


        List<String> results = grouped.entrySet().stream()
                .map(e -> {
                    String cp = e.getKey();
                    double net = e.getValue()[0];
                    int count = (int) e.getValue()[1];
                    String inOutLabel = net >= 0 ? "Total Income" : "Total Expense";
                    if (Math.abs(net) < 0.01 && count > 0) { // If net is near zero but there were transactions
                        inOutLabel = "Net Zero"; // Or specify "Income equals Expense"
                    }
                    return String.format("Counterparty: %s, Net %s: %.2f CNY, Transaction Count: %d",
                            cp, inOutLabel, Math.abs(net), count);
                })
                .collect(Collectors.toList());
        System.out.println("Formatted grouped results.");


        // Add time range information to the results list
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm");
        String rangeInfo = String.format("Analysis Time Range: %s - %s",
                formatter.format(startTime), formatter.format(endTime));
        results.add(0, rangeInfo); // Add range info at the beginning

        if (filtered.isEmpty()) { // Check if the filtered list was empty before grouping
            return List.of(rangeInfo, "No transactions found within this time period.");
        }
        return results;
    }


    // Keep parseDateTime method - ensure it matches the one in TransactionServiceImpl
    private LocalDateTime parseDateTime(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // Clean whitespace
        timeStr = timeStr.trim().replaceAll("\\s+", " ");

        // Append time if only date
        if (timeStr.matches("\\d{4}/\\d{1,2}/\\d{1,2}")) {
            timeStr += " 00:00"; // Assuming minutes format
        } else if (timeStr.matches("\\d{4}-\\d{1,2}-\\d{1,2}")) {
            timeStr += " 00:00:00"; // Assuming seconds format
        }


        // Try parsing with multiple formats
        List<String> patterns = List.of(
                "yyyy/M/d H:mm", "yyyy/M/d HH:mm",
                "yyyy/MM/d H:mm", "yyyy/MM/d HH:mm",
                "yyyy/M/dd H:mm", "yyyy/M/dd HH:mm",
                "yyyy/MM/dd H:mm", "yyyy/MM/dd HH:mm",
                "yyyy/MM/dd HH:mm:ss", // Added seconds format
                "yyyy-MM-dd HH:mm:ss", // Added dash format
                "yyyy/MM/dd" // Date only (handled above)
                // Add more patterns if needed based on your CSV data
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDateTime.parse(timeStr, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern and try the next
            }
        }
        System.err.println("AI Service: Failed to parse date string: " + timeStr);
        return null; // Return null if no pattern matches
    }


    // Keep askAi method
    public String askAi(String prompt) {
        try {
            if (API_KEY == null || API_KEY.trim().isEmpty()) {
                System.err.println("ARK_API_KEY environment variable is not set.");
                return "AI service configuration error: ARK_API_KEY not set.";
            }
            // Ensure the static service instance is properly built with the key
            // This might be better done once at application startup if API_KEY is loaded from config.
            // For now, relying on the static final initialization is acceptable if the env var is set before class loading.


            List<ChatMessage> messages = List.of(
                    ChatMessage.builder().role(ChatMessageRole.USER).content(prompt).build()
            );

            ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
                    .model("ep-20250308174053-7pbkq") // Use your model name
                    .messages(messages)
                    .build();

            System.out.println("AI Service: Sending request to VolcEngine Ark...");
            // Use the static service instance
            String responseContent = (String) service.createChatCompletion(chatCompletionRequest)
                    .getChoices().get(0).getMessage().getContent();
            System.out.println("AI Service: Received response from AI.");
            return responseContent;

        } catch (Exception e) {
            System.err.println("AI Service: AI request failed.");
            e.printStackTrace();
            return "AI request failed: " + e.getMessage();
        }
    }

    // Keep runAiInThread method, ensure it uses the correct analyzeTransactions method
    public void runAiInThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        // ExecutorService should ideally be managed at a higher level in a larger app,
        // but a simple single thread executor per request is acceptable for this scale.
        // However, this creates a new thread and executor every time.
        // A fixed thread pool managed statically or by a dedicated AI Service Manager would be more efficient.
        // For now, let's keep it simple as in the original code.

        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            // Call the instance method analyzeTransactions
            String result = this.analyzeTransactions(userRequest, filePath,startTimeStr, endTimeStr);
            System.out.println("AI analysis thread finished. Result: " + result);
            // TODO: How to pass the result back to the UI?
            // This thread doesn't have access to the UI components directly.
            // Need a mechanism like a callback or SwingUtilities.invokeLater.
            // This will be addressed when integrating AI output into the UI (Step 10).
        });
        // Consider shutting down the executor more gracefully, e.g., when the app exits.
        // executor.shutdown(); // Shutting down immediately might cancel the task
        // A better approach is `executor.shutdown()` after submitting, but manage the executor lifecycle elsewhere.
    }

    /**
     * Generates a personal consumption summary based on monthly data.
     * @param userFilePath The path to the user's transaction CSV file. (Might not be strictly needed if service handles context)
     * @return AI analysis result as a String.
     */
    public String generatePersonalSummary(String userFilePath) {
        try {
            // Get monthly summary data from TransactionService
            // Note: TransactionService already operates on the current user's data implicitly if passed correctly.
            // We might not need userFilePath explicitly in this method signature if the service instance is user-specific.
            // Let's assume the injected transactionService is already scoped to the current user.
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("AI Service: Retrieved " + summaries.size() + " months of summary data.");

            if (summaries.isEmpty()) {
                return "Not enough transaction data found to generate a personal spending summary.";
            }

            // Format the summary data for the AI prompt
            StringBuilder summaryPromptBuilder = new StringBuilder();
            summaryPromptBuilder.append("Please generate a personal spending habits summary based on the following monthly data. Analyze main expense categories, monthly trends, and assess my spending health:\n\n");

            // Sort months chronologically for better trend analysis by AI
            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                summaryPromptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                summaryPromptBuilder.append("  Total Income: ").append(String.format("%.2f", ms.getTotalIncome())).append(" CNY\n");
                summaryPromptBuilder.append("  Total Expense: ").append(String.format("%.2f", ms.getTotalExpense())).append(" CNY\n");
                summaryPromptBuilder.append("  Expense Breakdown:\n");
                if (ms.getExpenseByCategory().isEmpty()) {
                    summaryPromptBuilder.append("    (No expenses)\n");
                } else {
                    // Sort categories by amount descending for AI to easily see major categories
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    summaryPromptBuilder.append(String.format("    %s: %.2f CNY\n", entry.getKey(), entry.getValue()))
                            );
                }
                summaryPromptBuilder.append("\n"); // Add space between months
            }

            String aiPrompt = summaryPromptBuilder.toString();
            System.out.println("AI Service: Sending personal summary prompt to AI. Prompt length: " + aiPrompt.length());

            return askAi(aiPrompt); // Call the generic AI method
        } catch (Exception e) {
            System.err.println("AI Service: Failed to generate personal summary.");
            e.printStackTrace();
            return "Failed to generate personal spending summary: " + e.getMessage();
        }
    }

    /**
     * Generates suggestions for savings goals based on monthly data.
     * @param userFilePath The path to the user's transaction CSV file. (Might not be strictly needed)
     * @return AI suggestions as a String.
     */
    public String suggestSavingsGoals(String userFilePath) {
        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("AI Service: Retrieved " + summaries.size() + " months of summary data for savings goal suggestion.");

            if (summaries.isEmpty()) {
                return "Not enough transaction data found to suggest savings goals.";
            }

            StringBuilder promptBuilder = new StringBuilder();
            promptBuilder.append("Please provide some reasonable savings goal suggestions for my spending habits based on the following monthly income and expense summary data:\n\n");

            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  Total Income: ").append(String.format("%.2f", ms.getTotalIncome())).append(" CNY\n");
                promptBuilder.append("  Total Expense: ").append(String.format("%.2f", ms.getTotalExpense())).append(" CNY\n");
                double net = ms.getTotalIncome() - ms.getTotalExpense();
                promptBuilder.append("  Monthly Net Income/Expense: ").append(String.format("%.2f", net)).append(" CNY\n");
                promptBuilder.append("\n");
            }

            String aiPrompt = promptBuilder.toString();
            System.out.println("AI Service: Sending savings goals prompt to AI. Prompt length: " + aiPrompt.length());

            return askAi(aiPrompt);
        } catch (Exception e) {
            System.err.println("AI Service: Failed to suggest savings goals.");
            e.printStackTrace();
            return "Failed to suggest savings goals: " + e.getMessage();
        }
    }

    /**
     * Generates personalized cost-cutting recommendations based on monthly data.
     * @param userFilePath The path to the user's transaction CSV file. (Might not be strictly needed)
     * @return AI recommendations as a String.
     */
    public String givePersonalSavingTips(String userFilePath) {
        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("AI Service: Retrieved " + summaries.size() + " months of summary data for saving tips.");

            if (summaries.isEmpty()) {
                return "Not enough transaction data found to provide personalized saving tips.";
            }

            StringBuilder promptBuilder = new StringBuilder();
            promptBuilder.append("Please provide some targeted cost-saving suggestions for me based on the following monthly spending summary data:\n\n");

            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  Total Expense: ").append(String.format("%.2f", ms.getTotalExpense())).append(" CNY\n");
                promptBuilder.append("  Expense Breakdown:\n");
                if (ms.getExpenseByCategory().isEmpty()) {
                    promptBuilder.append("    (No expenses)\n");
                } else {
                    // Sort categories by amount descending
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    promptBuilder.append(String.format("    %s: %.2f CNY\n", entry.getKey(), entry.getValue()))
                            );
                }
                promptBuilder.append("\n");
            }

            String aiPrompt = promptBuilder.toString();
            System.out.println("AI Service: Sending personal saving tips prompt to AI. Prompt length: " + aiPrompt.length());

            return askAi(aiPrompt);
        } catch (Exception e) {
            System.err.println("AI Service: Failed to give personal saving tips.");
            e.printStackTrace();
            return "Failed to generate personalized saving tips: " + e.getMessage();
        }
    }


    // ... Keep other methods like analyzeTransactions, formatTransactions, parseDateTime, askAi ...

    // The existing CollegeStudentNeeds class also has budget and tips methods.
    // We need to decide: should AITransactionService offer general AI for anyone,
    // and CollegeStudentNeeds offer student-specific prompts/logic?
    // Or should AITransactionService be the main AI interaction point,
    // and CollegeStudentNeeds just holds student-specific logic/prompts used by AITransactionService?
    // Given the project structure, it might be better to keep student logic in CollegeStudentNeeds
    // and call it from MenuUI or a wrapper service.
    // Let's adjust: generatePersonalSummary, suggestSavingsGoals, givePersonalSavingTips will use monthly summary.
    // CollegeStudentNeeds.generateBudget and generateTipsForSaving can remain using their current logic
    // (budget uses weekly expenses, tips is generic for now).
    // The prompt for CollegeStudentNeeds.generateBudget might need to be updated to use the monthly summary data too for better context.
    // Let's refine CollegeStudentNeeds methods in the next step.

    // For now, the three new methods above will use the monthly summary.
    // The existing analyzeTransactions method in AITransactionService and the methods in CollegeStudentNeeds remain as is for now,
    // but their usage in UI might change slightly.

}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Service\AIservice\ColledgeStudentThread.java`:

```java
package Service.AIservice;

// Add required imports
import Service.TransactionService; // Keep import if generateBudget throws Exception
// import java.io.IOException; // Removed specific IOException import if using general Exception


public class ColledgeStudentThread implements Runnable{
    // Remove the old budgetRange field, it's not used here
    // public String budgetRange;

    // Field to hold the injected CollegeStudentNeeds service instance
    private final CollegeStudentNeeds collegeStudentNeeds;
    // The file path is still needed to pass to the generateBudget method
    private final String filePath;


    /**
     * Constructor now accepts the CollegeStudentNeeds service instance and the file path.
     * The injected service instance already contains the necessary TransactionService.
     *
     * @param collegeStudentNeeds The CollegeStudentNeeds service instance to use for generating the budget.
     * @param filePath The path to the user's transaction data file.
     */
    public ColledgeStudentThread(CollegeStudentNeeds collegeStudentNeeds, String filePath) {
        this.collegeStudentNeeds = collegeStudentNeeds;
        this.filePath = filePath;
        System.out.println("ColledgeStudentThread initialized for file: " + filePath);
    }

    @Override
    public void run(){
        System.out.println("ColledgeStudentThread started for file: " + filePath);
        try {
            // Call the generateBudget method on the injected service instance
            double[] budget = collegeStudentNeeds.generateBudget(filePath);

            // Print the result or handle it as needed by the test/caller that starts this thread
            if (budget != null && budget.length == 2 && budget[0] != -1) {
                System.out.println("Budget generated in thread for file " + filePath + ": [" + budget[0] + ", " + budget[1] + "]");
            } else {
                // handle the case where budget generation failed or returned -1
                System.out.println("Budget generation in thread finished, but no valid budget was returned for file " + filePath + ".");
                // You might want to distinguish between "no data" (-1,-1) and other exceptions here.
            }
        } catch (Exception e) { // Catch Exception as generateBudget throws Exception
            System.err.println("Error generating budget in thread for file " + filePath + ": " + e.getMessage());
            e.printStackTrace();
        }
        System.out.println("ColledgeStudentThread finished for file: " + filePath);
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Service\AIservice\CollegeStudentNeeds.java`:

```java
package Service.AIservice;

import Constants.StandardCategories;
import DAO.TransactionDao;
import DAO.Impl.CsvTransactionDao;
// Removed: import Service.Impl.TransactionServiceImpl; // Not directly used here
import Utils.CacheManager;
import model.Transaction;
import model.MonthlySummary;
import Service.TransactionService;

import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Collections;
import java.util.Optional;
import java.util.stream.Collectors;

public class CollegeStudentNeeds {
    // Prompts for AI interaction
    private final String requestBudge = "I am a college student with a limited budget. Based on my historical weekly spending and monthly income/expense summary provided below, please help me set a budget range for next week. You must provide the answer in the format [minimum_budget, maximum_budget], with no additional text.";
    private final String requestTips = "I am a college student with a limited budget. Based on my monthly spending summary data provided below, please recommend some targeted ways for me to save money.";
    private final String requestRecognition =
            "Please infer the most appropriate transaction type based on the following billing information. The returned type must exactly match one of the entries in the following list:\n" +
                    StandardCategories.getAllCategoriesString() + "\n" + // Include the list of valid categories
                    "If it cannot be determined, please return 'Other Expenses' or 'Other Income' (depending on the income/expense direction). Return only the type string, do not include additional text or explanations. Billing information:";

    // TransactionService is injected to access transaction data and summaries.
    private final TransactionService transactionService;

    /**
     * Constructor that accepts a TransactionService instance.
     * @param transactionService The service to interact with transaction data.
     */
    public CollegeStudentNeeds(TransactionService transactionService) {
        this.transactionService = transactionService;
        System.out.println("CollegeStudentNeeds initialized with TransactionService.");
    }

    /**
     * Recognizes the spending category of a single transaction using AI.
     * This method uses the raw transaction details for recognition.
     *
     * @param transaction The transaction to recognize.
     * @return The AI's suggested category.
     */
    public String RecognizeTransaction(Transaction transaction) {
        if (transaction == null) {
            return "Cannot recognize empty transaction information";
        }
        StringBuilder sb = new StringBuilder();
        // Build the string with transaction details for the AI prompt.
        // Assuming In/Out and other fields are in English or will be handled by AI.
        sb.append("Transaction Type:").append(transaction.getTransactionType()).append(",")
                .append("Counterparty:").append(transaction.getCounterparty()).append(",")
                .append("Commodity:").append(transaction.getCommodity()).append(",")
                .append("In/Out:").append(transaction.getInOut()).append(",")
                .append("Amount(CNY):").append(String.format("%.2f", transaction.getPaymentAmount())).append(",")
                .append("Payment Method:").append(transaction.getPaymentMethod()).append(",")
                .append("Remarks:").append(transaction.getRemarks());

        System.out.println("CollegeStudentNeeds: Sending recognition request to AI: " + sb.toString());
        // Create a local AITransactionService instance for askAi calls, as it doesn't need an injected TransactionService for this specific task.
        AITransactionService localAiService = new AITransactionService(null);
        return localAiService.askAi(requestRecognition + sb.toString());
    }

    /**
     * Generates saving tips for college students using AI, based on their monthly summary.
     * @param userFilePath The path to the user's transaction CSV file. This parameter might be
     *                     refactored if TransactionService is inherently user-scoped.
     * @return AI's suggested saving tips.
     */
    public String generateTipsForSaving(String userFilePath) {
        try {
            // Get monthly summary data using the injected TransactionService.
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("CollegeStudentNeeds: Retrieved " + summaries.size() + " months of summary data for tips.");

            if (summaries.isEmpty()) {
                return "Not enough transaction data found to provide personalized saving tips.";
            }

            StringBuilder promptBuilder = new StringBuilder();
            promptBuilder.append(requestTips).append("\n\nHere is my monthly spending summary data:\n\n");

            // Sort months chronologically to present data in order to the AI.
            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  Total Expense: ").append(String.format("%.2f", ms.getTotalExpense())).append(" CNY\n");
                promptBuilder.append("  Expense Breakdown:\n");
                if (ms.getExpenseByCategory().isEmpty()) {
                    promptBuilder.append("    (No expenses)\n");
                } else {
                    // Sort categories by amount in descending order for clarity.
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    promptBuilder.append(String.format("    %s: %.2f CNY\n", entry.getKey(), entry.getValue()))
                            );
                }
                promptBuilder.append("\n");
            }

            String aiPrompt = promptBuilder.toString();
            System.out.println("CollegeStudentNeeds: Sending saving tips prompt to AI. Prompt length: " + aiPrompt.length());

            AITransactionService localAiService = new AITransactionService(null);
            return localAiService.askAi(aiPrompt);

        } catch (Exception e) {
            System.err.println("CollegeStudentNeeds: Failed to generate saving tips.");
            e.printStackTrace();
            return "Failed to generate personalized saving tips: " + e.getMessage();
        }
    }

    /**
     * Analyzes weekly spending and monthly summaries to ask AI for a budget range.
     * @param filePath The path to the user's transaction CSV file.
     * @return A double array [minBudget, maxBudget] parsed from AI response, or [-1, -1] on failure.
     * @throws Exception If there's an error accessing transaction data or summaries.
     */
    public double[] generateBudget(String filePath) throws Exception {
        List<Transaction> transactions;
        Map<String, MonthlySummary> summaries;

        try {
            // Get transactions using CacheManager.
            TransactionDao transactionDaoForLoading = new CsvTransactionDao();
            transactions = CacheManager.getTransactions(filePath, transactionDaoForLoading);
            System.out.println("CollegeStudentNeeds: Retrieved " + transactions.size() + " transactions for budget analysis from: " + filePath);

            // Get monthly summary data for additional context.
            summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("CollegeStudentNeeds: Retrieved " + summaries.size() + " months of summary data for budget context.");

        } catch (Exception e) {
            System.err.println("CollegeStudentNeeds: Error retrieving transactions or summary for budget analysis: " + filePath);
            e.printStackTrace();
            throw e;
        }

        // Handle case with no transactions.
        if (transactions.isEmpty()) {
            System.out.println("CollegeStudentNeeds: No transactions found for budget analysis.");
            if (!summaries.isEmpty()) {
                // If monthly summaries exist, use them for the AI prompt.
                StringBuilder promptBuilder = new StringBuilder();
                promptBuilder.append("Here is my monthly income and expense summary data:\n\n");
                List<String> sortedMonths = new ArrayList<>(summaries.keySet());
                Collections.sort(sortedMonths);
                for (String month : sortedMonths) {
                    MonthlySummary ms = summaries.get(month);
                    promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                    promptBuilder.append("  Total Income: ").append(String.format("%.2f", ms.getTotalIncome())).append(" CNY\n");
                    promptBuilder.append("  Total Expense: ").append(String.format("%.2f", ms.getTotalExpense())).append(" CNY\n");
                    double net = ms.getTotalIncome() - ms.getTotalExpense();
                    promptBuilder.append("  Monthly Net Income/Expense: ").append(String.format("%.2f", net)).append(" CNY\n");
                    promptBuilder.append("  Main Expense Categories:\n");
                    if (ms.getExpenseByCategory().isEmpty()) {
                        promptBuilder.append("    (No expenses)\n");
                    } else {
                        ms.getExpenseByCategory().entrySet().stream()
                                .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                                .forEach(entry ->
                                        promptBuilder.append(String.format("    %s: %.2f CNY\n", entry.getKey(), entry.getValue()))
                                );
                    }
                    promptBuilder.append("\n");
                }
                String answer = new AITransactionService(null).askAi(requestBudge + "\n\nNo weekly spending data found.\n" + promptBuilder.toString());
                return parseDoubleArrayFromString(answer);
            }
            return new double[]{-1, -1}; // No data at all.
        }

        // Filter for 'Expense' transactions and sort them by date (newest first).
        // Assumes In/Out field uses "Expense" or "Out" for expense transactions.
        List<Transaction> expenseTransactions = transactions.stream()
                .filter(t -> t.getInOut() != null && (t.getInOut().equalsIgnoreCase("Expense") || t.getInOut().equalsIgnoreCase("Out")))
                .sorted((t1, t2) -> {
                    LocalDate date1 = parseDateSafe(t1.getTransactionTime());
                    LocalDate date2 = parseDateSafe(t2.getTransactionTime());
                    if (date1 != null && date2 != null) { return date2.compareTo(date1); }
                    else if (date1 == null && date2 == null) { return 0; }
                    else if (date1 == null) { return 1; } // Treat null dates as later for sorting purposes if needed.
                    else { return -1; }
                })
                .collect(Collectors.toList());
        System.out.println("CollegeStudentNeeds: Filtered " + expenseTransactions.size() + " expense transactions for budget analysis.");

        // Handle case with no expense transactions.
        if (expenseTransactions.isEmpty()) {
            System.out.println("CollegeStudentNeeds: No expense transactions found for budget analysis.");
            if (!summaries.isEmpty()) {
                // If monthly summaries exist, use them for the AI prompt.
                StringBuilder promptBuilder = new StringBuilder();
                promptBuilder.append("Here is my monthly income and expense summary data:\n\n");
                List<String> sortedMonths = new ArrayList<>(summaries.keySet());
                Collections.sort(sortedMonths);
                for (String month : sortedMonths) {
                    MonthlySummary ms = summaries.get(month);
                    promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                    promptBuilder.append("  Total Income: ").append(String.format("%.2f", ms.getTotalIncome())).append(" CNY\n");
                    promptBuilder.append("  Total Expense: ").append(String.format("%.2f", ms.getTotalExpense())).append(" CNY\n");
                    double net = ms.getTotalIncome() - ms.getTotalExpense();
                    promptBuilder.append("  Monthly Net Income/Expense: ").append(String.format("%.2f", net)).append(" CNY\n");
                    promptBuilder.append("  Main Expense Categories:\n");
                    if (ms.getExpenseByCategory().isEmpty()) {
                        promptBuilder.append("    (No expenses)\n");
                    } else {
                        ms.getExpenseByCategory().entrySet().stream()
                                .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                                .forEach(entry ->
                                        promptBuilder.append(String.format("    %s: %.2f CNY\n", entry.getKey(), entry.getValue()))
                                );
                    }
                    promptBuilder.append("\n");
                }
                String answer = new AITransactionService(null).askAi(requestBudge + "\n\nNo weekly spending data found.\n" + promptBuilder.toString());
                return parseDoubleArrayFromString(answer);
            }
            return new double[]{-1, -1}; // No expense data and no summary data.
        }

        // Calculate weekly expenses from the filtered expense transactions.
        List<Double> weeklyExpenses = new ArrayList<>();
        LocalDate currentWeekStart = null;
        double currentWeekTotal = 0;

        for (Transaction expense : expenseTransactions) {
            LocalDate transactionDate = parseDateSafe(expense.getTransactionTime());
            if (transactionDate == null) continue;

            if (currentWeekStart == null) {
                currentWeekStart = transactionDate;
            }

            long daysDifference = ChronoUnit.DAYS.between(transactionDate, currentWeekStart);

            if (daysDifference >= 0 && daysDifference < 7) {
                currentWeekTotal += expense.getPaymentAmount();
            } else if (daysDifference >= 7) {
                weeklyExpenses.add(currentWeekTotal);
                currentWeekStart = transactionDate;
                currentWeekTotal = expense.getPaymentAmount();
            }
        }
        if (currentWeekTotal > 0 || currentWeekStart != null) { // Add the last week's total.
            weeklyExpenses.add(currentWeekTotal);
        }
        System.out.println("CollegeStudentNeeds: Calculated weekly expenses for " + weeklyExpenses.size() + " weeks: " + weeklyExpenses);

        // Format the prompt including both weekly expenses and monthly summary.
        StringBuilder promptBuilder = new StringBuilder();
        promptBuilder.append(requestBudge).append("\n\n");

        promptBuilder.append("Here is my recent weekly spending data:\n");
        if (weeklyExpenses.isEmpty()) {
            promptBuilder.append("(Not enough periodic expense data found)\n");
        } else {
            for (int i = 0; i < weeklyExpenses.size(); i++) {
                promptBuilder.append("Week ");
                promptBuilder.append(weeklyExpenses.size() - i); // Week numbers count down (e.g., Week 3, Week 2, Week 1 (most recent))
                promptBuilder.append(": Spent ");
                promptBuilder.append(String.format("%.2f", weeklyExpenses.get(i)));
                promptBuilder.append(" CNY; ");
            }
            promptBuilder.append("\n");
        }

        promptBuilder.append("\nAdditionally, here is my monthly income and expense summary data:\n\n");
        if (summaries.isEmpty()) {
            promptBuilder.append("(No monthly summary data found)\n");
        } else {
            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);
            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  Total Income: ").append(String.format("%.2f", ms.getTotalIncome())).append(" CNY\n");
                promptBuilder.append("  Total Expense: ").append(String.format("%.2f", ms.getTotalExpense())).append(" CNY\n");
                double net = ms.getTotalIncome() - ms.getTotalExpense();
                promptBuilder.append("  Monthly Net Income/Expense: ").append(String.format("%.2f", net)).append(" CNY\n");
                promptBuilder.append("  Main Expense Categories:\n");
                if (ms.getExpenseByCategory().isEmpty()) {
                    promptBuilder.append("    (No expenses)\n");
                } else {
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    promptBuilder.append(String.format("    %s: %.2f CNY\n", entry.getKey(), entry.getValue()))
                            );
                }
                promptBuilder.append("\n");
            }
        }

        String aiPrompt = promptBuilder.toString();
        System.out.println("CollegeStudentNeeds: Sending budget request to AI. Prompt length: " + aiPrompt.length());

        String answer = new AITransactionService(null).askAi(aiPrompt);
        System.out.println("CollegeStudentNeeds: Received budget response from AI: " + answer);

        double[] ret = parseDoubleArrayFromString(answer);
        if (ret == null || ret.length != 2) {
            System.err.println("CollegeStudentNeeds: Failed to parse budget array from AI response: " + answer + ". Full AI Response: " + answer);
            return new double[]{-1, -1};
        }
        return ret;
    }

    /**
     * Helper method to safely parse a date string from a transaction's time field.
     * This method attempts to parse the date part of various common timestamp formats.
     * @param timeStr The transaction time string.
     * @return A LocalDate object, or null if parsing fails.
     */
    private LocalDate parseDateSafe(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        String datePart = timeStr.split(" ")[0]; // Get the date part (before space).
        datePart = datePart.trim().replace('-', '/'); // Normalize hyphens to slashes.

        List<String> patterns = List.of(
                "yyyy/M/d", "yyyy/MM/d", "yyyy/M/dd", "yyyy/MM/dd"
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDate.parse(datePart, formatter);
            } catch (DateTimeParseException ignored) {
                // Ignore parsing errors for this pattern and try the next.
            }
        }
        System.err.println("CollegeStudentNeeds: Failed to parse date part '" + datePart + "' from transaction time: " + timeStr);
        return null;
    }

    /**
     * Parses a string representation of a budget range (e.g., "[100.0, 200.0]") into a double array.
     * @param input The string to parse.
     * @return A double array containing [minBudget, maxBudget], or null if parsing fails.
     */
    public double[] parseDoubleArrayFromString(String input) {
        if (input == null) { return null; }
        String trimmedInput = input.trim();
        System.out.println("CollegeStudentNeeds: Attempting to parse budget string: '" + trimmedInput + "'");
        int startIndex = trimmedInput.indexOf('[');
        int endIndex = trimmedInput.lastIndexOf(']');
        if (startIndex == -1 || endIndex == -1 || endIndex < startIndex) {
            System.err.println("CollegeStudentNeeds: Budget string does not contain valid []. Input: " + trimmedInput);
            return null;
        }
        String content = trimmedInput.substring(startIndex + 1, endIndex).trim();
        // Split by comma, allowing for optional spaces around the comma.
        String[] numberStrings = content.split("\\s*,\\s*");
        if (numberStrings.length != 2) {
            System.err.println("CollegeStudentNeeds: Budget string content does not contain exactly two numbers separated by comma. Content: " + content);
            return null;
        }
        double[] result = new double[2];
        try {
            result[0] = Double.parseDouble(numberStrings[0].trim());
            result[1] = Double.parseDouble(numberStrings[1].trim());
            System.out.println("CollegeStudentNeeds: Successfully parsed budget: [" + result[0] + ", " + result[1] + "]");
            return result;
        } catch (NumberFormatException e) {
            System.err.println("CollegeStudentNeeds: Error parsing numbers from budget string: " + content);
            e.printStackTrace();
            return null;
        }
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Service\Impl\SummaryStatisticService.java`:

```java
package Service.Impl;

import Constants.StandardCategories; // Import StandardCategories
import DAO.TransactionDao; // Import TransactionDao interface
import DAO.UserDao; // Import UserDao interface
import DAO.SummaryStatisticDao; // Import SummaryStatisticDao interface
import model.SummaryStatistic;
import model.Transaction;
import model.User;
import Utils.CacheManager; // Import CacheManager
import Constants.ConfigConstants; // Import ConfigConstants for summary file path

import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.temporal.WeekFields; // For getting week of year
import java.util.*;
import java.util.stream.Collectors;
import java.time.format.DateTimeFormatter; // For generating timestamp

public class SummaryStatisticService {

    private final UserDao userDao;
    private final TransactionDao transactionDao; // Need a DAO instance for CacheManager loading
    private final SummaryStatisticDao summaryStatisticDao;
    private final String summaryFilePath;

    /**
     * Constructor to inject dependencies.
     * @param userDao DAO for user data.
     * @param transactionDao DAO for transaction data (used by CacheManager loader).
     * @param summaryStatisticDao DAO for summary statistics data.
     */
    public SummaryStatisticService(UserDao userDao, TransactionDao transactionDao, SummaryStatisticDao summaryStatisticDao) {
        this.userDao = userDao;
        this.transactionDao = transactionDao; // Injected for use in CacheManager loader
        this.summaryStatisticDao = summaryStatisticDao;
        this.summaryFilePath = ConfigConstants.SUMMARY_CSV_PATH; // Get summary file path from config
        System.out.println("SummaryStatisticService initialized. Summary file: " + summaryFilePath);
    }

    /**
     * Helper method to load all transactions from all user files.
     * Uses CacheManager to benefit from caching.
     * @param users List of all users.
     * @return A single list containing all transactions from all users.
     * @throws Exception If loading from any user file fails.
     */
    private List<Transaction> loadAllTransactionsFromAllUsers(List<User> users) throws Exception {
        List<Transaction> allTransactions = new ArrayList<>();
        for (User user : users) {
            String userFilePath = user.getTransactionFilePath();
            if (userFilePath != null && !userFilePath.trim().isEmpty()) {
                try {
                    // Use CacheManager to get transactions for this user's file
                    // Pass the transactionDao instance for the loader
                    List<Transaction> userTransactions = CacheManager.getTransactions(userFilePath, transactionDao);
                    allTransactions.addAll(userTransactions);
                    System.out.println("Loaded " + userTransactions.size() + " transactions for user: " + user.getUsername() + " from " + userFilePath);
                } catch (Exception e) {
                    System.err.println("Error loading transactions for user " + user.getUsername() + " from " + userFilePath + ". Skipping this user.");
                    e.printStackTrace();
                    // Decide whether to stop or continue if one user's file fails.
                    // Continuing is more robust for aggregate statistics.
                    // throw e; // Uncomment to stop processing if any user file fails
                }
            } else {
                System.out.println("User " + user.getUsername() + " has no transaction file path configured. Skipping.");
            }
        }
        return allTransactions;
    }


    /**
     * Helper method to group transactions by week identifier (YYYY-Www).
     * @param transactions The list of transactions.
     * @return A map where keys are week identifiers and values are lists of transactions in that week.
     */
    private Map<String, List<Transaction>> groupTransactionsByWeek(List<Transaction> transactions) {
        WeekFields weekFields = WeekFields.ISO; // ISO 8601 week numbering (Monday is the first day of the week)
        DateTimeFormatter weekFormatter = DateTimeFormatter.ofPattern("yyyy-'W'ww"); // Format as "YYYY-Www"

        return transactions.stream()
                .filter(t -> t.getTransactionTime() != null && !t.getTransactionTime().trim().isEmpty()) // Filter out transactions with no time
                .collect(Collectors.groupingBy(t -> {
                    try {
                        // Safely parse the transaction date (only date part is needed for week)
                        // Need to ensure the parser is consistent with the one in TransactionServiceImpl/AITransactionService
                        // Let's re-use the safe parsing logic or ensure consistency.
                        // Simplest: Use a helper method for date parsing just for this service, matching expected formats.
                        LocalDate date = parseDateFromTransactionTime(t.getTransactionTime());
                        if (date != null) {
                            return date.format(weekFormatter); // Format date to week identifier
                        }
                    } catch (Exception e) {
                        System.err.println("Failed to parse date for week grouping: " + t.getTransactionTime() + ". Skipping transaction.");
                        // Transaction with unparseable date will be grouped under 'null' or skipped by filter
                    }
                    return "未知周"; // Group unparseable dates under an 'unknown' key
                }));
    }

    // Helper method to parse date from transaction time string (should match other parsers)
    private LocalDate parseDateFromTransactionTime(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // Clean whitespace and potential hyphens if the expected format is slash-separated
        // Assume the format used in CSV/Transaction model is one of the parsers in other services
        // Let's use a robust set of date patterns matching parseDateTimeSafe in TransactionServiceImpl
        String datePart = timeStr.split(" ")[0]; // Get the date part

        datePart = datePart.trim().replace('-', '/').replaceAll("\\s+", "");


        // Try parsing with multiple slash formats
        List<String> patterns = List.of(
                "yyyy/M/d", "yyyy/MM/d", "yyyy/M/dd", "yyyy/MM/dd",
                "yyyy-MM-dd" // Add dash format just in case
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDate.parse(datePart, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern
            }
        }
        System.err.println("SummaryStatisticService: Failed to parse date part '" + datePart + "' from transaction time: " + timeStr);
        return null; // Return null if no pattern matches
    }


    /**
     * Retrieves all summary statistics from the data source.
     * @return List of summary statistics.
     * @throws IOException If loading fails.
     */
    public List<SummaryStatistic> getAllSummaryStatistics() throws IOException {
        // Simply delegate to the DAO
        return summaryStatisticDao.loadAllStatistics(summaryFilePath);
    }


    // --- Revised Plan for generateAndSaveWeeklyStatistics ---
    // The previous approach of loading all transactions and then grouping by week
    // doesn't easily allow counting unique users per week unless we augment the Transaction object
    // or wrap it with User info during loading.
    // A better approach for unique user count is to process user by user.

    public void generateAndSaveWeeklyStatistics() throws Exception {
        System.out.println("Generating weekly summary statistics (Revised approach)...");
        List<User> allUsers = userDao.getAllUsers();
        System.out.println("Loaded " + allUsers.size() + " users.");

        // Map to hold weekly stats per user (WeekId -> Map<UserId, UserWeeklyStats>)
        // This intermediate structure is complex.

        // Map to hold aggregated stats for each week (WeekId -> AggregatedWeeklyStats)
        Map<String, Double> totalIncomeByWeek = new HashMap<>();
        Map<String, Double> totalExpenseByWeek = new HashMap<>();
        Map<String, Map<String, Double>> expenseByCategoryByWeek = new HashMap<>(); // WeekId -> (Category -> Amount)
        Map<String, Set<String>> usersByWeek = new HashMap<>(); // WeekId -> Set<Username>

        WeekFields weekFields = WeekFields.ISO;
        DateTimeFormatter weekFormatter = DateTimeFormatter.ofPattern("yyyy-'W'ww");


        // Iterate through each user
        for (User user : allUsers) {
            String userFilePath = user.getTransactionFilePath();
            String username = user.getUsername();

            if (userFilePath != null && !userFilePath.trim().isEmpty()) {
                try {
                    // Load transactions for this user
                    List<Transaction> userTransactions = CacheManager.getTransactions(userFilePath, transactionDao);
                    System.out.println("Processing " + userTransactions.size() + " transactions for user: " + username);

                    // Iterate through transactions for this user
                    for (Transaction t : userTransactions) {
                        if (t.getTransactionTime() == null || t.getTransactionTime().trim().isEmpty()) {
                            System.err.println("Skipping transaction with no time for user " + username + ": " + t.getOrderNumber());
                            continue; // Skip transactions with no time
                        }

                        LocalDate date = parseDateFromTransactionTime(t.getTransactionTime());
                        if (date == null) {
                            System.err.println("Skipping transaction with unparseable date for user " + username + ": " + t.getTransactionTime());
                            continue; // Skip transactions with invalid date
                        }

                        String weekIdentifier = date.format(weekFormatter);

                        // Add user to the set for this week
                        usersByWeek.computeIfAbsent(weekIdentifier, k -> new HashSet<>()).add(username);

                        // Aggregate income/expense
                        if (t.getInOut() != null) {
                            String inOut = t.getInOut().trim();
                            if (inOut.equals("收入") || inOut.equals("收")) {
                                totalIncomeByWeek.put(weekIdentifier, totalIncomeByWeek.getOrDefault(weekIdentifier, 0.0) + t.getPaymentAmount());
                            } else if (inOut.equals("支出") || inOut.equals("支")) {
                                totalExpenseByWeek.put(weekIdentifier, totalExpenseByWeek.getOrDefault(weekIdentifier, 0.0) + t.getPaymentAmount());

                                // Aggregate expense by standard category
                                String rawType = t.getTransactionType();
                                String standardCategory = StandardCategories.getStandardCategory(rawType);
                                // Only aggregate standard expense categories for the top category calculation
                                if (StandardCategories.isStandardExpenseCategory(standardCategory) || !StandardCategories.ALL_KNOWN_TYPES.contains(standardCategory)) {
                                    String effectiveExpenseCategoryForTop = StandardCategories.isStandardExpenseCategory(standardCategory) ? standardCategory : "其他支出";
                                    expenseByCategoryByWeek.computeIfAbsent(weekIdentifier, k -> new HashMap<>())
                                            .put(effectiveExpenseCategoryForTop, expenseByCategoryByWeek.get(weekIdentifier).getOrDefault(effectiveExpenseCategoryForTop, 0.0) + t.getPaymentAmount());
                                }
                            }
                        }
                    }
                } catch (Exception e) {
                    System.err.println("Error loading transactions for user " + user.getUsername() + " from " + userFilePath + ". Skipping this user's data for statistics.");
                    e.printStackTrace();
                    // Continue processing other users
                }
            } else {
                System.out.println("User " + user.getUsername() + " has no transaction file path configured. Skipping for statistics.");
            }
        }
        System.out.println("Completed aggregation across all users by week.");


        // 5. Consolidate aggregated data into SummaryStatistic objects
        List<SummaryStatistic> calculatedStatistics = new ArrayList<>();
        DateTimeFormatter timestampFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String timestamp = LocalDateTime.now().format(timestampFormatter);

        // Iterate through all week identifiers found
        Set<String> allWeeks = new HashSet<>();
        allWeeks.addAll(totalIncomeByWeek.keySet());
        allWeeks.addAll(totalExpenseByWeek.keySet());
        allWeeks.addAll(usersByWeek.keySet());
        allWeeks.addAll(expenseByCategoryByWeek.keySet());

        List<String> sortedWeekIdentifiers = allWeeks.stream().sorted().collect(Collectors.toList());

        for (String weekIdentifier : sortedWeekIdentifiers) {
            double totalIncome = totalIncomeByWeek.getOrDefault(weekIdentifier, 0.0);
            double totalExpense = totalExpenseByWeek.getOrDefault(weekIdentifier, 0.0);
            int numberOfUsers = usersByWeek.getOrDefault(weekIdentifier, Collections.emptySet()).size();

            // Find top expense category for this week
            Map<String, Double> weeklyExpenseByCategory = expenseByCategoryByWeek.getOrDefault(weekIdentifier, Collections.emptyMap());
            String topExpenseCategory = "无支出";
            double topExpenseCategoryAmount = 0.0;

            Optional<Map.Entry<String, Double>> maxEntry = weeklyExpenseByCategory.entrySet().stream()
                    .max(Map.Entry.comparingByValue());

            if (maxEntry.isPresent()) {
                topExpenseCategory = maxEntry.get().getKey();
                topExpenseCategoryAmount = maxEntry.get().getValue();
            }

            calculatedStatistics.add(new SummaryStatistic(
                    weekIdentifier,
                    totalIncome,
                    totalExpense,
                    topExpenseCategory,
                    topExpenseCategoryAmount,
                    numberOfUsers,
                    timestamp // Timestamp is when the stats were generated, not per week
            ));
        }
        System.out.println("Created " + calculatedStatistics.size() + " SummaryStatistic objects.");


        // 6. Load existing statistics
        List<SummaryStatistic> existingStatistics = getAllSummaryStatistics();
        System.out.println("Loaded " + existingStatistics.size() + " existing summary statistics.");

        // 7. Merge existing and newly calculated statistics (overwrite new weeks, keep old)
        Map<String, SummaryStatistic> finalStatisticsMap = new HashMap<>();
        for(SummaryStatistic stat : existingStatistics) {
            finalStatisticsMap.put(stat.getWeekIdentifier(), stat);
        }
        for(SummaryStatistic stat : calculatedStatistics) {
            finalStatisticsMap.put(stat.getWeekIdentifier(), stat); // New calculation replaces old for the week
        }

        // 8. Sort merged statistics by week identifier (chronologically)
        List<SummaryStatistic> finalStatistics = finalStatisticsMap.values().stream()
                .sorted(Comparator.comparing(SummaryStatistic::getWeekIdentifier))
                .collect(Collectors.toList());

        // 9. Save the final list
        summaryStatisticDao.writeAllStatistics(summaryFilePath, finalStatistics);
        System.out.println("Weekly summary statistics generated and saved successfully to " + summaryFilePath);
    }


}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Service\Impl\TransactionServiceImpl.java`:

```java
package Service.Impl;

import Constants.StandardCategories;
import DAO.TransactionDao; // Import the interface
import DAO.Impl.CsvTransactionDao; // Import the implementation
import Service.TransactionService;
import Utils.CacheManager; // Import the new CacheManager
import model.MonthlySummary;
import model.Transaction;

import javax.swing.*;
import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.YearMonth;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException; // Added for clarity in catch blocks if specific parsing errors are handled
import java.util.*;
import java.util.stream.Collectors; // Needed for search

public class TransactionServiceImpl implements TransactionService {

    private final String currentUserTransactionFilePath; // Store the user's file path
    // TransactionDao instance needed to load data if cache misses
    private final TransactionDao transactionDao;

    /**
     * Constructor now accepts the user's transaction file path.
     *
     * @param currentUserTransactionFilePath The file path for the current user's transactions.
     */
    public TransactionServiceImpl(String currentUserTransactionFilePath) {
        this.currentUserTransactionFilePath = currentUserTransactionFilePath;
        // Create a DAO instance for this service instance.
        this.transactionDao = new CsvTransactionDao(); // One DAO instance per service instance
        System.out.println("TransactionServiceImpl initialized for file: " + currentUserTransactionFilePath);
        // Cache is managed by CacheManager, not directly by this instance.
    }

    @Override // Implement the new interface method
    public List<Transaction> getAllTransactions() throws Exception {
        // Simply call the internal method that uses the cache
        return getAllTransactionsForCurrentUser();
    }

    /**
     * Imports transactions from a given CSV file path into the current user's transactions.
     * Reads the import file, merges with existing data, and saves back.
     *
     * @param userFilePath The file path for the current user's transactions (target).
     * @param importFilePath The file path of the CSV to import from (source).
     * @return The number of transactions successfully imported.
     * @throws Exception If an error occurs during reading, parsing, or saving.
     */
    @Override // Implement the new interface method
    public int importTransactionsFromCsv(String userFilePath, String importFilePath) throws Exception {
        System.out.println("Starting import from " + importFilePath + " to user file " + userFilePath);
        List<Transaction> existingTransactions;
        List<Transaction> transactionsToImport;

        try {
            // 1. Load existing transactions for the current user (from cache/file)
            // Use the method that uses the CacheManager
            existingTransactions = getAllTransactions(); // Already uses CacheManager

            // 2. Read and parse transactions from the import file
            // Use the DAO's loadFromCSV method with the import file path
            // Need a *separate* DAO instance or method call that targets the import file
            TransactionDao importDao = new CsvTransactionDao(); // Create a temporary DAO for reading the import file
            transactionsToImport = importDao.loadFromCSV(importFilePath); // Load from the selected file
            System.out.println("Read " + transactionsToImport.size() + " transactions from import file.");

        } catch (IOException e) {
            System.err.println("Error loading files during import process.");
            e.printStackTrace();
            throw new Exception("Failed to read transaction data!", e); // Wrap and re-throw
        }

        // 3. Merge imported transactions with existing ones
        // Simple merge: add all imported transactions.
        // Handle potential duplicates: check if order number exists.
        // If order numbers are not guaranteed unique in imported file or against existing,
        // consider generating new unique IDs for imported items if their ON is empty or conflicts.
        List<Transaction> mergedTransactions = new ArrayList<>(existingTransactions);
        int importedCount = 0;

        for (Transaction importedTx : transactionsToImport) {
            // Basic Check: Ensure imported transaction has an order number or generate one
            if (importedTx.getOrderNumber() == null || importedTx.getOrderNumber().trim().isEmpty()) {
                // Generate a unique ID for transactions without one
                String uniqueId = "IMPORT_" + UUID.randomUUID().toString();
                importedTx.setOrderNumber(uniqueId);
                System.out.println("Generated unique order number for imported transaction: " + uniqueId);
            } else {
                // Check for potential duplicate order number against existing transactions
                boolean duplicate = existingTransactions.stream()
                        .anyMatch(t -> t.getOrderNumber().trim().equals(importedTx.getOrderNumber().trim()));
                if (duplicate) {
                    System.err.println("Skipping imported transaction due to duplicate order number: " + importedTx.getOrderNumber());
                    // Decide: skip, overwrite, or generate new ID. Skipping for now.
                    JOptionPane.showMessageDialog(null, "Duplicate transaction order number found: " + importedTx.getOrderNumber() + ", skipped.", "Import Warning", JOptionPane.WARNING_MESSAGE);
                    continue; // Skip this duplicate transaction
                }
            }

            // Add the transaction to the merged list
            mergedTransactions.add(importedTx);
            importedCount++;
        }
        System.out.println("Merged transactions. Total after merge: " + mergedTransactions.size() + ". Successfully imported count: " + importedCount);


        // 4. Save the merged list back to the current user's file
        try {
            // Use the DAO instance associated with this service
            transactionDao.writeTransactionsToCSV(userFilePath, mergedTransactions);
            System.out.println("Saved merged transactions to user file: " + userFilePath);

            // 5. Invalidate or update the cache for the current user's file
            // Invalidation is simpler: forces CacheManager to reload from the updated file next time.
            CacheManager.invalidateTransactionCache(userFilePath);
            System.out.println("Cache invalidated for user file: " + userFilePath);


        } catch (IOException e) {
            System.err.println("Error saving merged transactions after import.");
            e.printStackTrace();
            // Consider leaving the original file untouched on save failure
            throw new Exception("Failed to save imported transaction data!", e); // Wrap and re-throw
        }

        System.out.println("Import process finished.");
        return importedCount; // Return the count of transactions actually added
    }

    /**
     * Gets all transactions for the current user from the cache (loading if necessary).
     * @return List of transactions.
     * @throws Exception If an error occurs during loading.
     */
    private List<Transaction> getAllTransactionsForCurrentUser() throws Exception {
        // Get transactions using the CacheManager for the current user's file
        return CacheManager.getTransactions(currentUserTransactionFilePath, transactionDao);
    }

    /**
     * Add transaction for the current user.
     *
     * @param transaction The new transaction to add.
     */
    @Override
    public void addTransaction(Transaction transaction) throws IOException {
        // Set transaction time to current time if not already set
        if (transaction.getTransactionTime() == null || transaction.getTransactionTime().isEmpty()) {
            LocalDateTime now = LocalDateTime.now();
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
            String currentTime = now.format(formatter);
            transaction.setTransactionTime(currentTime);
        }

        try {
            // Call DAO layer to add transaction to the user's specific file
            transactionDao.addTransaction(currentUserTransactionFilePath, transaction);

            // After adding, invalidate the cache for this user's file
            CacheManager.invalidateTransactionCache(currentUserTransactionFilePath);
            System.out.println("Transaction added and cache invalidated for " + currentUserTransactionFilePath);

        } catch (IOException e) {
            System.err.println("Error adding transaction for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e; // Re-throw
        }
    }

    /**
     * Change transaction information for the current user.
     *
     * @param updatedTransaction The transaction object with updated information.
     */
    @Override
    public void changeTransaction(Transaction updatedTransaction) throws Exception {
        try {
            // Load existing transactions (from cache/file)
            List<Transaction> allTransactions = getAllTransactionsForCurrentUser();

            // Find and update the target transaction in the list
            boolean foundAndUpdatedInMemory = false;
            List<Transaction> updatedList = new ArrayList<>(allTransactions.size());
            for (Transaction t : allTransactions) {
                if (t.getOrderNumber().trim().equals(updatedTransaction.getOrderNumber().trim())) {
                    // Found the transaction, apply updates
                    updateTransactionFields(t, updatedTransaction); // Helper method to apply updates
                    updatedList.add(t); // Add the modified transaction
                    foundAndUpdatedInMemory = true;
                    System.out.println("Transaction with order number " + updatedTransaction.getOrderNumber() + " found and updated in memory.");
                } else {
                    updatedList.add(t); // Add unchanged transactions
                }
            }

            if (!foundAndUpdatedInMemory) {
                throw new IllegalArgumentException("Transaction order number not found: " + updatedTransaction.getOrderNumber() + " in file " + currentUserTransactionFilePath);
            }

            // Write the entire updated list back to the CSV file
            transactionDao.writeTransactionsToCSV(currentUserTransactionFilePath, updatedList);
            System.out.println("Updated transaction with order number " + updatedTransaction.getOrderNumber() + " and wrote back to file.");

            // Update the cache with the modified list
            CacheManager.putTransactions(currentUserTransactionFilePath, updatedList, transactionDao);
            System.out.println("Cache updated with the modified transaction list for " + currentUserTransactionFilePath);

        } catch (IOException e) {
            System.err.println("Error changing transaction for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e;
        } catch (Exception e) { // Catch exception from getAllTransactionsForCurrentUser
            System.err.println("Error loading transactions for change operation: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e;
        }
    }

    /**
     * Helper method: Updates non-empty fields from source to target.
     */
    private void updateTransactionFields(Transaction target, Transaction source) {
        // OrderNumber is the key and should generally not be updated this way.
        if (source.getTransactionTime() != null && !source.getTransactionTime().trim().isEmpty()) {
            target.setTransactionTime(source.getTransactionTime().trim());
        }
        if (source.getTransactionType() != null && !source.getTransactionType().trim().isEmpty()) {
            target.setTransactionType(source.getTransactionType().trim());
        }
        if (source.getCounterparty() != null && !source.getCounterparty().trim().isEmpty()) {
            target.setCounterparty(source.getCounterparty().trim());
        }
        if (source.getCommodity() != null && !source.getCommodity().trim().isEmpty()) {
            target.setCommodity(source.getCommodity().trim());
        }
        if (source.getInOut() != null && !source.getInOut().trim().isEmpty()) {
            String inOut = source.getInOut().trim();
            // Assuming inOut values from UI are already validated or are "Income"/"Expense" or "In"/"Out"
            if (inOut.equalsIgnoreCase("Income") || inOut.equalsIgnoreCase("In") ||
                    inOut.equalsIgnoreCase("Expense") || inOut.equalsIgnoreCase("Out")) {
                target.setInOut(inOut);
            } else {
                System.err.println("Warning: Invalid value for In/Out: " + source.getInOut() + ". Keeping original.");
            }
        }
        // For paymentAmount, assume the value from the source (e.g., UI dialog) is the intended new value.
        target.setPaymentAmount(source.getPaymentAmount());

        if (source.getPaymentMethod() != null && !source.getPaymentMethod().trim().isEmpty()) {
            target.setPaymentMethod(source.getPaymentMethod().trim());
        }
        if (source.getCurrentStatus() != null && !source.getCurrentStatus().trim().isEmpty()) {
            target.setCurrentStatus(source.getCurrentStatus().trim());
        }
        if (source.getMerchantNumber() != null && !source.getMerchantNumber().trim().isEmpty()) {
            target.setMerchantNumber(source.getMerchantNumber().trim());
        }
        if (source.getRemarks() != null && !source.getRemarks().trim().isEmpty()) { // Remarks can be empty, so allow empty string.
            target.setRemarks(source.getRemarks().trim());
        }
        System.out.println("Applied updates to transaction: " + target.getOrderNumber());
    }


    /**
     * Delete transaction for the current user by order number.
     *
     * @param orderNumber The unique order number of the transaction to delete.
     * @return true if deletion was successful.
     * @throws Exception If an error occurs or transaction is not found.
     */
    @Override
    public boolean deleteTransaction(String orderNumber) throws Exception {
        try {
            // Call DAO layer to delete transaction from the user's specific file
            boolean deleted = transactionDao.deleteTransaction(currentUserTransactionFilePath, orderNumber);

            if (deleted) {
                // After deleting, invalidate the cache for this user's file
                CacheManager.invalidateTransactionCache(currentUserTransactionFilePath);
                System.out.println("Transaction with order number " + orderNumber + " deleted and cache invalidated for " + currentUserTransactionFilePath);
            } else {
                System.out.println("Transaction with order number " + orderNumber + " not found for deletion in " + currentUserTransactionFilePath);
            }
            return deleted;

        } catch (IOException e) {
            System.err.println("Error deleting transaction for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e;
        }
    }

    /**
     * Search transactions for the current user based on criteria.
     *
     * @param searchCriteria The Transaction object containing search criteria.
     * @return List of matched transactions.
     */
    @Override
    public List<Transaction> searchTransaction(Transaction searchCriteria) {
        try {
            List<Transaction> allTransactions = getAllTransactionsForCurrentUser();
            System.out.println("Searching through " + allTransactions.size() + " transactions for user " + currentUserTransactionFilePath);

            List<Transaction> matched = allTransactions.stream()
                    .filter(t -> matchesCriteria(t, searchCriteria))
                    .collect(Collectors.toList());
            System.out.println("Found " + matched.size() + " matching transactions.");

            matched.sort((t1, t2) -> {
                LocalDateTime time1 = parseDateTimeSafe(t1.getTransactionTime());
                LocalDateTime time2 = parseDateTimeSafe(t2.getTransactionTime());
                if (time1 != null && time2 != null) {
                    return time2.compareTo(time1); // Newest first
                } else if (time1 == null && time2 == null) return 0;
                else if (time1 == null) return 1;
                else return -1;
            });
            System.out.println("Matched transactions sorted.");
            return matched;
        } catch (Exception e) {
            System.err.println("Error during search operation for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            return List.of();
        }
    }

    /**
     * Helper method: Checks if a single transaction matches the search criteria.
     */
    private boolean matchesCriteria(Transaction transaction, Transaction criteria) {
        return containsIgnoreCase(transaction.getTransactionTime(), criteria.getTransactionTime())
                && containsIgnoreCase(transaction.getTransactionType(), criteria.getTransactionType())
                && containsIgnoreCase(transaction.getCounterparty(), criteria.getCounterparty())
                && containsIgnoreCase(transaction.getCommodity(), criteria.getCommodity())
                && matchesInOutCriteria(transaction.getInOut(), criteria.getInOut())
                && containsIgnoreCase(transaction.getPaymentMethod(), criteria.getPaymentMethod());
    }

    /**
     * Helper method: Fuzzy match string, ignoring case and trimming whitespace.
     * An empty/null target criteria matches everything.
     */
    private boolean containsIgnoreCase(String source, String target) {
        if (target == null || target.trim().isEmpty()) {
            return true;
        }
        if (source == null) {
            return false;
        }
        return source.trim().toLowerCase().contains(target.trim().toLowerCase());
    }

    /**
     * Helper method: Matches In/Out criteria. Handles "Income" vs "In", "Expense" vs "Out".
     * An empty/null target criteria matches everything.
     */
    private boolean matchesInOutCriteria(String source, String target) {
        if (target == null || target.trim().isEmpty()) {
            return true;
        }
        if (source == null) {
            return false;
        }
        String sourceTrimmed = source.trim();
        String targetTrimmed = target.trim();

        if (targetTrimmed.equalsIgnoreCase("Income") || targetTrimmed.equalsIgnoreCase("In")) {
            return sourceTrimmed.equalsIgnoreCase("Income") || sourceTrimmed.equalsIgnoreCase("In");
        }
        if (targetTrimmed.equalsIgnoreCase("Expense") || targetTrimmed.equalsIgnoreCase("Out")) {
            return sourceTrimmed.equalsIgnoreCase("Expense") || sourceTrimmed.equalsIgnoreCase("Out");
        }
        return sourceTrimmed.toLowerCase().contains(targetTrimmed.toLowerCase());
    }

    /**
     * Helper method: Safely parses a time string into LocalDateTime.
     * Returns null if parsing fails.
     */
    private LocalDateTime parseDateTimeSafe(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;
        timeStr = timeStr.trim().replaceAll("\\s+", " ");

        if (timeStr.matches("\\d{4}/\\d{1,2}/\\d{1,2}")) {
            timeStr += " 00:00";
        } else if (timeStr.matches("\\d{4}-\\d{1,2}-\\d{1,2}")) {
            timeStr += " 00:00:00";
        }

        List<String> patterns = List.of(
                "yyyy/M/d H:mm", "yyyy/M/d HH:mm",
                "yyyy/MM/d H:mm", "yyyy/MM/d HH:mm",
                "yyyy/M/dd H:mm", "yyyy/M/dd HH:mm",
                "yyyy/MM/dd H:mm", "yyyy/MM/dd HH:mm",
                "yyyy/MM/dd HH:mm:ss",
                "yyyy-MM-dd HH:mm:ss"
        );
        for (String pattern : patterns) {
            try {
                return LocalDateTime.parse(timeStr, DateTimeFormatter.ofPattern(pattern));
            } catch (DateTimeParseException ignored) {}
        }
        System.err.println("Failed to parse date string: " + timeStr);
        return null;
    }

    /**
     * Aggregates transactions for the current user by month and standard category.
     *
     * @return A map where keys are month identifiers (e.g., "YYYY-MM") and values are MonthlySummary objects.
     * @throws Exception If an error occurs during data retrieval.
     */
    @Override
    public Map<String, MonthlySummary> getMonthlyTransactionSummary() throws Exception {
        System.out.println("Generating monthly transaction summary for user file: " + currentUserTransactionFilePath);
        List<Transaction> allTransactions;
        try {
            allTransactions = getAllTransactions();
            System.out.println("Retrieved " + allTransactions.size() + " transactions for summary.");
        } catch (Exception e) {
            System.err.println("Error retrieving transactions for summary generation.");
            e.printStackTrace();
            throw new Exception("Failed to get transaction data!", e);
        }

        Map<String, MonthlySummary> monthlySummaries = new HashMap<>();
        DateTimeFormatter monthFormatter = DateTimeFormatter.ofPattern("yyyy-MM");

        for (Transaction t : allTransactions) {
            if (t.getTransactionTime() == null || t.getTransactionTime().trim().isEmpty()) {
                System.err.println("Skipping transaction with no time for summary aggregation: " + t.getOrderNumber());
                continue;
            }
            LocalDate date = parseDateFromTransactionTimeSafe(t.getTransactionTime());
            if (date == null) {
                System.err.println("Skipping transaction with unparseable date for summary aggregation: " + t.getTransactionTime() + " - " + t.getOrderNumber());
                continue;
            }
            String monthIdentifier = YearMonth.from(date).format(monthFormatter);
            monthlySummaries.putIfAbsent(monthIdentifier, new MonthlySummary(monthIdentifier));
            MonthlySummary currentMonthSummary = monthlySummaries.get(monthIdentifier);

            if (t.getInOut() != null) {
                String inOut = t.getInOut().trim();
                if (inOut.equalsIgnoreCase("Income") || inOut.equalsIgnoreCase("In")) { // Use English here
                    currentMonthSummary.addIncome(t.getPaymentAmount());
                } else if (inOut.equalsIgnoreCase("Expense") || inOut.equalsIgnoreCase("Out")) { // Use English here
                    String rawType = t.getTransactionType();
                    String standardCategory = StandardCategories.getStandardCategory(rawType);
                    String effectiveExpenseCategoryForSummary = StandardCategories.isStandardExpenseCategory(standardCategory) ? standardCategory : StandardCategories.EXPENSE_CATEGORIES.get(StandardCategories.EXPENSE_CATEGORIES.size() - 1); // Default to "Other Expenses"
                    currentMonthSummary.addExpense(t.getPaymentAmount(), effectiveExpenseCategoryForSummary);
                }
            }
        }
        System.out.println("Generated summary for " + monthlySummaries.size() + " months.");
        return monthlySummaries;
    }

    /**
     * Helper method to parse date from transaction time string safely.
     */
    private LocalDate parseDateFromTransactionTimeSafe(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;
        String datePart = timeStr.split(" ")[0];
        datePart = datePart.trim().replace('-', '/');

        List<String> patterns = List.of(
                "yyyy/M/d", "yyyy/MM/d", "yyyy/M/dd", "yyyy/MM/dd"
        );
        for (String pattern : patterns) {
            try {
                return LocalDate.parse(datePart, DateTimeFormatter.ofPattern(pattern));
            } catch (DateTimeParseException ignored) {}
        }
        System.err.println("TransactionServiceImpl: Failed to parse date part '" + datePart + "' from transaction time: " + timeStr);
        return null;
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Service\TransactionService.java`:

```java
package Service;

import model.MonthlySummary;
import model.Transaction;

import java.io.IOException;
import java.util.List;
import java.util.Map;

public interface TransactionService {

    /**
     * Gets all transactions for the current user.
     * @return List of all transactions.
     * @throws Exception If data retrieval fails (e.g., IO error, cache issue).
     */
    List<Transaction> getAllTransactions() throws Exception; // Added this method


    /**
     * 新增交易
     * @param transaction
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * 修改交易
     * @param transaction
     * @throws Exception If modification fails.
     */
    void changeTransaction(Transaction transaction) throws Exception;

    /**
     * 根据订单号删除交易
     * @param orderNumber
     * @return true if deletion was successful, false if transaction not found.
     * @throws Exception If deletion fails (e.g., IO error).
     */
    boolean deleteTransaction(String orderNumber) throws Exception; // Changed return type to boolean

    /**
     * 根据用户输入信息查询交易
     * @param transaction Search criteria.
     * @return List of matched transactions.
     */
    List<Transaction> searchTransaction(Transaction transaction);

    /**
     * Imports transactions from a given CSV file path into the current user's transactions.
     *
     * @param userFilePath The file path for the current user's transactions (target).
     * @param importFilePath The file path of the CSV to import from (source).
     * @return The number of transactions successfully imported.
     * @throws Exception If an error occurs during reading, parsing, or saving.
     */
    int importTransactionsFromCsv(String userFilePath, String importFilePath) throws Exception; // Added this method


    /**
     * Aggregates transactions for the current user by month and standard category.
     *
     * @return A map where keys are month identifiers (e.g., "YYYY-MM") and values are MonthlySummary objects.
     * @throws Exception If an error occurs during data retrieval.
     */
    Map<String, MonthlySummary> getMonthlyTransactionSummary() throws Exception; // Added this method
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Service\User\UserService.java`:

```java
package Service.User; // Changed package

import DAO.UserDao;
import model.User;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class UserService {
    private final UserDao userDao;
    private final Map<String, User> userCache = new HashMap<>(); // Cache users in memory

    public UserService(UserDao userDao) {
        this.userDao = userDao;
        loadUsers(); // Load users when the service is initialized
    }

    private void loadUsers() {
        try {
            List<User> users = userDao.getAllUsers();
            userCache.clear(); // Clear previous cache
            for (User user : users) {
                userCache.put(user.getUsername(), user);
            }
            System.out.println("Loaded " + userCache.size() + " users into cache.");
        } catch (IOException e) {
            System.err.println("Failed to load users from data source.");
            e.printStackTrace();
            // Depending on requirements, you might want to exit or handle this more gracefully
            // For now, we'll allow the app to run with an empty user list, though login will fail.
        }
    }

    /**
     * Authenticates a user.
     *
     * @param username The username.
     * @param password The password.
     * @return The authenticated User object if successful, null otherwise.
     */
    public User authenticate(String username, String password) {
        if (username == null || username.trim().isEmpty() || password == null || password.trim().isEmpty()) {
            return null;
        }

        User user = userCache.get(username.trim());
        if (user != null && user.getPassword().equals(password.trim())) { // Simple password check
            System.out.println("Authentication successful for user: " + username);
            return user; // Authentication successful, return the User object
        }
        System.out.println("Authentication failed for username: " + username);
        return null; // Authentication failed
    }

    /**
     * Retrieves a user by username from the cache.
     * @param username The username.
     * @return The User object or null if not found.
     */
    public User getUserByUsername(String username) {
        if (username == null || username.trim().isEmpty()) {
            return null;
        }
        return userCache.get(username.trim());
    }


    // Add other user management methods if needed (e.g., registerUser, deleteUser)
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Service\deepseek\ChatCompletionsExample.java`:

```java
package Service.deepseek;

import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;
import okhttp3.ConnectionPool;
import okhttp3.Dispatcher;
import org.apache.commons.lang.StringUtils;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
public class ChatCompletionsExample {
    static String apiKey = System.getenv("ARK_API_KEY");
    static ConnectionPool connectionPool = new ConnectionPool(5, 1, TimeUnit.SECONDS);
    static Dispatcher dispatcher = new Dispatcher();
    // The output time of the reasoning model is relatively long. Please increase the timeout period.//
    static ArkService service = ArkService.builder().timeout(Duration.ofSeconds(1800)).connectTimeout(Duration.ofSeconds(20)).dispatcher(dispatcher).connectionPool(connectionPool).baseUrl("https://ark.cn-beijing.volces.com/api/v3").apiKey(apiKey).build();

//    public static void main(String[] args) {
//        System.out.println(" [Recommended]----- streaming request -----");
//        final List<ChatMessage> streamMessages = new ArrayList<>();
//        final ChatMessage streamUserMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("请回答15.11和15.9哪个大？").build();
//        streamMessages.add(streamUserMessage);
//        ChatCompletionRequest streamChatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(streamMessages)
//                .build();
//        service.streamChatCompletion(streamChatCompletionRequest)
//                .doOnError(Throwable::printStackTrace)
//                .blockingForEach(
//                        delta -> {
//                            if (!delta.getChoices().isEmpty()) {
//                                if (StringUtils.isNotEmpty(delta.getChoices().get(0).getMessage().getReasoningContent())) {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getReasoningContent());
//                                } else {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getContent());
//                                }
//                            }
//                        }
//                );
//        System.out.println(" ----- standard request -----");
//        final List<ChatMessage> messages = new ArrayList<>();
//        final ChatMessage userMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("常见的十字花科植物有哪些？").build();
//        messages.add(userMessage);
//        ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(messages)
//                .build();
//        service.createChatCompletion(chatCompletionRequest).getChoices().forEach(
//                choice -> {
//                    System.out.println(choice.getMessage().getReasoningContent());
//                    System.out.println(choice.getMessage().getContent());
//                }
//        );
//        // shutdown service after all requests is finished
//        service.shutdownExecutor();
//    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Utils\CacheManager.java`:

```java
package Utils;

import Constants.CaffeineKeys;
import DAO.Impl.CsvTransactionDao; // Assuming CsvTransactionDao is in DAO.Impl
import DAO.TransactionDao; // Assuming TransactionDao interface is in DAO
import model.Transaction;
import com.github.benmanes.caffeine.cache.Cache; // Use general Cache interface
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.LoadingCache;

import java.io.IOException;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

/**
 * Manages Caffeine caches for different transaction data files (per user).
 * Uses the file path as the cache key.
 */
public class CacheManager {

    // Use a map to hold caches, keyed by file path
    // The value is the Caffeine LoadingCache for that specific file path
    private static final ConcurrentHashMap<String, LoadingCache<String, List<Transaction>>> fileCaches = new ConcurrentHashMap<>();

    // Define default cache parameters
    private static final int DEFAULT_MAX_SIZE = 1; // Only cache one instance (the list of transactions) per file
    private static final long DEFAULT_EXPIRE_AFTER_WRITE_MINUTES = 10; // Cache entry expires after 10 minutes
    private static final long DEFAULT_REFRESH_AFTER_WRITE_MINUTES = 1; // Refresh entry after 1 minute

    // Private constructor to prevent instantiation
    private CacheManager() {}

    /**
     * Gets or creates a LoadingCache for the specified transaction file path.
     * The cache loads List<Transaction> from the file using TransactionDao.
     *
     * @param filePath The path to the user's transaction CSV file.
     * @param transactionDao The TransactionDao instance to use for loading.
     * @return The LoadingCache instance for the given file path.
     */
    public static LoadingCache<String, List<Transaction>> getTransactionCache(String filePath, TransactionDao transactionDao) {
        // Use computeIfAbsent to get or create the cache atomically
        return fileCaches.computeIfAbsent(filePath, key -> {
            System.out.println("CacheManager: Creating new cache for file: " + filePath);
            // Create a new LoadingCache for this specific file path
            return Caffeine.newBuilder()
                    .maximumSize(DEFAULT_MAX_SIZE)
                    .expireAfterWrite(DEFAULT_EXPIRE_AFTER_WRITE_MINUTES, TimeUnit.MINUTES)
                    .refreshAfterWrite(DEFAULT_REFRESH_AFTER_WRITE_MINUTES, TimeUnit.MINUTES)
                    // Define the loader function: how to load data when cache is missed or refreshed
                    .build(cacheKey -> {
                        System.out.println("CacheManager: Loading transactions from file: " + filePath + " (Cache Miss/Refresh)");
                        try {
                            // The cacheKey here will likely be a constant like "transactions"
                            // We use the outer filePath variable to load from the correct file
                            return transactionDao.loadFromCSV(filePath);
                        } catch (IOException e) {
                            System.err.println("CacheManager: Error loading data for file " + filePath);
                            e.printStackTrace();
                            throw new RuntimeException("Error loading transactions from " + filePath, e); // Wrap IOException in RuntimeException for Caffeine loader
                        }
                    });
        });
    }

    /**
     * Invalidates the cache for a specific transaction file path.
     * @param filePath The path to the user's transaction CSV file.
     */
    public static void invalidateTransactionCache(String filePath) {
        LoadingCache<String, List<Transaction>> cache = fileCaches.get(filePath);
        if (cache != null) {
            System.out.println("CacheManager: Invalidating cache for file: " + filePath);
            // The cache key for List<Transaction> is likely a constant like "transactions"
            cache.invalidate(CaffeineKeys.TRANSACTION_CAFFEINE_KEY); // Invalidate the entry storing the transaction list
        }

    }

    /**
     * Gets the transaction list from the cache for the specified file path.
     * Loads data if not present or expired. Handles exceptions thrown by the loader.
     *
     * @param filePath The path to the user's transaction CSV file.
     * @param transactionDao The TransactionDao instance to use for loading if cache misses.
     * @return The list of transactions.
     * @throws Exception If an error occurs during loading (e.g., IOException).
     */
    public static List<Transaction> getTransactions(String filePath, TransactionDao transactionDao) throws Exception {
        LoadingCache<String, List<Transaction>> cache = getTransactionCache(filePath, transactionDao);
        // The cache key for the list of transactions from a specific file is a constant.
        // This constant key maps to the *entire list* of transactions for that file.
        return cache.get(CaffeineKeys.TRANSACTION_CAFFEINE_KEY);
    }

    /**
     * Manually puts a list of transactions into the cache for a specific file path.
     * This is useful after a write operation (add, delete, update) to refresh the cache.
     *
     * @param filePath The path to the user's transaction CSV file.
     * @param transactions The updated list of transactions.
     * @param transactionDao The TransactionDao instance (needed to get/create cache if not exists).
     */
    public static void putTransactions(String filePath, List<Transaction> transactions, TransactionDao transactionDao) {
        LoadingCache<String, List<Transaction>> cache = getTransactionCache(filePath, transactionDao);
        cache.put(CaffeineKeys.TRANSACTION_CAFFEINE_KEY, transactions);
        System.out.println("CacheManager: Manually updated cache for file: " + filePath);
    }

    /**
     * Shutdown any resources if necessary (though Caffeine typically manages its threads).
     */
    public static void shutdown() {
        // Caffeine cache doesn't require explicit shutdown in most cases
        // If using custom executors, they might need shutdown.
        System.out.println("CacheManager: Shutdown completed.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\Utils\CacheUtil.java`:

```java
package Utils;

import com.github.benmanes.caffeine.cache.*;

import java.util.concurrent.TimeUnit;
import java.util.function.Function;

import com.github.benmanes.caffeine.cache.Caffeine;

/**
 * Generic Cache Utility Class (Supports generics and exception propagation through the loader)
 * @param <K> Key type
 * @param <V> Value type
 * @param <E> Exception type (e.g., IOException, which the loader function might throw)
 */
public class CacheUtil<K, V, E extends Exception> {
    private final LoadingCache<K, V> cache;

    public CacheUtil(Function<K, V> loader,
                     int maxSize,
                     long expireAfterWrite,
                     long refreshAfterWrite) {

        this.cache = Caffeine.newBuilder()
                .maximumSize(maxSize)
                .expireAfterWrite(expireAfterWrite, TimeUnit.MINUTES)
                .refreshAfterWrite(refreshAfterWrite, TimeUnit.MINUTES)
                .build(loader::apply); // 关键修改：使用build(loader)创建LoadingCache
    }

    /**
     * Gets the cached value.
     * If the key is not in the cache, the loader function will be called to compute it.
     * @param key The key whose associated value is to be returned.
     * @return The value associated with the key.
     */
    public V get(K key) {
        return cache.get(key);
    }

    /**
     * Manually updates the cache with a new value for a given key.
     * @param key The key with which the specified value is to be associated.
     * @param value The value to be associated with the specified key.
     */
    public void put(K key, V value) {
        cache.put(key, value);
    }

    /**
     * Manually removes the entry for a key from the cache.
     * @param key The key whose mapping is to be removed from the cache.
     */
    public void invalidate(K key) {
        cache.invalidate(key);
    }
}



```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\model\MonthlySummary.java`:

```java
package model;

import java.util.HashMap;
import java.util.Map;

// Represents a summary of transactions for a specific month
public class MonthlySummary {
    private String monthIdentifier; // e.g., "2025-03"
    private double totalIncome;
    private double totalExpense;
    // Map from standard expense category to total amount spent in that category
    private Map<String, Double> expenseByCategory;

    public MonthlySummary(String monthIdentifier) {
        this.monthIdentifier = monthIdentifier;
        this.totalIncome = 0.0;
        this.totalExpense = 0.0;
        this.expenseByCategory = new HashMap<>();
    }

    // Getters
    public String getMonthIdentifier() {
        return monthIdentifier;
    }

    public double getTotalIncome() {
        return totalIncome;
    }

    public double getTotalExpense() {
        return totalExpense;
    }

    public Map<String, Double> getExpenseByCategory() {
        return expenseByCategory;
    }

    // Methods to add transaction amounts
    public void addIncome(double amount) {
        this.totalIncome += amount;
    }

    public void addExpense(double amount, String standardCategory) {
        this.totalExpense += amount;
        // Aggregate by standard category
        expenseByCategory.put(standardCategory, expenseByCategory.getOrDefault(standardCategory, 0.0) + amount);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Month: ").append(monthIdentifier).append("\n");
        sb.append("  Total Income: ").append(String.format("%.2f", totalIncome)).append("元\n");
        sb.append("  Total Expense: ").append(String.format("%.2f", totalExpense)).append("元\n");
        sb.append("  Expenses by Category:\n");
        if (expenseByCategory.isEmpty()) {
            sb.append("    (None)\n");
        } else {
            // Sort categories alphabetically for consistent output
            expenseByCategory.entrySet().stream()
                    .sorted(Map.Entry.comparingByKey())
                    .forEach(entry ->
                            sb.append(String.format("    %s: %.2fCNY\n", entry.getKey(), entry.getValue()))
                    );
        }
        return sb.toString();
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\model\SummaryStatistic.java`:

```java
package model;

// Represents a summary statistic for a specific week across all users
public class SummaryStatistic {
    private String weekIdentifier; // e.g., "2025-W14"
    private double totalIncomeAllUsers;
    private double totalExpenseAllUsers;
    private String topExpenseCategory; // e.g., "FOOD"
    private double topExpenseCategoryAmount; // Amount spent in the top category
    private int numberOfUsersWithTransactions; // Number of users who had any transaction this week
    private String timestampGenerated; // When this statistic record was created

    // Constructors
    public SummaryStatistic() {
    }

    public SummaryStatistic(String weekIdentifier, double totalIncomeAllUsers, double totalExpenseAllUsers, String topExpenseCategory, double topExpenseCategoryAmount, int numberOfUsersWithTransactions, String timestampGenerated) {
        this.weekIdentifier = weekIdentifier;
        this.totalIncomeAllUsers = totalIncomeAllUsers;
        this.totalExpenseAllUsers = totalExpenseAllUsers;
        this.topExpenseCategory = topExpenseCategory;
        this.topExpenseCategoryAmount = topExpenseCategoryAmount;
        this.numberOfUsersWithTransactions = numberOfUsersWithTransactions;
        this.timestampGenerated = timestampGenerated;
    }

    // Getters
    public String getWeekIdentifier() {
        return weekIdentifier;
    }

    public double getTotalIncomeAllUsers() {
        return totalIncomeAllUsers;
    }

    public double getTotalExpenseAllUsers() {
        return totalExpenseAllUsers;
    }

    public String getTopExpenseCategory() {
        return topExpenseCategory;
    }

    public double getTopExpenseCategoryAmount() {
        return topExpenseCategoryAmount;
    }

    public int getNumberOfUsersWithTransactions() {
        return numberOfUsersWithTransactions;
    }

    public String getTimestampGenerated() {
        return timestampGenerated;
    }

    // Setters (if needed for creation/population)
    public void setWeekIdentifier(String weekIdentifier) {
        this.weekIdentifier = weekIdentifier;
    }

    public void setTotalIncomeAllUsers(double totalIncomeAllUsers) {
        this.totalIncomeAllUsers = totalIncomeAllUsers;
    }

    public void setTotalExpenseAllUsers(double totalExpenseAllUsers) {
        this.totalExpenseAllUsers = totalExpenseAllUsers;
    }

    public void setTopExpenseCategory(String topExpenseCategory) {
        this.topExpenseCategory = topExpenseCategory;
    }

    public void setTopExpenseCategoryAmount(double topExpenseCategoryAmount) {
        this.topExpenseCategoryAmount = topExpenseCategoryAmount;
    }

    public void setNumberOfUsersWithTransactions(int numberOfUsersWithTransactions) {
        this.numberOfUsersWithTransactions = numberOfUsersWithTransactions;
    }

    public void setTimestampGenerated(String timestampGenerated) {
        this.timestampGenerated = timestampGenerated;
    }

    @Override
    public String toString() {
        return "SummaryStatistic{" +
                "weekIdentifier='" + weekIdentifier + '\'' +
                ", totalIncomeAllUsers=" + totalIncomeAllUsers +
                ", totalExpenseAllUsers=" + totalExpenseAllUsers +
                ", topExpenseCategory='" + topExpenseCategory + '\'' +
                ", topExpenseCategoryAmount=" + topExpenseCategoryAmount +
                ", numberOfUsersWithTransactions=" + numberOfUsersWithTransactions +
                ", timestampGenerated='" + timestampGenerated + '\'' +
                '}';
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\model\Transaction.java`:

```java
package model;
//Transaction time, transaction type, transaction counterparty,
// commodity receipt/payment amount (yuan), payment method, current status,
// transaction order number, merchant order number, remarks
public class Transaction {
    private String transactionTime;
    private String transactionType;
    private String counterparty;
    private String commodity;
    private String inOut;
    private double paymentAmount;
    private String paymentMethod;
    private String currentStatus;
    private String orderNumber;
    private String merchantNumber;
    private String remarks;

    public Transaction() {
    }

    public Transaction(String transactionTime, String transactionType, String counterparty, String commodity, String inOut, double paymentAmount, String paymentMethod, String currentStatus, String orderNumber, String merchantNumber, String remarks) {
        this.transactionTime = transactionTime;
        this.transactionType = transactionType;
        this.counterparty = counterparty;
        this.commodity = commodity;
        this.inOut = inOut;
        this.paymentAmount = paymentAmount;
        this.paymentMethod = paymentMethod;
        this.currentStatus = currentStatus;
        this.orderNumber = orderNumber;
        this.merchantNumber = merchantNumber;
        this.remarks = remarks;
    }

    public String getInOut() {
        return inOut;
    }

    public void setInOut(String inOut) {
        this.inOut = inOut;
    }

    public void setTransactionTime(String transactionTime) {
        this.transactionTime = transactionTime;
    }

    public void setTransactionType(String transactionType) {
        this.transactionType = transactionType;
    }

    public void setCounterparty(String counterparty) {
        this.counterparty = counterparty;
    }

    public void setCommodity(String commodity) {
        this.commodity = commodity;
    }

    public void setPaymentAmount(double paymentAmount) {
        this.paymentAmount = paymentAmount;
    }

    public void setPaymentMethod(String paymentMethod) {
        this.paymentMethod = paymentMethod;
    }

    public void setCurrentStatus(String currentStatus) {
        this.currentStatus = currentStatus;
    }

    public void setOrderNumber(String orderNumbe) {
        this.orderNumber = orderNumbe;
    }

    public void setMerchantNumber(String merchantNumber) {
        this.merchantNumber = merchantNumber;
    }

    public void setRemarks(String remarks) {
        this.remarks = remarks;
    }

    public String getTransactionTime() {
        return transactionTime;
    }

    public String getTransactionType() {
        return transactionType;
    }

    public String getCounterparty() {
        return counterparty;
    }

    public String getCommodity() {
        return commodity;
    }

    public double getPaymentAmount() {
        return paymentAmount;
    }

    public String getPaymentMethod() {
        return paymentMethod;
    }

    public String getCurrentStatus() {
        return currentStatus;
    }

    public String getOrderNumber() {
        return orderNumber;
    }

    public String getMerchantNumber() {
        return merchantNumber;
    }

    public String getRemarks() {
        return remarks;
    }
}

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\java\model\User.java`:

```java
package model;

// User model class
public class User {
    private String username;
    private String password;
    private String role; // e.g., "user", "admin"
    private String transactionFilePath; // Path to the user's transaction CSV file

    // Constructors
    public User() {
    }

    public User(String username, String password, String role, String transactionFilePath) {
        this.username = username;
        this.password = password;
        this.role = role;
        this.transactionFilePath = transactionFilePath;
    }

    // Getters and Setters
    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }

    public String getTransactionFilePath() {
        return transactionFilePath;
    }

    public void setTransactionFilePath(String transactionFilePath) {
        this.transactionFilePath = transactionFilePath;
    }

    @Override
    public String toString() {
        return "User{" +
                "username='" + username + '\'' +
                ", role='" + role + '\'' +
                ", transactionFilePath='" + transactionFilePath + '\'' +
                '}';
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\resources\CSVForm\stats\summary_statistics.csv`:

```csv
week_identifier,total_income_all_users,total_expense_all_users,top_expense_category,top_expense_category_amount,number_of_users_with_transactions,timestamp_generated
2022-W37,0.0,0.0,无支出,0.0,1,2025-05-24 12:02:53
2025-W09,0.0,0.0,无支出,0.0,3,2025-05-24 12:02:53
2025-W10,0.0,0.0,无支出,0.0,3,2025-05-24 12:02:53
2025-W11,0.0,0.0,无支出,0.0,3,2025-05-24 12:02:53
2025-W12,0.0,0.0,无支出,0.0,3,2025-05-24 12:02:53

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\resources\CSVForm\transactions\admin_transactions.csv`:

```csv
Transaction Time,Transaction Type,Counterparty,Commodity,In/Out,Amount(CNY),Payment Method,Current Status,Order Number,Merchant Number,Remarks
2025/03/01 09:00:00,Salary,Company A,March Salary,Income,¥10000.00,Bank Card,Credited,SALARY_MAR_A,PAYROLL_A_001,This month's base salary
2025/03/05 14:30:00,Groceries,Supermarket B,Groceries,Expense,¥250.50,Alipay,Completed,SHOP_B_001,ALIPAY_12345,Weekend shopping
2025/03/15 11:00:00,Dining,Restaurant C,Lunch Takeaway,Expense,¥35.75,Meituan Pay,Completed,MEAL_C_001,MEITUAN_11223,Workday lunch
2025/03/20 16:00:00,Financial Services,Stock Account,Stock Purchase,Expense,¥5000.00,Meituan Pay,Completed,INVEST_STOCK_001,BANK_99887,Long-term investment
2022/09/10 16:00:00,Investment,Stock Account,Stock Purchase,Expense,¥5000.00,TongHuaShun,Pending,INVEST_STOCK_002,BANK_99887,Short-term investment
2025/03/10 10:00:00,Transfer,User 1,Lunch Reimbursement,Expense,¥50.00,WeChat Pay,Completed,TRANSFER_U1_001,WECHAT_56789,Returning lunch money
2025/03/10 10:00:00,Transfer,BUPT,ASS,Income,¥2000.00,AliPay,Completed,1,1,Wow!

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\resources\CSVForm\transactions\user1_transactions.csv`:

```csv
Transaction Time,Transaction Type,Counterparty,Commodity,In/Out,Amount(CNY),Payment Method,Current Status,Order Number,Merchant Number,Remarks
2025/03/01 09:00:00,Salary,Company A,March Salary,Expense,¥10000.00,Bank Card,Credited,SALARY_MAR_A,PAYROLL_A_001,This month's base salary
2025/03/05 14:30:00,Groceries,Supermarket B,Groceries,Expense,¥250.50,Alipay,Completed,SHOP_B_001,ALIPAY_12345,Weekend shopping
2025/03/10 10:00:00,Transfer,User 1,Lunch Reimbursement,Expense,¥50.00,WeChat Pay,Completed,TRANSFER_U1_001,WECHAT_56789,Returning lunch money
2025/03/15 11:00:00,Dining,Restaurant C,Lunch Takeaway,Expense,¥35.75,Meituan Pay,Completed,MEAL_C_001,MEITUAN_11223,Workday lunch
2025/03/20 16:00:00,Investment,Stock Account,Stock Purchase,Expense,¥5000.00,Bank Transfer,Completed,INVEST_STOCK_001,BANK_99887,Long-term investment
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\resources\CSVForm\transactions\user2_transactions.csv`:

```csv
Transaction Time,Transaction Type,Counterparty,Commodity,In/Out,Amount(CNY),Payment Method,Current Status,Order Number,Merchant Number,Remarks
2025/03/01 09:00:00,Salary,Company A,March Salary,Expense,¥10000.00,Bank Card,Credited,SALARY_MAR_A,PAYROLL_A_001,This month's base salary
2025/03/05 14:30:00,Groceries,Supermarket B,Groceries,Expense,¥250.50,Alipay,Completed,SHOP_B_001,ALIPAY_12345,Weekend shopping
2025/03/10 10:00:00,Transfer,User 1,Lunch Reimbursement,Expense,¥50.00,WeChat Pay,Completed,TRANSFER_U1_001,WECHAT_56789,Returning lunch money
2025/03/15 11:00:00,Dining,Restaurant C,Lunch Takeaway,Expense,¥35.75,Meituan Pay,Completed,MEAL_C_001,MEITUAN_11223,Workday lunch
2025/03/20 16:00:00,Investment,Stock Account,Stock Purchase,Expense,¥5000.00,Bank Transfer,Completed,INVEST_STOCK_001,BANK_99887,Long-term investment
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\resources\CSVForm\users\users.csv`:

```csv
username,password,role,transaction_csv_path
admin,admin123,admin,Ai Bill Application/src/main/resources/CSVForm/transactions/admin_transactions.csv
user1,pass123,user,Ai Bill Application/src/main/resources/CSVForm/transactions/user1_transactions.csv
user2,securepwd,user,Ai Bill Application/src/main/resources/CSVForm/transactions/user2_transactions.csv

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\main\resources\config.properties`:

```properties
# config.properties
#csv.path=Ai Bill Application/src/main/resources/CSVForm/0001.csv
csv.path=Ai Bill Application/src/main/resources/CSVForm/transactions/admin_transactions.csv
csv.users_path=Ai Bill Application/src/main/resources/CSVForm/users/users.csv
csv.summary_path=Ai Bill Application/src/main/resources/CSVForm/stats/summary_statistics.csv
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Controller\ButtonEditorTest.java`:

```java
package Controller;

import Controller.ButtonEditor;
import Controller.MenuUI;
import DAO.Impl.CsvSummaryStatisticDao;
import DAO.Impl.CsvTransactionDao;
import DAO.Impl.CsvUserDao;
import DAO.SummaryStatisticDao;
import DAO.TransactionDao;
import DAO.UserDao;
import Service.AIservice.AITransactionService;
import Service.AIservice.CollegeStudentNeeds;
import Service.Impl.SummaryStatisticService;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Service.User.UserService;
import model.User;
import Constants.ConfigConstants;

import org.junit.jupiter.api.Test;
import javax.swing.*;
import java.awt.*;

public class ButtonEditorTest {

    @Test
    void testButtonEditorInstantiationAndUsage() {
        // Full setup for MenuUI is required because ButtonEditor depends on it.
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        UserService userService = new UserService(userDao);
        User testUser = userService.authenticate("user1", "pass123");

        if (testUser == null) {
            System.err.println("ButtonEditorTest: Failed to authenticate test user 'user1'. Test cannot proceed.");
            return;
        }

        TransactionDao transactionDao = new CsvTransactionDao();
        TransactionService transactionService = new TransactionServiceImpl(testUser.getTransactionFilePath());
        SummaryStatisticDao summaryStatisticDao = new CsvSummaryStatisticDao();
        SummaryStatisticService summaryStatisticService = new SummaryStatisticService(userDao, transactionDao, summaryStatisticDao);
        AITransactionService aiTransactionService = new AITransactionService(transactionService);
        CollegeStudentNeeds collegeStudentNeeds = new CollegeStudentNeeds(transactionService);

        // MenuUI needs to be created on EDT if it does heavy UI work in constructor,
        // but its constructor seems okay for direct call here.
        // For safety, let's ensure any UI part of MenuUI setup is on EDT if it were an issue.
        // However, the constructor itself doesn't build the final panel yet.
        MenuUI menuUI = new MenuUI(testUser, transactionService, summaryStatisticService, aiTransactionService, collegeStudentNeeds);
        // We don't need to display MenuUI itself for this ButtonEditor test.

        try {
            ButtonEditor editor = new ButtonEditor(menuUI); // Pass the MenuUI instance
            // Simulate a call from JTable
            Component component = editor.getTableCellEditorComponent(
                    null,           // JTable (can be null for basic test)
                    "Edit Button",  // value
                    false,          // isSelected
                    0,              // row
                    0               // column
            );
            System.out.println("ButtonEditorTest: ButtonEditor instantiated and getTableCellEditorComponent called.");
            Object editorValue = editor.getCellEditorValue();
            System.out.println("ButtonEditorTest: getCellEditorValue returned: " + editorValue);

            if (component instanceof JPanel) {
                System.out.println("ButtonEditorTest: Editor component is a JPanel as expected.");
            } else {
                System.err.println("ButtonEditorTest: Editor component is NOT a JPanel.");
            }

        } catch (Exception e) {
            System.err.println("ButtonEditorTest: Error during test.");
            e.printStackTrace();
            throw e; // Re-throw to make JUnit mark it as failed
        }
        System.out.println("ButtonEditorTest: testButtonEditorInstantiationAndUsage finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Controller\ButtonRendererTest.java`:

```java
package Controller;

import Controller.ButtonRenderer;
import org.junit.jupiter.api.Test;
import javax.swing.*;
import java.awt.*;

public class ButtonRendererTest {

    @Test
    void testButtonRendererInstantiationAndUsage() {
        try {
            ButtonRenderer renderer = new ButtonRenderer();
            // Simulate a call from JTable
            Component component = renderer.getTableCellRendererComponent(
                    null, // JTable (can be null for basic test)
                    "Test Button",  // value
                    false,          // isSelected
                    false,          // hasFocus
                    0,              // row
                    0               // column
            );
            System.out.println("ButtonRendererTest: ButtonRenderer instantiated and getTableCellRendererComponent called.");
            // To visually test, you'd need to add this component to a visible frame,
            // but for a "can it run" test, just calling the method is sufficient.
            if (component instanceof JPanel) {
                System.out.println("ButtonRendererTest: Component is a JPanel as expected.");
            } else {
                System.err.println("ButtonRendererTest: Component is NOT a JPanel.");
            }
        } catch (Exception e) {
            System.err.println("ButtonRendererTest: Error during test.");
            e.printStackTrace();
            // If we reach here, the test effectively fails for "can it run"
            throw e; // Re-throw to make JUnit mark it as failed
        }
        System.out.println("ButtonRendererTest: testButtonRendererInstantiationAndUsage finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Controller\HistogramPanelContainerTest.java`:

```java
package Controller;

import Controller.HistogramPanelContainer;
import org.junit.jupiter.api.Test;
import javax.swing.*;
import java.awt.*;

public class HistogramPanelContainerTest {

    @Test
    void testDisplayHistogramPanelContainer() {
        SwingUtilities.invokeLater(() -> {
            try {
                JFrame frame = new JFrame("HistogramPanelContainer Test Display");
                frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
                frame.setSize(800, 600);
                frame.add(new HistogramPanelContainer());
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
                System.out.println("HistogramPanelContainerTest: HistogramPanelContainer displayed.");
            } catch (Exception e) {
                System.err.println("HistogramPanelContainerTest: Error creating or displaying HistogramPanelContainer.");
                e.printStackTrace();
            }
        });

        try {
            Thread.sleep(5000); // Keep frame visible for 5 seconds
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("HistogramPanelContainerTest: testDisplayHistogramPanelContainer finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Controller\MenuUITest.java`:

```java
package Controller;

import Controller.MenuUI;
import DAO.Impl.CsvSummaryStatisticDao;
import DAO.Impl.CsvTransactionDao;
import DAO.Impl.CsvUserDao;
import DAO.SummaryStatisticDao;
import DAO.TransactionDao;
import DAO.UserDao;
import Interceptor.Login.LoginDialog; // Not used directly for MenuUI test, but part of typical flow
import Service.AIservice.AITransactionService;
import Service.AIservice.CollegeStudentNeeds;
import Service.Impl.SummaryStatisticService;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Service.User.UserService;
import model.User;
import Constants.ConfigConstants; // For paths

import org.junit.jupiter.api.Test;
import javax.swing.*;
import java.awt.*;

public class MenuUITest {

    @Test
    void testDisplayMenuUI() {
        // Setup services and user
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        UserService userService = new UserService(userDao);
        // Authenticate a test user (e.g., user1)
        User testUser = userService.authenticate("user1", "pass123");
        if (testUser == null) {
            System.err.println("MenuUITest: Failed to authenticate test user 'user1'. Check credentials and users.csv.");
            // Attempt with admin if user1 fails, for robustness in test setup
            testUser = userService.authenticate("admin", "admin123");
            if (testUser == null) {
                System.err.println("MenuUITest: Failed to authenticate test user 'admin' as well. Test cannot proceed.");
                return;
            }
        }
        final User currentUser = testUser; // Effectively final for lambda

        TransactionDao transactionDao = new CsvTransactionDao();
        TransactionService transactionService = new TransactionServiceImpl(currentUser.getTransactionFilePath());

        SummaryStatisticDao summaryStatisticDao = new CsvSummaryStatisticDao();
        SummaryStatisticService summaryStatisticService = new SummaryStatisticService(userDao, transactionDao, summaryStatisticDao);

        AITransactionService aiTransactionService = new AITransactionService(transactionService);
        CollegeStudentNeeds collegeStudentNeeds = new CollegeStudentNeeds(transactionService);

        SwingUtilities.invokeLater(() -> {
            try {
                MenuUI menuUI = new MenuUI(currentUser, transactionService, summaryStatisticService, aiTransactionService, collegeStudentNeeds);
                JPanel mainPanel = menuUI.createMainPanel();

                JFrame frame = new JFrame("MenuUI Test Display");
                frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
                frame.setSize(1200, 700);
                frame.add(mainPanel);
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
                System.out.println("MenuUITest: MenuUI panel for user '" + currentUser.getUsername() + "' displayed.");
            } catch (Exception e) {
                System.err.println("MenuUITest: Error creating or displaying MenuUI.");
                e.printStackTrace();
            }
        });

        try {
            Thread.sleep(5000); // Keep frame visible for 5 seconds
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("MenuUITest: testDisplayMenuUI finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Controller\VisualizationPanelTest.java`:

```java
package Controller;

import Controller.VisualizationPanel;
import DAO.Impl.CsvUserDao;
import DAO.UserDao;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Service.User.UserService;
import model.User;
import Constants.ConfigConstants;

import org.junit.jupiter.api.Test;
import javax.swing.*;
import java.awt.*;

public class VisualizationPanelTest {

    @Test
    void testDisplayVisualizationPanel() {
        // Setup a TransactionService instance
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        UserService userService = new UserService(userDao);
        User testUser = userService.authenticate("user1", "pass123"); // Using user1 for transaction data

        if (testUser == null) {
            System.err.println("VisualizationPanelTest: Failed to authenticate test user 'user1'. Check credentials and users.csv.");
            return;
        }

        TransactionService transactionService = new TransactionServiceImpl(testUser.getTransactionFilePath());

        SwingUtilities.invokeLater(() -> {
            try {
                VisualizationPanel visualizationPanel = new VisualizationPanel(transactionService);
                // Optionally call a method to load initial data/charts if available
                // visualizationPanel.refreshPanelData(); // As per VisualizationPanel's own method

                JFrame frame = new JFrame("VisualizationPanel Test Display");
                frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
                frame.setSize(800, 600);
                frame.add(visualizationPanel);
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
                System.out.println("VisualizationPanelTest: VisualizationPanel displayed.");

                // Call refreshPanelData after the panel is visible and has a size
                SwingUtilities.invokeLater(visualizationPanel::refreshPanelData);

            } catch (Exception e) {
                System.err.println("VisualizationPanelTest: Error creating or displaying VisualizationPanel.");
                e.printStackTrace();
            }
        });

        try {
            Thread.sleep(5000); // Keep frame visible for 5 seconds
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("VisualizationPanelTest: testDisplayVisualizationPanel finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\DAOTest\CsvTransactionDaoTest.java`:

```java
package DAOTest;

import DAO.Impl.CsvTransactionDao;
import model.Transaction;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static Constants.ConfigConstants.CSV_PATH;
import static org.junit.Assert.*; // Using JUnit 4 Assert for assertEquals, assertNotNull etc.

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List; // Keep this import as it's used.
import java.util.ArrayList; // Added this import as List.of() is used in createTestCsvFile and its usage might imply ArrayList for modifications later.


class CsvTransactionDaoTest {
    private static final String TEST_ADMIN_CSV_PATH = "Ai Bill Application/src/test/resources/CSVForm/transactions/admin_transactions.csv"; // Path to admin CSV for testing

    // Test file path (adjust according to actual structure)
    private static final String TEST_CSV_PATH = CSV_PATH; // General test CSV path from constants
    private static CsvTransactionDao dao;

    @Test
    void testLoadFromCSV_ValidFile_ReturnsTransactions() throws Exception {
        // Given
        CsvTransactionDao dao = new CsvTransactionDao();

        // When
        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);

        // Verify fields of the first record (or all records)
        for (int i = 0; i < transactions.size(); i++) {
            System.out.println(transactions.get(i).getRemarks());
            System.out.println(transactions.get(i).getCommodity());
        }
    }

    @Test
    void testAddTransaction() throws IOException {
        dao = new CsvTransactionDao();
        Transaction newTx = new Transaction(
                "2025-03-09 10:00",
                "Transfer",           // "Transfer"
                "Xiao Ming",          // "Xiao Ming"
                "Books",              // "Books"
                "Out",                // "Out" (Assuming "支" means "Out" or "Expense")
                99.99,
                "WeChat",             // "WeChat"
                "Completed",          // "Completed"
                "TX123456",
                "M789012",
                "");

        dao.addTransaction("src/test/resources/001.csv", newTx); // Path to a specific test file for adding

        List<Transaction> transactions = dao.loadFromCSV(TEST_CSV_PATH); // Load from the general test path to verify
    }

    @BeforeEach
        // This runs before each test method
    void setUp() {
        // Initialize DAO before each test
        dao = new CsvTransactionDao();
        // Ensure the test file exists - maybe create it programmatically here for reliable testing
        // or rely on it being present in src/test/resources and copied to classpath
    }

    @Test
    void testLoadAdminCSV() throws IOException {
        System.out.println("Attempting to load test CSV: " + TEST_ADMIN_CSV_PATH);
        Path csvPath = Paths.get(TEST_ADMIN_CSV_PATH);
        assertTrue("Test CSV file should exist at " + TEST_ADMIN_CSV_PATH, Files.exists(csvPath));
        assertTrue("Test CSV file should not be empty.", Files.size(csvPath) > 0);

        // When loading the specific admin CSV
        List<Transaction> transactions = dao.loadFromCSV(TEST_ADMIN_CSV_PATH);

        // Then assert that loading was successful and data is present
        assertNotNull(transactions.toString(), "Loaded transactions list should not be null");
        assertFalse("Loaded transactions list should not be empty", transactions.isEmpty());
        // Assuming the DAO returns 5 data rows. Adjust if header affects count.
        assertEquals("Should load 5 transaction records", 5, transactions.size());

        // Optional: Verify content of a specific row
        Transaction firstTx = transactions.get(0);
        // Assuming the Transaction object field names are English, and CSV values map to them.
        // If CSV values are Chinese and DAO maps them:
        assertEquals("CompanyA", firstTx.getCounterparty()); // Example: "公司A" maps to CompanyA
        assertEquals("March Salary", firstTx.getCommodity());   // Example: "三月工资" maps to March Salary
        assertEquals(10000.00, firstTx.getPaymentAmount(), 0.01); // Use delta for double comparison
    }

    // Add other tests like testAddTransaction, testDeleteTransaction, testChangeInformation etc.
    // Ensure these tests also use the correct file paths and verify file content changes.
    // For modification/deletion tests, you might need to create a temporary CSV file
    // or use a file specifically for testing that can be modified without affecting other tests.

    // Example of a helper method to create a test CSV file programmatically
    // This is more reliable than relying on manual copying/pasting for tests.
    private void createTestCsvFile(String filePath, List<Transaction> transactions) throws IOException {
        Path path = Paths.get(filePath);
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }
        // Delete old file if it exists
        if (Files.exists(path)) {
            Files.delete(path);
        }

        // Assuming English headers for consistency with most CSV libraries' defaults
        // If your DAO strictly expects Chinese headers, use the Chinese header array.
        String[] headers = {"Transaction Time", "Transaction Type", "Counterparty", "Commodity", "In/Out", "Amount(CNY)", "Payment Method", "Current Status", "Order Number", "Merchant Number", "Remarks"};
        // Chinese version for reference:
        // String[] headers = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"};
        try (BufferedWriter writer = Files.newBufferedWriter(path, StandardCharsets.UTF_8); // Use UTF-8 for potential Chinese characters in data
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(headers).withTrim())) {

            for (Transaction t : transactions) {
                csvPrinter.printRecord(
                        t.getTransactionTime(),
                        t.getTransactionType(),
                        t.getCounterparty(),
                        t.getCommodity(),
                        t.getInOut(), // Expecting English like "Income", "Expense"
                        String.format("¥%.2f", t.getPaymentAmount()), // Or your DAO might handle currency symbol differently
                        t.getPaymentMethod(),
                        t.getCurrentStatus(),
                        t.getOrderNumber(),
                        t.getMerchantNumber(),
                        t.getRemarks()
                );
            }
        }
    }

    @Test
    void testAddTransactionToFile() throws IOException {
        // Create a temporary test file path or use a dedicated test file name
        String tempFilePath = "Ai Bill Application/src/main/resources/CSVForm/transactions/test_add.csv"; // Path might need adjustment for test resources
        // Create an empty or initial test file
        createTestCsvFile(tempFilePath, new ArrayList<>()); // Start with an empty file

        CsvTransactionDao testDao = new CsvTransactionDao(); // Or reuse the instance from BeforeEach if path is managed

        Transaction newTx = new Transaction(
                "2025/04/11 08:00:00",
                "TestType",        // "Test Type"
                "TestCounterparty",// "Test Counterparty"
                "TestCommodity",   // "Test Commodity"
                "Income",          // "Income"
                123.45,
                "TestMethod",      // "Test Method"
                "TestStatus",      // "Test Status"
                "TEST001",
                "MERCHANT001",
                "TestRemark"       // "Test Remark"
        );

        // Add the transaction
        testDao.addTransaction(tempFilePath, newTx);

        // Load the file back and verify
        List<Transaction> transactions = testDao.loadFromCSV(tempFilePath);

        assertNotNull(transactions);
        assertEquals(1, transactions.size());
        Transaction addedTx = transactions.get(0);
        assertEquals("TEST001", addedTx.getOrderNumber());
        assertEquals(123.45, addedTx.getPaymentAmount(), 0.01);

        // Clean up the test file (optional but good practice)
        Files.deleteIfExists(Paths.get(tempFilePath));
    }

    @Test
    void testDeleteTransaction() throws IOException {
        dao = new CsvTransactionDao(); // Assuming dao is class member initialized in @BeforeEach

        // Path "CSV_RELATIVE_PATH" is a placeholder. For a real test, set up a file.
        // Using the temp file from setUp as an example, assuming it was copied from admin_transactions.csv
        // String testFileForDelete = testCsvPathForWrites.toString(); // If using @TempDir or similar setup

        // For this example, let's assume TEST_CSV_PATH is a valid, modifiable test file.
        // To make this test robust, you'd first ensure the transaction to delete exists.
        // For now, this is just a call demonstration.
        String orderToDelete = "4200057899202502250932735481"; // An example order number
        // dao.deleteTransaction(testFileForDelete, orderToDelete);
        // List<Transaction> transactions = dao.loadFromCSV(testFileForDelete);
        // Then assert that the transaction is no longer in the list.

        // The original lines:
        dao.deleteTransaction("CSV_RELATIVE_PATH", orderToDelete); // This path needs to be valid.
        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH); // This path also needs to be valid and reflect the deletion.
        // Add assertions here.
    }

//    @Test
//    void testChangeInfo() throws IOException{
//        dao=new CsvTransactionDao();
//        // dao.changeInformation("TX123456","remarks","Test modify information",TEST_CSV_PATH); // "Test modify information"
//        // dao.changeInformation("TX123456","paymentAmount","116156",TEST_CSV_PATH);
//        // The changeInformation method is not standard in TransactionDao interface. Prefer using updateTransaction.
//        // If testing updateTransaction, it would look like:
//        // dao.updateTransaction(TEST_CSV_PATH, "TX123456", "remarks", "Test modify information");
//        // dao.updateTransaction(TEST_CSV_PATH, "TX123456", "paymentAmount", "116156.00"); // Ensure amount is a valid double string
//    }

}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\DAO\Impl\CsvSummaryStatisticDaoTest.java`:

```java
package DAO.Impl;


import DAO.Impl.CsvSummaryStatisticDao;
import DAO.SummaryStatisticDao;
import model.SummaryStatistic;
import Constants.ConfigConstants; // For SUMMARY_CSV_PATH

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.List;

public class CsvSummaryStatisticDaoTest {

    private SummaryStatisticDao summaryDao;
    private final String sampleSummaryFilePath = ConfigConstants.SUMMARY_CSV_PATH;
    private Path tempSummaryFilePath;

    @BeforeEach
    void setUp() throws IOException {
        summaryDao = new CsvSummaryStatisticDao();
        Path originalPath = Paths.get(sampleSummaryFilePath);
        if (!Files.exists(originalPath)) {
            // Create a dummy original file if it doesn't exist, so copy works
            Files.createFile(originalPath);
            // Optionally write a header or a dummy record
            Files.writeString(originalPath, "week_identifier,total_income_all_users,total_expense_all_users,top_expense_category,top_expense_category_amount,number_of_users_with_transactions,timestamp_generated\n");
            System.out.println("CsvSummaryStatisticDaoTest: Created dummy summary file at " + sampleSummaryFilePath + " because it was missing.");
        }
        tempSummaryFilePath = Files.createTempFile("test_summary_stats_", ".csv");
        Files.copy(originalPath, tempSummaryFilePath, StandardCopyOption.REPLACE_EXISTING);
        System.out.println("CsvSummaryStatisticDaoTest: Copied " + sampleSummaryFilePath + " to temporary file " + tempSummaryFilePath.toString() + " for testing.");
    }

    @AfterEach
    void tearDown() throws IOException {
        if (tempSummaryFilePath != null && Files.exists(tempSummaryFilePath)) {
            Files.delete(tempSummaryFilePath);
            System.out.println("CsvSummaryStatisticDaoTest: Deleted temporary summary file " + tempSummaryFilePath.toString());
        }
    }

    @Test
    void testLoadAllStatistics() {
        try {
            // Test loading from the original sample file
            List<SummaryStatistic> stats = summaryDao.loadAllStatistics(sampleSummaryFilePath);
            System.out.println("CsvSummaryStatisticDaoTest (loadAll): Loaded " + stats.size() + " summary statistics from " + sampleSummaryFilePath);
            if (!stats.isEmpty()) {
                System.out.println("CsvSummaryStatisticDaoTest (loadAll): First statistic: " + stats.get(0).getWeekIdentifier());
            }
        } catch (Exception e) {
            System.err.println("CsvSummaryStatisticDaoTest (loadAll): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("CsvSummaryStatisticDaoTest (loadAll): testLoadAllStatistics finished.");
    }

    @Test
    void testWriteAllStatistics() {
        try {
            List<SummaryStatistic> newStats = new ArrayList<>();
            newStats.add(new SummaryStatistic("2024-W01", 1000, 500, "Food", 200, 10, "2024-01-08 10:00:00"));
            newStats.add(new SummaryStatistic("2024-W02", 1200, 600, "Transport", 150, 12, "2024-01-15 10:00:00"));

            System.out.println("CsvSummaryStatisticDaoTest (writeAll): Attempting to write " + newStats.size() + " new statistics to " + tempSummaryFilePath.toString());
            summaryDao.writeAllStatistics(tempSummaryFilePath.toString(), newStats);
            System.out.println("CsvSummaryStatisticDaoTest (writeAll): Statistics written.");

            List<SummaryStatistic> reReadStats = summaryDao.loadAllStatistics(tempSummaryFilePath.toString());
            System.out.println("CsvSummaryStatisticDaoTest (writeAll): Re-read " + reReadStats.size() + " statistics.");
            if (reReadStats.size() == newStats.size()) {
                System.out.println("CsvSummaryStatisticDaoTest (writeAll): Count matches.");
                if(!reReadStats.isEmpty()){
                    System.out.println("CsvSummaryStatisticDaoTest (writeAll): First re-read stat week: " + reReadStats.get(0).getWeekIdentifier());
                }
            } else {
                System.err.println("CsvSummaryStatisticDaoTest (writeAll): Count MISMATCH after write/read.");
            }

        } catch (Exception e) {
            System.err.println("CsvSummaryStatisticDaoTest (writeAll): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("CsvSummaryStatisticDaoTest (writeAll): testWriteAllStatistics finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\DAO\Impl\CsvTransactionDaoTest.java`:

```java
package DAO.Impl;

// No specific imports needed for TransactionDao interface itself in JUnit test usually
// import DAO.TransactionDao;
import model.Transaction;
// import Constants.ConfigConstants; // Not directly used in this test logic

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
// It's good practice to import static assertions if used, e.g., import static org.junit.jupiter.api.Assertions.*;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

// Test class for CsvTransactionDao
public class CsvTransactionDaoTest {

    private CsvTransactionDao transactionDao; // Use concrete class for testing its specific implementation
    // Path to a sample CSV file used for read tests and as a base for write tests.
    // Ensure this file exists in the specified location relative to the project root.
    private final String sampleTransactionFilePath = "src/test/resources/CSVForm/transactions/admin_transactions.csv";
    private Path tempTransactionFilePath; // Temporary file path for tests that modify data.

    @BeforeEach
    void setUp() throws IOException {
        transactionDao = new CsvTransactionDao();
        // Create a temporary copy of the sample file before each test that might modify data.
        // This ensures test isolation.
        Path originalPath = Paths.get(sampleTransactionFilePath);
        if (!Files.exists(originalPath)) {
            throw new IOException("Sample transaction file not found at: " + sampleTransactionFilePath);
        }
        tempTransactionFilePath = Files.createTempFile("test_transactions_", ".csv");
        Files.copy(originalPath, tempTransactionFilePath, StandardCopyOption.REPLACE_EXISTING);
        System.out.println("CsvTransactionDaoTest: Copied " + sampleTransactionFilePath + " to temporary file " + tempTransactionFilePath.toString() + " for testing.");
    }

    @AfterEach
    void tearDown() throws IOException {
        // Delete the temporary file after each test to clean up.
        if (tempTransactionFilePath != null && Files.exists(tempTransactionFilePath)) {
            Files.delete(tempTransactionFilePath);
            System.out.println("CsvTransactionDaoTest: Deleted temporary file " + tempTransactionFilePath.toString());
        }
    }

    @Test
    void testLoadFromCSV() {
        // Test loading transactions from a CSV file.
        try {
            List<Transaction> transactions = transactionDao.loadFromCSV(sampleTransactionFilePath);
            System.out.println("CsvTransactionDaoTest (loadFromCSV): Loaded " + transactions.size() + " transactions from " + sampleTransactionFilePath);
            // Basic check: if transactions were loaded, print info about the first one.
            if (!transactions.isEmpty()) {
                System.out.println("CsvTransactionDaoTest (loadFromCSV): First transaction order number: " + transactions.get(0).getOrderNumber());
            }
            // Add assertions here, e.g., assertTrue(!transactions.isEmpty()); assertEquals(expectedSize, transactions.size());
        } catch (Exception e) {
            System.err.println("CsvTransactionDaoTest (loadFromCSV): Error during test.");
            e.printStackTrace();
            // Fail the test if an exception occurs.
            throw new RuntimeException("testLoadFromCSV failed", e);
        }
        System.out.println("CsvTransactionDaoTest (loadFromCSV): testLoadFromCSV finished.");
    }

    @Test
    void testGetAllTransactions() {
        // Test the getAllTransactions method (which typically calls loadFromCSV).
        try {
            List<Transaction> transactions = transactionDao.getAllTransactions(sampleTransactionFilePath);
            System.out.println("CsvTransactionDaoTest (getAllTransactions): Loaded " + transactions.size() + " transactions from " + sampleTransactionFilePath);
            if (!transactions.isEmpty()) {
                System.out.println("CsvTransactionDaoTest (getAllTransactions): First transaction order number: " + transactions.get(0).getOrderNumber());
            }
            // Add assertions.
        } catch (Exception e) {
            System.err.println("CsvTransactionDaoTest (getAllTransactions): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testGetAllTransactions failed", e);
        }
        System.out.println("CsvTransactionDaoTest (getAllTransactions): testGetAllTransactions finished.");
    }

    @Test
    void testAddTransaction() {
        // Test adding a new transaction to the CSV file.
        try {
            String uniqueOrderNumber = "TEST_ADD_" + UUID.randomUUID().toString();
            Transaction newTx = new Transaction("2024/01/01 10:00", "TestType", "TestCounterparty", "TestCommodity", "Expense", 10.0, "TestPay", "Completed", uniqueOrderNumber, "M001", "Add test");

            System.out.println("CsvTransactionDaoTest (addTransaction): Attempting to add transaction with ON: " + uniqueOrderNumber + " to " + tempTransactionFilePath.toString());
            transactionDao.addTransaction(tempTransactionFilePath.toString(), newTx);
            System.out.println("CsvTransactionDaoTest (addTransaction): Transaction added.");

            // Verify by reloading and checking.
            List<Transaction> transactions = transactionDao.loadFromCSV(tempTransactionFilePath.toString());
            boolean found = transactions.stream().anyMatch(t -> t.getOrderNumber().equals(uniqueOrderNumber));
            System.out.println("CsvTransactionDaoTest (addTransaction): Transaction found after add: " + found);
            if (!found) {
                System.err.println("CsvTransactionDaoTest (addTransaction): Added transaction NOT FOUND in file.");
                // Assert.fail("Added transaction was not found after reload.");
            }
            // Assert.assertTrue(found, "Transaction should be found after adding.");
        } catch (Exception e) {
            System.err.println("CsvTransactionDaoTest (addTransaction): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testAddTransaction failed", e);
        }
        System.out.println("CsvTransactionDaoTest (addTransaction): testAddTransaction finished.");
    }

    @Test
    void testDeleteTransaction() {
        // Test deleting an existing transaction.
        try {
            // First, add a transaction to ensure it exists, then delete it.
            String uniqueOrderNumber = "TEST_DELETE_" + UUID.randomUUID().toString();
            Transaction txToDelete = new Transaction("2024/01/02 11:00", "ToDelete", "DelCounter", "DelItem", "Expense", 20.0, "DelPay", "Done", uniqueOrderNumber, "M002", "Delete test");
            transactionDao.addTransaction(tempTransactionFilePath.toString(), txToDelete);
            System.out.println("CsvTransactionDaoTest (deleteTransaction): Added transaction for deletion: " + uniqueOrderNumber);

            boolean deleted = transactionDao.deleteTransaction(tempTransactionFilePath.toString(), uniqueOrderNumber);
            System.out.println("CsvTransactionDaoTest (deleteTransaction): Deletion result for ON " + uniqueOrderNumber + ": " + deleted);
            // Assert.assertTrue(deleted, "Deletion should return true for an existing transaction.");

            // Verify by reloading.
            List<Transaction> transactions = transactionDao.loadFromCSV(tempTransactionFilePath.toString());
            boolean stillExists = transactions.stream().anyMatch(t -> t.getOrderNumber().equals(uniqueOrderNumber));
            System.out.println("CsvTransactionDaoTest (deleteTransaction): Transaction still exists after delete: " + stillExists);
            if (stillExists) {
                System.err.println("CsvTransactionDaoTest (deleteTransaction): Deleted transaction STILL FOUND in file.");
                // Assert.fail("Transaction was found after it should have been deleted.");
            }
            // Assert.assertFalse(stillExists, "Transaction should not exist after deletion.");
        } catch (Exception e) {
            System.err.println("CsvTransactionDaoTest (deleteTransaction): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testDeleteTransaction failed", e);
        }
        System.out.println("CsvTransactionDaoTest (deleteTransaction): testDeleteTransaction finished.");
    }

    @Test
    void testUpdateTransaction() {
        // Test updating a field of an existing transaction.
        try {
            String uniqueOrderNumber = "TEST_UPDATE_" + UUID.randomUUID().toString();
            Transaction txToUpdate = new Transaction("2024/01/03 12:00", "ToUpdate", "UpdCounter", "UpdItem", "Income", 30.0, "UpdPay", "Pending", uniqueOrderNumber, "M003", "Update test original");
            transactionDao.addTransaction(tempTransactionFilePath.toString(), txToUpdate);
            System.out.println("CsvTransactionDaoTest (updateTransaction): Added transaction for update: " + uniqueOrderNumber);

            String newRemark = "Remark updated successfully!";
            boolean updated = transactionDao.updateTransaction(tempTransactionFilePath.toString(), uniqueOrderNumber, "remarks", newRemark);
            System.out.println("CsvTransactionDaoTest (updateTransaction): Update result for ON " + uniqueOrderNumber + ": " + updated);
            // Assert.assertTrue(updated, "Update should return true for an existing transaction and valid field.");

            // Verify by fetching the transaction.
            Transaction fetched = transactionDao.getTransactionByOrderNumber(tempTransactionFilePath.toString(), uniqueOrderNumber);
            if (fetched != null) {
                System.out.println("CsvTransactionDaoTest (updateTransaction): Fetched remark: " + fetched.getRemarks() + ". Expected: " + newRemark);
                if (!newRemark.equals(fetched.getRemarks())) {
                    System.err.println("CsvTransactionDaoTest (updateTransaction): Remark NOT updated correctly.");
                    // Assert.fail("Remark was not updated as expected.");
                }
                // Assert.assertEquals(newRemark, fetched.getRemarks(), "Remark should be updated.");
            } else {
                System.err.println("CsvTransactionDaoTest (updateTransaction): Transaction NOT FOUND after update attempt.");
                // Assert.fail("Transaction not found after update attempt.");
            }
        } catch (Exception e) {
            System.err.println("CsvTransactionDaoTest (updateTransaction): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testUpdateTransaction failed", e);
        }
        System.out.println("CsvTransactionDaoTest (updateTransaction): testUpdateTransaction finished.");
    }

    @Test
    void testGetTransactionByOrderNumber() {
        // Test fetching a specific transaction by its order number.
        try {
            // Assuming 'SALARY_MAR_A' exists in the sample admin_transactions.csv.
            // This order number should be present in the temp file after copy.
            String existingOrderNumber = "SALARY_MAR_A"; // Make sure this ON exists in your sample CSV.
            Transaction transaction = transactionDao.getTransactionByOrderNumber(tempTransactionFilePath.toString(), existingOrderNumber);
            if (transaction != null) {
                System.out.println("CsvTransactionDaoTest (getByON): Found transaction commodity: " + transaction.getCommodity() + " for ON " + existingOrderNumber);
                // Assert.assertEquals(existingOrderNumber, transaction.getOrderNumber());
            } else {
                System.err.println("CsvTransactionDaoTest (getByON): Transaction with ON " + existingOrderNumber + " NOT FOUND in " + tempTransactionFilePath.toString());
                // Assert.fail("Expected transaction not found: " + existingOrderNumber);
            }

            // Test with a non-existing order number.
            String nonExistingOrderNumber = "NON_EXISTENT_ON_123";
            Transaction nonExistingTx = transactionDao.getTransactionByOrderNumber(tempTransactionFilePath.toString(), nonExistingOrderNumber);
            System.out.println("CsvTransactionDaoTest (getByON): Result for non-existing ON " + nonExistingOrderNumber + ": " + (nonExistingTx == null ? "null (Correct)" : "Found (Incorrect)"));
            // Assert.assertNull(nonExistingTx, "Should return null for a non-existing order number.");
        } catch (Exception e) {
            System.err.println("CsvTransactionDaoTest (getByON): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testGetTransactionByOrderNumber failed", e);
        }
        System.out.println("CsvTransactionDaoTest (getByON): testGetTransactionByOrderNumber finished.");
    }

    @Test
    void testWriteTransactionsToCSV() {
        // Test writing a list of transactions to a new CSV file (overwrite).
        Path newTempFile = null;
        try {
            newTempFile = Files.createTempFile("test_write_all_", ".csv");
            List<Transaction> transactionsToWrite = new ArrayList<>();
            transactionsToWrite.add(new Transaction("2024/02/01", "Write1", "W_Counter1", "W_Item1", "Expense", 1.0, "Cash", "OK", "W_ON001", "WM001", "Note1"));
            transactionsToWrite.add(new Transaction("2024/02/02", "Write2", "W_Counter2", "W_Item2", "Income", 2.0, "Card", "OK", "W_ON002", "WM002", "Note2"));

            System.out.println("CsvTransactionDaoTest (writeAll): Attempting to write " + transactionsToWrite.size() + " transactions to " + newTempFile.toString());
            transactionDao.writeTransactionsToCSV(newTempFile.toString(), transactionsToWrite);
            System.out.println("CsvTransactionDaoTest (writeAll): Wrote transactions.");

            // Verify by reloading from the new file.
            List<Transaction> reReadTransactions = transactionDao.loadFromCSV(newTempFile.toString());
            System.out.println("CsvTransactionDaoTest (writeAll): Re-read " + reReadTransactions.size() + " transactions.");
            if (reReadTransactions.size() == transactionsToWrite.size()) {
                System.out.println("CsvTransactionDaoTest (writeAll): Count matches.");
                // Assert.assertEquals(transactionsToWrite.size(), reReadTransactions.size(), "Number of transactions should match after writing and rereading.");
            } else {
                System.err.println("CsvTransactionDaoTest (writeAll): Count MISMATCH after write/read.");
                // Assert.fail("Transaction count mismatch after write and read.");
            }
        } catch (Exception e) {
            System.err.println("CsvTransactionDaoTest (writeAll): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testWriteTransactionsToCSV failed", e);
        } finally {
            // Clean up the newly created temporary file for this test.
            if (newTempFile != null) {
                try {
                    Files.deleteIfExists(newTempFile);
                    System.out.println("CsvTransactionDaoTest (writeAll): Deleted temp write file " + newTempFile.toString());
                } catch (IOException e) {
                    System.err.println("CsvTransactionDaoTest (writeAll): Error deleting temp file " + newTempFile.toString());
                    e.printStackTrace();
                }
            }
        }
        System.out.println("CsvTransactionDaoTest (writeAll): testWriteTransactionsToCSV finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\DAO\Impl\CsvUserDaoTest.java`:

```java
package DAO.Impl;

import DAO.Impl.CsvUserDao;
import DAO.UserDao;
import model.User;
import Constants.ConfigConstants; // For USERS_CSV_PATH

import org.junit.jupiter.api.Test;
import java.util.List;

public class CsvUserDaoTest {

    @Test
    void testGetAllUsers() {
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        try {
            List<User> users = userDao.getAllUsers();
            System.out.println("CsvUserDaoTest: Loaded " + users.size() + " users.");
            if (!users.isEmpty()) {
                System.out.println("CsvUserDaoTest: First user: " + users.get(0));
            }
            // No assertions, just checking if it runs
        } catch (Exception e) {
            System.err.println("CsvUserDaoTest: Error in testGetAllUsers.");
            e.printStackTrace();
            // To make JUnit fail the test if an exception occurs
            throw new RuntimeException("Test failed due to exception in getAllUsers", e);
        }
        System.out.println("CsvUserDaoTest: testGetAllUsers finished successfully.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Service\AIAnalyzerThreadTest.java`:

```java
package Service;



import Service.AIservice.AIAnalyzerThread;
import org.junit.jupiter.api.Test;

public class AIAnalyzerThreadTest {

//    @Test
//    public void testRunAIAnalyzerThread() throws InterruptedException {
//        String userRequest = "Please help me analyze the recent transaction income and expenditure";
//        String filePath = "src/test/resources/sample_transactions.csv";
//        String startTimeStr = "2025/03/20";
//        String endTimeStr = "";
//
//        // Starting a Thread
//        Thread thread = new Thread(new AIAnalyzerThread(userRequest, filePath, startTimeStr, endTimeStr));
//        thread.start();
//
//        // Waiting for thread execution to complete
//        thread.join();
//    }
}

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Service\AIserviceTest.java`:

```java
package Service;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

public class AIserviceTest {

    @Test
    public void testAnalyzeTransactions() {
//        AITransactionService service = new AITransactionService();
//
//        String userRequest = "Please help me analyze this month's income and expenditure";
//        String filePath = "src/test/resources/sample_transactions.csv";
//
//        String result = service.analyzeTransactions(userRequest, filePath,"2025/03/20","");
//
//        assertNotNull(result, "AI analysis results cannot be empty");
//        System.out.println("AI analysis results: " + result);
    }


}

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Service\AIservice\AIAnalyzerThreadTest.java`:

```java
package Service.AIservice;

import DAO.Impl.CsvUserDao;
import DAO.UserDao;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Service.User.UserService;
import model.User;
import Constants.ConfigConstants;

import org.junit.jupiter.api.Test;

public class AIAnalyzerThreadTest {

    @Test
    void testRunAIAnalyzerThread() {
        System.out.println("AIAnalyzerThreadTest: Running testRunAIAnalyzerThread...");
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        UserService userService = new UserService(userDao);
        User testUser = userService.authenticate("admin", "admin123");

        if (testUser == null) {
            System.err.println("AIAnalyzerThreadTest: Failed to authenticate test user 'admin'. Test cannot proceed.");
            return;
        }

        TransactionService transactionService = new TransactionServiceImpl(testUser.getTransactionFilePath());
        AITransactionService aiService = new AITransactionService(transactionService);

        AIAnalyzerThread analyzerThread = new AIAnalyzerThread(
                aiService,
                "Analyze my spending",
                testUser.getTransactionFilePath(),
                "2025/03/01",
                ""
        );
        Thread thread = new Thread(analyzerThread);
        thread.start();
        try {
            thread.join(10000); // Wait for up to 10 seconds
            System.out.println("AIAnalyzerThreadTest: Thread finished or timed out.");
        } catch (InterruptedException e) {
            System.err.println("AIAnalyzerThreadTest: Thread interrupted.");
            e.printStackTrace();
            Thread.currentThread().interrupt();
        }
        System.out.println("AIAnalyzerThreadTest: testRunAIAnalyzerThread finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Service\AIservice\AITransactionServiceTest.java`:

```java
package Service.AIservice;


import DAO.Impl.CsvUserDao;
import DAO.UserDao;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Service.User.UserService;
import model.User;
import Constants.ConfigConstants;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

public class AITransactionServiceTest {

    private AITransactionService aiTransactionService;
    private TransactionService transactionService; // For AITransactionService dependency
    private User testUser;

    @BeforeEach
    void setUp() {
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        UserService userService = new UserService(userDao);
        testUser = userService.authenticate("user1", "pass123"); // Use a common test user

        if (testUser == null) {
            System.err.println("AITransactionServiceTest: Failed to authenticate test user 'user1'. Using admin.");
            testUser = userService.authenticate("admin", "admin123");
        }
        if (testUser == null) {
            throw new IllegalStateException("AITransactionServiceTest: Cannot authenticate any test user. Aborting setup.");
        }

        transactionService = new TransactionServiceImpl(testUser.getTransactionFilePath());
        aiTransactionService = new AITransactionService(transactionService); // Inject dependency
    }

    @Test
    void testAnalyzeTransactions() {
        System.out.println("AITransactionServiceTest: Running testAnalyzeTransactions...");
        try {
            String result = aiTransactionService.analyzeTransactions(
                    "Help me analyze my recent spending",
                    testUser.getTransactionFilePath(),
                    "2025/03/01",
                    "2025/03/31"
            );
            System.out.println("AITransactionServiceTest (analyzeTransactions) Result: " + result);
        } catch (Exception e) {
            System.err.println("AITransactionServiceTest (analyzeTransactions): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("AITransactionServiceTest: testAnalyzeTransactions finished.");
    }

    @Test
    void testGeneratePersonalSummary() {
        System.out.println("AITransactionServiceTest: Running testGeneratePersonalSummary...");
        try {
            String result = aiTransactionService.generatePersonalSummary(testUser.getTransactionFilePath());
            System.out.println("AITransactionServiceTest (generatePersonalSummary) Result: " + result);
        } catch (Exception e) {
            System.err.println("AITransactionServiceTest (generatePersonalSummary): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("AITransactionServiceTest: testGeneratePersonalSummary finished.");
    }

    @Test
    void testSuggestSavingsGoals() {
        System.out.println("AITransactionServiceTest: Running testSuggestSavingsGoals...");
        try {
            String result = aiTransactionService.suggestSavingsGoals(testUser.getTransactionFilePath());
            System.out.println("AITransactionServiceTest (suggestSavingsGoals) Result: " + result);
        } catch (Exception e) {
            System.err.println("AITransactionServiceTest (suggestSavingsGoals): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("AITransactionServiceTest: testSuggestSavingsGoals finished.");
    }

    @Test
    void testGivePersonalSavingTips() {
        System.out.println("AITransactionServiceTest: Running testGivePersonalSavingTips...");
        try {
            String result = aiTransactionService.givePersonalSavingTips(testUser.getTransactionFilePath());
            System.out.println("AITransactionServiceTest (givePersonalSavingTips) Result: " + result);
        } catch (Exception e) {
            System.err.println("AITransactionServiceTest (givePersonalSavingTips): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("AITransactionServiceTest: testGivePersonalSavingTips finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Service\AIservice\ColledgeStudentThreadTest.java`:

```java
package Service.AIservice;

import DAO.Impl.CsvUserDao;
import DAO.UserDao;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Service.User.UserService;
import model.User;
import Constants.ConfigConstants;

import org.junit.jupiter.api.Test;

public class ColledgeStudentThreadTest { // Corrected class name

    @Test
    void testRunCollegeStudentThread() {
        System.out.println("CollegeStudentThreadTest: Running testRunCollegeStudentThread...");
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        UserService userService = new UserService(userDao);
        User testUser = userService.authenticate("user1", "pass123"); // Student user

        if (testUser == null) {
            System.err.println("CollegeStudentThreadTest: Failed to authenticate test user 'user1'. Test cannot proceed.");
            return;
        }

        TransactionService transactionService = new TransactionServiceImpl(testUser.getTransactionFilePath());
        CollegeStudentNeeds collegeStudentNeeds = new CollegeStudentNeeds(transactionService);

        // Corrected instantiation of ColledgeStudentThread (as per original file name)
        // If the class name was intended to be CollegeStudentThread, adjust accordingly.
        ColledgeStudentThread studentThread = new ColledgeStudentThread(
                collegeStudentNeeds,
                testUser.getTransactionFilePath()
        );
        Thread thread = new Thread(studentThread);
        thread.start();
        try {
            thread.join(10000); // Wait for up to 10 seconds
            System.out.println("CollegeStudentThreadTest: Thread finished or timed out.");
        } catch (InterruptedException e) {
            System.err.println("CollegeStudentThreadTest: Thread interrupted.");
            e.printStackTrace();
            Thread.currentThread().interrupt();
        }
        System.out.println("CollegeStudentThreadTest: testRunCollegeStudentThread finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Service\AIservice\CollegeStudentNeedsTest.java`:

```java
package Service.AIservice;

import DAO.Impl.CsvUserDao;
import DAO.UserDao;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Service.User.UserService;
import model.Transaction;
import model.User;
import Constants.ConfigConstants;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

public class CollegeStudentNeedsTest {

    private CollegeStudentNeeds collegeStudentNeeds;
    private User testUser;
    private TransactionService transactionService; // For CollegeStudentNeeds dependency

    @BeforeEach
    void setUp() {
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        UserService userService = new UserService(userDao);
        testUser = userService.authenticate("user1", "pass123"); // Assuming user1 might be a student

        if (testUser == null) {
            System.err.println("CollegeStudentNeedsTest: Failed to authenticate test user 'user1'. Using admin.");
            testUser = userService.authenticate("admin", "admin123");
        }
        if (testUser == null) {
            throw new IllegalStateException("CollegeStudentNeedsTest: Cannot authenticate any test user. Aborting setup.");
        }

        transactionService = new TransactionServiceImpl(testUser.getTransactionFilePath());
        collegeStudentNeeds = new CollegeStudentNeeds(transactionService); // Inject dependency
    }

    @Test
    void testRecognizeTransaction() {
        System.out.println("CollegeStudentNeedsTest: Running testRecognizeTransaction...");
        try {
            Transaction sampleTransaction = new Transaction(
                    "2025/03/15 12:00", "lunch", "school cafeteria", "braised pork set meal", "expenditure",
                    15.0, "Campus Card", "Completed", "STU001", "SCH001", "Regular Lunch"
            );
            String category = collegeStudentNeeds.RecognizeTransaction(sampleTransaction);
            System.out.println("CollegeStudentNeedsTest (RecognizeTransaction) Suggested Category: " + category);
        } catch (Exception e) {
            System.err.println("CollegeStudentNeedsTest (RecognizeTransaction): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("CollegeStudentNeedsTest: testRecognizeTransaction finished.");
    }

    @Test
    void testGenerateTipsForSaving() {
        System.out.println("CollegeStudentNeedsTest: Running testGenerateTipsForSaving...");
        try {
            String tips = collegeStudentNeeds.generateTipsForSaving(testUser.getTransactionFilePath());
            System.out.println("CollegeStudentNeedsTest (generateTipsForSaving) Tips: " + tips);
        } catch (Exception e) {
            System.err.println("CollegeStudentNeedsTest (generateTipsForSaving): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("CollegeStudentNeedsTest: testGenerateTipsForSaving finished.");
    }

    @Test
    void testGenerateBudget() {
        System.out.println("CollegeStudentNeedsTest: Running testGenerateBudget...");
        try {
            double[] budget = collegeStudentNeeds.generateBudget(testUser.getTransactionFilePath());
            if (budget != null && budget.length == 2) {
                System.out.println("CollegeStudentNeedsTest (generateBudget) Budget: [" + budget[0] + ", " + budget[1] + "]");
            } else {
                System.out.println("CollegeStudentNeedsTest (generateBudget) Budget: Could not be generated or invalid format.");
            }
        } catch (Exception e) {
            System.err.println("CollegeStudentNeedsTest (generateBudget): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("CollegeStudentNeedsTest: testGenerateBudget finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Service\AiFunctionTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.Test;
import Service.AIservice.AITransactionService;

import java.io.IOException;
import java.util.List;

public class AiFunctionTest {

    @Test
    public void testAnalyzeTransactions() throws IOException {

//        String filePath = "src/test/resources/sample_transactions.csv";
//        CsvTransactionDao transactionDao = new CsvTransactionDao();
//
//        List<Transaction> transactions = transactionDao.loadFromCSV(filePath);
//
//        // Instantiate the service class
//        AITransactionService service = new AITransactionService();
//
//        // Call the merge formatting function
//        List<String> result = service.formatTransactions(transactions,"2025/03/29","2025/04/10");
//
//        // Output
//        result.forEach(System.out::println);
    }




}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Service\CacheTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import model.Transaction;
import org.junit.jupiter.api.Test;

import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;

public class CacheTest {

//    TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());
//
//    @Test
//    void DeleteCache(){
//        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;
//        cache.invalidate(TRANSACTION_CAFFEINE_KEY);
//    }

}

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Service\CollegeStudentNeedsTest.java`:

```java
//package Service;
//
//import Service.AIservice.ColledgeStudentThread;
//import Service.AIservice.CollegeStudentNeeds;
//import org.junit.jupiter.api.*;
//
//import java.io.IOException;
//import java.net.URISyntaxException;
//import java.net.URL;
//import java.nio.file.Files;
//import java.nio.file.Path;
//import java.nio.file.Paths;
//import java.util.Arrays;
//
//import static org.junit.jupiter.api.Assertions.*;
//
//// No @ExtendWith needed as we are not using Mockito extensions
//class CollegeStudentNeedsTest {
//
//
//
//    private CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
//    private static final String TEST_CSV_FILENAME = "src/test/resources/001.csv";
//    @Test
//    public void testGenerateBudget() throws IOException, InterruptedException {
//        Thread t=new Thread( new ColledgeStudentThread(TEST_CSV_FILENAME));
//        t.start();
//        t.join();
////        collegeStudentNeeds.generateBudget(TEST_CSV_FILENAME);
//    }
//    @Test
//    public void testParseStringToDouble(){
//        String s="asdas[369.39,1090.1]das";
//        double[] arr=collegeStudentNeeds.parseDoubleArrayFromString(s);
//        System.out.println(arr[0]+" "+arr[1]);
//    }
//
//
//}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Service\Impl\SummaryStatisticServiceTest.java`:

```java
package Service.Impl;

import DAO.Impl.CsvSummaryStatisticDao;
import DAO.Impl.CsvTransactionDao;
import DAO.Impl.CsvUserDao;
import DAO.SummaryStatisticDao;
import DAO.TransactionDao;
import DAO.UserDao;
import model.SummaryStatistic;
import Constants.ConfigConstants;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.List;

public class SummaryStatisticServiceTest {

    private SummaryStatisticService summaryStatisticService;
    private Path tempSummaryFilePath;
    private final String originalSummaryPath = ConfigConstants.SUMMARY_CSV_PATH;

    // For generateAndSaveWeeklyStatistics, we also need user and transaction DAOs and their data
    private UserDao userDao;
    private TransactionDao transactionDao; // This DAO is used by CacheManager within SummaryStatisticService

    @BeforeEach
    void setUp() throws IOException {
        userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        transactionDao = new CsvTransactionDao(); // For CacheManager
        SummaryStatisticDao summaryDao = new CsvSummaryStatisticDao();

        summaryStatisticService = new SummaryStatisticService(userDao, transactionDao, summaryDao);

        // Create a temporary copy of the summary statistics file
        Path originalPathFile = Paths.get(originalSummaryPath);
        if (!Files.exists(originalPathFile)) {
            Files.createDirectories(originalPathFile.getParent());
            Files.createFile(originalPathFile);
            Files.writeString(originalPathFile, "week_identifier,total_income_all_users,total_expense_all_users,top_expense_category,top_expense_category_amount,number_of_users_with_transactions,timestamp_generated\n");
            System.out.println("SummaryStatisticServiceTest: Created dummy original summary file as it was missing: " + originalSummaryPath);
        }
        tempSummaryFilePath = Files.createTempFile("test_summary_service_", ".csv");
        Files.copy(originalPathFile, tempSummaryFilePath, StandardCopyOption.REPLACE_EXISTING);

        // Override the summaryFilePath in the service to use the temp file for write operations
        // This requires SummaryStatisticService to allow setting the path, or we test against the original.
        // For simplicity, generateAndSaveWeeklyStatistics will write to the original path configured in ConfigConstants.
        // So, for that test, we'll back up the original, run the test, then restore.
        // For getAllSummaryStatistics, we can read from the original.
        System.out.println("SummaryStatisticServiceTest: Setup complete. Temp summary file for some tests: " + tempSummaryFilePath);
    }

    @AfterEach
    void tearDown() throws IOException {
        if (tempSummaryFilePath != null && Files.exists(tempSummaryFilePath)) {
            Files.delete(tempSummaryFilePath);
            System.out.println("SummaryStatisticServiceTest: Deleted temp summary file: " + tempSummaryFilePath);
        }
    }

    @Test
    void testGetAllSummaryStatistics() {
        System.out.println("SummaryStatisticServiceTest: Running testGetAllSummaryStatistics...");
        try {
            // This will read from ConfigConstants.SUMMARY_CSV_PATH
            List<SummaryStatistic> stats = summaryStatisticService.getAllSummaryStatistics();
            System.out.println("SummaryStatisticServiceTest (getAll): Loaded " + stats.size() + " summary statistics.");
            if (!stats.isEmpty()) {
                System.out.println("SummaryStatisticServiceTest (getAll): First stat week: " + stats.get(0).getWeekIdentifier());
            }
        } catch (Exception e) {
            System.err.println("SummaryStatisticServiceTest (getAll): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("SummaryStatisticServiceTest: testGetAllSummaryStatistics finished.");
    }

    @Test
    void testGenerateAndSaveWeeklyStatistics() {
        System.out.println("SummaryStatisticServiceTest: Running testGenerateAndSaveWeeklyStatistics...");
        Path backupPath = null;
        Path originalPath = Paths.get(ConfigConstants.SUMMARY_CSV_PATH);
        try {
            // Backup the original summary_statistics.csv
            if (Files.exists(originalPath)) {
                backupPath = Paths.get(originalPath.toString() + ".bak");
                Files.copy(originalPath, backupPath, StandardCopyOption.REPLACE_EXISTING);
                System.out.println("SummaryStatisticServiceTest (generate): Backed up original summary to " + backupPath);
            }

            summaryStatisticService.generateAndSaveWeeklyStatistics();
            System.out.println("SummaryStatisticServiceTest (generate): generateAndSaveWeeklyStatistics completed.");

            // Optionally, load and print some of the generated stats to verify
            List<SummaryStatistic> generatedStats = summaryStatisticService.getAllSummaryStatistics();
            System.out.println("SummaryStatisticServiceTest (generate): Found " + generatedStats.size() + " stats after generation.");
            if(!generatedStats.isEmpty()){
                System.out.println("SummaryStatisticServiceTest (generate): Sample generated stat week: " + generatedStats.get(generatedStats.size()-1).getWeekIdentifier() + " with " + generatedStats.get(generatedStats.size()-1).getNumberOfUsersWithTransactions() + " users.");
            }

        } catch (Exception e) {
            System.err.println("SummaryStatisticServiceTest (generate): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        } finally {
            // Restore the original summary_statistics.csv
            if (backupPath != null && Files.exists(backupPath)) {
                try {
                    Files.move(backupPath, originalPath, StandardCopyOption.REPLACE_EXISTING);
                    System.out.println("SummaryStatisticServiceTest (generate): Restored original summary from " + backupPath);
                } catch (IOException e) {
                    System.err.println("SummaryStatisticServiceTest (generate): Error restoring backup.");
                    e.printStackTrace();
                }
            } else if (backupPath == null && Files.exists(originalPath) && !originalSummaryPath.equals(ConfigConstants.SUMMARY_CSV_PATH)) {
                // If no backup was made (original didn't exist), but test created one, delete it.
                // This case is less likely with current setup.
                try {
                    // Files.delete(originalPath);
                    // System.out.println("SummaryStatisticServiceTest (generate): Deleted summary file created by test.");
                } catch (Exception e) {
                    // ignore
                }
            }
        }
        System.out.println("SummaryStatisticServiceTest: testGenerateAndSaveWeeklyStatistics finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Service\Impl\TransactionServiceImplTest.java`:

```java
package Service.Impl;

import DAO.Impl.CsvTransactionDao; // For direct use in creating temp files if needed
import DAO.Impl.CsvUserDao;
import DAO.UserDao;
import Service.TransactionService;
import Service.User.UserService;
import model.MonthlySummary;
import model.Transaction;
import model.User;
import Constants.ConfigConstants;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
// It's good practice to import static assertions from JUnit 5:
// import static org.junit.jupiter.api.Assertions.*;


import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.Map;
import java.util.UUID;

// Test class for TransactionServiceImpl
public class TransactionServiceImplTest {

    private TransactionService transactionService;
    private User testUser;
    private Path tempUserTransactionFilePath; // Path for the temporary transaction file for the test user
    // Path to an original sample transaction file for user1
    private final String originalUser1CsvPath = "src/test/resources/CSVForm/transactions/user1_transactions.csv";
    // Path to a sample CSV file to be used as a source for import tests
    private final String importTestCsvPath = "src/test/resources/CSVForm/transactions/admin_transactions.csv";

    @BeforeEach
    void setUp() throws IOException {
        // Initialize UserService and authenticate a test user.
        // This setup assumes user authentication and user CSV structure are working.
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH); // Assumes USERS_CSV_PATH is correctly configured.
        UserService userService = new UserService(userDao);
        testUser = userService.authenticate("user1", "pass123"); // Use actual credentials for a test user

        if (testUser == null) {
            throw new IllegalStateException("TransactionServiceImplTest: Cannot authenticate test user 'user1'. Aborting setup.");
        }

        // Create a temporary copy of user1's transaction file to avoid modifying original test data.
        Path originalPath = Paths.get(originalUser1CsvPath);
        if (!Files.exists(originalPath)) {
            throw new IOException("Original user1 transaction file not found: " + originalUser1CsvPath);
        }
        tempUserTransactionFilePath = Files.createTempFile("test_user1_transactions_", ".csv");
        Files.copy(originalPath, tempUserTransactionFilePath, StandardCopyOption.REPLACE_EXISTING);

        // IMPORTANT: Update the testUser's transaction file path to the temporary one for this test run.
        // This ensures the TransactionServiceImpl instance operates on the temporary file.
        testUser.setTransactionFilePath(tempUserTransactionFilePath.toString());

        // Initialize the service to be tested with the path to the temporary transaction file.
        transactionService = new TransactionServiceImpl(testUser.getTransactionFilePath());
        System.out.println("TransactionServiceImplTest: Set up with temp file: " + testUser.getTransactionFilePath());
    }

    @AfterEach
    void tearDown() throws IOException {
        // Delete the temporary transaction file after each test to clean up.
        if (tempUserTransactionFilePath != null && Files.exists(tempUserTransactionFilePath)) {
            Files.delete(tempUserTransactionFilePath);
            System.out.println("TransactionServiceImplTest: Deleted temporary transaction file: " + tempUserTransactionFilePath);
        }
    }

    @Test
    void testGetAllTransactions() {
        System.out.println("TransactionServiceImplTest: Running testGetAllTransactions...");
        try {
            List<Transaction> transactions = transactionService.getAllTransactions();
            System.out.println("TransactionServiceImplTest (getAllTransactions): Loaded " + transactions.size() + " transactions.");
            // Basic check: print info about the first transaction if the list is not empty.
            if (!transactions.isEmpty()) {
                System.out.println("TransactionServiceImplTest (getAllTransactions): First transaction ON: " + transactions.get(0).getOrderNumber());
            }
            // Add assertions here, e.g., assertTrue(!transactions.isEmpty());
        } catch (Exception e) {
            System.err.println("TransactionServiceImplTest (getAllTransactions): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testGetAllTransactions failed", e); // Fail the test
        }
        System.out.println("TransactionServiceImplTest: testGetAllTransactions finished.");
    }

    @Test
    void testAddTransaction() {
        System.out.println("TransactionServiceImplTest: Running testAddTransaction...");
        try {
            String uniqueOrderNumber = "SERVICE_ADD_" + UUID.randomUUID().toString();
            Transaction newTx = new Transaction(
                    "2024/03/01 10:00", "ServiceAdd", "S_Counter", "S_Item", "Expense", // "Expense"
                    55.0, "S_Pay", "Completed", uniqueOrderNumber, "S_M001", "Service add test"
            );
            transactionService.addTransaction(newTx);
            System.out.println("TransactionServiceImplTest (addTransaction): Added transaction with ON: " + uniqueOrderNumber);

            // Verify by fetching all transactions and checking if the new one exists.
            List<Transaction> all = transactionService.getAllTransactions();
            boolean found = all.stream().anyMatch(t -> t.getOrderNumber().equals(uniqueOrderNumber));
            System.out.println("TransactionServiceImplTest (addTransaction): Found after add: " + found);
            if (!found) {
                System.err.println("TransactionServiceImplTest (addTransaction): Added transaction NOT FOUND.");
                // fail("Added transaction was not found.");
            }
            // assertTrue(found, "Transaction should be found after adding.");
        } catch (Exception e) {
            System.err.println("TransactionServiceImplTest (addTransaction): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testAddTransaction failed", e);
        }
        System.out.println("TransactionServiceImplTest: testAddTransaction finished.");
    }

    @Test
    void testChangeTransaction() {
        System.out.println("TransactionServiceImplTest: Running testChangeTransaction...");
        try {
            List<Transaction> initialTransactions = transactionService.getAllTransactions();
            if (initialTransactions.isEmpty()) {
                System.out.println("TransactionServiceImplTest (changeTransaction): No transactions to change. Adding one for the test.");
                // Add a transaction if the list is empty to ensure the test can proceed.
                String uniqueOrderNumber = "SERVICE_CHANGE_" + UUID.randomUUID().toString();
                Transaction newTx = new Transaction("2024/03/02", "ForChange", "FC", "FCI", "Expense", 1.0, "Cash", "OK", uniqueOrderNumber, "FCM", "Original");
                transactionService.addTransaction(newTx);
                initialTransactions = transactionService.getAllTransactions(); // Reload
                if(initialTransactions.isEmpty()){
                    System.err.println("TransactionServiceImplTest (changeTransaction): Still no transactions after add. Test cannot proceed.");
                    // fail("Could not add a transaction to test change operation.");
                    return;
                }
            }

            Transaction toChange = new Transaction(); // Create a new Transaction object for update criteria
            toChange.setOrderNumber(initialTransactions.get(0).getOrderNumber()); // Get OrderNumber of the first transaction
            toChange.setRemarks("Updated via Service Test");
            toChange.setTransactionType("ChangedType");
            // Note: Other fields in 'toChange' will be null/default, changeTransaction should only update specified fields.

            transactionService.changeTransaction(toChange);
            System.out.println("TransactionServiceImplTest (changeTransaction): Changed transaction with ON: " + toChange.getOrderNumber());

            // Verify the changes.
            Transaction changedTx = transactionService.getAllTransactions().stream()
                    .filter(t -> t.getOrderNumber().equals(toChange.getOrderNumber()))
                    .findFirst().orElse(null);

            if(changedTx != null) {
                System.out.println("TransactionServiceImplTest (changeTransaction): New remark: " + changedTx.getRemarks());
                System.out.println("TransactionServiceImplTest (changeTransaction): New type: " + changedTx.getTransactionType());
                if (!"Updated via Service Test".equals(changedTx.getRemarks())) {
                    System.err.println("TransactionServiceImplTest (changeTransaction): Remark NOT updated as expected.");
                    // fail("Remark was not updated correctly.");
                }
                // assertEquals("Updated via Service Test", changedTx.getRemarks());
                // assertEquals("ChangedType", changedTx.getTransactionType());
            } else {
                System.err.println("TransactionServiceImplTest (changeTransaction): Changed transaction NOT FOUND after update.");
                // fail("Transaction not found after change operation.");
            }
        } catch (Exception e) {
            System.err.println("TransactionServiceImplTest (changeTransaction): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testChangeTransaction failed", e);
        }
        System.out.println("TransactionServiceImplTest: testChangeTransaction finished.");
    }

    @Test
    void testDeleteTransaction() {
        System.out.println("TransactionServiceImplTest: Running testDeleteTransaction...");
        try {
            List<Transaction> initialTransactions = transactionService.getAllTransactions();
            if (initialTransactions.isEmpty()) {
                System.out.println("TransactionServiceImplTest (deleteTransaction): No transactions to delete. Adding one for the test.");
                String uniqueOrderNumber = "SERVICE_DELETE_" + UUID.randomUUID().toString();
                Transaction newTx = new Transaction("2024/03/03", "ForDelete", "FD", "FDI", "Expense", 1.0, "Cash", "OK", uniqueOrderNumber, "FDM", "Original to be deleted");
                transactionService.addTransaction(newTx);
                initialTransactions = transactionService.getAllTransactions(); // Reload
                if(initialTransactions.isEmpty()){
                    System.err.println("TransactionServiceImplTest (deleteTransaction): Still no transactions after add. Test cannot proceed.");
                    // fail("Could not add a transaction to test delete operation.");
                    return;
                }
            }
            String orderNumberToDelete = initialTransactions.get(0).getOrderNumber();
            boolean deleted = transactionService.deleteTransaction(orderNumberToDelete);
            System.out.println("TransactionServiceImplTest (deleteTransaction): Deletion result for ON " + orderNumberToDelete + ": " + deleted);
            // assertTrue(deleted, "deleteTransaction should return true for an existing transaction.");

            // Verify the transaction is gone.
            boolean stillExists = transactionService.getAllTransactions().stream()
                    .anyMatch(t -> t.getOrderNumber().equals(orderNumberToDelete));
            System.out.println("TransactionServiceImplTest (deleteTransaction): Still exists after delete: " + stillExists);
            if (stillExists) {
                System.err.println("TransactionServiceImplTest (deleteTransaction): Deleted transaction STILL FOUND.");
                // fail("Transaction should not exist after deletion.");
            }
            // assertFalse(stillExists, "Transaction should be deleted.");
        } catch (Exception e) {
            System.err.println("TransactionServiceImplTest (deleteTransaction): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testDeleteTransaction failed", e);
        }
        System.out.println("TransactionServiceImplTest: testDeleteTransaction finished.");
    }

    @Test
    void testSearchTransaction() {
        System.out.println("TransactionServiceImplTest: Running testSearchTransaction...");
        try {
            Transaction criteria = new Transaction();
            // Assuming "Salary" or a similar term exists as a commodity in user1_transactions.csv for this test.
            // If CSV uses Chinese, and Transaction model uses English, ensure mapping or test with English term.
            criteria.setCommodity("Salary"); // Search for "Salary" in commodity. "工资" in Chinese.
            List<Transaction> results = transactionService.searchTransaction(criteria);
            System.out.println("TransactionServiceImplTest (searchTransaction): Found " + results.size() + " transactions matching commodity 'Salary'.");
            results.forEach(t -> System.out.println("  - Found: " + t.getOrderNumber() + " | " + t.getCommodity()));
            // Add assertions, e.g., assertTrue(!results.isEmpty()) if "Salary" is expected.
        } catch (Exception e) {
            System.err.println("TransactionServiceImplTest (searchTransaction): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testSearchTransaction failed", e);
        }
        System.out.println("TransactionServiceImplTest: testSearchTransaction finished.");
    }

    @Test
    void testGetMonthlyTransactionSummary() {
        System.out.println("TransactionServiceImplTest: Running testGetMonthlyTransactionSummary...");
        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("TransactionServiceImplTest (getMonthlySummary): Generated " + summaries.size() + " monthly summaries.");
            summaries.forEach((month, summary) -> {
                System.out.println("  Month: " + month + ", Income: " + summary.getTotalIncome() + ", Expense: " + summary.getTotalExpense());
                summary.getExpenseByCategory().forEach((cat, amt) -> System.out.println("    - Cat: " + cat + ", Amt: " + amt));
            });
            // Add assertions, e.g., assertFalse(summaries.isEmpty()) if data is expected.
        } catch (Exception e) {
            System.err.println("TransactionServiceImplTest (getMonthlySummary): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testGetMonthlyTransactionSummary failed", e);
        }
        System.out.println("TransactionServiceImplTest: testGetMonthlyTransactionSummary finished.");
    }

    @Test
    void testImportTransactionsFromCsv() {
        System.out.println("TransactionServiceImplTest: Running testImportTransactionsFromCsv...");
        try {
            // Ensure the import source file exists.
            Path importSourcePath = Paths.get(importTestCsvPath);
            if (!Files.exists(importSourcePath)) {
                System.err.println("TransactionServiceImplTest (import): Import source file missing: " + importTestCsvPath + ". Skipping test.");
                // fail("Import source file missing, cannot run test.");
                return;
            }

            long initialCount = transactionService.getAllTransactions().size();
            System.out.println("TransactionServiceImplTest (import): Transactions before import: " + initialCount);

            // Perform import from importTestCsvPath (e.g., admin_transactions.csv) into the temp user1 file.
            int importedCount = transactionService.importTransactionsFromCsv(testUser.getTransactionFilePath(), importTestCsvPath);
            System.out.println("TransactionServiceImplTest (import): Imported " + importedCount + " transactions.");
            // assertTrue(importedCount > 0, "Should import at least one transaction if source is not empty and has new data.");

            long finalCount = transactionService.getAllTransactions().size();
            System.out.println("TransactionServiceImplTest (import): Transactions after import: " + finalCount);

            // Basic check for count. This assumes no duplicates were skipped if importTestCsvPath
            // has unique OrderNumbers not present in the original user1_transactions.csv.
            // This check might need to be more sophisticated based on data and duplicate handling logic.
            // For example, if all imported items are new:
            // assertEquals(initialCount + importedCount, finalCount, "Final count should be initial + imported if all new.");
            // If duplicates are skipped, this assertion needs adjustment.
            if (finalCount >= initialCount + importedCount - 5 && finalCount <= initialCount + importedCount + 5) { // Allow some leeway for duplicates or variations
                System.out.println("TransactionServiceImplTest (import): Count after import seems reasonable.");
            } else {
                System.err.println("TransactionServiceImplTest (import): Count after import seems off. Initial: " + initialCount + ", Imported: " + importedCount + ", Final: " + finalCount);
                // Consider a more precise assertion if duplicate behavior is strictly defined.
            }

        } catch (Exception e) {
            System.err.println("TransactionServiceImplTest (import): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testImportTransactionsFromCsv failed", e);
        }
        System.out.println("TransactionServiceImplTest: testImportTransactionsFromCsv finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Service\TransactionServiceTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao; // This import implies you might be using it directly, which is okay for test setup
import Service.Impl.TransactionServiceImpl;
import model.Transaction;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.io.IOException;
import java.nio.file.Files; // Added for file operations if needed for setup
import java.nio.file.Path;   // Added for file operations
import java.nio.file.Paths; // Added for file operations
import java.nio.file.StandardCopyOption; // Added for file operations
import java.util.List;

// Test class for TransactionService
class TransactionServiceTest {
    private TransactionService transactionService;
    // Define a temporary file path for tests to operate on, to avoid affecting real data
    private static final String TEST_TRANSACTION_FILE_PATH = "target/test-transactions.csv"; // Example path, adjust as needed
    private static final String SAMPLE_TRANSACTION_FILE_PATH = "src/test/resources/CSVForm/transactions/user1_transactions.csv"; // A sample file to copy from

    @BeforeEach
    void setUp() throws IOException {
        // Initialize DAO and Service
        // For TransactionServiceImpl, it now expects a file path.
        // For isolated testing, it's best to use a temporary or test-specific file.
        // Copy a sample file to the test path before each test.
        Path sourcePath = Paths.get(SAMPLE_TRANSACTION_FILE_PATH);
        Path destinationPath = Paths.get(TEST_TRANSACTION_FILE_PATH);
        // Ensure parent directory for destinationPath exists
        if (destinationPath.getParent() != null) {
            Files.createDirectories(destinationPath.getParent());
        }
        if (Files.exists(sourcePath)) {
            Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);
        } else {
            // If no sample, create an empty file with headers for some tests to work (like add)
            // This part depends on how CsvTransactionDao handles empty files or if it requires headers.
            // For simplicity, this example assumes a sample file is copied.
            // If not, you might need to create an empty file or a file with just headers.
            System.err.println("Warning: Sample transaction file not found at " + SAMPLE_TRANSACTION_FILE_PATH + ". Tests might behave unexpectedly.");
            // Create an empty file if no sample (some tests might fail if they expect data)
            Files.deleteIfExists(destinationPath); // Delete if exists to start fresh
            Files.createFile(destinationPath); // Create empty file
            // Optionally write headers here if your DAO expects them for an "empty" file
        }

        transactionService = new TransactionServiceImpl(TEST_TRANSACTION_FILE_PATH);
    }

    @Test
    void testAddTransaction() throws IOException {
        // Prepare test data
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "Transfer", "Li Si", "Virtual Product", "Expense", 500.0,
                "Bank Card", "Completed", "T123456789", "M987654321", "Test"
        );

        // Perform add operation
        transactionService.addTransaction(transaction);

        // Verify if added successfully
        // Searching with an empty criteria should return all transactions
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertFalse(transactions.isEmpty(), "Transaction list should not be empty after adding.");
        // Check if the added transaction is present
        assertTrue(transactions.stream().anyMatch(t -> "T123456789".equals(t.getOrderNumber())),
                "Added transaction with OrderNumber T123456789 should be found.");
    }

    @Test
    void testChangeTransaction() throws Exception {
        // Prepare test data
        String orderNumber = "T_CHANGE_001";
        Transaction originalTransaction = new Transaction(
                "2023-08-20 15:30:00", "Transfer", "Li Si", "Virtual Product", "Expense", 500.0,
                "Bank Card", "Completed", orderNumber, "M987654321", "Original Test"
        );
        transactionService.addTransaction(originalTransaction); // Add it first

        // Prepare update data
        Transaction updatedTransactionInfo = new Transaction(
                null, "Recharge", null, null, null, 0.0,
                "WeChat Pay", null, orderNumber, null, "Updated Remark"
        ); // Only fields to be updated are set, plus the OrderNumber key

        // Perform update operation
        transactionService.changeTransaction(updatedTransactionInfo);

        // Verify if updated successfully
        Transaction searchCriteria = new Transaction();
        searchCriteria.setOrderNumber(orderNumber); // Search specifically for the updated transaction
        List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);

        assertFalse(transactions.isEmpty(), "Updated transaction should be found.");
        assertEquals(1, transactions.size(), "Should find exactly one transaction with the order number.");
        Transaction fetchedTransaction = transactions.get(0);
        assertEquals("Recharge", fetchedTransaction.getTransactionType(), "Transaction type should be updated.");
        assertEquals("WeChat Pay", fetchedTransaction.getPaymentMethod(), "Payment method should be updated.");
        assertEquals("Updated Remark", fetchedTransaction.getRemarks(), "Remarks should be updated.");
        // Verify that unchanged fields remain the same
        assertEquals("Li Si", fetchedTransaction.getCounterparty(), "Counterparty should remain unchanged.");
        assertEquals(500.0, fetchedTransaction.getPaymentAmount(), 0.01, "Amount should remain unchanged as per update logic.");
    }

    @Test
    void testDeleteTransaction() throws Exception {
        // Prepare test data
        String orderNumberToDelete = "T_DELETE_002";
        Transaction transaction = new Transaction(
                "2023-08-21 10:00:00", "Sale", "Wang Wu", "Physical Product", "Income", 300.0,
                "Alipay", "Completed", orderNumberToDelete, "M_DEL_002", "To Delete"
        );
        transactionService.addTransaction(transaction); // Add it first

        // Perform delete operation
        boolean result = transactionService.deleteTransaction(orderNumberToDelete);

        // Verify if deleted successfully
        assertTrue(result, "Deletion should be successful for an existing transaction.");
        Transaction searchCriteria = new Transaction();
        searchCriteria.setOrderNumber(orderNumberToDelete);
        List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);
        assertTrue(transactions.isEmpty(), "Transaction should no longer be found after deletion.");
    }

    @Test
    void testSearchTransaction() throws IOException {
        // Setup: Add a specific transaction to ensure search criteria can find something
        Transaction txToFind = new Transaction(
                "2023-08-22 11:00:00", "Payment", "Alipay", "Service Fee", "Expense", 25.0,
                "Balance", "Done", "T_SEARCH_003", "M_SEARCH_003", "Alipay search test"
        );
        transactionService.addTransaction(txToFind);


        // Set search criteria
        Transaction searchCriteria = new Transaction();
        searchCriteria.setCounterparty("Alipay"); // Search for transactions with counterparty "Alipay"

        // Perform search operation
        List<Transaction> result = transactionService.searchTransaction(searchCriteria);

        // Verify search result
        assertFalse(result.isEmpty(), "Search results should not be empty if matching data exists/was added.");
        result.forEach(res -> {
            System.out.println("Found Commodity: " + res.getCommodity() + " for Counterparty: " + res.getCounterparty());
            assertEquals("Alipay", res.getCounterparty(), "All results should have 'Alipay' as counterparty.");
        });
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Service\User\UserServiceTest.java`:

```java
package Service.User;

import DAO.Impl.CsvUserDao;
import DAO.UserDao;
import model.User;
import Constants.ConfigConstants;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

public class UserServiceTest {

    private UserService userService;

    @BeforeEach
    void setUp() {
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        userService = new UserService(userDao);
    }

    @Test
    void testAuthenticate_Success() {
        System.out.println("UserServiceTest: Running testAuthenticate_Success...");
        User user = userService.authenticate("admin", "admin123");
        if (user != null) {
            System.out.println("UserServiceTest (auth_success): Authenticated user: " + user.getUsername() + " with role: " + user.getRole());
        } else {
            System.err.println("UserServiceTest (auth_success): Authentication FAILED for admin.");
        }
        System.out.println("UserServiceTest: testAuthenticate_Success finished.");
    }

    @Test
    void testAuthenticate_Failure_WrongPassword() {
        System.out.println("UserServiceTest: Running testAuthenticate_Failure_WrongPassword...");
        User user = userService.authenticate("user1", "wrongpassword");
        if (user == null) {
            System.out.println("UserServiceTest (auth_fail_pwd): Authentication correctly failed for user1 with wrong password.");
        } else {
            System.err.println("UserServiceTest (auth_fail_pwd): Authentication INCORRECTLY succeeded for user1 with wrong password.");
        }
        System.out.println("UserServiceTest: testAuthenticate_Failure_WrongPassword finished.");
    }

    @Test
    void testAuthenticate_Failure_UnknownUser() {
        System.out.println("UserServiceTest: Running testAuthenticate_Failure_UnknownUser...");
        User user = userService.authenticate("unknownuser", "somepassword");
        if (user == null) {
            System.out.println("UserServiceTest (auth_fail_user): Authentication correctly failed for unknownuser.");
        } else {
            System.err.println("UserServiceTest (auth_fail_user): Authentication INCORRECTLY succeeded for unknownuser.");
        }
        System.out.println("UserServiceTest: testAuthenticate_Failure_UnknownUser finished.");
    }

    @Test
    void testGetUserByUsername() {
        System.out.println("UserServiceTest: Running testGetUserByUsername...");
        User user = userService.getUserByUsername("user2");
        if (user != null) {
            System.out.println("UserServiceTest (getByUsername): Found user: " + user.getUsername() + ", File: " + user.getTransactionFilePath());
        } else {
            System.err.println("UserServiceTest (getByUsername): User 'user2' NOT FOUND.");
        }

        User nonExistentUser = userService.getUserByUsername("no_such_user");
        if (nonExistentUser == null) {
            System.out.println("UserServiceTest (getByUsername): Correctly did not find 'no_such_user'.");
        } else {
            System.err.println("UserServiceTest (getByUsername): INCORRECTLY found 'no_such_user'.");
        }
        System.out.println("UserServiceTest: testGetUserByUsername finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\java\Utils\CacheManagerTest.java`:

```java
package Utils;

import DAO.Impl.CsvTransactionDao;
import DAO.TransactionDao;
import model.Transaction;
import Constants.CaffeineKeys;
import Constants.ConfigConstants; // For a sample file path

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.List;

public class CacheManagerTest {

    private TransactionDao transactionDao;
    private Path tempFilePath;
    // Use a known existing file for setting up the temp file
    private final String sampleTransactionFilePath = "src/test/resources/CSVForm/transactions/admin_transactions.csv";


    @BeforeEach
    void setUp() throws IOException {
        transactionDao = new CsvTransactionDao();
        Path originalPath = Paths.get(sampleTransactionFilePath);
        tempFilePath = Files.createTempFile("cache_manager_test_", ".csv");
        Files.copy(originalPath, tempFilePath, StandardCopyOption.REPLACE_EXISTING);
        System.out.println("CacheManagerTest: Set up with temp file: " + tempFilePath.toString());
    }

    @AfterEach
    void tearDown() throws IOException {
        if (tempFilePath != null && Files.exists(tempFilePath)) {
            Files.delete(tempFilePath);
            System.out.println("CacheManagerTest: Deleted temp file: " + tempFilePath.toString());
        }
        // Clean up the cache for this file path to avoid interference between tests
        CacheManager.invalidateTransactionCache(tempFilePath.toString());
        // Optionally, if fileCaches map allows removal:
        // CacheManager.fileCaches.remove(tempFilePath.toString());
    }

    @Test
    void testGetTransactions_LoadsAndCaches() {
        System.out.println("CacheManagerTest: Running testGetTransactions_LoadsAndCaches...");
        try {
            System.out.println("CacheManagerTest: First call to getTransactions for: " + tempFilePath.toString());
            List<Transaction> transactions1 = CacheManager.getTransactions(tempFilePath.toString(), transactionDao);
            System.out.println("CacheManagerTest: Loaded " + transactions1.size() + " transactions (call 1).");

            System.out.println("CacheManagerTest: Second call to getTransactions for: " + tempFilePath.toString());
            List<Transaction> transactions2 = CacheManager.getTransactions(tempFilePath.toString(), transactionDao);
            System.out.println("CacheManagerTest: Loaded " + transactions2.size() + " transactions (call 2 - should be cached).");

            // Simple check: sizes should be the same.
            if (transactions1.size() == transactions2.size()) {
                System.out.println("CacheManagerTest: Sizes match, caching likely worked.");
            } else {
                System.err.println("CacheManagerTest: Sizes MISMATCH. Caching might have issues.");
            }

        } catch (Exception e) {
            System.err.println("CacheManagerTest (getTransactions): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("CacheManagerTest: testGetTransactions_LoadsAndCaches finished.");
    }

    @Test
    void testPutAndInvalidateTransactions() {
        System.out.println("CacheManagerTest: Running testPutAndInvalidateTransactions...");
        try {
            // Get initial state
            List<Transaction> initialTransactions = CacheManager.getTransactions(tempFilePath.toString(), transactionDao);
            System.out.println("CacheManagerTest: Initial transactions count: " + initialTransactions.size());

            // Create a new list and put it into cache
            List<Transaction> manualList = new ArrayList<>();
            manualList.add(new Transaction("2024/04/01", "ManualPut", "MP_C", "MP_I", "支出", 1.0, "MP_P", "OK", "MP_ON", "MP_M", "Manual"));

            System.out.println("CacheManagerTest: Putting manual list with " + manualList.size() + " transaction(s) into cache for: " + tempFilePath.toString());
            CacheManager.putTransactions(tempFilePath.toString(), manualList, transactionDao);

            List<Transaction> afterPut = CacheManager.getTransactions(tempFilePath.toString(), transactionDao);
            System.out.println("CacheManagerTest: Transactions count after put: " + afterPut.size());
            if (afterPut.size() == manualList.size()) {
                System.out.println("CacheManagerTest: 'putTransactions' seems to have updated the cache.");
            } else {
                System.err.println("CacheManagerTest: 'putTransactions' did NOT update cache as expected.");
            }

            // Invalidate and get again (should reload from file, which still has original content)
            System.out.println("CacheManagerTest: Invalidating cache for: " + tempFilePath.toString());
            CacheManager.invalidateTransactionCache(tempFilePath.toString());

            List<Transaction> afterInvalidate = CacheManager.getTransactions(tempFilePath.toString(), transactionDao);
            System.out.println("CacheManagerTest: Transactions count after invalidate and get: " + afterInvalidate.size());
            if (afterInvalidate.size() == initialTransactions.size()) {
                System.out.println("CacheManagerTest: Cache invalidation and reload from original file content worked.");
            } else {
                System.err.println("CacheManagerTest: Cache invalidation or reload FAILED. Expected " + initialTransactions.size() + ", got " + afterInvalidate.size());
            }

        } catch (Exception e) {
            System.err.println("CacheManagerTest (putInvalidate): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("CacheManagerTest: testPutAndInvalidateTransactions finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\resources\CSVForm\stats\summary_statistics.csv`:

```csv
week_identifier,total_income_all_users,total_expense_all_users,top_expense_category,top_expense_category_amount,number_of_users_with_transactions,timestamp_generated
2022-W37,0.0,5000.0,Other Expenses,5000.0,1,2025-05-22 23:34:23
2025-W09,10000.0,20000.0,No Expense,0.0,3,2025-05-22 23:34:23
2025-W10,0.0,751.5,Other Expenses,751.5,3,2025-05-22 23:34:23
2025-W11,0.0,257.25,Dining,107.25,3,2025-05-22 23:34:23
2025-W12,0.0,15000.0,Other Expenses,10000.0,3,2025-05-22 23:34:23
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\resources\CSVForm\transactions\admin_transactions.csv`:

```csv
Transaction Time,Transaction Type,Counterparty,Commodity,In/Out,Amount(CNY),Payment Method,Current Status,Order Number,Merchant Number,Remarks
2025/03/01 09:00:00,Salary,Company A,March Salary,Expense,¥10000.00,Bank Card,Credited,SALARY_MAR_A,PAYROLL_A_001,This month's base salary
2025/03/05 14:30:00,Groceries,Supermarket B,Groceries,Expense,¥250.50,Alipay,Completed,SHOP_B_001,ALIPAY_12345,Weekend shopping
2025/03/10 10:00:00,Transfer,User 1,Lunch Reimbursement,Expense,¥50.00,WeChat Pay,Completed,TRANSFER_U1_001,WECHAT_56789,Returning lunch money
2025/03/15 11:00:00,Dining,Restaurant C,Lunch Takeaway,Expense,¥35.75,Meituan Pay,Completed,MEAL_C_001,MEITUAN_11223,Workday lunch
2025/03/20 16:00:00,Investment,Stock Account,Stock Purchase,Expense,¥5000.00,Bank Transfer,Completed,INVEST_STOCK_001,BANK_99887,Long-term investment
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\resources\CSVForm\transactions\user1_transactions.csv`:

```csv
Transaction Time,Transaction Type,Counterparty,Commodity,In/Out,Amount(CNY),Payment Method,Current Status,Order Number,Merchant Number,Remarks
2025/03/01 09:00:00,Salary,Company A,March Salary,Expense,¥10000.00,Bank Card,Credited,SALARY_MAR_A,PAYROLL_A_001,This month's base salary
2025/03/05 14:30:00,Groceries,Supermarket B,Groceries,Expense,¥250.50,Alipay,Completed,SHOP_B_001,ALIPAY_12345,Weekend shopping
2025/03/10 10:00:00,Transfer,User 1,Lunch Reimbursement,Expense,¥50.00,WeChat Pay,Completed,TRANSFER_U1_001,WECHAT_56789,Returning lunch money
2025/03/15 11:00:00,Dining,Restaurant C,Lunch Takeaway,Expense,¥35.75,Meituan Pay,Completed,MEAL_C_001,MEITUAN_11223,Workday lunch
2025/03/20 16:00:00,Investment,Stock Account,Stock Purchase,Expense,¥5000.00,Bank Transfer,Completed,INVEST_STOCK_001,BANK_99887,Long-term investment
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\resources\CSVForm\transactions\user2_transactions.csv`:

```csv
Transaction Time,Transaction Type,Counterparty,Commodity,In/Out,Amount(CNY),Payment Method,Current Status,Order Number,Merchant Number,Remarks
2025/03/01 09:00:00,Salary,Company A,March Salary,Expense,¥10000.00,Bank Card,Credited,SALARY_MAR_A,PAYROLL_A_001,This month's base salary
2025/03/05 14:30:00,Groceries,Supermarket B,Groceries,Expense,¥250.50,Alipay,Completed,SHOP_B_001,ALIPAY_12345,Weekend shopping
2025/03/10 10:00:00,Transfer,User 1,Lunch Reimbursement,Expense,¥50.00,WeChat Pay,Completed,TRANSFER_U1_001,WECHAT_56789,Returning lunch money
2025/03/15 11:00:00,Dining,Restaurant C,Lunch Takeaway,Expense,¥35.75,Meituan Pay,Completed,MEAL_C_001,MEITUAN_11223,Workday lunch
2025/03/20 16:00:00,Investment,Stock Account,Stock Purchase,Expense,¥5000.00,Bank Transfer,Completed,INVEST_STOCK_001,BANK_99887,Long-term investment
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\resources\CSVForm\users\users.csv`:

```csv
username,password,role,transaction_csv_path
admin,admin123,admin,Ai Bill Application/src/test/resources/CSVForm/transactions/admin_transactions.csv
user1,pass123,user,Ai Bill Application/src/test/resources/CSVForm/transactions/user1_transactions.csv
user2,securepwd,user,Ai Bill Application/src/test/resources/CSVForm/transactions/user2_transactions.csv

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai Bill Application\src\test\resources\config.properties`:

```properties
# config.properties
#csv.path=src/main/resources/CSVForm/0001.csv # 保持 main 路径，或者指向测试数据
csv.path=src/test/resources/CSVForm/transactions/admin_transactions.csv
csv.users_path=src/test/resources/CSVForm/users/users.csv
csv.summary_path=src/test/resources/CSVForm/stats/summary_statistics.csv
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai-Bill-Application-Prompt.txt`:

```txt
Project Path: Ai-Bill-Application-Group21

Source Tree:

```txt
软工
├── Ai-Bill-Application-Group21
│   ├── Ai Bill Application
│   │   ├── HistogramPanelContainer.java
│   │   ├── pom.xml
│   │   └── src
│   │       ├── main
│   │       │   ├── java
│   │       │   │   ├── Constants
│   │       │   │   │   ├── CaffeineKeys.java
│   │       │   │   │   ├── ConfigConstants.java
│   │       │   │   │   └── StandardCategories.java
│   │       │   │   ├── Controller
│   │       │   │   │   ├── ButtonEditor.java
│   │       │   │   │   ├── ButtonRenderer.java
│   │       │   │   │   ├── HistogramExample.java
│   │       │   │   │   ├── HistogramPanelContainer.java
│   │       │   │   │   ├── MenuUI.java
│   │       │   │   │   └── VisualizationPanel.java
│   │       │   │   ├── DAO
│   │       │   │   │   ├── Impl
│   │       │   │   │   │   ├── CsvSummaryStatisticDao.java
│   │       │   │   │   │   ├── CsvTransactionDao.java
│   │       │   │   │   │   └── CsvUserDao.java
│   │       │   │   │   ├── SummaryStatisticDao.java
│   │       │   │   │   ├── TransactionDao.java
│   │       │   │   │   └── UserDao.java
│   │       │   │   ├── Interceptor
│   │       │   │   │   └── Login
│   │       │   │   │       └── LoginDialog.java
│   │       │   │   ├── Main.java
│   │       │   │   ├── Service
│   │       │   │   │   ├── AIservice
│   │       │   │   │   │   ├── AIAnalyzerThread.java
│   │       │   │   │   │   ├── AITransactionService.java
│   │       │   │   │   │   ├── ColledgeStudentThread.java
│   │       │   │   │   │   └── CollegeStudentNeeds.java
│   │       │   │   │   ├── Impl
│   │       │   │   │   │   ├── SummaryStatisticService.java
│   │       │   │   │   │   └── TransactionServiceImpl.java
│   │       │   │   │   ├── TransactionService.java
│   │       │   │   │   ├── User
│   │       │   │   │   │   └── UserService.java
│   │       │   │   │   └── deepseek
│   │       │   │   │       └── ChatCompletionsExample.java
│   │       │   │   ├── Utils
│   │       │   │   │   ├── CacheManager.java
│   │       │   │   │   └── CacheUtil.java
│   │       │   │   └── model
│   │       │   │       ├── MonthlySummary.java
│   │       │   │       ├── SummaryStatistic.java
│   │       │   │       ├── Transaction.java
│   │       │   │       └── User.java
│   │       │   └── resources
│   │       │       ├── CSVForm
│   │       │       │   ├── stats
│   │       │       │   │   └── summary_statistics.csv
│   │       │       │   ├── transactions
│   │       │       │   │   ├── admin_transactions.csv
│   │       │       │   │   ├── user1_transactions.csv
│   │       │       │   │   └── user2_transactions.csv
│   │       │       │   └── users
│   │       │       │       └── users.csv
│   │       │       └── config.properties
│   │       └── test
│   │           ├── java
│   │           │   ├── ControllerTest
│   │           │   │   ├── AITest.java
│   │           │   │   └── MenuUITest.java
│   │           │   ├── DAOTest
│   │           │   │   └── CsvTransactionDaoTest.java
│   │           │   └── Service
│   │           │       ├── AIAnalyzerThreadTest.java
│   │           │       ├── AIserviceTest.java
│   │           │       ├── AiFunctionTest.java
│   │           │       ├── CacheTest.java
│   │           │       ├── CollegeStudentNeedsTest.java
│   │           │       └── TransactionServiceTest.java
│   │           └── resources
│   │               └── CSVForm
│   │                   ├── transactions
│   │                   │   ├── admin_transactions.csv
│   │                   │   ├── user1_transactions.csv
│   │                   │   └── user2_transactions.csv
│   │                   └── users
│   │                       └── users.csv
│   ├── Ai-Bill-Application-Prompt.txt
│   ├── README.md
│   ├── README.txt
│   ├── img.png
│   ├── 开发文档.docx
│   └── 项目要求.txt
├── Ai-Bill-Application-Group21 - 副本
│   ├── Ai Bill Application
│   │   ├── HistogramPanelContainer.java
│   │   ├── pom.xml
│   │   └── src
│   │       ├── main
│   │       │   ├── java
│   │       │   │   ├── Constants
│   │       │   │   │   ├── CaffeineKeys.java
│   │       │   │   │   └── ConfigConstants.java
│   │       │   │   ├── Controller
│   │       │   │   │   ├── ButtonEditor.java
│   │       │   │   │   ├── ButtonRenderer.java
│   │       │   │   │   ├── HistogramExample.java
│   │       │   │   │   ├── HistogramPanelContainer.java
│   │       │   │   │   └── MenuUI.java
│   │       │   │   ├── DAO
│   │       │   │   │   ├── CsvTransactionDao.java
│   │       │   │   │   └── TransactionDao.java
│   │       │   │   ├── Interceptor
│   │       │   │   │   └── Login
│   │       │   │   │       ├── LoginDialog.java
│   │       │   │   │       └── UserService.java
│   │       │   │   ├── Main.java
│   │       │   │   ├── Service
│   │       │   │   │   ├── AIservice
│   │       │   │   │   │   ├── AIAnalyzerThread.java
│   │       │   │   │   │   ├── AITransactionService.java
│   │       │   │   │   │   ├── ColledgeStudentThread.java
│   │       │   │   │   │   └── CollegeStudentNeeds.java
│   │       │   │   │   ├── Impl
│   │       │   │   │   │   └── TransactionServiceImpl.java
│   │       │   │   │   ├── TransactionService.java
│   │       │   │   │   └── deepseek
│   │       │   │   │       └── ChatCompletionsExample.java
│   │       │   │   ├── Utils
│   │       │   │   │   └── CacheUtil.java
│   │       │   │   └── model
│   │       │   │       └── Transaction.java
│   │       │   └── resources
│   │       │       ├── CSVForm
│   │       │       │   └── 0001.csv
│   │       │       └── config.properties
│   │       └── test
│   │           ├── java
│   │           │   ├── ControllerTest
│   │           │   │   ├── AITest.java
│   │           │   │   └── MenuUITest.java
│   │           │   ├── DAOTest
│   │           │   │   └── CsvTransactionDaoTest.java
│   │           │   └── Service
│   │           │       ├── AIAnalyzerThreadTest.java
│   │           │       ├── AIserviceTest.java
│   │           │       ├── AiFunctionTest.java
│   │           │       ├── CacheTest.java
│   │           │       ├── CollegeStudentNeedsTest.java
│   │           │       └── TransactionServiceTest.java
│   │           └── resources
│   ├── Ai-Bill-Application-Prompt.txt
│   ├── README.md
│   ├── README.txt
│   ├── img.png
│   └── 项目要求.txt
├── Lab5,6-Demostration-Vid.mp4
├── Labs
│   └── lab6
├── Submission
│   ├── Labs
│   │   ├── lab5
│   │   │   ├── lab5.iml
│   │   │   ├── out
│   │   │   │   └── production
│   │   │   │       └── lab5
│   │   │   │           ├── lab5.iml
│   │   │   │           ├── src
│   │   │   │           │   ├── main
│   │   │   │           │   │   └── java
│   │   │   │           │   │       └── DegreeClassifier.class
│   │   │   │           │   └── test
│   │   │   │           │       └── java
│   │   │   │           │           └── DegreeClassifierTest.class
│   │   │   │           └── untitled
│   │   │   ├── src
│   │   │   │   ├── main
│   │   │   │   │   └── java
│   │   │   │   │       └── DegreeClassifier.java
│   │   │   │   └── test
│   │   │   │       └── java
│   │   │   │           └── DegreeClassifierTest.java
│   │   │   └── untitled
│   │   └── lab6
│   │       ├── lab6.iml
│   │       ├── out
│   │       │   └── production
│   │       │       └── lab6
│   │       │           ├── lab6.iml
│   │       │           └── src
│   │       │               ├── main
│   │       │               │   └── java
│   │       │               │       └── DegreeClassifier.class
│   │       │               └── test
│   │       │                   └── java
│   │       │                       └── DegreeClassifierTest.class
│   │       └── src
│   │           ├── main
│   │           │   └── java
│   │           │       └── DegreeClassifier.java
│   │           └── test
│   │               └── java
│   │                   └── DegreeClassifierTest.java
│   └── Submission(Test & Production)
│       ├── Production
│       │   ├── DegreeClassifierLab5.java
│       │   └── DegreeClassifierLab6.java
│       └── Test
│           ├── DegreeClassifierTestLab5.java
│           └── DegreeClassifierTestLab6.java
├── Submission.zip
├── UI.png
└── 大代码
    ├── MenuUI-post.txt
    └── MenuUI-pre.txt

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>Ai-bill</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.2</version>
            <scope>test</scope>
        </dependency>

        <!-- CSV 解析核心库 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-csv</artifactId>
            <version>1.10.0</version>
        </dependency>

        <!-- 文件操作工具 -->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>2.15.1</version>
        </dependency>

        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>5.10.0</version>
            <scope>test</scope>
        </dependency>

        <!-- 断言增强库 -->
        <dependency>
            <groupId>org.assertj</groupId>
            <artifactId>assertj-core</artifactId>
            <version>3.24.2</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.volcengine</groupId>
            <artifactId>volcengine-java-sdk-ark-runtime</artifactId>
            <version>LATEST</version>
        </dependency>
        <dependency>
            <groupId>javax.annotation</groupId>
            <artifactId>javax.annotation-api</artifactId>
            <version>1.3.2</version>
        </dependency>
        <!-- pom.xml -->



        <!-- JSON 处理 -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.15.2</version>
        </dependency>

        <!--        caffeine缓存中间件-->
        <dependency>
            <groupId>com.github.ben-manes.caffeine</groupId>
            <artifactId>caffeine</artifactId>
            <version>3.1.8</version> <!-- 使用最新版本 -->
        </dependency>

    </dependencies>

</project>
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Constants\CaffeineKeys.java`:

```java
package Constants;

public class CaffeineKeys {
    public static final String TRANSACTION_CAFFEINE_KEY = "transactions";

}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Constants\ConfigConstants.java`:

```java
package Constants;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

/**
 * 配置常量类（线程安全初始化）
 */
public final class ConfigConstants {
    // 私有构造防止实例化
    private ConfigConstants() {}

    /**
     * transactionCSV路径加载逻辑
     */
    // CSV路径常量
    public static final String CSV_PATH;
    // 静态初始化块（类加载时执行）
    static {
        Properties prop = new Properties();
        try (InputStream input = ConfigConstants.class.getClassLoader()
                .getResourceAsStream("config.properties")) {

            prop.load(input);
            CSV_PATH = prop.getProperty("csv.path");
        } catch (IOException e) {
            throw new RuntimeException("加载配置文件失败", e); // 转换为运行时异常
        }
    }
}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Controller\ButtonEditor.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.TableCellEditor;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

class ButtonEditor extends AbstractCellEditor implements TableCellEditor {
    private final JPanel panel = new JPanel(new BorderLayout()); // 使用 BorderLayout
    private final JButton button = new JButton();
    private int rowIndex;
    private final MenuUI menuUI;

    public ButtonEditor(MenuUI menuUI) {
        this.menuUI = menuUI;

        // 设置按钮样式
        button.setFocusPainted(false); // 移除按钮的焦点边框
        button.setPreferredSize(new Dimension(80, 30)); // 设置按钮的固定尺寸

        // 添加按钮到面板
        panel.add(button, BorderLayout.CENTER);

        // 为按钮添加事件监听器
        button.addActionListener(e -> {
            System.out.println("按钮点击事件触发: " + button.getText());
            fireEditingStopped(); // 停止编辑
            String buttonText = button.getText();
            if ("Modify".equals(buttonText)) {
                menuUI.editRow(rowIndex); // 调用 MenuUI 的 editRow 方法
            } else if ("Delete".equals(buttonText)) {
                int confirm = JOptionPane.showConfirmDialog(panel, "确定要删除此行吗？", "确认删除", JOptionPane.YES_NO_OPTION);
                if (confirm == JOptionPane.YES_OPTION) {
                    menuUI.deleteRow(rowIndex); // 调用 MenuUI 的 deleteRow 方法
                }
            }
        });
    }

    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
        this.rowIndex = row; // 更新当前行索引
        button.setText(value != null ? value.toString() : ""); // 根据单元格的值设置按钮文本
        return panel;
    }

    @Override
    public Object getCellEditorValue() {
        return button.getText(); // 返回按钮的当前文本
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Controller\ButtonRenderer.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import java.awt.*;

class ButtonRenderer extends DefaultTableCellRenderer {
    private final JPanel panel = new JPanel(new BorderLayout()); // 使用 BorderLayout
    private final JButton button = new JButton();

    public ButtonRenderer() {
        button.setFocusPainted(false); // 移除按钮的焦点边框
        button.setPreferredSize(new Dimension(80, 30)); // 设置按钮的固定尺寸
        panel.add(button, BorderLayout.CENTER); // 将按钮添加到面板中心
    }

    @Override
    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
        // 根据单元格的值设置按钮文本
        button.setText(value != null ? value.toString() : "");
        return panel;
    }
}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Controller\HistogramExample.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;
import java.util.HashMap;
import java.util.Random;

// 数据生成类
class DataGenerator {
    public static int[] generateData(int numberOfDataPoints, int maxValue) {
        Random random = new Random();
        int[] data = new int[numberOfDataPoints];
        for (int i = 0; i < numberOfDataPoints; i++) {
            data[i] = random.nextInt(maxValue);
        }
        return data;
    }
}

// 直方图计算类
class Histogram {
    private int binSize;
    private int[] data;

    public Histogram(int[] data, int binSize) {
        this.data = data;
        this.binSize = binSize;
    }

    public HashMap<Integer, Integer> computeFrequency() {
        HashMap<Integer, Integer> frequencyMap = new HashMap<>();
        for (int number : data) {
            int bin = number / binSize;
            frequencyMap.put(bin, frequencyMap.getOrDefault(bin, 0) + 1);
        }
        return frequencyMap;
    }
}

// 直方图 GUI 绘制类
class HistogramPanel extends JPanel {
    HashMap<Integer, Integer> frequencyMap;

    public HistogramPanel() {
        this.frequencyMap = new HashMap<>();
    }

    public void updateData(HashMap<Integer, Integer> frequencyMap) {
        this.frequencyMap = frequencyMap;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        int barWidth = 40;
        int gap = 10;
        int maxFrequency = frequencyMap.values().stream().mapToInt(v -> v).max().orElse(1);

        int index = 0;
        for (Integer key : frequencyMap.keySet()) {
            int height = (int) ((frequencyMap.get(key) / (double) maxFrequency) * getHeight());
            g.setColor(Color.BLUE);
            g.fillRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.setColor(Color.BLACK);
            g.drawRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.drawString("Bin " + key, index * (barWidth + gap) + 5, getHeight() - 5);
            index++;
        }
    }
}


// 主窗口类
public class HistogramExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("数据分析界面");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Controller\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Controller\MenuUI.java`:

```java
package Controller;

import Constants.ConfigConstants;
import DAO.CsvTransactionDao;

import Service.Impl.TransactionServiceImpl;

import Service.Impl.TransactionServiceImpl;

import Utils.CacheUtil;
import model.Transaction;

import javax.swing.*;
import java.awt.*;
import java.io.IOException;
import java.util.List;
import java.util.Vector;
import javax.swing.table.DefaultTableModel;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class MenuUI {
    private static final String FILE_PATH = CSV_PATH;
    private static DefaultTableModel tableModel;
    private static Vector<Vector<String>> allData = new Vector<>();
    private static TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());
    private JTable table;  // 把table定义为静态字段
    private HistogramPanelContainer histogramPanelContainer; // 添加 HistogramPanelContainer 实例
    private JPanel rightPanel; // 右边的面板，用于显示搜索和表格界面或 AI 界面
    private CardLayout cardLayout; // 用于管理界面切换的布局

    public MenuUI(){
        String[] columnNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注", "Modify", "Delete"};
        tableModel = new DefaultTableModel(columnNames, 0);
        table = new JTable(tableModel);

        histogramPanelContainer = new HistogramPanelContainer(); // 初始化 HistogramPanelContainer
        cardLayout = new CardLayout(); // 初始化 CardLayout
        rightPanel = new JPanel(cardLayout); // 初始化 rightPanel
    }

    public JPanel createMainPanel() {
        // 主面板，使用 BorderLayout
        JPanel mainPanel = new JPanel(new BorderLayout());

        // 左边的面板，包含 Menu 和 AI 按钮
        JPanel leftPanel = createLeftPanel();
        mainPanel.add(leftPanel, BorderLayout.WEST);

        // 右边的面板，用于显示搜索和表格界面或 AI 界面
        setupRightPanel();
        mainPanel.add(rightPanel, BorderLayout.CENTER);

        return mainPanel;
    }

    // 创建左边的面板，包含 Menu 和 AI 按钮
    private JPanel createLeftPanel() {
        JPanel leftPanel = new JPanel(new GridLayout(2, 1));
        JButton menuButton = new JButton("Menu");
        JButton aiButton = new JButton("AI");

        leftPanel.add(menuButton);
        leftPanel.add(aiButton);

        // 为 Menu 按钮添加 ActionListener
        menuButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Table"); // 切换到表格界面
        });

        // 为 AI 按钮添加 ActionListener
        aiButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Histogram"); // 切换到直方图界面
        });

        return leftPanel;
    }

    // 设置右边的面板，包含搜索和表格界面或 AI 界面
    private void setupRightPanel() {
        // 创建搜索和表格的面板
        JPanel tablePanel = createTablePanel();

        // 将表格面板和直方图面板添加到 rightPanel
        rightPanel.add(tablePanel, "Table");
        rightPanel.add(histogramPanelContainer, "Histogram");
    }

    // 创建搜索和表格的面板
    private JPanel createTablePanel() {
        JPanel tablePanel = new JPanel(new BorderLayout());

        // 创建输入面板
        JPanel inputPanel = createInputPanel();
        tablePanel.add(inputPanel, BorderLayout.NORTH);

        // 创建表格的滚动面板
        JScrollPane tableScrollPane = new JScrollPane(table);
        tableScrollPane.setPreferredSize(new Dimension(1000, 250));
        table.setRowHeight(30); // 设置表格的行高

        tablePanel.add(tableScrollPane, BorderLayout.CENTER);

        // 为 Modify 列设置渲染器和编辑器
        table.getColumnModel().getColumn(11).setCellRenderer(new ButtonRenderer());
        table.getColumnModel().getColumn(11).setCellEditor(new ButtonEditor(this));

        // 为 Delete 列设置渲染器和编辑器
        table.getColumnModel().getColumn(12).setCellRenderer(new ButtonRenderer());
        table.getColumnModel().getColumn(12).setCellEditor(new ButtonEditor(this));

        // 加载 CSV 数据
        loadCSVData(FILE_PATH);

        return tablePanel;
    }

    // 创建输入面板
    private JPanel createInputPanel() {
        JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));

        // 创建输入字段
        JTextField transactionTimeField = new JTextField(10); // 交易时间输入框
        JTextField transactionTypeField = new JTextField(10); // 交易类型输入框
        JTextField counterpartyField = new JTextField(10);    // 交易对方输入框
        JTextField commodityField = new JTextField(10);      // 商品输入框
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"}); // 收/支下拉框
        JTextField paymentMethodField = new JTextField(10);  // 支付方式输入框

        // 添加标签和输入字段到输入面板
        inputPanel.add(new JLabel("交易时间:"));
        inputPanel.add(transactionTimeField);
        inputPanel.add(new JLabel("交易类型:"));
        inputPanel.add(transactionTypeField);
        inputPanel.add(new JLabel("交易对方:"));
        inputPanel.add(counterpartyField);
        inputPanel.add(new JLabel("商品:"));
        inputPanel.add(commodityField);
        inputPanel.add(new JLabel("收/支:"));
        inputPanel.add(inOutComboBox);
        inputPanel.add(new JLabel("支付方式:"));
        inputPanel.add(paymentMethodField);

        // 创建 Search 和 Add 按钮
        JButton searchButton = new JButton("Search");
        JButton addButton = new JButton("Add");

        // 将按钮添加到输入面板
        inputPanel.add(searchButton);
        inputPanel.add(addButton);

        // 为 Search 按钮添加 ActionListener
        searchButton.addActionListener(e -> {
            // 获取输入字段的值
            searchData(
                    transactionTimeField.getText().trim(),
                    transactionTypeField.getText().trim(),
                    counterpartyField.getText().trim(),
                    commodityField.getText().trim(),
                    (String) inOutComboBox.getSelectedItem(),
                    paymentMethodField.getText().trim()
            );
        });

        // 为 Add 按钮添加 ActionListener
        addButton.addActionListener(e -> {
            // 弹出对话框，输入交易信息
            showAddTransactionDialog();
        });

        return inputPanel;
    }

    // 弹出对话框，输入交易信息
    private void showAddTransactionDialog() {
        // 创建对话框
        JDialog addDialog = new JDialog();
        addDialog.setTitle("添加交易");
        addDialog.setLayout(new GridLayout(12, 2)); // 11 个字段 + 1 个按钮行

        // 创建输入字段
        JTextField transactionTimeField = new JTextField();
        JTextField transactionTypeField = new JTextField();
        JTextField counterpartyField = new JTextField();
        JTextField commodityField = new JTextField();
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"});
        JTextField paymentAmountField = new JTextField();
        JTextField paymentMethodField = new JTextField();
        JTextField currentStatusField = new JTextField();
        JTextField orderNumberField = new JTextField();
        JTextField merchantNumberField = new JTextField();
        JTextField remarksField = new JTextField();

        // 添加标签和输入字段到对话框
        addDialog.add(new JLabel("交易时间:"));
        addDialog.add(transactionTimeField);
        addDialog.add(new JLabel("交易类型:"));
        addDialog.add(transactionTypeField);
        addDialog.add(new JLabel("交易对方:"));
        addDialog.add(counterpartyField);
        addDialog.add(new JLabel("商品:"));
        addDialog.add(commodityField);
        addDialog.add(new JLabel("收/支:"));
        addDialog.add(inOutComboBox);
        addDialog.add(new JLabel("金额(元):"));
        addDialog.add(paymentAmountField);
        addDialog.add(new JLabel("支付方式:"));
        addDialog.add(paymentMethodField);
        addDialog.add(new JLabel("当前状态:"));
        addDialog.add(currentStatusField);
        addDialog.add(new JLabel("交易单号:"));
        addDialog.add(orderNumberField);
        addDialog.add(new JLabel("商户单号:"));
        addDialog.add(merchantNumberField);
        addDialog.add(new JLabel("备注:"));
        addDialog.add(remarksField);

        // 添加确认按钮
        JButton confirmButton = new JButton("确认");
        confirmButton.addActionListener(e -> {
            // 获取输入字段的值，若为空则设置为默认值
            String transactionTime = emptyIfNull(transactionTimeField.getText().trim());
            String transactionType = emptyIfNull(transactionTypeField.getText().trim());
            String counterparty = emptyIfNull(counterpartyField.getText().trim());
            String commodity = emptyIfNull(commodityField.getText().trim());
            String inOut = (String) inOutComboBox.getSelectedItem();
            String paymentAmountText = paymentAmountField.getText().trim();
            double paymentAmount = paymentAmountText.isEmpty() ? 0.0 : Double.parseDouble(paymentAmountText); // 处理空字符串
            String paymentMethod = emptyIfNull(paymentMethodField.getText().trim());
            String currentStatus = emptyIfNull(currentStatusField.getText().trim());
            String orderNumber = emptyIfNull(orderNumberField.getText().trim());
            String merchantNumber = emptyIfNull(merchantNumberField.getText().trim());
            String remarks = emptyIfNull(remarksField.getText().trim());

            // 创建 Transaction 对象
            Transaction newTransaction = new Transaction(
                    transactionTime,
                    transactionType,
                    counterparty,
                    commodity,
                    inOut,
                    paymentAmount,
                    paymentMethod,
                    currentStatus,
                    orderNumber,
                    merchantNumber,
                    remarks
            );

            try {
                // 调用 TransactionServiceImpl 的 addTransaction 方法
                transactionService.addTransaction(newTransaction);

                // 重新加载 CSV 数据以更新表格
                loadCSVData(TRANSACTION_CAFFEINE_KEY);

                // 关闭对话框
                addDialog.dispose();

                JOptionPane.showMessageDialog(null, "交易添加成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(null, "交易添加失败！", "错误", JOptionPane.ERROR_MESSAGE);
            }
        });

        addDialog.add(confirmButton);

        // 设置对话框大小并显示
        addDialog.setSize(400, 300);
        addDialog.setModal(true); // 设置为模态对话框
        addDialog.setVisible(true);
    }

    // 加载 CSV 数据
    public void loadCSVData(String caffeineKey) {
        allData.clear();
        tableModel.setRowCount(0);

        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;

//        CsvTransactionDao csvTransactionDao = new CsvTransactionDao();

        List<Transaction> transactions = cache.get(caffeineKey);
        for (Transaction transaction : transactions) {
            Vector<String> row = createRowFromTransaction(transaction);
            allData.add(row);
            tableModel.addRow(row);
        }
    }

    // 搜索数据
    public void searchData(String query1, String query2, String query3, String query4, String query6, String query5) {
        tableModel.setRowCount(0);
        Transaction searchCriteria = new Transaction(query1, query2, query3, query4, query6, 0, query5, "", "", "", "");

        try {
            List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);
            for (Transaction transaction : transactions) {
                Vector<String> row = createRowFromTransaction(transaction);
                tableModel.addRow(row);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(null, "查询失败！", "错误", JOptionPane.ERROR_MESSAGE);
        }
    }

    // 从 Transaction 对象创建表格行
    private Vector<String> createRowFromTransaction(Transaction transaction) {
        Vector<String> row = new Vector<>();
        row.add(transaction.getTransactionTime());
        row.add(transaction.getTransactionType());
        row.add(transaction.getCounterparty());
        row.add(transaction.getCommodity());
        row.add(transaction.getInOut());
        row.add(String.valueOf(transaction.getPaymentAmount()));
        row.add(transaction.getPaymentMethod());
        row.add(transaction.getCurrentStatus());
        row.add(transaction.getOrderNumber());
        row.add(transaction.getMerchantNumber());
        row.add(transaction.getRemarks());
        row.add("Modify"); // Modify 按钮
        row.add("Delete"); // 添加 Delete 按钮
        return row;
    }

    // 删除行
    public void deleteRow(int rowIndex) {
        if (rowIndex >= 0 && rowIndex < allData.size()) {
            String orderNumber = allData.get(rowIndex).get(8).trim();
            System.out.println("尝试删除的交易单号: " + orderNumber); // 打印交易单号

            try {
                if (transactionService.deleteTransaction(orderNumber)) {
                    allData.remove(rowIndex);
                    tableModel.removeRow(rowIndex);
                    JOptionPane.showMessageDialog(null, "删除成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                } else {
                    JOptionPane.showMessageDialog(null, "删除失败：未找到对应的交易单号", "错误", JOptionPane.ERROR_MESSAGE);
                }
            } catch (IOException ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(null, "删除失败！", "错误", JOptionPane.ERROR_MESSAGE);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    // 编辑行
    public void editRow(int rowIndex) {
        System.out.println("编辑行: " + rowIndex);
        if (rowIndex >= 0 && rowIndex < allData.size()) {
            Vector<String> rowData = allData.get(rowIndex);

            // 创建一个面板用于显示编辑字段
            JPanel panel = new JPanel(new GridLayout(rowData.size() - 2, 2)); // 排除最后两列

            // 创建字段数组，用于存储用户输入的值
            JTextField[] fields = new JTextField[rowData.size() - 2]; // 排除最后两列

            // 遍历 rowData，跳过最后两列（"Modify" 和 "Delete"）
            for (int i = 0; i < rowData.size() - 2; i++) {
                panel.add(new JLabel(tableModel.getColumnName(i))); // 添加列名标签
                fields[i] = new JTextField(rowData .get(i)); // 添加输入字段
                panel.add(fields[i]);
            }

            // 弹出对话框，让用户修改数据
            int result = JOptionPane.showConfirmDialog(null, panel, "修改交易信息", JOptionPane.OK_CANCEL_OPTION);
            if (result == JOptionPane.OK_OPTION) {
                // 用户点击了确认按钮，更新交易信息
                Transaction transaction = new Transaction(
                        fields[0].getText().trim(), // 交易时间
                        fields[1].getText().trim(), // 交易类型
                        fields[2].getText().trim(), // 交易对方
                        fields[3].getText().trim(), // 商品
                        fields[4].getText().trim(), // 收/支
                        Double.parseDouble(fields[5].getText().trim()), // 金额(元)
                        fields[6].getText().trim(), // 支付方式
                        fields[7].getText().trim(), // 当前状态
                        fields[8].getText().trim(), // 交易单号
                        fields[9].getText().trim(), // 商户单号
                        fields[10].getText().trim() // 备注
                );

                try {
                    // 调用 TransactionServiceImpl 的 changeTransaction 方法更新交易
                    transactionService.changeTransaction(transaction);

                    // 重新加载 CSV 数据以更新表格
                    loadCSVData(TRANSACTION_CAFFEINE_KEY);

                    JOptionPane.showMessageDialog(null, "修改成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                } catch (Exception ex) {
                    ex.printStackTrace();
                    JOptionPane.showMessageDialog(null, "修改失败！", "错误", JOptionPane.ERROR_MESSAGE);
                }
            }
        }
    }

    /**
     * 查找对话框中的输入字段
     *
     * @param dialog 对话框
     * @param index  输入字段的索引
     * @return 输入字段
     */
    /**
     * 查找容器中的输入字段
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0;
        for (Component component : container.getComponents()) {
            if (component instanceof JTextField) {
                if (count == index) {
                    return (JTextField) component;
                }
                count++;
            }
        }
        return null;
    }

    /**
     * 查找对话框中的下拉框
     *
     * @param dialog 对话框
     * @return 下拉框
     */
    /**
     * 查找容器中的下拉框
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) {
            if (component instanceof JComboBox) {
                return (JComboBox<String>) component;
            }
        }
        return null;
    }

    /**
     * 如果字段为 null，则返回空文本
     *
     * @param value 字段值
     * @return 非 null 的字段值
     */
    private String emptyIfNull(String value) {
        return value == null ? "" : value;
    }

    // 添加此方法以便测试时可以获取table
    public JTable getTable() {
        return table;
    }
}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\DAO\CsvTransactionDao.java`:

```java
package DAO;

import Constants.ConfigConstants;
import model.Transaction;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static Constants.ConfigConstants.CSV_PATH;

public class CsvTransactionDao implements TransactionDao {
    //避免每次都调用loadFromCSV() 方法
    private List<Transaction> transactions;
    private boolean isLoad= false;
//HEAD 交易时间	交易类型	交易对方	商品	收/支	金额(元)	支付方式	当前状态	交易单号	商户单号	备注
    //
    @Override
    public List<Transaction> loadFromCSV(String filePath) throws IOException {
        try (
                Reader reader = new InputStreamReader(
                        new BOMInputStream(Files.newInputStream(Paths.get(filePath))),
                        StandardCharsets.UTF_8)) {
            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()    //根据首行的内容设置为表格的头
                    .withIgnoreHeaderCase(false)  // 禁用忽略大小写
                    .withTrim(false);             // 禁用自动trim（防止意外空格问题）

            try (CSVParser csvParser = new CSVParser(reader, format)) {

                List<Transaction> transactions = new ArrayList<>();
                for (CSVRecord record : csvParser) {
                    Transaction transaction = parseRecord(record);
                    transactions.add(transaction);
                }
                reader.close();
                this.transactions = transactions;
                this.isLoad=true;
                return transactions;
            }
        }
    }


    private Transaction parseRecord(CSVRecord record) {
        return new Transaction(
                record.get("交易时间"),
                record.get("交易类型"),
                record.get("交易对方"),
                record.get("商品"),
                record.get("收/支"),
                Double.parseDouble(record.get("金额(元)").substring(1)),
                record.get("支付方式"),
                record.get("当前状态"),
                record.get("交易单号"),
                record.get("商户单号"),
                record.get("备注")
        );
    }

    // 根据交易单号删除交易记录
    public boolean deleteTransaction(String filePath, String orderNumber) throws IOException {
        if(!isLoad){ loadFromCSV(filePath);}

        List<Transaction> updatedTransactions = transactions.stream()
                .filter(t -> !t.getOrderNumber().trim().equals(orderNumber))
                .collect(Collectors.toList());

        if (transactions.size() == updatedTransactions.size()) {
            return false;
        }

        writeTransactionsToCSV(filePath, updatedTransactions);
        return true;
    }

    // 添加交易
    public void addTransaction(String filePath, Transaction newTransaction) throws IOException {
        boolean fileExists = Files.exists(Paths.get(filePath)) && Files.size(Paths.get(filePath)) > 0;

        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(filePath), StandardOpenOption.CREATE, StandardOpenOption.APPEND);
             CSVPrinter csvPrinter = new CSVPrinter(writer, fileExists ? getCsvFormatWithoutHeader() : getCsvFormatWithHeader(filePath))) {

            csvPrinter.printRecord(
                    newTransaction.getTransactionTime(),
                    newTransaction.getTransactionType(),
                    newTransaction.getCounterparty(),
                    newTransaction.getCommodity(),
                    newTransaction.getInOut(),
                    "¥" + newTransaction.getPaymentAmount(),
                    newTransaction.getPaymentMethod(),
                    newTransaction.getCurrentStatus(),
                    newTransaction.getOrderNumber(),
                    newTransaction.getMerchantNumber(),
                    newTransaction.getRemarks()
            );

            csvPrinter.flush();
        }
    }

    // 统一写回 CSV
    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
        // 1. 创建临时文件（确保与原文件同目录）
        File targetFile = new File(filePath);
        File tempFile = File.createTempFile("transaction_temp", ".csv", targetFile.getParentFile());

        // 2. 写入数据到临时文件（使用 try-with-resources 确保资源释放）
        try (BufferedWriter writer = Files.newBufferedWriter(tempFile.toPath());
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(
                     "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"))) {

            for (Transaction t : transactions) {
                csvPrinter.printRecord(
                        t.getTransactionTime(),
                        t.getTransactionType(),
                        t.getCounterparty(),
                        t.getCommodity(),
                        t.getInOut(),
                        "¥" + t.getPaymentAmount(),
                        t.getPaymentMethod(),
                        t.getCurrentStatus(),
                        t.getOrderNumber(),
                        t.getMerchantNumber(),
                        t.getRemarks()
                );
            }
            csvPrinter.flush(); // 强制刷盘
        } catch (IOException e) {
            tempFile.delete(); // 失败时删除临时文件
            throw e;
        }

        // 3. 原子性替换原文件
        Path source = tempFile.toPath();
        Path target = Paths.get(filePath);
        try {
            Files.move(source, target, StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            System.err.println("移动失败原因: " + e.getMessage());
        }
    }

//    // 统一写回 CSV
//    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
//        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(filePath));
//             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(
//                     "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注")))  {
//
//            for (Transaction t : transactions) {
//                csvPrinter.printRecord(
//                        t.getTransactionTime(),
//                        t.getTransactionType(),
//                        t.getCounterparty(),
//                        t.getCommodity(),
//                        t.getInOut(),
//                        "¥" + t.getPaymentAmount(),
//                        t.getPaymentMethod(),
//                        t.getCurrentStatus(),
//                        t.getOrderNumber(),
//                        t.getMerchantNumber(),
//                        t.getRemarks()
//                );
//            }
//        }
//    }

    // 获取 CSV 格式（包含表头）
    private CSVFormat getCsvFormatWithHeader(String filePath) throws IOException {
        try (BufferedReader reader = Files.newBufferedReader(Paths.get(filePath))) {
            String headerLine = reader.readLine();
            if (headerLine == null || headerLine.trim().isEmpty()) {
                // 如果文件为空或不存在，返回默认表头
                return CSVFormat.DEFAULT.withHeader(
                        "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"
                );
            }
            return CSVFormat.DEFAULT.withHeader(headerLine.split(",")).withTrim();
        }
    }

    // 获取 CSV 格式（不包含表头）
    private CSVFormat getCsvFormatWithoutHeader() {
        return CSVFormat.DEFAULT.withTrim();
    }

    public boolean changeInformation(String orderNumber, String head, String value,String path) throws IOException{
        if(isLoad==false){ loadFromCSV(path);}
        for (int i = 0; i < transactions.size(); i++) {
            if(transactions.get(i).getOrderNumber().trim().equals(orderNumber)){
                Transaction newTransaction=transactions.get(i);
                switch (head){
                    case "transactionTime" :{
                        newTransaction.setTransactionTime(value);
                        break;}
                    case "transactionType" :{
                        newTransaction.setTransactionType(value);
                        break;
                    }
                    case "counterparty" :{
                        newTransaction.setCounterparty(value);
                        break;
                    } case "commodity" :{
                        newTransaction.setCommodity(value);
                        break;
                    } case "inOut" :{
                        newTransaction.setInOut(value);
                        break;
                    } case "paymentAmount" :{
                        newTransaction.setPaymentAmount(Double.parseDouble(value));
                        break;
                    } case "paymentMethod" :{
                        newTransaction.setPaymentMethod(value);
                        break;
                    } case "currentStatus" :{
                        newTransaction.setCurrentStatus(value);
                        break;
                    } case "orderNumber" :{
                        newTransaction.setOrderNumber(value);
                        break;
                    } case "merchantNumber" :{
                        newTransaction.setMerchantNumber(value);
                        break;
                    } case "remarks" :{
                        newTransaction.setRemarks(value);
                        break;
                    } default:{
                        System.err.println("error head");
                    }
                }

                boolean flag=deleteTransaction(path,transactions.get(i).getOrderNumber());
                if(flag) {
                    addTransaction(path,newTransaction);
                    System.out.println("success to delete");
                }
                else System.err.println("failed to delete");
            }
        }
        return true;
    }

    @Override
    public List<Transaction> getAllTransactions() throws IOException {
        return List.of();
    }

    @Override
    public void addTransaction(Transaction transaction) throws IOException {

    }

    @Override
    public boolean deleteTransaction(String orderNumber) throws IOException {
        return false;
    }

    @Override
    public boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException {
        return false;
    }

    @Override
    public Transaction getTransactionByOrderNumber(String orderNumber) throws IOException {
        return null;
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\DAO\TransactionDao.java`:

```java
package DAO;

import model.Transaction;

import java.io.IOException;
import java.util.List;

/**
 * Interface for Data Access Object (DAO) operations related to Transactions.
 * Defines the contract for loading, adding, deleting, and updating transaction data.
 */
public interface
TransactionDao {

    //HEAD 交易时间	交易类型	交易对方	商品	收/支	金额(元)	支付方式	当前状态	交易单号	商户单号	备注
        //
    List<Transaction> loadFromCSV(String filePath) throws IOException;

    /**
     * Loads all transactions from the configured data source.
     *
     * @return A list of all transactions.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<Transaction> getAllTransactions() throws IOException;

    /**
     * Adds a new transaction to the data source.
     *
     * @param transaction The new transaction to add.
     * @throws IOException If an I/O error occurs during saving.
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * Deletes a transaction identified by its order number.
     *
     * @param orderNumber The unique order number of the transaction to delete.
     * @return true if a transaction was found and deleted, false otherwise.
     * @throws IOException If an I/O error occurs during loading or saving.
     */
    boolean deleteTransaction(String orderNumber) throws IOException;

    /**
     * Updates a specific field of an existing transaction identified by its order number.
     *
     * @param orderNumber The unique order number of the transaction to update.
     * @param fieldName   The name of the field to update (e.g., "transactionType", "paymentAmount").
     * @param newValue    The new value for the specified field.
     * @return true if the transaction was found and updated, false otherwise.
     * @throws IOException             If an I/O error occurs during loading or saving.
     * @throws NumberFormatException   If updating 'paymentAmount' and newValue is not a valid double.
     * @throws IllegalArgumentException If the fieldName is invalid.
     */
    boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException;

    /**
     * Retrieves a transaction by its unique order number.
     * (Optional but often useful)
     *
     * @param orderNumber The unique order number.
     * @return The Transaction object if found, null otherwise.
     * @throws IOException If an I/O error occurs during loading.
     */
    Transaction getTransactionByOrderNumber(String orderNumber) throws IOException;

}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Interceptor\Login\LoginDialog.java`:

```java
package Interceptor.Login;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class LoginDialog extends JDialog {
    private boolean loginSuccessful = false;
    private JTextField usernameField;
    private JPasswordField passwordField;
    private UserService userService = new UserService();

    public LoginDialog() {
        setTitle("用户登录");
        setLayout(new GridLayout(3, 2));
        setModal(true);
        setSize(300, 150);

        // 输入组件
        usernameField = new JTextField();
        passwordField = new JPasswordField();
        JButton loginButton = new JButton("登录");
        JButton cancelButton = new JButton("取消");

        // 添加组件
        add(new JLabel("用户名:"));
        add(usernameField);
        add(new JLabel("密码:"));
        add(passwordField);
        add(loginButton);
        add(cancelButton);

        // 登录按钮逻辑
        loginButton.addActionListener(e -> {
            String username = usernameField.getText().trim();
            String password = new String(passwordField.getPassword()).trim();

            if (userService.authenticate(username, password)) {
                loginSuccessful = true;
                dispose(); // 关闭对话框
            } else {
                JOptionPane.showMessageDialog(
                        this,
                        "用户名或密码错误！",
                        "登录失败",
                        JOptionPane.ERROR_MESSAGE
                );
                clearFields(); // 登录失败后清空文本框
            }
        });

        // 取消按钮逻辑
        cancelButton.addActionListener(e -> {
            dispose();
            System.exit(0);
        });

        setLocationRelativeTo(null); // 居中显示
    }

    // 清空文本框的方法
    private void clearFields() {
        usernameField.setText("");
        passwordField.setText("");
        usernameField.requestFocus(); // 焦点回到用户名输入框
    }

    public boolean isLoginSuccessful() {
        return loginSuccessful;
    }
}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Interceptor\Login\UserService.java`:

```java
package Interceptor.Login;

import java.util.HashMap;
import java.util.Map;

public class UserService {
    // 模拟用户数据库（用户名 -> 密码哈希值）
    private static final Map<String, String> userDatabase = new HashMap<>();

    public UserService() {
        // 初始化测试用户（密码为 "admin123" 的 SHA-256 哈希）
        userDatabase.put("admin", "admin123");
    }

    public boolean authenticate(String username, String password) {
        if (username.isEmpty() || password.isEmpty()) return false;
        String storedHash = userDatabase.get(username);
        return password.equals(storedHash);
    }

}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Main.java`:

```java
import javax.swing.*;

import Controller.MenuUI;
import DAO.CsvTransactionDao;
import Interceptor.Login.LoginDialog;
import Service.Impl.TransactionServiceImpl;

public class Main {
    public static void main(String[] args) {
        // 初始化服务（依赖注入）
        TransactionServiceImpl.csvTransactionDao = new CsvTransactionDao();

        // 在事件调度线程中启动 GUI（Swing 规范）
        SwingUtilities.invokeLater(() -> {
            // 1. 显示登录对话框
            LoginDialog loginDialog = new LoginDialog();
            loginDialog.setVisible(true);

            // 2. 登录成功后再显示主界面
            if (loginDialog.isLoginSuccessful()) {
                MenuUI menuUI = new MenuUI();
                JPanel mainPanel = menuUI.createMainPanel();
                showMainUI(mainPanel);
            } else {
                System.exit(0); // 登录失败退出
            }
        });
    }

    /**
     * 显示主界面窗口
     */
    private static void showMainUI(JPanel panel) {
        JFrame frame = new JFrame("交易管理系统");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(1200, 600);
        frame.setLocationRelativeTo(null); // 窗口居中
        frame.add(panel);
        frame.setVisible(true);
    }
}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Service\AIservice\AIAnalyzerThread.java`:

```java
package Service.AIservice;

public class AIAnalyzerThread implements Runnable {
    private final String userRequest;
    private final String filePath;
    private final String startTimeStr;
    private final String endTimeStr;

    public AIAnalyzerThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        this.userRequest = userRequest;
        this.filePath = filePath;
        this.startTimeStr = startTimeStr;
        this.endTimeStr = endTimeStr;
    }

    @Override
    public void run() {
        String result = new AITransactionService().analyzeTransactions(userRequest, filePath, startTimeStr, endTimeStr);
        System.out.println("AI分析结果: " + result);
        // TODO: 如果是UI程序，可用 SwingUtilities.invokeLater() 更新UI组件
    }

}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Service\AIservice\AITransactionService.java`:

```java
package Service.AIservice;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Constants.ConfigConstants;
import DAO.CsvTransactionDao;
import Utils.CacheUtil;
import model.Transaction;
import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;

import java.io.IOException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;
import java.util.concurrent.*;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class AITransactionService {
    private static final String API_KEY = System.getenv("ARK_API_KEY");
    private static final ArkService service = ArkService.builder()
            .timeout(Duration.ofSeconds(1800))
            .connectTimeout(Duration.ofSeconds(20))
            .baseUrl("https://ark.cn-beijing.volces.com/api/v3")
            .apiKey(API_KEY)
            .build();

    private final CsvTransactionDao transactionDao = new CsvTransactionDao();

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    private final CacheUtil<String, List<Transaction>, Exception> cache;
    /**
     * 重构构造器初始化Caffeine
     */
    public AITransactionService()  {
        // 1. 注入Dao层接口
        TransactionServiceImpl.csvTransactionDao = transactionDao;
        // 2. 初始化CacheUtil
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return transactionDao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );
    }

    public String analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        try {
            List<Transaction> transactions = cache.get(TRANSACTION_CAFFEINE_KEY);
            List<String> transactionDetails = formatTransactions(transactions, startTimeStr, endTimeStr);

            String aiPrompt = userRequest + "\n" + "以下是我的账单信息：\n" + String.join("\n", transactionDetails);
            return askAi(aiPrompt);
        } catch (Exception e) {
            e.printStackTrace();
            return "AI分析失败: " + e.getMessage();
        }
    }


    //private List<String> formatTransactions(List<Transaction> transactions) {
        //return transactions.stream().map(t -> String.format(
               // "交易时间: %s, 商品: %s, 收/支: %s, 金额: %.2f元",
               // t.getTransactionTime(),
               // t.getCommodity(),
               // t.getInOut(),
               // t.getPaymentAmount()
        //)).collect(Collectors.toList());
    //}

    public List<String> formatTransactions(List<Transaction> transactions, String startTimeStr, String endTimeStr) {
        LocalDateTime startTime = parseDateTime(startTimeStr);
        LocalDateTime endTime = (endTimeStr == null || endTimeStr.isEmpty())
                ? LocalDateTime.now()
                : parseDateTime(endTimeStr);

        if (startTime == null) {
            throw new IllegalArgumentException("起始时间格式不正确");
        }

        List<Transaction> filtered = transactions.stream()
                .filter(t -> {
                    LocalDateTime tTime = parseDateTime(t.getTransactionTime());
                    return tTime != null && !tTime.isBefore(startTime) && !tTime.isAfter(endTime);
                })
                .collect(Collectors.toList());

        Map<String, double[]> grouped = new HashMap<>();
        for (Transaction t : filtered) {
            String counterparty = t.getCounterparty();
            double amount = t.getInOut().equals("支出") ? -t.getPaymentAmount() : t.getPaymentAmount();
            grouped.putIfAbsent(counterparty, new double[]{0.0, 0});
            grouped.get(counterparty)[0] += amount;
            grouped.get(counterparty)[1] += 1;
        }

        List<String> results = grouped.entrySet().stream()
                .map(e -> {
                    String cp = e.getKey();
                    double net = e.getValue()[0];
                    int count = (int) e.getValue()[1];
                    String inOut = net >= 0 ? "收入" : "支出";
                    return String.format("交易对方: %s, 收/支: %s, 金额: %.2f元，交易次数: %d",
                            cp, inOut, Math.abs(net), count);
                })
                .collect(Collectors.toList());

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm");
        results.add(String.format("交易时间范围：%s - %s",
                formatter.format(startTime), formatter.format(endTime)));

        return results.isEmpty() ? List.of("该时间段内没有交易记录。") : results;
    }




    //private LocalDateTime parseDateTime(String timeStr) {
        // 你可以按实际情况支持不同格式，比如 yyyy/MM/dd HH:mm 或 yyyy-MM-dd HH:mm:ss
        //List<String> patterns = Arrays.asList("yyyy/MM/dd HH:mm","yyyy/MM/dd H:mm", "yyyy/M/dd H:mm","yyyy/M/dd HH:mm","yyyy/M/d H:mm","yyyy/M/d HH:mm","yyyy-MM-dd HH:mm:ss", "yyyy/MM/dd");

        //for (String pattern : patterns) {
            //try {
                //DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                //return LocalDateTime.parse(timeStr, formatter);
            //} catch (Exception ignored) {}
        //}
        //return null;
    //}
        private LocalDateTime parseDateTime(String timeStr) {
            if (timeStr == null || timeStr.trim().isEmpty()) return null;

            // 中文空格等统一清理
            timeStr = timeStr.trim().replaceAll("\\s+", " ");

            // 如果只有日期，补 00:00
            if (timeStr.matches("\\d{4}/\\d{1,2}/\\d{1,2}")) {
                timeStr += " 00:00";
            }

            // 多种时间格式尝试解析
            List<String> patterns = Arrays.asList(
                    "yyyy/M/d H:mm", "yyyy/M/d HH:mm",
                    "yyyy/MM/d H:mm", "yyyy/MM/d HH:mm",
                    "yyyy/M/dd H:mm", "yyyy/M/dd HH:mm",
                    "yyyy/MM/dd H:mm", "yyyy/MM/dd HH:mm",
                    "yyyy-MM-dd HH:mm:ss",
                    "yyyy/MM/dd"
            );

            for (String pattern : patterns) {
                try {
                    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                    return LocalDateTime.parse(timeStr, formatter);
                } catch (Exception ignored) {}
            }

            return null;
        }






    public String askAi(String prompt) {
        try {
            List<ChatMessage> messages = List.of(
                    ChatMessage.builder().role(ChatMessageRole.USER).content(prompt).build()
            );

            ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
                    .model("ep-20250308174053-7pbkq")
                    .messages(messages)
                    .build();

            return (String) service.createChatCompletion(chatCompletionRequest)
                    .getChoices().get(0).getMessage().getContent();
        } catch (Exception e) {
            e.printStackTrace();
            return "AI请求失败: " + e.getMessage();
        }
    }

    public void runAiInThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            String result = analyzeTransactions(userRequest, filePath,startTimeStr, endTimeStr);
            System.out.println("AI分析结果: " + result);
        });
        executor.shutdown();
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Service\AIservice\ColledgeStudentThread.java`:

```java
package Service.AIservice;

import java.io.IOException;

public class ColledgeStudentThread implements Runnable{
//    private final int userRequest;
    private final String filePath;
    public String budgetRange;
    public ColledgeStudentThread( String filePath) {
//        this.userRequest = userRequest;
        this.filePath = filePath;
    }

    @Override
    public void run(){
        CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
        try {
            collegeStudentNeeds.generateBudget(filePath);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Service\AIservice\CollegeStudentNeeds.java`:

```java
package Service.AIservice;

import Constants.ConfigConstants;
import DAO.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import model.Transaction;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class CollegeStudentNeeds {
    private final String requestBudge="我是一名预算有限的大学生，请根据下面我给出的花费，帮助我给下周预算范围，必须以[最低预算，最高预算],的方式给出回答，不能有多余的回复。";
    private final String requestTips="我是一名预算有限的大学生，请给我推荐一些省钱方法。";

    private final String requestRecognition="下面我将给你一些账单的信息，请推测这个账单是什么方面的消费: ";
    CsvTransactionDao dao;

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    private final CacheUtil<String, List<Transaction>, Exception> cache;

    public CollegeStudentNeeds() {
        TransactionServiceImpl.csvTransactionDao = dao;
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return dao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );

    }
    public String RecognizeTransaction(Transaction transaction){
        StringBuilder sb=new StringBuilder();
        sb.append("交易类型:").append(transaction.getTransactionType()+",").append("交易对方").append(transaction.getCounterparty()+",")
                .append("商品:").append(transaction.getCommodity()+",").append("收/支:").append(transaction.getInOut()+",")
                        .append("金额(元):").append(transaction.getPaymentAmount()+",").append("支付方式").append(transaction.getPaymentMethod()+",").append("备注:").append(transaction.getRemarks());
        return  new AITransactionService().askAi(requestRecognition+sb.toString());
    }

    public String generateTipsForSaving(){
        return  new AITransactionService().askAi(requestTips);
    }
    //按周统计已有的支出，依靠ai得到下周的预算
    public double[] generateBudget(String path) throws IOException {
        List<Transaction> transactions=cache.get(TRANSACTION_CAFFEINE_KEY);

        int size=transactions.size();
        if(size==0||size==1) return new double[]{-1,-1};
        int count=1;
        int base=0;
        int index=0;//指示首个适合当基准的时间点
        for (index = 0; index < size; index++) {
            int data=convertDateToNumber(transactions.get(index).getTransactionTime().split(" ")[0]);
            if(data>0){
                base=data;
                break;
            }
        }
        List<Double> list=new ArrayList<>();
        double weekConsumption=0;
        for (int i = 0; i < size; i++) {
            int data=convertDateToNumber(transactions.get(i).getTransactionTime().split(" ")[0]);
            if(data<0) continue;
            if((base-data>=0&&base-data<7)&&transactions.get(i).getInOut().equals("支出")){
                weekConsumption+=transactions.get(i).getPaymentAmount();
            }else if(base-data>=7){
                base=data;
                list.add(weekConsumption);
                count++;
                weekConsumption=0;
                if(transactions.get(i).getInOut().equals("支出")){
                    weekConsumption+=transactions.get(i).getPaymentAmount();
                }
            }
        }
        StringBuilder stringBuilder=new StringBuilder();
        for (int i = 0; i < count-1; i++) {
            stringBuilder.append("第");
            stringBuilder.append(i);
            stringBuilder.append("周:花费");
            stringBuilder.append(list.get(i));
            stringBuilder.append("元;");
        }
        String answer=new AITransactionService().askAi(requestBudge+stringBuilder.toString());
        System.out.println(answer);
        double[] ret=new double[2];
        ret=parseDoubleArrayFromString(answer);
        return ret;
    }

    private int convertDateToNumber(String date) {
        // format yyyy/MM/dd
        String[] parts = date.split("/");
        if (parts.length != 3) {
            return -1; // Invalid date format
        }
        try {
            int year = Integer.parseInt(parts[0]);
            int month = Integer.parseInt(parts[1]);
            int day = Integer.parseInt(parts[2]);
            int days = day;
            int[] daysInMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // Days in each month
            if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
                daysInMonth[2] = 29; // February has 29 days in a leap year
            }
            for (int i = 1; i < month; i++) {
                days += daysInMonth[i];
            }
            return year * 365 + (year / 4 - year / 100 + year / 400) + days;
        } catch (NumberFormatException e) {
            return -1;
        }
    }
    public double[] parseDoubleArrayFromString(String input) {
        int length=input.length();
        int l=0,rightindex=input.length();
        // 1. 去除首尾括号
        for (int i = 0; i < length; i++) {
            if(input.charAt(i)<58&&input.charAt(i)>47){
                l=i;
                break;
            }
        }
        for (int r =length-1 ; r >0; r--) {
            if(input.charAt(r)<58&&input.charAt(r)>47){
                rightindex=r;
                break;
            }
        }
        String content = input.substring(l, rightindex+1 ); // 获取 "1.1, 11.0" 或 " 2.5 ,3.14 , -0.5 "

        // 2. 按逗号分割
        String[] numberStrings1 = content.split("，"); // 得到 ["1.1", " 11.0"] 或 [" 2.5 ", "3.14 ", " -0.5 "]
        String[] numberStrings2 = content.split(","); // 得到 ["1.1", " 11.0"] 或 [" 2.5 ", "3.14 ", " -0.5 "]
        String[] numberStrings= numberStrings1.length> numberStrings2.length?numberStrings1:numberStrings2;
//        System.out.println(numberStrings[0]);
//        System.out.println(numberStrings[1]);
        // 3. & 4. 遍历、清理、解析并存储
        List<Double> numberList = new ArrayList<>();
        try {
            for (String numStr : numberStrings) {
                String trimmedStr = numStr.trim(); // 去除首尾空格
                if (!trimmedStr.isEmpty()) { // 避免分割后产生空字符串（例如 "[1.1, , 2.2]"）
                    numberList.add(Double.parseDouble(trimmedStr)); // 解析为 double
                }
            }
        } catch (NumberFormatException e) {
            System.err.println("错误：字符串无法解析为 double 类型。");
            return null; // 或者抛出异常
        }

        // 将 List<Double> 转换为 double[]
        double[] result = new double[numberList.size()];
        for (int i = 0; i < numberList.size(); i++) {
            result[i] = numberList.get(i);
        }
        return result;
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Service\Impl\TransactionServiceImpl.java`:

```java
package Service.Impl;

import Constants.ConfigConstants;
import DAO.CsvTransactionDao;
import Service.TransactionService;
import Utils.CacheUtil;
import model.Transaction;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class TransactionServiceImpl implements TransactionService {
    public static CsvTransactionDao csvTransactionDao;

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    public final CacheUtil<String, List<Transaction>, Exception> cache;

    /**
     * 通过构造函数注入路径和csvTransactionDao
     * @param csvTransactionDao
     * @throws IOException
     */
    public TransactionServiceImpl(CsvTransactionDao csvTransactionDao)  {
        // 1. 注入Dao层接口
        TransactionServiceImpl.csvTransactionDao = csvTransactionDao;
        // 2. 初始化CacheUtil
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return csvTransactionDao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );
    }

    /**
     * 从transactions缓存中读取transactions如果没有则从csv文件中找
     * @return
     * @throws IOException
     */
    private List<Transaction> getAllTransactions() throws Exception {
        return cache.get(TRANSACTION_CAFFEINE_KEY);
    }


    /**
     * 新增交易
     * @param transaction
     */
    @Override
    public void addTransaction(Transaction transaction) throws IOException {
        // 设置交易时间为当前时间
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
        String currentTime = now.format(formatter);
        transaction.setTransactionTime(currentTime);

        // 调用 DAO 层方法添加交易
        csvTransactionDao.addTransaction(CSV_PATH, transaction);
    }

    @Override
    public void changeTransaction(Transaction updatedTransaction) throws Exception {
        // 1. 加载所有交易记录 先加载 caffeine存储的缓存
        List<Transaction> allTransactions = getAllTransactions();

        // 2. 查找并修改目标交易
        boolean found = false;
        for (int i = 0; i < allTransactions.size(); i++) {
            Transaction t = allTransactions.get(i);
            // 根据交易单号匹配记录（唯一标识）
            if (t.getOrderNumber().equals(updatedTransaction.getOrderNumber())) {
                // 3. 更新非空字段
                updateTransactionFields(t, updatedTransaction);
                found = true;
                break;
            }
        }
        if (!found) {
            throw new IllegalArgumentException("未找到交易单号: " + updatedTransaction.getOrderNumber());
        }
        // 使用事务将写后数据写回csv文件
        csvTransactionDao.writeTransactionsToCSV(CSV_PATH, allTransactions);
        // 修改后使缓存失效 （删缓存）
        cache.invalidate("transactions");
    }

    /**
     *  辅助方法：更新非空字段
     * @param target
     * @param source
     */
    private void updateTransactionFields(Transaction target, Transaction source) {
        if (source.getTransactionTime() != null && !source.getTransactionTime().isEmpty()) {
            target.setTransactionTime(source.getTransactionTime());
        }
        if (source.getTransactionType() != null && !source.getTransactionType().isEmpty()) {
            target.setTransactionType(source.getTransactionType());
        }
        if (source.getCounterparty() != null && !source.getCounterparty().isEmpty()) {
            target.setCounterparty(source.getCounterparty());
        }
        if (source.getCommodity() != null && !source.getCommodity().isEmpty()) {
            target.setCommodity(source.getCommodity());
        }
        if (source.getInOut() != null && !source.getInOut().isEmpty()) {
            target.setInOut(source.getInOut());
        }
        if (source.getPaymentAmount() != 0.0) { // 假设金额为0表示未修改
            target.setPaymentAmount(source.getPaymentAmount());
        }
        if (source.getPaymentMethod() != null && !source.getPaymentMethod().isEmpty()) {
            target.setPaymentMethod(source.getPaymentMethod());
        }
        if (source.getCurrentStatus() != null && !source.getCurrentStatus().isEmpty()) {
            target.setCurrentStatus(source.getCurrentStatus());
        }
        if (source.getMerchantNumber() != null && !source.getMerchantNumber().isEmpty()) {
            target.setMerchantNumber(source.getMerchantNumber());
        }
        if (source.getRemarks() != null && !source.getRemarks().isEmpty()) {
            target.setRemarks(source.getRemarks());
        }
    }

    /**
     * 根据订单号删除交易 (若成功则返回true)
     * @param orderNumber
     */
    @Override
    public boolean deleteTransaction(String orderNumber) throws Exception {
        boolean result = csvTransactionDao.deleteTransaction(CSV_PATH, orderNumber);
        if (!result) {
            throw new Exception("未找到交易单号: " + orderNumber); // 或记录日志
        }
        cache.invalidate("transactions");
        return result;
    }

    /**
     * 按照查询条件查询交易信息
     * @param searchCriteria
     * @return
     */
    @Override
    public List<Transaction> searchTransaction(Transaction searchCriteria) {
        try {
            // 1. 读取所有交易记录 首先读取caffeine
            List<Transaction> allTransactions = getAllTransactions();

            // 2. 动态模糊匹配
            List<Transaction> matched = new ArrayList<>();
            for (Transaction t : allTransactions) {
                if (matchesCriteria(t, searchCriteria)) {
                    matched.add(t);
                }
            }

            // 3. 按交易时间倒序排序
            matched.sort((t1, t2) -> compareTransactionTime(t2.getTransactionTime(), t1.getTransactionTime()));

            return matched;
        } catch (IOException e) {
            e.printStackTrace();
            return List.of(); // 实际应用中应处理异常
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * 辅助方法:判断单个交易记录是否匹配条件
     * @param transaction
     * @param criteria
     * @return
     */
    private boolean matchesCriteria(Transaction transaction, Transaction criteria) {
        return (criteria.getTransactionTime() == null || containsIgnoreCase(transaction.getTransactionTime(), criteria.getTransactionTime()))
                && (criteria.getTransactionType() == null || containsIgnoreCase(transaction.getTransactionType(), criteria.getTransactionType()))
                && (criteria.getCounterparty() == null || containsIgnoreCase(transaction.getCounterparty(), criteria.getCounterparty()))
                && (criteria.getCommodity() == null || containsIgnoreCase(transaction.getCommodity(), criteria.getCommodity()))
                && (criteria.getInOut() == null || containsIgnoreCase(transaction.getInOut(), criteria.getInOut()))
                && (criteria.getPaymentMethod() == null || containsIgnoreCase(transaction.getPaymentMethod(), criteria.getPaymentMethod()));
    }

    /**
     * 辅助方法：字符串模糊匹配（空条件视为匹配）
     * @param source
     * @param target
     * @return
     */
    private boolean containsIgnoreCase(String source, String target) {
        if (target == null || target.trim().isEmpty()) return true; // 空条件不参与筛选
        if (source == null) return false;
        return source.toLowerCase().contains(target.toLowerCase().trim());
    }

    /**
     * 辅助方法：安全的时间比较（处理 null 值）
     * @param time1
     * @param time2
     * @return
     */
    private int compareTransactionTime(String time1, String time2) {
        if (time1 == null && time2 == null) return 0;
        if (time1 == null) return -1;
        if (time2 == null) return 1;
        return time2.compareTo(time1); // 倒序排序
    }

}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Service\TransactionService.java`:

```java
package Service;

import model.Transaction;

import java.io.IOException;
import java.util.List;

public interface TransactionService {

    /**
     * 新增交易
     * @param transaction
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * 修改交易
     * @param transaction
     */
    void changeTransaction(Transaction transaction) throws Exception;

    /**
     * 根据订单号删除交易
     * @param orderNumber
     */
    boolean deleteTransaction(String orderNumber) throws Exception;

    /**
     * 根据用户输入信息查询交易
     * @param transaction
     * @return
     */
    List<Transaction> searchTransaction(Transaction transaction);

}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Service\deepseek\ChatCompletionsExample.java`:

```java
package Service.deepseek;

import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;
import okhttp3.ConnectionPool;
import okhttp3.Dispatcher;
import org.apache.commons.lang.StringUtils;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
public class ChatCompletionsExample {
    static String apiKey = System.getenv("ARK_API_KEY");
    static ConnectionPool connectionPool = new ConnectionPool(5, 1, TimeUnit.SECONDS);
    static Dispatcher dispatcher = new Dispatcher();
    // The output time of the reasoning model is relatively long. Please increase the timeout period.//
    static ArkService service = ArkService.builder().timeout(Duration.ofSeconds(1800)).connectTimeout(Duration.ofSeconds(20)).dispatcher(dispatcher).connectionPool(connectionPool).baseUrl("https://ark.cn-beijing.volces.com/api/v3").apiKey(apiKey).build();

//    public static void main(String[] args) {
//        System.out.println(" [Recommended]----- streaming request -----");
//        final List<ChatMessage> streamMessages = new ArrayList<>();
//        final ChatMessage streamUserMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("请回答15.11和15.9哪个大？").build();
//        streamMessages.add(streamUserMessage);
//        ChatCompletionRequest streamChatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(streamMessages)
//                .build();
//        service.streamChatCompletion(streamChatCompletionRequest)
//                .doOnError(Throwable::printStackTrace)
//                .blockingForEach(
//                        delta -> {
//                            if (!delta.getChoices().isEmpty()) {
//                                if (StringUtils.isNotEmpty(delta.getChoices().get(0).getMessage().getReasoningContent())) {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getReasoningContent());
//                                } else {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getContent());
//                                }
//                            }
//                        }
//                );
//        System.out.println(" ----- standard request -----");
//        final List<ChatMessage> messages = new ArrayList<>();
//        final ChatMessage userMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("常见的十字花科植物有哪些？").build();
//        messages.add(userMessage);
//        ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(messages)
//                .build();
//        service.createChatCompletion(chatCompletionRequest).getChoices().forEach(
//                choice -> {
//                    System.out.println(choice.getMessage().getReasoningContent());
//                    System.out.println(choice.getMessage().getContent());
//                }
//        );
//        // shutdown service after all requests is finished
//        service.shutdownExecutor();
//    }
}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Utils\CacheUtil.java`:

```java
package Utils;

import com.github.benmanes.caffeine.cache.*;

import java.util.concurrent.TimeUnit;
import java.util.function.Function;

import com.github.benmanes.caffeine.cache.Caffeine;

/**
 * 通用缓存工具类（支持泛型和异常传播）
 * @param <K> 键类型
 * @param <V> 值类型
 * @param <E> 异常类型（如 IOException）
 */
public class CacheUtil<K, V, E extends Exception> {
    private final LoadingCache<K, V> cache;

    public CacheUtil(Function<K, V> loader,
                     int maxSize,
                     long expireAfterWrite,
                     long refreshAfterWrite) {

        this.cache = Caffeine.newBuilder()
                .maximumSize(maxSize)
                .expireAfterWrite(expireAfterWrite, TimeUnit.MINUTES)
                .refreshAfterWrite(refreshAfterWrite, TimeUnit.MINUTES)
                .build(loader::apply); // 关键修改：使用build(loader)创建LoadingCache
    }

    /**
     * 获取缓存值
     */
    public V get(K key) {
        return cache.get(key);
    }

    /**
     * 手动更新缓存
     */
    public void put(K key, V value) {
        cache.put(key, value);
    }

    /**
     * 手动移除缓存
     */
    public void invalidate(K key) {
        cache.invalidate(key);
    }
}



```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\model\Transaction.java`:

```java
package model;
//Transaction time, transaction type, transaction counterparty,
// commodity receipt/payment amount (yuan), payment method, current status,
// transaction order number, merchant order number, remarks
public class Transaction {
    private String transactionTime;
    private String transactionType;
    private String counterparty;
    private String commodity;
    private String inOut;
    private double paymentAmount;
    private String paymentMethod;
    private String currentStatus;
    private String orderNumber;
    private String merchantNumber;
    private String remarks;

    public Transaction() {
    }

    public Transaction(String transactionTime, String transactionType, String counterparty, String commodity, String inOut, double paymentAmount, String paymentMethod, String currentStatus, String orderNumber, String merchantNumber, String remarks) {
        this.transactionTime = transactionTime;
        this.transactionType = transactionType;
        this.counterparty = counterparty;
        this.commodity = commodity;
        this.inOut = inOut;
        this.paymentAmount = paymentAmount;
        this.paymentMethod = paymentMethod;
        this.currentStatus = currentStatus;
        this.orderNumber = orderNumber;
        this.merchantNumber = merchantNumber;
        this.remarks = remarks;
    }

    public String getInOut() {
        return inOut;
    }

    public void setInOut(String inOut) {
        this.inOut = inOut;
    }

    public void setTransactionTime(String transactionTime) {
        this.transactionTime = transactionTime;
    }

    public void setTransactionType(String transactionType) {
        this.transactionType = transactionType;
    }

    public void setCounterparty(String counterparty) {
        this.counterparty = counterparty;
    }

    public void setCommodity(String commodity) {
        this.commodity = commodity;
    }

    public void setPaymentAmount(double paymentAmount) {
        this.paymentAmount = paymentAmount;
    }

    public void setPaymentMethod(String paymentMethod) {
        this.paymentMethod = paymentMethod;
    }

    public void setCurrentStatus(String currentStatus) {
        this.currentStatus = currentStatus;
    }

    public void setOrderNumber(String orderNumbe) {
        this.orderNumber = orderNumbe;
    }

    public void setMerchantNumber(String merchantNumber) {
        this.merchantNumber = merchantNumber;
    }

    public void setRemarks(String remarks) {
        this.remarks = remarks;
    }

    public String getTransactionTime() {
        return transactionTime;
    }

    public String getTransactionType() {
        return transactionType;
    }

    public String getCounterparty() {
        return counterparty;
    }

    public String getCommodity() {
        return commodity;
    }

    public double getPaymentAmount() {
        return paymentAmount;
    }

    public String getPaymentMethod() {
        return paymentMethod;
    }

    public String getCurrentStatus() {
        return currentStatus;
    }

    public String getOrderNumber() {
        return orderNumber;
    }

    public String getMerchantNumber() {
        return merchantNumber;
    }

    public String getRemarks() {
        return remarks;
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\resources\CSVForm\0001.csv`:

```csv
交易时间,交易类型,交易对方,商品,收/支,金额(元),支付方式,当前状态,交易单号,商户单号,备注
2025/04/22 14:38:46,充值,支付宝,虚拟商品,收入,¥1000.0,微信支付,已完成,T987654321,M123456789,测试
2025/04/22 14:38:06,充值,支付宝,虚拟商品,收入,¥1000.0,微信支付,已完成,T987654322,M123456789,测123
2025/04/22 14:38:46,充值,支付宝,虚拟商品,收入,¥1000.0,微信支付,已完成,T987654323,M123456789,测试
2025/04/22 15:40:01,充值,支付宝,虚拟商品,收入,¥1000.0,微信支付,已完成,T987654324,M123456789,测试

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\resources\config.properties`:

```properties
# config.properties
csv.path=Ai Bill Application/src/main/resources/CSVForm/0001.csv
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\test\java\ControllerTest\AITest.java`:

```java
package ControllerTest;

import Controller.HistogramPanelContainer;
import org.junit.Test;

import javax.swing.*;
import java.awt.*;

public class AITest {

    @Test
    public void testHistogramPanel() throws Exception {
        EventQueue.invokeAndWait(() -> {
            JFrame frame = new JFrame("数据分析界面 - 测试");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });




        // 保持窗口显示一段时间，防止测试结束时窗口立即关闭
        Thread.sleep(5000);
    }

}




```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\test\java\ControllerTest\MenuUITest.java`:

```java
package ControllerTest;

import Controller.HistogramExample;
import Controller.HistogramPanelContainer;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.io.IOException;
import Controller.MenuUI;

import Service.Impl.TransactionServiceImpl;

import Service.Impl.TransactionServiceImpl;

import DAO.CsvTransactionDao;

public class MenuUITest {

    private MenuUI menuUI;

    @BeforeEach
    public void setUp() {
        menuUI = new MenuUI();

        // 手动初始化 TransactionServiceImpl 的 csvTransactionDao
        TransactionServiceImpl.csvTransactionDao = new CsvTransactionDao();
    }

    @Test
    public void testSearchFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取输入字段和搜索按钮
        JTextField transactionTimeField = findTextField(inputPanel, 0);
        JTextField transactionTypeField = findTextField(inputPanel, 1);
        JTextField counterpartyField = findTextField(inputPanel, 2);
        JTextField commodityField = findTextField(inputPanel, 3);
        JComboBox<String> inOutComboBox = findComboBox(inputPanel);
        JTextField paymentMethodField = findTextField(inputPanel, 4);
        JButton searchButton = findButton(inputPanel,"Search");

        assertNotNull(transactionTimeField, "交易时间输入字段不应为空");
        assertNotNull(transactionTypeField, "交易类型输入字段不应为空");
        assertNotNull(counterpartyField, "交易对方输入字段不应为空");
        assertNotNull(commodityField, "商品输入字段不应为空");
        assertNotNull(inOutComboBox, "收/支下拉框不应为空");
        assertNotNull(paymentMethodField, "支付方式输入字段不应为空");
        assertNotNull(searchButton, "搜索按钮不应为空");

        // 设置搜索条件
        transactionTimeField.setText("2025/3/14 11:48"); // 交易时间
        transactionTypeField.setText("商户消费");       // 交易类型
        counterpartyField.setText("物美WUMART");         // 交易对方
        commodityField.setText("扫码支付");            // 商品
        inOutComboBox.setSelectedItem("支出");     // 收/支
        paymentMethodField.setText("零钱");    // 支付方式

        // 模拟点击搜索按钮
        searchButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证搜索结果是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);

            // 验证每一行数据是否符合搜索条件
            assertTrue(rowTransactionTime.contains("2025/3/14 11:48"), "交易时间应符合搜索条件");
            assertTrue(rowTransactionType.contains("商户消费"), "交易类型应符合搜索条件");
            assertTrue(rowCounterparty.contains("物美WUMART"), "交易对方应符合搜索条件");
            assertTrue(rowCommodity.contains("扫码支付"), "商品应符合搜索条件");
            assertTrue(rowInOut.contains("支出"), "收/支应符合搜索条件");
            assertTrue(rowPaymentMethod.contains("零钱"), "支付方式应符合搜索条件");
        }
    }

    @Test
    public void testDeleteFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 获取初始行数
        int initialRowCount = tableModel.getRowCount();

        // 模拟删除第一行
        menuUI.deleteRow(0);

        // 验证行数是否减少
        assertEquals(initialRowCount - 1, tableModel.getRowCount(), "删除后行数应减少");

        // 验证删除后的数据是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            assertNotEquals("2025/3/14 11:48", rowTransactionTime, "删除的行不应再出现在表格中");
        }
    }

    @Test
    public void testEditFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 模拟编辑第一行
        menuUI.editRow(0);

        // 验证编辑后的数据是否正确
        String editedTransactionTime = (String) tableModel.getValueAt(0, 0);
        String editedTransactionType = (String) tableModel.getValueAt(0, 1);
        String editedCounterparty = (String) tableModel.getValueAt(0, 2);
        String editedCommodity = (String) tableModel.getValueAt(0, 3);
        String editedInOut = (String) tableModel.getValueAt(0, 4);
        String editedPaymentMethod = (String) tableModel.getValueAt(0, 6);

        // 验证编辑后的数据是否符合预期
        assertNotNull(editedTransactionTime, "编辑后的交易时间不应为空");
        assertNotNull(editedTransactionType, "编辑后的交易类型不应为空");
        assertNotNull(editedCounterparty, "编辑后的交易对方不应为空");
        assertNotNull(editedCommodity, "编辑后的商品不应为空");
        assertNotNull(editedInOut, "编辑后的收/支不应为空");
        assertNotNull(editedPaymentMethod, "编辑后的支付方式不应为空");
    }

    @Test
    public void testAddFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取 Add 按钮
        JButton addButton = findButton(inputPanel, "Add");
        assertNotNull(addButton, "Add 按钮不应为空");

        // 模拟点击 Add 按钮
        addButton.doClick();

        // 获取对话框
        Window[] windows = Window.getWindows();
        JDialog addDialog = null;
        for (Window window : windows) {
            if (window instanceof JDialog && "添加交易".equals(((JDialog) window).getTitle())) {
                addDialog = (JDialog) window;
                break;
            }
        }
        assertNotNull(addDialog, "添加交易的对话框应弹出");

        // 获取对话框中的输入字段
        JTextField transactionTimeField = findTextField(addDialog.getContentPane(), 0);
        JTextField transactionTypeField = findTextField(addDialog.getContentPane(), 1);
        JTextField counterpartyField = findTextField(addDialog.getContentPane(), 2);
        JTextField commodityField = findTextField(addDialog.getContentPane(), 3);
        JComboBox<String> inOutComboBox = findComboBox(addDialog.getContentPane());
        JTextField paymentAmountField = findTextField(addDialog.getContentPane(), 4);
        JTextField paymentMethodField = findTextField(addDialog.getContentPane(), 5);
        JTextField currentStatusField = findTextField(addDialog.getContentPane(), 6);
        JTextField orderNumberField = findTextField(addDialog.getContentPane(), 7);
        JTextField merchantNumberField = findTextField(addDialog.getContentPane(), 8);
        JTextField remarksField = findTextField(addDialog.getContentPane(), 9);

        // 设置新交易的输入值
        transactionTimeField.setText("2025/3/15 12:00"); // 交易时间
        transactionTypeField.setText("转账");            // 交易类型
        counterpartyField.setText("张三");               // 交易对方
        commodityField.setText("转账");                 // 商品
        inOutComboBox.setSelectedItem("支出");          // 收/支
        paymentAmountField.setText("100.0");            // 金额(元)
        paymentMethodField.setText("银行卡");           // 支付方式
        currentStatusField.setText("已完成");           // 当前状态
        orderNumberField.setText("123456789");          // 交易单号
        merchantNumberField.setText("987654321");       // 商户单号
        remarksField.setText("测试备注");               // 备注

        // 获取确认按钮
        JButton confirmButton = findButton(addDialog.getContentPane(), "确认");
        assertNotNull(confirmButton, "确认按钮不应为空");

        // 模拟点击确认按钮
        confirmButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证新交易是否添加到表格中
        boolean isTransactionAdded = false;
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentAmount = (String) tableModel.getValueAt(i, 5);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);
            String rowCurrentStatus = (String) tableModel.getValueAt(i, 7);
            String rowOrderNumber = (String) tableModel.getValueAt(i, 8);
            String rowMerchantNumber = (String) tableModel.getValueAt(i, 9);
            String rowRemarks = (String) tableModel.getValueAt(i, 10);

            if (rowTransactionTime.equals("2025/3/15 12:00") &&
                    rowTransactionType.equals("转账") &&
                    rowCounterparty.equals("张三") &&
                    rowCommodity.equals("转账") &&
                    rowInOut.equals("支出") &&
                    rowPaymentAmount.equals("100.0") &&
                    rowPaymentMethod.equals("银行卡") &&
                    rowCurrentStatus.equals("已完成") &&
                    rowOrderNumber.equals("123456789") &&
                    rowMerchantNumber.equals("987654321") &&
                    rowRemarks.equals("测试备注")) {
                isTransactionAdded = true;
                break;
            }
        }

        // 验证新交易是否成功添加
        assertTrue(isTransactionAdded, "新交易应成功添加到表格中");
    }

    /**
     * 显示界面以便手动验证
     *
     * @param panel 要显示的面板
     */
    private void showUI(JPanel panel) {
        JFrame frame = new JFrame("MenuUI Test");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(1200, 600);
        frame.add(panel);
        frame.setVisible(true);

        // 保持界面显示一段时间（5秒）
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        frame.dispose(); // 关闭界面
    }

    /**
     * 查找输入面板
     *
     * @param mainPanel 主面板
     * @return 输入面板
     */
    private JPanel findInputPanel(JPanel mainPanel) {
        // 获取右边的面板
        Component[] components = mainPanel.getComponents();
        JPanel rightPanel = null;
        for (Component component : components) {
            if (component instanceof JPanel && ((JPanel) component).getComponentCount() > 0) {
                rightPanel = (JPanel) component;
                break;
            }
        }

        if (rightPanel != null) {
            // 在右边面板中查找输入面板
            for (Component component : rightPanel.getComponents()) {
                if (component instanceof JPanel) {
                    JPanel panel = (JPanel) component;
                    System.out.println("Panel found: " + panel.getName()); // 打印面板名称
                    if (panel.getComponentCount() > 0 && panel.getComponent(0) instanceof JLabel) {
                        return panel; // 输入面板通常包含 JLabel
                    }
                }
            }
        }
        return null;
    }

    /**
     * 查找输入字段
     *
     * @param container     输入面板
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0;
        for (Component component : container.getComponents()) {
            if (component instanceof JTextField) {
                if (count == index) {
                    return (JTextField) component;
                }
                count++;
            }
        }
        return null;
    }


    /**
     * 查找下拉框
     *
     * @param container 输入面板
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) {
            if (component instanceof JComboBox) {
                return (JComboBox<String>) component;
            }
        }
        return null;
    }

    /**
     * 查找按钮
     *
     * @param panel 输入面板
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container  容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    private JButton findButton(Container container, String buttonText) {
        for (Component component : container.getComponents()) {
            if (component instanceof JButton) {
                JButton button = (JButton) component;
                if (button.getText().equals(buttonText)) {
                    return button;
                }
            }
        }
        return null;
    }
}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\test\java\DAOTest\CsvTransactionDaoTest.java`:

```java
package DAOTest;

import DAO.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static Constants.ConfigConstants.CSV_PATH;
import static org.assertj.core.api.Assertions.*;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

class CsvTransactionDaoTest {
    // 测试文件路径（根据实际结构调整）
    private static final String TEST_CSV_PATH = CSV_PATH;
    private static CsvTransactionDao dao;

    @Test
    void testLoadFromCSV_ValidFile_ReturnsTransactions() throws Exception {
        // Given
        CsvTransactionDao dao = new CsvTransactionDao();

        // When
        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);

        // 验证第一条记录的字段
        for (int i = 0; i < transactions.size(); i++) {
            System.out.println(transactions.get(i).getRemarks());
            System.out.println(transactions.get(i).getCommodity());
        }


    }
    @Test
    void testAddTransaction() throws IOException {
        dao=new CsvTransactionDao();
        Transaction newTx = new Transaction(
                "2025-03-09 10:00",
                "转账",
                "小明",
                "书籍",
                "支",
                99.99,
                "微信",
                "已完成",
                "TX123456",
                "M789012",
                "");

        dao.addTransaction("src/test/resources/001.csv", newTx);

        List<Transaction> transactions = dao.loadFromCSV(TEST_CSV_PATH);

    }

    @Test
    void testDeleteTransaction() throws IOException {
        dao=new CsvTransactionDao();

        dao.deleteTransaction("CSV_RELATIVE_PATH", "4200057899202502250932735481");

        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);
    }
    @Test
    void testChangeInfo() throws IOException{
        dao=new CsvTransactionDao();
        dao.changeInformation("TX123456","remarks","测试修改信息",TEST_CSV_PATH);
        dao.changeInformation("TX123456","paymentAmount","116156",TEST_CSV_PATH);
    }

}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\test\java\Service\AIAnalyzerThreadTest.java`:

```java
package Service;



import Service.AIservice.AIAnalyzerThread;
import org.junit.jupiter.api.Test;

public class AIAnalyzerThreadTest {

    @Test
    public void testRunAIAnalyzerThread() throws InterruptedException {
        String userRequest = "请帮我分析最近的交易收支情况";
        String filePath = "src/test/resources/sample_transactions.csv";
        String startTimeStr = "2025/03/20";
        String endTimeStr = "";

        // 启动线程
        Thread thread = new Thread(new AIAnalyzerThread(userRequest, filePath, startTimeStr, endTimeStr));
        thread.start();

        // 等待线程执行完成
        thread.join();
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\test\java\Service\AIserviceTest.java`:

```java
package Service;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

public class AIserviceTest {

    @Test
    public void testAnalyzeTransactions() {
        AITransactionService service = new AITransactionService();

        String userRequest = "请帮我分析这个月的收支情况";
        String filePath = "src/test/resources/sample_transactions.csv";

        String result = service.analyzeTransactions(userRequest, filePath,"2025/03/20","");

        assertNotNull(result, "AI分析结果不能为空");
        System.out.println("AI分析结果: " + result);
    }


}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\test\java\Service\AiFunctionTest.java`:

```java
package Service;

import DAO.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

import java.io.IOException;
import java.util.List;

public class AiFunctionTest {

    @Test
    public void testAnalyzeTransactions() throws IOException {

        String filePath = "src/test/resources/sample_transactions.csv";
        CsvTransactionDao transactionDao = new CsvTransactionDao();

        List<Transaction> transactions = transactionDao.loadFromCSV(filePath);

        // 实例化服务类
        AITransactionService service = new AITransactionService();

        // 调用合并格式化函数
        List<String> result = service.formatTransactions(transactions,"2025/03/29","2025/04/10");

        // 输出结果
        result.forEach(System.out::println);
    }




}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\test\java\Service\CacheTest.java`:

```java
package Service;

import Constants.CaffeineKeys;
import DAO.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import com.github.benmanes.caffeine.cache.Caffeine;
import model.Transaction;
import org.junit.jupiter.api.Test;

import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;

public class CacheTest {

    TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());

    @Test
    void DeleteCache(){
        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;
        cache.invalidate(TRANSACTION_CAFFEINE_KEY);
    }

}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\test\java\Service\CollegeStudentNeedsTest.java`:

```java
package Service;

import Service.AIservice.ColledgeStudentThread;
import Service.AIservice.CollegeStudentNeeds;
import org.junit.jupiter.api.*;

import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.*;

// No @ExtendWith needed as we are not using Mockito extensions
class CollegeStudentNeedsTest {



    private CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
    private static final String TEST_CSV_FILENAME = "src/test/resources/001.csv";
    @Test
    public void testGenerateBudget() throws IOException, InterruptedException {
        Thread t=new Thread( new ColledgeStudentThread(TEST_CSV_FILENAME));
        t.start();
        t.join();
//        collegeStudentNeeds.generateBudget(TEST_CSV_FILENAME);
    }
    @Test
    public void testParseStringToDouble(){
        String s="asdas[369.39,1090.1]das";
        double[] arr=collegeStudentNeeds.parseDoubleArrayFromString(s);
        System.out.println(arr[0]+" "+arr[1]);
    }


}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\test\java\Service\TransactionServiceTest.java`:

```java
package Service;

import DAO.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import model.Transaction;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.io.IOException;
import java.util.List;

class TransactionServiceTest {
    private TransactionService transactionService;

    @BeforeEach
    void setUp() {
        // 初始化 DAO 和 Service
        CsvTransactionDao csvTransactionDao = new CsvTransactionDao();
        transactionService = new TransactionServiceImpl(csvTransactionDao);
    }

    @Test
    void testAddTransaction() throws IOException {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );

        // 执行添加操作
        transactionService.addTransaction(transaction);

        // 验证是否添加成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertFalse(transactions.isEmpty());
        assertEquals("T123456789", transactions.get(0).getOrderNumber());
    }

    @Test
    void testChangeTransaction() throws Exception {
        // 准备测试数据
        Transaction originalTransaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(originalTransaction);

        // 准备更新数据
        Transaction updatedTransaction = new Transaction(
                null, "充值", null, null, null, 0.0, "微信支付", null, "T123456789", null, "更新备注"
        );

        // 执行更新操作
        transactionService.changeTransaction(updatedTransaction);

        // 验证是否更新成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertEquals("充值", transactions.get(0).getTransactionType());
        assertEquals("微信支付", transactions.get(0).getPaymentMethod());
        assertEquals("更新备注", transactions.get(0).getRemarks());
    }

    @Test
    void testDeleteTransaction() throws Exception {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(transaction);

        // 执行删除操作
        boolean result = transactionService.deleteTransaction("T123456789");

        // 验证是否删除成功
        assertTrue(result);
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertTrue(transactions.isEmpty());
    }

    @Test
    void testSearchTransaction() throws IOException {

        // 设置搜索条件
        Transaction searchCriteria = new Transaction();
        searchCriteria.setCounterparty("支付宝");

        // 执行搜索操作
        List<Transaction> result = transactionService.searchTransaction(searchCriteria);

        // 验证搜索结果
        result.forEach(res -> System.out.println(res.getCommodity()));
    }


}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai-Bill-Application-Prompt.txt`:

```txt
Project Path: Ai-Bill-Application-Group21

Source Tree:

```txt
Ai-Bill-Application-Group21
└── Ai Bill Application
    ├── HistogramPanelContainer.java
    └── src
        ├── main
        │   └── java
        │       ├── Constants
        │       │   ├── CaffeineKeys.java
        │       │   └── ConfigConstants.java
        │       ├── Controller
        │       │   ├── ButtonEditor.java
        │       │   ├── ButtonRenderer.java
        │       │   ├── HistogramExample.java
        │       │   ├── HistogramPanelContainer.java
        │       │   └── MenuUI.java
        │       ├── DAO
        │       │   ├── CsvTransactionDao.java
        │       │   └── TransactionDao.java
        │       ├── Interceptor
        │       │   └── Login
        │       │       ├── LoginDialog.java
        │       │       └── UserService.java
        │       ├── Main.java
        │       ├── Service
        │       │   ├── AIservice
        │       │   │   ├── AIAnalyzerThread.java
        │       │   │   ├── AITransactionService.java
        │       │   │   ├── ColledgeStudentThread.java
        │       │   │   └── CollegeStudentNeeds.java
        │       │   ├── Impl
        │       │   │   └── TransactionServiceImpl.java
        │       │   ├── TransactionService.java
        │       │   └── deepseek
        │       │       └── ChatCompletionsExample.java
        │       ├── Utils
        │       │   └── CacheUtil.java
        │       └── model
        │           └── Transaction.java
        └── test
            └── java
                ├── ControllerTest
                │   ├── AITest.java
                │   └── MenuUITest.java
                ├── DAOTest
                │   └── CsvTransactionDaoTest.java
                └── Service
                    ├── AIAnalyzerThreadTest.java
                    ├── AIserviceTest.java
                    ├── AiFunctionTest.java
                    ├── CacheTest.java
                    ├── CollegeStudentNeedsTest.java
                    └── TransactionServiceTest.java

```

`Ai-Bill-Application-Group21/Ai Bill Application\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Constants\CaffeineKeys.java`:

```java
package Constants;

public class CaffeineKeys {
    public static final String TRANSACTION_CAFFEINE_KEY = "transactions";

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Constants\ConfigConstants.java`:

```java
package Constants;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

/**
 * 配置常量类（线程安全初始化）
 */
public final class ConfigConstants {
    // 私有构造防止实例化
    private ConfigConstants() {}

    /**
     * transactionCSV路径加载逻辑
     */
    // CSV路径常量
    public static final String CSV_PATH;
    // 静态初始化块（类加载时执行）
    static {
        Properties prop = new Properties();
        try (InputStream input = ConfigConstants.class.getClassLoader()
                .getResourceAsStream("config.properties")) {

            prop.load(input);
            CSV_PATH = prop.getProperty("csv.path");
        } catch (IOException e) {
            throw new RuntimeException("加载配置文件失败", e); // 转换为运行时异常
        }
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\ButtonEditor.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.TableCellEditor;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

class ButtonEditor extends AbstractCellEditor implements TableCellEditor {
    private final JPanel panel = new JPanel(new BorderLayout()); // 使用 BorderLayout
    private final JButton button = new JButton();
    private int rowIndex;
    private final MenuUI menuUI;

    public ButtonEditor(MenuUI menuUI) {
        this.menuUI = menuUI;

        // 设置按钮样式
        button.setFocusPainted(false); // 移除按钮的焦点边框
        button.setPreferredSize(new Dimension(80, 30)); // 设置按钮的固定尺寸

        // 添加按钮到面板
        panel.add(button, BorderLayout.CENTER);

        // 为按钮添加事件监听器
        button.addActionListener(e -> {
            System.out.println("按钮点击事件触发: " + button.getText());
            fireEditingStopped(); // 停止编辑
            String buttonText = button.getText();
            if ("Modify".equals(buttonText)) {
                menuUI.editRow(rowIndex); // 调用 MenuUI 的 editRow 方法
            } else if ("Delete".equals(buttonText)) {
                int confirm = JOptionPane.showConfirmDialog(panel, "确定要删除此行吗？", "确认删除", JOptionPane.YES_NO_OPTION);
                if (confirm == JOptionPane.YES_OPTION) {
                    menuUI.deleteRow(rowIndex); // 调用 MenuUI 的 deleteRow 方法
                }
            }
        });
    }

    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
        this.rowIndex = row; // 更新当前行索引
        button.setText(value != null ? value.toString() : ""); // 根据单元格的值设置按钮文本
        return panel;
    }

    @Override
    public Object getCellEditorValue() {
        return button.getText(); // 返回按钮的当前文本
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\ButtonRenderer.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import java.awt.*;

class ButtonRenderer extends DefaultTableCellRenderer {
    private final JPanel panel = new JPanel(new BorderLayout()); // 使用 BorderLayout
    private final JButton button = new JButton();

    public ButtonRenderer() {
        button.setFocusPainted(false); // 移除按钮的焦点边框
        button.setPreferredSize(new Dimension(80, 30)); // 设置按钮的固定尺寸
        panel.add(button, BorderLayout.CENTER); // 将按钮添加到面板中心
    }

    @Override
    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
        // 根据单元格的值设置按钮文本
        button.setText(value != null ? value.toString() : "");
        return panel;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\HistogramExample.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;
import java.util.HashMap;
import java.util.Random;

// 数据生成类
class DataGenerator {
    public static int[] generateData(int numberOfDataPoints, int maxValue) {
        Random random = new Random();
        int[] data = new int[numberOfDataPoints];
        for (int i = 0; i < numberOfDataPoints; i++) {
            data[i] = random.nextInt(maxValue);
        }
        return data;
    }
}

// 直方图计算类
class Histogram {
    private int binSize;
    private int[] data;

    public Histogram(int[] data, int binSize) {
        this.data = data;
        this.binSize = binSize;
    }

    public HashMap<Integer, Integer> computeFrequency() {
        HashMap<Integer, Integer> frequencyMap = new HashMap<>();
        for (int number : data) {
            int bin = number / binSize;
            frequencyMap.put(bin, frequencyMap.getOrDefault(bin, 0) + 1);
        }
        return frequencyMap;
    }
}

// 直方图 GUI 绘制类
class HistogramPanel extends JPanel {
    HashMap<Integer, Integer> frequencyMap;

    public HistogramPanel() {
        this.frequencyMap = new HashMap<>();
    }

    public void updateData(HashMap<Integer, Integer> frequencyMap) {
        this.frequencyMap = frequencyMap;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        int barWidth = 40;
        int gap = 10;
        int maxFrequency = frequencyMap.values().stream().mapToInt(v -> v).max().orElse(1);

        int index = 0;
        for (Integer key : frequencyMap.keySet()) {
            int height = (int) ((frequencyMap.get(key) / (double) maxFrequency) * getHeight());
            g.setColor(Color.BLUE);
            g.fillRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.setColor(Color.BLACK);
            g.drawRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.drawString("Bin " + key, index * (barWidth + gap) + 5, getHeight() - 5);
            index++;
        }
    }
}


// 主窗口类
public class HistogramExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("数据分析界面");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\MenuUI.java`:

```java
package Controller;

import Constants.ConfigConstants;
import DAO.CsvTransactionDao;

import Service.Impl.TransactionServiceImpl;

import Service.Impl.TransactionServiceImpl;

import Utils.CacheUtil;
import model.Transaction;

import javax.swing.*;
import java.awt.*;
import java.io.IOException;
import java.util.List;
import java.util.Vector;
import javax.swing.table.DefaultTableModel;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class MenuUI {
    private static final String FILE_PATH = CSV_PATH;
    private static DefaultTableModel tableModel;
    private static Vector<Vector<String>> allData = new Vector<>();
    private static TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());
    private JTable table;  // 把table定义为静态字段
    private HistogramPanelContainer histogramPanelContainer; // 添加 HistogramPanelContainer 实例
    private JPanel rightPanel; // 右边的面板，用于显示搜索和表格界面或 AI 界面
    private CardLayout cardLayout; // 用于管理界面切换的布局

    public MenuUI(){
        String[] columnNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注", "Modify", "Delete"};
        tableModel = new DefaultTableModel(columnNames, 0);
        table = new JTable(tableModel);

        histogramPanelContainer = new HistogramPanelContainer(); // 初始化 HistogramPanelContainer
        cardLayout = new CardLayout(); // 初始化 CardLayout
        rightPanel = new JPanel(cardLayout); // 初始化 rightPanel
    }

    public JPanel createMainPanel() {
        // 主面板，使用 BorderLayout
        JPanel mainPanel = new JPanel(new BorderLayout());

        // 左边的面板，包含 Menu 和 AI 按钮
        JPanel leftPanel = createLeftPanel();
        mainPanel.add(leftPanel, BorderLayout.WEST);

        // 右边的面板，用于显示搜索和表格界面或 AI 界面
        setupRightPanel();
        mainPanel.add(rightPanel, BorderLayout.CENTER);

        return mainPanel;
    }

    // 创建左边的面板，包含 Menu 和 AI 按钮
    private JPanel createLeftPanel() {
        JPanel leftPanel = new JPanel(new GridLayout(2, 1));
        JButton menuButton = new JButton("Menu");
        JButton aiButton = new JButton("AI");

        leftPanel.add(menuButton);
        leftPanel.add(aiButton);

        // 为 Menu 按钮添加 ActionListener
        menuButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Table"); // 切换到表格界面
        });

        // 为 AI 按钮添加 ActionListener
        aiButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Histogram"); // 切换到直方图界面
        });

        return leftPanel;
    }

    // 设置右边的面板，包含搜索和表格界面或 AI 界面
    private void setupRightPanel() {
        // 创建搜索和表格的面板
        JPanel tablePanel = createTablePanel();

        // 将表格面板和直方图面板添加到 rightPanel
        rightPanel.add(tablePanel, "Table");
        rightPanel.add(histogramPanelContainer, "Histogram");
    }

    // 创建搜索和表格的面板
    private JPanel createTablePanel() {
        JPanel tablePanel = new JPanel(new BorderLayout());

        // 创建输入面板
        JPanel inputPanel = createInputPanel();
        tablePanel.add(inputPanel, BorderLayout.NORTH);

        // 创建表格的滚动面板
        JScrollPane tableScrollPane = new JScrollPane(table);
        tableScrollPane.setPreferredSize(new Dimension(1000, 250));
        table.setRowHeight(30); // 设置表格的行高

        tablePanel.add(tableScrollPane, BorderLayout.CENTER);

        // 为 Modify 列设置渲染器和编辑器
        table.getColumnModel().getColumn(11).setCellRenderer(new ButtonRenderer());
        table.getColumnModel().getColumn(11).setCellEditor(new ButtonEditor(this));

        // 为 Delete 列设置渲染器和编辑器
        table.getColumnModel().getColumn(12).setCellRenderer(new ButtonRenderer());
        table.getColumnModel().getColumn(12).setCellEditor(new ButtonEditor(this));

        // 加载 CSV 数据
        loadCSVData(FILE_PATH);

        return tablePanel;
    }

    // 创建输入面板
    private JPanel createInputPanel() {
        JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));

        // 创建输入字段
        JTextField transactionTimeField = new JTextField(10); // 交易时间输入框
        JTextField transactionTypeField = new JTextField(10); // 交易类型输入框
        JTextField counterpartyField = new JTextField(10);    // 交易对方输入框
        JTextField commodityField = new JTextField(10);      // 商品输入框
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"}); // 收/支下拉框
        JTextField paymentMethodField = new JTextField(10);  // 支付方式输入框

        // 添加标签和输入字段到输入面板
        inputPanel.add(new JLabel("交易时间:"));
        inputPanel.add(transactionTimeField);
        inputPanel.add(new JLabel("交易类型:"));
        inputPanel.add(transactionTypeField);
        inputPanel.add(new JLabel("交易对方:"));
        inputPanel.add(counterpartyField);
        inputPanel.add(new JLabel("商品:"));
        inputPanel.add(commodityField);
        inputPanel.add(new JLabel("收/支:"));
        inputPanel.add(inOutComboBox);
        inputPanel.add(new JLabel("支付方式:"));
        inputPanel.add(paymentMethodField);

        // 创建 Search 和 Add 按钮
        JButton searchButton = new JButton("Search");
        JButton addButton = new JButton("Add");

        // 将按钮添加到输入面板
        inputPanel.add(searchButton);
        inputPanel.add(addButton);

        // 为 Search 按钮添加 ActionListener
        searchButton.addActionListener(e -> {
            // 获取输入字段的值
            searchData(
                    transactionTimeField.getText().trim(),
                    transactionTypeField.getText().trim(),
                    counterpartyField.getText().trim(),
                    commodityField.getText().trim(),
                    (String) inOutComboBox.getSelectedItem(),
                    paymentMethodField.getText().trim()
            );
        });

        // 为 Add 按钮添加 ActionListener
        addButton.addActionListener(e -> {
            // 弹出对话框，输入交易信息
            showAddTransactionDialog();
        });

        return inputPanel;
    }

    // 弹出对话框，输入交易信息
    private void showAddTransactionDialog() {
        // 创建对话框
        JDialog addDialog = new JDialog();
        addDialog.setTitle("添加交易");
        addDialog.setLayout(new GridLayout(12, 2)); // 11 个字段 + 1 个按钮行

        // 创建输入字段
        JTextField transactionTimeField = new JTextField();
        JTextField transactionTypeField = new JTextField();
        JTextField counterpartyField = new JTextField();
        JTextField commodityField = new JTextField();
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"});
        JTextField paymentAmountField = new JTextField();
        JTextField paymentMethodField = new JTextField();
        JTextField currentStatusField = new JTextField();
        JTextField orderNumberField = new JTextField();
        JTextField merchantNumberField = new JTextField();
        JTextField remarksField = new JTextField();

        // 添加标签和输入字段到对话框
        addDialog.add(new JLabel("交易时间:"));
        addDialog.add(transactionTimeField);
        addDialog.add(new JLabel("交易类型:"));
        addDialog.add(transactionTypeField);
        addDialog.add(new JLabel("交易对方:"));
        addDialog.add(counterpartyField);
        addDialog.add(new JLabel("商品:"));
        addDialog.add(commodityField);
        addDialog.add(new JLabel("收/支:"));
        addDialog.add(inOutComboBox);
        addDialog.add(new JLabel("金额(元):"));
        addDialog.add(paymentAmountField);
        addDialog.add(new JLabel("支付方式:"));
        addDialog.add(paymentMethodField);
        addDialog.add(new JLabel("当前状态:"));
        addDialog.add(currentStatusField);
        addDialog.add(new JLabel("交易单号:"));
        addDialog.add(orderNumberField);
        addDialog.add(new JLabel("商户单号:"));
        addDialog.add(merchantNumberField);
        addDialog.add(new JLabel("备注:"));
        addDialog.add(remarksField);

        // 添加确认按钮
        JButton confirmButton = new JButton("确认");
        confirmButton.addActionListener(e -> {
            // 获取输入字段的值，若为空则设置为默认值
            String transactionTime = emptyIfNull(transactionTimeField.getText().trim());
            String transactionType = emptyIfNull(transactionTypeField.getText().trim());
            String counterparty = emptyIfNull(counterpartyField.getText().trim());
            String commodity = emptyIfNull(commodityField.getText().trim());
            String inOut = (String) inOutComboBox.getSelectedItem();
            String paymentAmountText = paymentAmountField.getText().trim();
            double paymentAmount = paymentAmountText.isEmpty() ? 0.0 : Double.parseDouble(paymentAmountText); // 处理空字符串
            String paymentMethod = emptyIfNull(paymentMethodField.getText().trim());
            String currentStatus = emptyIfNull(currentStatusField.getText().trim());
            String orderNumber = emptyIfNull(orderNumberField.getText().trim());
            String merchantNumber = emptyIfNull(merchantNumberField.getText().trim());
            String remarks = emptyIfNull(remarksField.getText().trim());

            // 创建 Transaction 对象
            Transaction newTransaction = new Transaction(
                    transactionTime,
                    transactionType,
                    counterparty,
                    commodity,
                    inOut,
                    paymentAmount,
                    paymentMethod,
                    currentStatus,
                    orderNumber,
                    merchantNumber,
                    remarks
            );

            try {
                // 调用 TransactionServiceImpl 的 addTransaction 方法
                transactionService.addTransaction(newTransaction);

                // 重新加载 CSV 数据以更新表格
                loadCSVData(TRANSACTION_CAFFEINE_KEY);

                // 关闭对话框
                addDialog.dispose();

                JOptionPane.showMessageDialog(null, "交易添加成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(null, "交易添加失败！", "错误", JOptionPane.ERROR_MESSAGE);
            }
        });

        addDialog.add(confirmButton);

        // 设置对话框大小并显示
        addDialog.setSize(400, 300);
        addDialog.setModal(true); // 设置为模态对话框
        addDialog.setVisible(true);
    }

    // 加载 CSV 数据
    public void loadCSVData(String caffeineKey) {
        allData.clear();
        tableModel.setRowCount(0);

        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;

//        CsvTransactionDao csvTransactionDao = new CsvTransactionDao();

        List<Transaction> transactions = cache.get(caffeineKey);
        for (Transaction transaction : transactions) {
            Vector<String> row = createRowFromTransaction(transaction);
            allData.add(row);
            tableModel.addRow(row);
        }
    }

    // 搜索数据
    public void searchData(String query1, String query2, String query3, String query4, String query6, String query5) {
        tableModel.setRowCount(0);
        Transaction searchCriteria = new Transaction(query1, query2, query3, query4, query6, 0, query5, "", "", "", "");

        try {
            List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);
            for (Transaction transaction : transactions) {
                Vector<String> row = createRowFromTransaction(transaction);
                tableModel.addRow(row);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(null, "查询失败！", "错误", JOptionPane.ERROR_MESSAGE);
        }
    }

    // 从 Transaction 对象创建表格行
    private Vector<String> createRowFromTransaction(Transaction transaction) {
        Vector<String> row = new Vector<>();
        row.add(transaction.getTransactionTime());
        row.add(transaction.getTransactionType());
        row.add(transaction.getCounterparty());
        row.add(transaction.getCommodity());
        row.add(transaction.getInOut());
        row.add(String.valueOf(transaction.getPaymentAmount()));
        row.add(transaction.getPaymentMethod());
        row.add(transaction.getCurrentStatus());
        row.add(transaction.getOrderNumber());
        row.add(transaction.getMerchantNumber());
        row.add(transaction.getRemarks());
        row.add("Modify"); // Modify 按钮
        row.add("Delete"); // 添加 Delete 按钮
        return row;
    }

    // 删除行
    public void deleteRow(int rowIndex) {
        if (rowIndex >= 0 && rowIndex < allData.size()) {
            String orderNumber = allData.get(rowIndex).get(8).trim();
            System.out.println("尝试删除的交易单号: " + orderNumber); // 打印交易单号

            try {
                if (transactionService.deleteTransaction(orderNumber)) {
                    allData.remove(rowIndex);
                    tableModel.removeRow(rowIndex);
                    JOptionPane.showMessageDialog(null, "删除成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                } else {
                    JOptionPane.showMessageDialog(null, "删除失败：未找到对应的交易单号", "错误", JOptionPane.ERROR_MESSAGE);
                }
            } catch (IOException ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(null, "删除失败！", "错误", JOptionPane.ERROR_MESSAGE);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    // 编辑行
    public void editRow(int rowIndex) {
        System.out.println("编辑行: " + rowIndex);
        if (rowIndex >= 0 && rowIndex < allData.size()) {
            Vector<String> rowData = allData.get(rowIndex);

            // 创建一个面板用于显示编辑字段
            JPanel panel = new JPanel(new GridLayout(rowData.size() - 2, 2)); // 排除最后两列

            // 创建字段数组，用于存储用户输入的值
            JTextField[] fields = new JTextField[rowData.size() - 2]; // 排除最后两列

            // 遍历 rowData，跳过最后两列（"Modify" 和 "Delete"）
            for (int i = 0; i < rowData.size() - 2; i++) {
                panel.add(new JLabel(tableModel.getColumnName(i))); // 添加列名标签
                fields[i] = new JTextField(rowData .get(i)); // 添加输入字段
                panel.add(fields[i]);
            }

            // 弹出对话框，让用户修改数据
            int result = JOptionPane.showConfirmDialog(null, panel, "修改交易信息", JOptionPane.OK_CANCEL_OPTION);
            if (result == JOptionPane.OK_OPTION) {
                // 用户点击了确认按钮，更新交易信息
                Transaction transaction = new Transaction(
                        fields[0].getText().trim(), // 交易时间
                        fields[1].getText().trim(), // 交易类型
                        fields[2].getText().trim(), // 交易对方
                        fields[3].getText().trim(), // 商品
                        fields[4].getText().trim(), // 收/支
                        Double.parseDouble(fields[5].getText().trim()), // 金额(元)
                        fields[6].getText().trim(), // 支付方式
                        fields[7].getText().trim(), // 当前状态
                        fields[8].getText().trim(), // 交易单号
                        fields[9].getText().trim(), // 商户单号
                        fields[10].getText().trim() // 备注
                );

                try {
                    // 调用 TransactionServiceImpl 的 changeTransaction 方法更新交易
                    transactionService.changeTransaction(transaction);

                    // 重新加载 CSV 数据以更新表格
                    loadCSVData(TRANSACTION_CAFFEINE_KEY);

                    JOptionPane.showMessageDialog(null, "修改成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                } catch (Exception ex) {
                    ex.printStackTrace();
                    JOptionPane.showMessageDialog(null, "修改失败！", "错误", JOptionPane.ERROR_MESSAGE);
                }
            }
        }
    }

    /**
     * 查找对话框中的输入字段
     *
     * @param dialog 对话框
     * @param index  输入字段的索引
     * @return 输入字段
     */
    /**
     * 查找容器中的输入字段
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0;
        for (Component component : container.getComponents()) {
            if (component instanceof JTextField) {
                if (count == index) {
                    return (JTextField) component;
                }
                count++;
            }
        }
        return null;
    }

    /**
     * 查找对话框中的下拉框
     *
     * @param dialog 对话框
     * @return 下拉框
     */
    /**
     * 查找容器中的下拉框
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) {
            if (component instanceof JComboBox) {
                return (JComboBox<String>) component;
            }
        }
        return null;
    }

    /**
     * 如果字段为 null，则返回空文本
     *
     * @param value 字段值
     * @return 非 null 的字段值
     */
    private String emptyIfNull(String value) {
        return value == null ? "" : value;
    }

    // 添加此方法以便测试时可以获取table
    public JTable getTable() {
        return table;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\DAO\CsvTransactionDao.java`:

```java
package DAO;

import Constants.ConfigConstants;
import model.Transaction;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static Constants.ConfigConstants.CSV_PATH;

public class CsvTransactionDao implements TransactionDao {
    //避免每次都调用loadFromCSV() 方法
    private List<Transaction> transactions;
    private boolean isLoad= false;
//HEAD 交易时间	交易类型	交易对方	商品	收/支	金额(元)	支付方式	当前状态	交易单号	商户单号	备注
    //
    @Override
    public List<Transaction> loadFromCSV(String filePath) throws IOException {
        try (
                Reader reader = new InputStreamReader(
                        new BOMInputStream(Files.newInputStream(Paths.get(filePath))),
                        StandardCharsets.UTF_8)) {
            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()    //根据首行的内容设置为表格的头
                    .withIgnoreHeaderCase(false)  // 禁用忽略大小写
                    .withTrim(false);             // 禁用自动trim（防止意外空格问题）

            try (CSVParser csvParser = new CSVParser(reader, format)) {

                List<Transaction> transactions = new ArrayList<>();
                for (CSVRecord record : csvParser) {
                    Transaction transaction = parseRecord(record);
                    transactions.add(transaction);
                }
                reader.close();
                this.transactions = transactions;
                this.isLoad=true;
                return transactions;
            }
        }
    }


    private Transaction parseRecord(CSVRecord record) {
        return new Transaction(
                record.get("交易时间"),
                record.get("交易类型"),
                record.get("交易对方"),
                record.get("商品"),
                record.get("收/支"),
                Double.parseDouble(record.get("金额(元)").substring(1)),
                record.get("支付方式"),
                record.get("当前状态"),
                record.get("交易单号"),
                record.get("商户单号"),
                record.get("备注")
        );
    }

    // 根据交易单号删除交易记录
    public boolean deleteTransaction(String filePath, String orderNumber) throws IOException {
        if(!isLoad){ loadFromCSV(filePath);}

        List<Transaction> updatedTransactions = transactions.stream()
                .filter(t -> !t.getOrderNumber().trim().equals(orderNumber))
                .collect(Collectors.toList());

        if (transactions.size() == updatedTransactions.size()) {
            return false;
        }

        writeTransactionsToCSV(filePath, updatedTransactions);
        return true;
    }

    // 添加交易
    public void addTransaction(String filePath, Transaction newTransaction) throws IOException {
        boolean fileExists = Files.exists(Paths.get(filePath)) && Files.size(Paths.get(filePath)) > 0;

        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(filePath), StandardOpenOption.CREATE, StandardOpenOption.APPEND);
             CSVPrinter csvPrinter = new CSVPrinter(writer, fileExists ? getCsvFormatWithoutHeader() : getCsvFormatWithHeader(filePath))) {

            csvPrinter.printRecord(
                    newTransaction.getTransactionTime(),
                    newTransaction.getTransactionType(),
                    newTransaction.getCounterparty(),
                    newTransaction.getCommodity(),
                    newTransaction.getInOut(),
                    "¥" + newTransaction.getPaymentAmount(),
                    newTransaction.getPaymentMethod(),
                    newTransaction.getCurrentStatus(),
                    newTransaction.getOrderNumber(),
                    newTransaction.getMerchantNumber(),
                    newTransaction.getRemarks()
            );

            csvPrinter.flush();
        }
    }

    // 统一写回 CSV
    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
        // 1. 创建临时文件（确保与原文件同目录）
        File targetFile = new File(filePath);
        File tempFile = File.createTempFile("transaction_temp", ".csv", targetFile.getParentFile());

        // 2. 写入数据到临时文件（使用 try-with-resources 确保资源释放）
        try (BufferedWriter writer = Files.newBufferedWriter(tempFile.toPath());
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(
                     "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"))) {

            for (Transaction t : transactions) {
                csvPrinter.printRecord(
                        t.getTransactionTime(),
                        t.getTransactionType(),
                        t.getCounterparty(),
                        t.getCommodity(),
                        t.getInOut(),
                        "¥" + t.getPaymentAmount(),
                        t.getPaymentMethod(),
                        t.getCurrentStatus(),
                        t.getOrderNumber(),
                        t.getMerchantNumber(),
                        t.getRemarks()
                );
            }
            csvPrinter.flush(); // 强制刷盘
        } catch (IOException e) {
            tempFile.delete(); // 失败时删除临时文件
            throw e;
        }

        // 3. 原子性替换原文件
        Path source = tempFile.toPath();
        Path target = Paths.get(filePath);
        try {
            Files.move(source, target, StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            System.err.println("移动失败原因: " + e.getMessage());
        }
    }

//    // 统一写回 CSV
//    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
//        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(filePath));
//             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(
//                     "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注")))  {
//
//            for (Transaction t : transactions) {
//                csvPrinter.printRecord(
//                        t.getTransactionTime(),
//                        t.getTransactionType(),
//                        t.getCounterparty(),
//                        t.getCommodity(),
//                        t.getInOut(),
//                        "¥" + t.getPaymentAmount(),
//                        t.getPaymentMethod(),
//                        t.getCurrentStatus(),
//                        t.getOrderNumber(),
//                        t.getMerchantNumber(),
//                        t.getRemarks()
//                );
//            }
//        }
//    }

    // 获取 CSV 格式（包含表头）
    private CSVFormat getCsvFormatWithHeader(String filePath) throws IOException {
        try (BufferedReader reader = Files.newBufferedReader(Paths.get(filePath))) {
            String headerLine = reader.readLine();
            if (headerLine == null || headerLine.trim().isEmpty()) {
                // 如果文件为空或不存在，返回默认表头
                return CSVFormat.DEFAULT.withHeader(
                        "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"
                );
            }
            return CSVFormat.DEFAULT.withHeader(headerLine.split(",")).withTrim();
        }
    }

    // 获取 CSV 格式（不包含表头）
    private CSVFormat getCsvFormatWithoutHeader() {
        return CSVFormat.DEFAULT.withTrim();
    }

    public boolean changeInformation(String orderNumber, String head, String value,String path) throws IOException{
        if(isLoad==false){ loadFromCSV(path);}
        for (int i = 0; i < transactions.size(); i++) {
            if(transactions.get(i).getOrderNumber().trim().equals(orderNumber)){
                Transaction newTransaction=transactions.get(i);
                switch (head){
                    case "transactionTime" :{
                        newTransaction.setTransactionTime(value);
                        break;}
                    case "transactionType" :{
                        newTransaction.setTransactionType(value);
                        break;
                    }
                    case "counterparty" :{
                        newTransaction.setCounterparty(value);
                        break;
                    } case "commodity" :{
                        newTransaction.setCommodity(value);
                        break;
                    } case "inOut" :{
                        newTransaction.setInOut(value);
                        break;
                    } case "paymentAmount" :{
                        newTransaction.setPaymentAmount(Double.parseDouble(value));
                        break;
                    } case "paymentMethod" :{
                        newTransaction.setPaymentMethod(value);
                        break;
                    } case "currentStatus" :{
                        newTransaction.setCurrentStatus(value);
                        break;
                    } case "orderNumber" :{
                        newTransaction.setOrderNumber(value);
                        break;
                    } case "merchantNumber" :{
                        newTransaction.setMerchantNumber(value);
                        break;
                    } case "remarks" :{
                        newTransaction.setRemarks(value);
                        break;
                    } default:{
                        System.err.println("error head");
                    }
                }

                boolean flag=deleteTransaction(path,transactions.get(i).getOrderNumber());
                if(flag) {
                    addTransaction(path,newTransaction);
                    System.out.println("success to delete");
                }
                else System.err.println("failed to delete");
            }
        }
        return true;
    }

    @Override
    public List<Transaction> getAllTransactions() throws IOException {
        return List.of();
    }

    @Override
    public void addTransaction(Transaction transaction) throws IOException {

    }

    @Override
    public boolean deleteTransaction(String orderNumber) throws IOException {
        return false;
    }

    @Override
    public boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException {
        return false;
    }

    @Override
    public Transaction getTransactionByOrderNumber(String orderNumber) throws IOException {
        return null;
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\DAO\TransactionDao.java`:

```java
package DAO;

import model.Transaction;

import java.io.IOException;
import java.util.List;

/**
 * Interface for Data Access Object (DAO) operations related to Transactions.
 * Defines the contract for loading, adding, deleting, and updating transaction data.
 */
public interface
TransactionDao {

    //HEAD 交易时间	交易类型	交易对方	商品	收/支	金额(元)	支付方式	当前状态	交易单号	商户单号	备注
        //
    List<Transaction> loadFromCSV(String filePath) throws IOException;

    /**
     * Loads all transactions from the configured data source.
     *
     * @return A list of all transactions.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<Transaction> getAllTransactions() throws IOException;

    /**
     * Adds a new transaction to the data source.
     *
     * @param transaction The new transaction to add.
     * @throws IOException If an I/O error occurs during saving.
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * Deletes a transaction identified by its order number.
     *
     * @param orderNumber The unique order number of the transaction to delete.
     * @return true if a transaction was found and deleted, false otherwise.
     * @throws IOException If an I/O error occurs during loading or saving.
     */
    boolean deleteTransaction(String orderNumber) throws IOException;

    /**
     * Updates a specific field of an existing transaction identified by its order number.
     *
     * @param orderNumber The unique order number of the transaction to update.
     * @param fieldName   The name of the field to update (e.g., "transactionType", "paymentAmount").
     * @param newValue    The new value for the specified field.
     * @return true if the transaction was found and updated, false otherwise.
     * @throws IOException             If an I/O error occurs during loading or saving.
     * @throws NumberFormatException   If updating 'paymentAmount' and newValue is not a valid double.
     * @throws IllegalArgumentException If the fieldName is invalid.
     */
    boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException;

    /**
     * Retrieves a transaction by its unique order number.
     * (Optional but often useful)
     *
     * @param orderNumber The unique order number.
     * @return The Transaction object if found, null otherwise.
     * @throws IOException If an I/O error occurs during loading.
     */
    Transaction getTransactionByOrderNumber(String orderNumber) throws IOException;

}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Interceptor\Login\LoginDialog.java`:

```java
package Interceptor.Login;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class LoginDialog extends JDialog {
    private boolean loginSuccessful = false;
    private JTextField usernameField;
    private JPasswordField passwordField;
    private UserService userService = new UserService();

    public LoginDialog() {
        setTitle("用户登录");
        setLayout(new GridLayout(3, 2));
        setModal(true);
        setSize(300, 150);

        // 输入组件
        usernameField = new JTextField();
        passwordField = new JPasswordField();
        JButton loginButton = new JButton("登录");
        JButton cancelButton = new JButton("取消");

        // 添加组件
        add(new JLabel("用户名:"));
        add(usernameField);
        add(new JLabel("密码:"));
        add(passwordField);
        add(loginButton);
        add(cancelButton);

        // 登录按钮逻辑
        loginButton.addActionListener(e -> {
            String username = usernameField.getText().trim();
            String password = new String(passwordField.getPassword()).trim();

            if (userService.authenticate(username, password)) {
                loginSuccessful = true;
                dispose(); // 关闭对话框
            } else {
                JOptionPane.showMessageDialog(
                        this,
                        "用户名或密码错误！",
                        "登录失败",
                        JOptionPane.ERROR_MESSAGE
                );
                clearFields(); // 登录失败后清空文本框
            }
        });

        // 取消按钮逻辑
        cancelButton.addActionListener(e -> {
            dispose();
            System.exit(0);
        });

        setLocationRelativeTo(null); // 居中显示
    }

    // 清空文本框的方法
    private void clearFields() {
        usernameField.setText("");
        passwordField.setText("");
        usernameField.requestFocus(); // 焦点回到用户名输入框
    }

    public boolean isLoginSuccessful() {
        return loginSuccessful;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Interceptor\Login\UserService.java`:

```java
package Interceptor.Login;

import java.util.HashMap;
import java.util.Map;

public class UserService {
    // 模拟用户数据库（用户名 -> 密码哈希值）
    private static final Map<String, String> userDatabase = new HashMap<>();

    public UserService() {
        // 初始化测试用户（密码为 "admin123" 的 SHA-256 哈希）
        userDatabase.put("admin", "admin123");
    }

    public boolean authenticate(String username, String password) {
        if (username.isEmpty() || password.isEmpty()) return false;
        String storedHash = userDatabase.get(username);
        return password.equals(storedHash);
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Main.java`:

```java
import javax.swing.*;

import Controller.MenuUI;
import DAO.CsvTransactionDao;
import Interceptor.Login.LoginDialog;
import Service.Impl.TransactionServiceImpl;

public class Main {
    public static void main(String[] args) {
        // 初始化服务（依赖注入）
        TransactionServiceImpl.csvTransactionDao = new CsvTransactionDao();

        // 在事件调度线程中启动 GUI（Swing 规范）
        SwingUtilities.invokeLater(() -> {
            // 1. 显示登录对话框
            LoginDialog loginDialog = new LoginDialog();
            loginDialog.setVisible(true);

            // 2. 登录成功后再显示主界面
            if (loginDialog.isLoginSuccessful()) {
                MenuUI menuUI = new MenuUI();
                JPanel mainPanel = menuUI.createMainPanel();
                showMainUI(mainPanel);
            } else {
                System.exit(0); // 登录失败退出
            }
        });
    }

    /**
     * 显示主界面窗口
     */
    private static void showMainUI(JPanel panel) {
        JFrame frame = new JFrame("交易管理系统");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(1200, 600);
        frame.setLocationRelativeTo(null); // 窗口居中
        frame.add(panel);
        frame.setVisible(true);
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\AIAnalyzerThread.java`:

```java
package Service.AIservice;

public class AIAnalyzerThread implements Runnable {
    private final String userRequest;
    private final String filePath;
    private final String startTimeStr;
    private final String endTimeStr;

    public AIAnalyzerThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        this.userRequest = userRequest;
        this.filePath = filePath;
        this.startTimeStr = startTimeStr;
        this.endTimeStr = endTimeStr;
    }

    @Override
    public void run() {
        String result = new AITransactionService().analyzeTransactions(userRequest, filePath, startTimeStr, endTimeStr);
        System.out.println("AI分析结果: " + result);
        // TODO: 如果是UI程序，可用 SwingUtilities.invokeLater() 更新UI组件
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\AITransactionService.java`:

```java
package Service.AIservice;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Constants.ConfigConstants;
import DAO.CsvTransactionDao;
import Utils.CacheUtil;
import model.Transaction;
import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;

import java.io.IOException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;
import java.util.concurrent.*;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class AITransactionService {
    private static final String API_KEY = System.getenv("ARK_API_KEY");
    private static final ArkService service = ArkService.builder()
            .timeout(Duration.ofSeconds(1800))
            .connectTimeout(Duration.ofSeconds(20))
            .baseUrl("https://ark.cn-beijing.volces.com/api/v3")
            .apiKey(API_KEY)
            .build();

    private final CsvTransactionDao transactionDao = new CsvTransactionDao();

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    private final CacheUtil<String, List<Transaction>, Exception> cache;
    /**
     * 重构构造器初始化Caffeine
     */
    public AITransactionService()  {
        // 1. 注入Dao层接口
        TransactionServiceImpl.csvTransactionDao = transactionDao;
        // 2. 初始化CacheUtil
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return transactionDao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );
    }

    public String analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        try {
            List<Transaction> transactions = cache.get(TRANSACTION_CAFFEINE_KEY);
            List<String> transactionDetails = formatTransactions(transactions, startTimeStr, endTimeStr);

            String aiPrompt = userRequest + "\n" + "以下是我的账单信息：\n" + String.join("\n", transactionDetails);
            return askAi(aiPrompt);
        } catch (Exception e) {
            e.printStackTrace();
            return "AI分析失败: " + e.getMessage();
        }
    }


    //private List<String> formatTransactions(List<Transaction> transactions) {
        //return transactions.stream().map(t -> String.format(
               // "交易时间: %s, 商品: %s, 收/支: %s, 金额: %.2f元",
               // t.getTransactionTime(),
               // t.getCommodity(),
               // t.getInOut(),
               // t.getPaymentAmount()
        //)).collect(Collectors.toList());
    //}

    public List<String> formatTransactions(List<Transaction> transactions, String startTimeStr, String endTimeStr) {
        LocalDateTime startTime = parseDateTime(startTimeStr);
        LocalDateTime endTime = (endTimeStr == null || endTimeStr.isEmpty())
                ? LocalDateTime.now()
                : parseDateTime(endTimeStr);

        if (startTime == null) {
            throw new IllegalArgumentException("起始时间格式不正确");
        }

        List<Transaction> filtered = transactions.stream()
                .filter(t -> {
                    LocalDateTime tTime = parseDateTime(t.getTransactionTime());
                    return tTime != null && !tTime.isBefore(startTime) && !tTime.isAfter(endTime);
                })
                .collect(Collectors.toList());

        Map<String, double[]> grouped = new HashMap<>();
        for (Transaction t : filtered) {
            String counterparty = t.getCounterparty();
            double amount = t.getInOut().equals("支出") ? -t.getPaymentAmount() : t.getPaymentAmount();
            grouped.putIfAbsent(counterparty, new double[]{0.0, 0});
            grouped.get(counterparty)[0] += amount;
            grouped.get(counterparty)[1] += 1;
        }

        List<String> results = grouped.entrySet().stream()
                .map(e -> {
                    String cp = e.getKey();
                    double net = e.getValue()[0];
                    int count = (int) e.getValue()[1];
                    String inOut = net >= 0 ? "收入" : "支出";
                    return String.format("交易对方: %s, 收/支: %s, 金额: %.2f元，交易次数: %d",
                            cp, inOut, Math.abs(net), count);
                })
                .collect(Collectors.toList());

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm");
        results.add(String.format("交易时间范围：%s - %s",
                formatter.format(startTime), formatter.format(endTime)));

        return results.isEmpty() ? List.of("该时间段内没有交易记录。") : results;
    }




    //private LocalDateTime parseDateTime(String timeStr) {
        // 你可以按实际情况支持不同格式，比如 yyyy/MM/dd HH:mm 或 yyyy-MM-dd HH:mm:ss
        //List<String> patterns = Arrays.asList("yyyy/MM/dd HH:mm","yyyy/MM/dd H:mm", "yyyy/M/dd H:mm","yyyy/M/dd HH:mm","yyyy/M/d H:mm","yyyy/M/d HH:mm","yyyy-MM-dd HH:mm:ss", "yyyy/MM/dd");

        //for (String pattern : patterns) {
            //try {
                //DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                //return LocalDateTime.parse(timeStr, formatter);
            //} catch (Exception ignored) {}
        //}
        //return null;
    //}
        private LocalDateTime parseDateTime(String timeStr) {
            if (timeStr == null || timeStr.trim().isEmpty()) return null;

            // 中文空格等统一清理
            timeStr = timeStr.trim().replaceAll("\\s+", " ");

            // 如果只有日期，补 00:00
            if (timeStr.matches("\\d{4}/\\d{1,2}/\\d{1,2}")) {
                timeStr += " 00:00";
            }

            // 多种时间格式尝试解析
            List<String> patterns = Arrays.asList(
                    "yyyy/M/d H:mm", "yyyy/M/d HH:mm",
                    "yyyy/MM/d H:mm", "yyyy/MM/d HH:mm",
                    "yyyy/M/dd H:mm", "yyyy/M/dd HH:mm",
                    "yyyy/MM/dd H:mm", "yyyy/MM/dd HH:mm",
                    "yyyy-MM-dd HH:mm:ss",
                    "yyyy/MM/dd"
            );

            for (String pattern : patterns) {
                try {
                    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                    return LocalDateTime.parse(timeStr, formatter);
                } catch (Exception ignored) {}
            }

            return null;
        }






    public String askAi(String prompt) {
        try {
            List<ChatMessage> messages = List.of(
                    ChatMessage.builder().role(ChatMessageRole.USER).content(prompt).build()
            );

            ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
                    .model("ep-20250308174053-7pbkq")
                    .messages(messages)
                    .build();

            return (String) service.createChatCompletion(chatCompletionRequest)
                    .getChoices().get(0).getMessage().getContent();
        } catch (Exception e) {
            e.printStackTrace();
            return "AI请求失败: " + e.getMessage();
        }
    }

    public void runAiInThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            String result = analyzeTransactions(userRequest, filePath,startTimeStr, endTimeStr);
            System.out.println("AI分析结果: " + result);
        });
        executor.shutdown();
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\ColledgeStudentThread.java`:

```java
package Service.AIservice;

import java.io.IOException;

public class ColledgeStudentThread implements Runnable{
//    private final int userRequest;
    private final String filePath;
    public String budgetRange;
    public ColledgeStudentThread( String filePath) {
//        this.userRequest = userRequest;
        this.filePath = filePath;
    }

    @Override
    public void run(){
        CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
        try {
            collegeStudentNeeds.generateBudget(filePath);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\CollegeStudentNeeds.java`:

```java
package Service.AIservice;

import Constants.ConfigConstants;
import DAO.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import model.Transaction;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class CollegeStudentNeeds {
    private final String requestBudge="我是一名预算有限的大学生，请根据下面我给出的花费，帮助我给下周预算范围，必须以[最低预算，最高预算],的方式给出回答，不能有多余的回复。";
    private final String requestTips="我是一名预算有限的大学生，请给我推荐一些省钱方法。";

    private final String requestRecognition="下面我将给你一些账单的信息，请推测这个账单是什么方面的消费: ";
    CsvTransactionDao dao;

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    private final CacheUtil<String, List<Transaction>, Exception> cache;

    public CollegeStudentNeeds() {
        TransactionServiceImpl.csvTransactionDao = dao;
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return dao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );

    }
    public String RecognizeTransaction(Transaction transaction){
        StringBuilder sb=new StringBuilder();
        sb.append("交易类型:").append(transaction.getTransactionType()+",").append("交易对方").append(transaction.getCounterparty()+",")
                .append("商品:").append(transaction.getCommodity()+",").append("收/支:").append(transaction.getInOut()+",")
                        .append("金额(元):").append(transaction.getPaymentAmount()+",").append("支付方式").append(transaction.getPaymentMethod()+",").append("备注:").append(transaction.getRemarks());
        return  new AITransactionService().askAi(requestRecognition+sb.toString());
    }

    public String generateTipsForSaving(){
        return  new AITransactionService().askAi(requestTips);
    }
    //按周统计已有的支出，依靠ai得到下周的预算
    public double[] generateBudget(String path) throws IOException {
        List<Transaction> transactions=cache.get(TRANSACTION_CAFFEINE_KEY);

        int size=transactions.size();
        if(size==0||size==1) return new double[]{-1,-1};
        int count=1;
        int base=0;
        int index=0;//指示首个适合当基准的时间点
        for (index = 0; index < size; index++) {
            int data=convertDateToNumber(transactions.get(index).getTransactionTime().split(" ")[0]);
            if(data>0){
                base=data;
                break;
            }
        }
        List<Double> list=new ArrayList<>();
        double weekConsumption=0;
        for (int i = 0; i < size; i++) {
            int data=convertDateToNumber(transactions.get(i).getTransactionTime().split(" ")[0]);
            if(data<0) continue;
            if((base-data>=0&&base-data<7)&&transactions.get(i).getInOut().equals("支出")){
                weekConsumption+=transactions.get(i).getPaymentAmount();
            }else if(base-data>=7){
                base=data;
                list.add(weekConsumption);
                count++;
                weekConsumption=0;
                if(transactions.get(i).getInOut().equals("支出")){
                    weekConsumption+=transactions.get(i).getPaymentAmount();
                }
            }
        }
        StringBuilder stringBuilder=new StringBuilder();
        for (int i = 0; i < count-1; i++) {
            stringBuilder.append("第");
            stringBuilder.append(i);
            stringBuilder.append("周:花费");
            stringBuilder.append(list.get(i));
            stringBuilder.append("元;");
        }
        String answer=new AITransactionService().askAi(requestBudge+stringBuilder.toString());
        System.out.println(answer);
        double[] ret=new double[2];
        ret=parseDoubleArrayFromString(answer);
        return ret;
    }

    private int convertDateToNumber(String date) {
        // format yyyy/MM/dd
        String[] parts = date.split("/");
        if (parts.length != 3) {
            return -1; // Invalid date format
        }
        try {
            int year = Integer.parseInt(parts[0]);
            int month = Integer.parseInt(parts[1]);
            int day = Integer.parseInt(parts[2]);
            int days = day;
            int[] daysInMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // Days in each month
            if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
                daysInMonth[2] = 29; // February has 29 days in a leap year
            }
            for (int i = 1; i < month; i++) {
                days += daysInMonth[i];
            }
            return year * 365 + (year / 4 - year / 100 + year / 400) + days;
        } catch (NumberFormatException e) {
            return -1;
        }
    }
    public double[] parseDoubleArrayFromString(String input) {
        int length=input.length();
        int l=0,rightindex=input.length();
        // 1. 去除首尾括号
        for (int i = 0; i < length; i++) {
            if(input.charAt(i)<58&&input.charAt(i)>47){
                l=i;
                break;
            }
        }
        for (int r =length-1 ; r >0; r--) {
            if(input.charAt(r)<58&&input.charAt(r)>47){
                rightindex=r;
                break;
            }
        }
        String content = input.substring(l, rightindex+1 ); // 获取 "1.1, 11.0" 或 " 2.5 ,3.14 , -0.5 "

        // 2. 按逗号分割
        String[] numberStrings1 = content.split("，"); // 得到 ["1.1", " 11.0"] 或 [" 2.5 ", "3.14 ", " -0.5 "]
        String[] numberStrings2 = content.split(","); // 得到 ["1.1", " 11.0"] 或 [" 2.5 ", "3.14 ", " -0.5 "]
        String[] numberStrings= numberStrings1.length> numberStrings2.length?numberStrings1:numberStrings2;
//        System.out.println(numberStrings[0]);
//        System.out.println(numberStrings[1]);
        // 3. & 4. 遍历、清理、解析并存储
        List<Double> numberList = new ArrayList<>();
        try {
            for (String numStr : numberStrings) {
                String trimmedStr = numStr.trim(); // 去除首尾空格
                if (!trimmedStr.isEmpty()) { // 避免分割后产生空字符串（例如 "[1.1, , 2.2]"）
                    numberList.add(Double.parseDouble(trimmedStr)); // 解析为 double
                }
            }
        } catch (NumberFormatException e) {
            System.err.println("错误：字符串无法解析为 double 类型。");
            return null; // 或者抛出异常
        }

        // 将 List<Double> 转换为 double[]
        double[] result = new double[numberList.size()];
        for (int i = 0; i < numberList.size(); i++) {
            result[i] = numberList.get(i);
        }
        return result;
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\Impl\TransactionServiceImpl.java`:

```java
package Service.Impl;

import Constants.ConfigConstants;
import DAO.CsvTransactionDao;
import Service.TransactionService;
import Utils.CacheUtil;
import model.Transaction;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class TransactionServiceImpl implements TransactionService {
    public static CsvTransactionDao csvTransactionDao;

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    public final CacheUtil<String, List<Transaction>, Exception> cache;

    /**
     * 通过构造函数注入路径和csvTransactionDao
     * @param csvTransactionDao
     * @throws IOException
     */
    public TransactionServiceImpl(CsvTransactionDao csvTransactionDao)  {
        // 1. 注入Dao层接口
        TransactionServiceImpl.csvTransactionDao = csvTransactionDao;
        // 2. 初始化CacheUtil
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return csvTransactionDao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );
    }

    /**
     * 从transactions缓存中读取transactions如果没有则从csv文件中找
     * @return
     * @throws IOException
     */
    private List<Transaction> getAllTransactions() throws Exception {
        return cache.get(TRANSACTION_CAFFEINE_KEY);
    }


    /**
     * 新增交易
     * @param transaction
     */
    @Override
    public void addTransaction(Transaction transaction) throws IOException {
        // 设置交易时间为当前时间
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
        String currentTime = now.format(formatter);
        transaction.setTransactionTime(currentTime);

        // 调用 DAO 层方法添加交易
        csvTransactionDao.addTransaction(CSV_PATH, transaction);
    }

    @Override
    public void changeTransaction(Transaction updatedTransaction) throws Exception {
        // 1. 加载所有交易记录 先加载 caffeine存储的缓存
        List<Transaction> allTransactions = getAllTransactions();

        // 2. 查找并修改目标交易
        boolean found = false;
        for (int i = 0; i < allTransactions.size(); i++) {
            Transaction t = allTransactions.get(i);
            // 根据交易单号匹配记录（唯一标识）
            if (t.getOrderNumber().equals(updatedTransaction.getOrderNumber())) {
                // 3. 更新非空字段
                updateTransactionFields(t, updatedTransaction);
                found = true;
                break;
            }
        }
        if (!found) {
            throw new IllegalArgumentException("未找到交易单号: " + updatedTransaction.getOrderNumber());
        }
        // 使用事务将写后数据写回csv文件
        csvTransactionDao.writeTransactionsToCSV(CSV_PATH, allTransactions);
        // 修改后使缓存失效 （删缓存）
        cache.invalidate("transactions");
    }

    /**
     *  辅助方法：更新非空字段
     * @param target
     * @param source
     */
    private void updateTransactionFields(Transaction target, Transaction source) {
        if (source.getTransactionTime() != null && !source.getTransactionTime().isEmpty()) {
            target.setTransactionTime(source.getTransactionTime());
        }
        if (source.getTransactionType() != null && !source.getTransactionType().isEmpty()) {
            target.setTransactionType(source.getTransactionType());
        }
        if (source.getCounterparty() != null && !source.getCounterparty().isEmpty()) {
            target.setCounterparty(source.getCounterparty());
        }
        if (source.getCommodity() != null && !source.getCommodity().isEmpty()) {
            target.setCommodity(source.getCommodity());
        }
        if (source.getInOut() != null && !source.getInOut().isEmpty()) {
            target.setInOut(source.getInOut());
        }
        if (source.getPaymentAmount() != 0.0) { // 假设金额为0表示未修改
            target.setPaymentAmount(source.getPaymentAmount());
        }
        if (source.getPaymentMethod() != null && !source.getPaymentMethod().isEmpty()) {
            target.setPaymentMethod(source.getPaymentMethod());
        }
        if (source.getCurrentStatus() != null && !source.getCurrentStatus().isEmpty()) {
            target.setCurrentStatus(source.getCurrentStatus());
        }
        if (source.getMerchantNumber() != null && !source.getMerchantNumber().isEmpty()) {
            target.setMerchantNumber(source.getMerchantNumber());
        }
        if (source.getRemarks() != null && !source.getRemarks().isEmpty()) {
            target.setRemarks(source.getRemarks());
        }
    }

    /**
     * 根据订单号删除交易 (若成功则返回true)
     * @param orderNumber
     */
    @Override
    public boolean deleteTransaction(String orderNumber) throws Exception {
        boolean result = csvTransactionDao.deleteTransaction(CSV_PATH, orderNumber);
        if (!result) {
            throw new Exception("未找到交易单号: " + orderNumber); // 或记录日志
        }
        cache.invalidate("transactions");
        return result;
    }

    /**
     * 按照查询条件查询交易信息
     * @param searchCriteria
     * @return
     */
    @Override
    public List<Transaction> searchTransaction(Transaction searchCriteria) {
        try {
            // 1. 读取所有交易记录 首先读取caffeine
            List<Transaction> allTransactions = getAllTransactions();

            // 2. 动态模糊匹配
            List<Transaction> matched = new ArrayList<>();
            for (Transaction t : allTransactions) {
                if (matchesCriteria(t, searchCriteria)) {
                    matched.add(t);
                }
            }

            // 3. 按交易时间倒序排序
            matched.sort((t1, t2) -> compareTransactionTime(t2.getTransactionTime(), t1.getTransactionTime()));

            return matched;
        } catch (IOException e) {
            e.printStackTrace();
            return List.of(); // 实际应用中应处理异常
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * 辅助方法:判断单个交易记录是否匹配条件
     * @param transaction
     * @param criteria
     * @return
     */
    private boolean matchesCriteria(Transaction transaction, Transaction criteria) {
        return (criteria.getTransactionTime() == null || containsIgnoreCase(transaction.getTransactionTime(), criteria.getTransactionTime()))
                && (criteria.getTransactionType() == null || containsIgnoreCase(transaction.getTransactionType(), criteria.getTransactionType()))
                && (criteria.getCounterparty() == null || containsIgnoreCase(transaction.getCounterparty(), criteria.getCounterparty()))
                && (criteria.getCommodity() == null || containsIgnoreCase(transaction.getCommodity(), criteria.getCommodity()))
                && (criteria.getInOut() == null || containsIgnoreCase(transaction.getInOut(), criteria.getInOut()))
                && (criteria.getPaymentMethod() == null || containsIgnoreCase(transaction.getPaymentMethod(), criteria.getPaymentMethod()));
    }

    /**
     * 辅助方法：字符串模糊匹配（空条件视为匹配）
     * @param source
     * @param target
     * @return
     */
    private boolean containsIgnoreCase(String source, String target) {
        if (target == null || target.trim().isEmpty()) return true; // 空条件不参与筛选
        if (source == null) return false;
        return source.toLowerCase().contains(target.toLowerCase().trim());
    }

    /**
     * 辅助方法：安全的时间比较（处理 null 值）
     * @param time1
     * @param time2
     * @return
     */
    private int compareTransactionTime(String time1, String time2) {
        if (time1 == null && time2 == null) return 0;
        if (time1 == null) return -1;
        if (time2 == null) return 1;
        return time2.compareTo(time1); // 倒序排序
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\TransactionService.java`:

```java
package Service;

import model.Transaction;

import java.io.IOException;
import java.util.List;

public interface TransactionService {

    /**
     * 新增交易
     * @param transaction
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * 修改交易
     * @param transaction
     */
    void changeTransaction(Transaction transaction) throws Exception;

    /**
     * 根据订单号删除交易
     * @param orderNumber
     */
    boolean deleteTransaction(String orderNumber) throws Exception;

    /**
     * 根据用户输入信息查询交易
     * @param transaction
     * @return
     */
    List<Transaction> searchTransaction(Transaction transaction);

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\deepseek\ChatCompletionsExample.java`:

```java
package Service.deepseek;

import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;
import okhttp3.ConnectionPool;
import okhttp3.Dispatcher;
import org.apache.commons.lang.StringUtils;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
public class ChatCompletionsExample {
    static String apiKey = System.getenv("ARK_API_KEY");
    static ConnectionPool connectionPool = new ConnectionPool(5, 1, TimeUnit.SECONDS);
    static Dispatcher dispatcher = new Dispatcher();
    // The output time of the reasoning model is relatively long. Please increase the timeout period.//
    static ArkService service = ArkService.builder().timeout(Duration.ofSeconds(1800)).connectTimeout(Duration.ofSeconds(20)).dispatcher(dispatcher).connectionPool(connectionPool).baseUrl("https://ark.cn-beijing.volces.com/api/v3").apiKey(apiKey).build();

//    public static void main(String[] args) {
//        System.out.println(" [Recommended]----- streaming request -----");
//        final List<ChatMessage> streamMessages = new ArrayList<>();
//        final ChatMessage streamUserMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("请回答15.11和15.9哪个大？").build();
//        streamMessages.add(streamUserMessage);
//        ChatCompletionRequest streamChatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(streamMessages)
//                .build();
//        service.streamChatCompletion(streamChatCompletionRequest)
//                .doOnError(Throwable::printStackTrace)
//                .blockingForEach(
//                        delta -> {
//                            if (!delta.getChoices().isEmpty()) {
//                                if (StringUtils.isNotEmpty(delta.getChoices().get(0).getMessage().getReasoningContent())) {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getReasoningContent());
//                                } else {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getContent());
//                                }
//                            }
//                        }
//                );
//        System.out.println(" ----- standard request -----");
//        final List<ChatMessage> messages = new ArrayList<>();
//        final ChatMessage userMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("常见的十字花科植物有哪些？").build();
//        messages.add(userMessage);
//        ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(messages)
//                .build();
//        service.createChatCompletion(chatCompletionRequest).getChoices().forEach(
//                choice -> {
//                    System.out.println(choice.getMessage().getReasoningContent());
//                    System.out.println(choice.getMessage().getContent());
//                }
//        );
//        // shutdown service after all requests is finished
//        service.shutdownExecutor();
//    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Utils\CacheUtil.java`:

```java
package Utils;

import com.github.benmanes.caffeine.cache.*;

import java.util.concurrent.TimeUnit;
import java.util.function.Function;

import com.github.benmanes.caffeine.cache.Caffeine;

/**
 * 通用缓存工具类（支持泛型和异常传播）
 * @param <K> 键类型
 * @param <V> 值类型
 * @param <E> 异常类型（如 IOException）
 */
public class CacheUtil<K, V, E extends Exception> {
    private final LoadingCache<K, V> cache;

    public CacheUtil(Function<K, V> loader,
                     int maxSize,
                     long expireAfterWrite,
                     long refreshAfterWrite) {

        this.cache = Caffeine.newBuilder()
                .maximumSize(maxSize)
                .expireAfterWrite(expireAfterWrite, TimeUnit.MINUTES)
                .refreshAfterWrite(refreshAfterWrite, TimeUnit.MINUTES)
                .build(loader::apply); // 关键修改：使用build(loader)创建LoadingCache
    }

    /**
     * 获取缓存值
     */
    public V get(K key) {
        return cache.get(key);
    }

    /**
     * 手动更新缓存
     */
    public void put(K key, V value) {
        cache.put(key, value);
    }

    /**
     * 手动移除缓存
     */
    public void invalidate(K key) {
        cache.invalidate(key);
    }
}



```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\model\Transaction.java`:

```java
package model;
//Transaction time, transaction type, transaction counterparty,
// commodity receipt/payment amount (yuan), payment method, current status,
// transaction order number, merchant order number, remarks
public class Transaction {
    private String transactionTime;
    private String transactionType;
    private String counterparty;
    private String commodity;
    private String inOut;
    private double paymentAmount;
    private String paymentMethod;
    private String currentStatus;
    private String orderNumber;
    private String merchantNumber;
    private String remarks;

    public Transaction() {
    }

    public Transaction(String transactionTime, String transactionType, String counterparty, String commodity, String inOut, double paymentAmount, String paymentMethod, String currentStatus, String orderNumber, String merchantNumber, String remarks) {
        this.transactionTime = transactionTime;
        this.transactionType = transactionType;
        this.counterparty = counterparty;
        this.commodity = commodity;
        this.inOut = inOut;
        this.paymentAmount = paymentAmount;
        this.paymentMethod = paymentMethod;
        this.currentStatus = currentStatus;
        this.orderNumber = orderNumber;
        this.merchantNumber = merchantNumber;
        this.remarks = remarks;
    }

    public String getInOut() {
        return inOut;
    }

    public void setInOut(String inOut) {
        this.inOut = inOut;
    }

    public void setTransactionTime(String transactionTime) {
        this.transactionTime = transactionTime;
    }

    public void setTransactionType(String transactionType) {
        this.transactionType = transactionType;
    }

    public void setCounterparty(String counterparty) {
        this.counterparty = counterparty;
    }

    public void setCommodity(String commodity) {
        this.commodity = commodity;
    }

    public void setPaymentAmount(double paymentAmount) {
        this.paymentAmount = paymentAmount;
    }

    public void setPaymentMethod(String paymentMethod) {
        this.paymentMethod = paymentMethod;
    }

    public void setCurrentStatus(String currentStatus) {
        this.currentStatus = currentStatus;
    }

    public void setOrderNumber(String orderNumbe) {
        this.orderNumber = orderNumbe;
    }

    public void setMerchantNumber(String merchantNumber) {
        this.merchantNumber = merchantNumber;
    }

    public void setRemarks(String remarks) {
        this.remarks = remarks;
    }

    public String getTransactionTime() {
        return transactionTime;
    }

    public String getTransactionType() {
        return transactionType;
    }

    public String getCounterparty() {
        return counterparty;
    }

    public String getCommodity() {
        return commodity;
    }

    public double getPaymentAmount() {
        return paymentAmount;
    }

    public String getPaymentMethod() {
        return paymentMethod;
    }

    public String getCurrentStatus() {
        return currentStatus;
    }

    public String getOrderNumber() {
        return orderNumber;
    }

    public String getMerchantNumber() {
        return merchantNumber;
    }

    public String getRemarks() {
        return remarks;
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\ControllerTest\AITest.java`:

```java
package ControllerTest;

import Controller.HistogramPanelContainer;
import org.junit.Test;

import javax.swing.*;
import java.awt.*;

public class AITest {

    @Test
    public void testHistogramPanel() throws Exception {
        EventQueue.invokeAndWait(() -> {
            JFrame frame = new JFrame("数据分析界面 - 测试");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });




        // 保持窗口显示一段时间，防止测试结束时窗口立即关闭
        Thread.sleep(5000);
    }

}




```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\ControllerTest\MenuUITest.java`:

```java
package ControllerTest;

import Controller.HistogramExample;
import Controller.HistogramPanelContainer;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.io.IOException;
import Controller.MenuUI;

import Service.Impl.TransactionServiceImpl;

import Service.Impl.TransactionServiceImpl;

import DAO.CsvTransactionDao;

public class MenuUITest {

    private MenuUI menuUI;

    @BeforeEach
    public void setUp() {
        menuUI = new MenuUI();

        // 手动初始化 TransactionServiceImpl 的 csvTransactionDao
        TransactionServiceImpl.csvTransactionDao = new CsvTransactionDao();
    }

    @Test
    public void testSearchFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取输入字段和搜索按钮
        JTextField transactionTimeField = findTextField(inputPanel, 0);
        JTextField transactionTypeField = findTextField(inputPanel, 1);
        JTextField counterpartyField = findTextField(inputPanel, 2);
        JTextField commodityField = findTextField(inputPanel, 3);
        JComboBox<String> inOutComboBox = findComboBox(inputPanel);
        JTextField paymentMethodField = findTextField(inputPanel, 4);
        JButton searchButton = findButton(inputPanel,"Search");

        assertNotNull(transactionTimeField, "交易时间输入字段不应为空");
        assertNotNull(transactionTypeField, "交易类型输入字段不应为空");
        assertNotNull(counterpartyField, "交易对方输入字段不应为空");
        assertNotNull(commodityField, "商品输入字段不应为空");
        assertNotNull(inOutComboBox, "收/支下拉框不应为空");
        assertNotNull(paymentMethodField, "支付方式输入字段不应为空");
        assertNotNull(searchButton, "搜索按钮不应为空");

        // 设置搜索条件
        transactionTimeField.setText("2025/3/14 11:48"); // 交易时间
        transactionTypeField.setText("商户消费");       // 交易类型
        counterpartyField.setText("物美WUMART");         // 交易对方
        commodityField.setText("扫码支付");            // 商品
        inOutComboBox.setSelectedItem("支出");     // 收/支
        paymentMethodField.setText("零钱");    // 支付方式

        // 模拟点击搜索按钮
        searchButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证搜索结果是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);

            // 验证每一行数据是否符合搜索条件
            assertTrue(rowTransactionTime.contains("2025/3/14 11:48"), "交易时间应符合搜索条件");
            assertTrue(rowTransactionType.contains("商户消费"), "交易类型应符合搜索条件");
            assertTrue(rowCounterparty.contains("物美WUMART"), "交易对方应符合搜索条件");
            assertTrue(rowCommodity.contains("扫码支付"), "商品应符合搜索条件");
            assertTrue(rowInOut.contains("支出"), "收/支应符合搜索条件");
            assertTrue(rowPaymentMethod.contains("零钱"), "支付方式应符合搜索条件");
        }
    }

    @Test
    public void testDeleteFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 获取初始行数
        int initialRowCount = tableModel.getRowCount();

        // 模拟删除第一行
        menuUI.deleteRow(0);

        // 验证行数是否减少
        assertEquals(initialRowCount - 1, tableModel.getRowCount(), "删除后行数应减少");

        // 验证删除后的数据是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            assertNotEquals("2025/3/14 11:48", rowTransactionTime, "删除的行不应再出现在表格中");
        }
    }

    @Test
    public void testEditFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 模拟编辑第一行
        menuUI.editRow(0);

        // 验证编辑后的数据是否正确
        String editedTransactionTime = (String) tableModel.getValueAt(0, 0);
        String editedTransactionType = (String) tableModel.getValueAt(0, 1);
        String editedCounterparty = (String) tableModel.getValueAt(0, 2);
        String editedCommodity = (String) tableModel.getValueAt(0, 3);
        String editedInOut = (String) tableModel.getValueAt(0, 4);
        String editedPaymentMethod = (String) tableModel.getValueAt(0, 6);

        // 验证编辑后的数据是否符合预期
        assertNotNull(editedTransactionTime, "编辑后的交易时间不应为空");
        assertNotNull(editedTransactionType, "编辑后的交易类型不应为空");
        assertNotNull(editedCounterparty, "编辑后的交易对方不应为空");
        assertNotNull(editedCommodity, "编辑后的商品不应为空");
        assertNotNull(editedInOut, "编辑后的收/支不应为空");
        assertNotNull(editedPaymentMethod, "编辑后的支付方式不应为空");
    }

    @Test
    public void testAddFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取 Add 按钮
        JButton addButton = findButton(inputPanel, "Add");
        assertNotNull(addButton, "Add 按钮不应为空");

        // 模拟点击 Add 按钮
        addButton.doClick();

        // 获取对话框
        Window[] windows = Window.getWindows();
        JDialog addDialog = null;
        for (Window window : windows) {
            if (window instanceof JDialog && "添加交易".equals(((JDialog) window).getTitle())) {
                addDialog = (JDialog) window;
                break;
            }
        }
        assertNotNull(addDialog, "添加交易的对话框应弹出");

        // 获取对话框中的输入字段
        JTextField transactionTimeField = findTextField(addDialog.getContentPane(), 0);
        JTextField transactionTypeField = findTextField(addDialog.getContentPane(), 1);
        JTextField counterpartyField = findTextField(addDialog.getContentPane(), 2);
        JTextField commodityField = findTextField(addDialog.getContentPane(), 3);
        JComboBox<String> inOutComboBox = findComboBox(addDialog.getContentPane());
        JTextField paymentAmountField = findTextField(addDialog.getContentPane(), 4);
        JTextField paymentMethodField = findTextField(addDialog.getContentPane(), 5);
        JTextField currentStatusField = findTextField(addDialog.getContentPane(), 6);
        JTextField orderNumberField = findTextField(addDialog.getContentPane(), 7);
        JTextField merchantNumberField = findTextField(addDialog.getContentPane(), 8);
        JTextField remarksField = findTextField(addDialog.getContentPane(), 9);

        // 设置新交易的输入值
        transactionTimeField.setText("2025/3/15 12:00"); // 交易时间
        transactionTypeField.setText("转账");            // 交易类型
        counterpartyField.setText("张三");               // 交易对方
        commodityField.setText("转账");                 // 商品
        inOutComboBox.setSelectedItem("支出");          // 收/支
        paymentAmountField.setText("100.0");            // 金额(元)
        paymentMethodField.setText("银行卡");           // 支付方式
        currentStatusField.setText("已完成");           // 当前状态
        orderNumberField.setText("123456789");          // 交易单号
        merchantNumberField.setText("987654321");       // 商户单号
        remarksField.setText("测试备注");               // 备注

        // 获取确认按钮
        JButton confirmButton = findButton(addDialog.getContentPane(), "确认");
        assertNotNull(confirmButton, "确认按钮不应为空");

        // 模拟点击确认按钮
        confirmButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证新交易是否添加到表格中
        boolean isTransactionAdded = false;
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentAmount = (String) tableModel.getValueAt(i, 5);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);
            String rowCurrentStatus = (String) tableModel.getValueAt(i, 7);
            String rowOrderNumber = (String) tableModel.getValueAt(i, 8);
            String rowMerchantNumber = (String) tableModel.getValueAt(i, 9);
            String rowRemarks = (String) tableModel.getValueAt(i, 10);

            if (rowTransactionTime.equals("2025/3/15 12:00") &&
                    rowTransactionType.equals("转账") &&
                    rowCounterparty.equals("张三") &&
                    rowCommodity.equals("转账") &&
                    rowInOut.equals("支出") &&
                    rowPaymentAmount.equals("100.0") &&
                    rowPaymentMethod.equals("银行卡") &&
                    rowCurrentStatus.equals("已完成") &&
                    rowOrderNumber.equals("123456789") &&
                    rowMerchantNumber.equals("987654321") &&
                    rowRemarks.equals("测试备注")) {
                isTransactionAdded = true;
                break;
            }
        }

        // 验证新交易是否成功添加
        assertTrue(isTransactionAdded, "新交易应成功添加到表格中");
    }

    /**
     * 显示界面以便手动验证
     *
     * @param panel 要显示的面板
     */
    private void showUI(JPanel panel) {
        JFrame frame = new JFrame("MenuUI Test");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(1200, 600);
        frame.add(panel);
        frame.setVisible(true);

        // 保持界面显示一段时间（5秒）
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        frame.dispose(); // 关闭界面
    }

    /**
     * 查找输入面板
     *
     * @param mainPanel 主面板
     * @return 输入面板
     */
    private JPanel findInputPanel(JPanel mainPanel) {
        // 获取右边的面板
        Component[] components = mainPanel.getComponents();
        JPanel rightPanel = null;
        for (Component component : components) {
            if (component instanceof JPanel && ((JPanel) component).getComponentCount() > 0) {
                rightPanel = (JPanel) component;
                break;
            }
        }

        if (rightPanel != null) {
            // 在右边面板中查找输入面板
            for (Component component : rightPanel.getComponents()) {
                if (component instanceof JPanel) {
                    JPanel panel = (JPanel) component;
                    System.out.println("Panel found: " + panel.getName()); // 打印面板名称
                    if (panel.getComponentCount() > 0 && panel.getComponent(0) instanceof JLabel) {
                        return panel; // 输入面板通常包含 JLabel
                    }
                }
            }
        }
        return null;
    }

    /**
     * 查找输入字段
     *
     * @param container     输入面板
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0;
        for (Component component : container.getComponents()) {
            if (component instanceof JTextField) {
                if (count == index) {
                    return (JTextField) component;
                }
                count++;
            }
        }
        return null;
    }


    /**
     * 查找下拉框
     *
     * @param container 输入面板
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) {
            if (component instanceof JComboBox) {
                return (JComboBox<String>) component;
            }
        }
        return null;
    }

    /**
     * 查找按钮
     *
     * @param panel 输入面板
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container  容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    private JButton findButton(Container container, String buttonText) {
        for (Component component : container.getComponents()) {
            if (component instanceof JButton) {
                JButton button = (JButton) component;
                if (button.getText().equals(buttonText)) {
                    return button;
                }
            }
        }
        return null;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\DAOTest\CsvTransactionDaoTest.java`:

```java
package DAOTest;

import DAO.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static Constants.ConfigConstants.CSV_PATH;
import static org.assertj.core.api.Assertions.*;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

class CsvTransactionDaoTest {
    // 测试文件路径（根据实际结构调整）
    private static final String TEST_CSV_PATH = CSV_PATH;
    private static CsvTransactionDao dao;

    @Test
    void testLoadFromCSV_ValidFile_ReturnsTransactions() throws Exception {
        // Given
        CsvTransactionDao dao = new CsvTransactionDao();

        // When
        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);

        // 验证第一条记录的字段
        for (int i = 0; i < transactions.size(); i++) {
            System.out.println(transactions.get(i).getRemarks());
            System.out.println(transactions.get(i).getCommodity());
        }


    }
    @Test
    void testAddTransaction() throws IOException {
        dao=new CsvTransactionDao();
        Transaction newTx = new Transaction(
                "2025-03-09 10:00",
                "转账",
                "小明",
                "书籍",
                "支",
                99.99,
                "微信",
                "已完成",
                "TX123456",
                "M789012",
                "");

        dao.addTransaction("src/test/resources/001.csv", newTx);

        List<Transaction> transactions = dao.loadFromCSV(TEST_CSV_PATH);

    }

    @Test
    void testDeleteTransaction() throws IOException {
        dao=new CsvTransactionDao();

        dao.deleteTransaction("CSV_RELATIVE_PATH", "4200057899202502250932735481");

        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);
    }
    @Test
    void testChangeInfo() throws IOException{
        dao=new CsvTransactionDao();
        dao.changeInformation("TX123456","remarks","测试修改信息",TEST_CSV_PATH);
        dao.changeInformation("TX123456","paymentAmount","116156",TEST_CSV_PATH);
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\AIAnalyzerThreadTest.java`:

```java
package Service;



import Service.AIservice.AIAnalyzerThread;
import org.junit.jupiter.api.Test;

public class AIAnalyzerThreadTest {

    @Test
    public void testRunAIAnalyzerThread() throws InterruptedException {
        String userRequest = "请帮我分析最近的交易收支情况";
        String filePath = "src/test/resources/sample_transactions.csv";
        String startTimeStr = "2025/03/20";
        String endTimeStr = "";

        // 启动线程
        Thread thread = new Thread(new AIAnalyzerThread(userRequest, filePath, startTimeStr, endTimeStr));
        thread.start();

        // 等待线程执行完成
        thread.join();
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\AIserviceTest.java`:

```java
package Service;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

public class AIserviceTest {

    @Test
    public void testAnalyzeTransactions() {
        AITransactionService service = new AITransactionService();

        String userRequest = "请帮我分析这个月的收支情况";
        String filePath = "src/test/resources/sample_transactions.csv";

        String result = service.analyzeTransactions(userRequest, filePath,"2025/03/20","");

        assertNotNull(result, "AI分析结果不能为空");
        System.out.println("AI分析结果: " + result);
    }


}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\AiFunctionTest.java`:

```java
package Service;

import DAO.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

import java.io.IOException;
import java.util.List;

public class AiFunctionTest {

    @Test
    public void testAnalyzeTransactions() throws IOException {

        String filePath = "src/test/resources/sample_transactions.csv";
        CsvTransactionDao transactionDao = new CsvTransactionDao();

        List<Transaction> transactions = transactionDao.loadFromCSV(filePath);

        // 实例化服务类
        AITransactionService service = new AITransactionService();

        // 调用合并格式化函数
        List<String> result = service.formatTransactions(transactions,"2025/03/29","2025/04/10");

        // 输出结果
        result.forEach(System.out::println);
    }




}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\CacheTest.java`:

```java
package Service;

import Constants.CaffeineKeys;
import DAO.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import com.github.benmanes.caffeine.cache.Caffeine;
import model.Transaction;
import org.junit.jupiter.api.Test;

import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;

public class CacheTest {

    TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());

    @Test
    void DeleteCache(){
        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;
        cache.invalidate(TRANSACTION_CAFFEINE_KEY);
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\CollegeStudentNeedsTest.java`:

```java
package Service;

import Service.AIservice.ColledgeStudentThread;
import Service.AIservice.CollegeStudentNeeds;
import org.junit.jupiter.api.*;

import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.*;

// No @ExtendWith needed as we are not using Mockito extensions
class CollegeStudentNeedsTest {



    private CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
    private static final String TEST_CSV_FILENAME = "src/test/resources/001.csv";
    @Test
    public void testGenerateBudget() throws IOException, InterruptedException {
        Thread t=new Thread( new ColledgeStudentThread(TEST_CSV_FILENAME));
        t.start();
        t.join();
//        collegeStudentNeeds.generateBudget(TEST_CSV_FILENAME);
    }
    @Test
    public void testParseStringToDouble(){
        String s="asdas[369.39,1090.1]das";
        double[] arr=collegeStudentNeeds.parseDoubleArrayFromString(s);
        System.out.println(arr[0]+" "+arr[1]);
    }


}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\TransactionServiceTest.java`:

```java
package Service;

import DAO.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import model.Transaction;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.io.IOException;
import java.util.List;

class TransactionServiceTest {
    private TransactionService transactionService;

    @BeforeEach
    void setUp() {
        // 初始化 DAO 和 Service
        CsvTransactionDao csvTransactionDao = new CsvTransactionDao();
        transactionService = new TransactionServiceImpl(csvTransactionDao);
    }

    @Test
    void testAddTransaction() throws IOException {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );

        // 执行添加操作
        transactionService.addTransaction(transaction);

        // 验证是否添加成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertFalse(transactions.isEmpty());
        assertEquals("T123456789", transactions.get(0).getOrderNumber());
    }

    @Test
    void testChangeTransaction() throws Exception {
        // 准备测试数据
        Transaction originalTransaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(originalTransaction);

        // 准备更新数据
        Transaction updatedTransaction = new Transaction(
                null, "充值", null, null, null, 0.0, "微信支付", null, "T123456789", null, "更新备注"
        );

        // 执行更新操作
        transactionService.changeTransaction(updatedTransaction);

        // 验证是否更新成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertEquals("充值", transactions.get(0).getTransactionType());
        assertEquals("微信支付", transactions.get(0).getPaymentMethod());
        assertEquals("更新备注", transactions.get(0).getRemarks());
    }

    @Test
    void testDeleteTransaction() throws Exception {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(transaction);

        // 执行删除操作
        boolean result = transactionService.deleteTransaction("T123456789");

        // 验证是否删除成功
        assertTrue(result);
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertTrue(transactions.isEmpty());
    }

    @Test
    void testSearchTransaction() throws IOException {

        // 设置搜索条件
        Transaction searchCriteria = new Transaction();
        searchCriteria.setCounterparty("支付宝");

        // 执行搜索操作
        List<Transaction> result = transactionService.searchTransaction(searchCriteria);

        // 验证搜索结果
        result.forEach(res -> System.out.println(res.getCommodity()));
    }


}
```
```

`软工/Ai-Bill-Application-Group21 - 副本\README.md`:

```md
## Project Overview
This module is a transaction record management 
system in the Service layer of the project that connects 
with the Dao layer that provides CRUD (Create, Read, Update
, Delete) functionality and data processing for
transaction data. Core features include transaction 
creation, modification, deletion, and flexible querying,
all accessible through standardized interfaces.

## Structure and Function
Swing GUI (Controller) <- Service <- DAO <-data(CSV/JSON)<-model

##  Model 

### Overview

This Java class, located in the `model` package, serves 
as a Plain Old Java Object (POJO) or data model to 
represent a single financial transaction record. It 
encapsulates all the standard details associated with 
a transaction, such as its time, type, amount, parties 
involved, status, and unique identifiers.

This class is typically used in conjunction with Data 
Access Objects (DAOs) like `TransactionDao` and
`CsvTransactionDao` to load, save, and manipulate 
transaction data from a persistent store (e.g., a CSV 
file or database).

### Package

`model`

### Fields

The `Transaction` class contains the following fields:

* `transactionTime` (String): The date and time when the transaction occurred (e.g., "2023-10-27 15:30:00").
* `transactionType` (String): The category or type of the transaction (e.g., "在线支付" - Online Payment, "转账" - Transfer, "退款" - Refund).
* `counterparty` (String): The name or identifier of the other party involved in the transaction.
* `commodity` (String): A description of the goods, service, or reason for the transaction (e.g., "Coffee", "Salary", "Online Course Fee").
* `inOut` (String): Indicates the direction of the money flow relative to the account holder. Typically:
* `paymentAmount` (double): The monetary value of the transaction. The currency unit (e.g., Yuan) is implied by the context where this class is used (often indicated by header names like "金额(元)" in associated CSV files).
* `paymentMethod` (String): The method used for the payment (e.g., "支付宝" - Alipay, "微信支付" - WeChat Pay, "银行卡" - Bank Card, "现金" - Cash).
* `currentStatus` (String): The current processing status of the transaction (e.g., "交易成功" - Transaction Successful, "等待付款" - Awaiting Payment, "已关闭" - Closed, "退款成功" - Refund Successful).
* `orderNumber` (String): A unique identifier assigned to this specific transaction instance by the payment system or application. Often used as a primary key.
* `merchantNumber` (String): An order number or identifier associated with the merchant's system, often provided for reconciliation purposes. May be empty or null if not applicable.
* `remarks` (String): An optional field for any additional notes, comments, or user-provided descriptions about the transaction.

### Constructors

* **`public Transaction()`**
    * Default no-argument constructor. Creates an empty `Transaction` object with all fields initialized to their default values (null for String, 0.0 for double).

* **`public Transaction(String transactionTime, String transactionType, ..., String remarks)`**
    * Parameterized constructor that accepts values for all fields. Allows for quick instantiation of a fully populated `Transaction` object.

### Methods

The class provides standard public **getter** (`get...()`) and **setter** (`set...()`) methods for all its private fields. These methods allow controlled access and modification of the transaction's attributes from other parts of the application.

* `getTransactionTime()` / `setTransactionTime(String time)`
* `getTransactionType()` / `setTransactionType(String type)`
* `getCounterparty()` / `setCounterparty(String counterparty)`
* `getCommodity()` / `setCommodity(String commodity)`
* `getInOut()` / `setInOut(String inOut)`
* `getPaymentAmount()` / `setPaymentAmount(double amount)`
* `getPaymentMethod()` / `setPaymentMethod(String method)`
* `getCurrentStatus()` / `setCurrentStatus(String status)`
* `getOrderNumber()` / `setOrderNumber(String orderNumber)`
* `getMerchantNumber()` / `setMerchantNumber(String merchantNumber)`
* `getRemarks()` / `setRemarks(String remarks)`

 
### Service (Business logic)
- Responsibilities:
Transaction CRUD operations, calling the DAO layer to read and write local files,
User-defined classification logic (e.g. modifying transaction categories)
  (3) Operations:

Add Transaction:

Transaction t = new Transaction();
// Set field values
service.addTransaction(t);

Modify Transaction:

Transaction update = new Transaction();
update.setOrderNumber("ORD123");
// Set fields to update
service.changeTransaction(update);

Query Transactions:

Transaction criteria = new Transaction();
criteria.setCounterparty("Alipay");
List<Transaction> results = service.searchTransaction(criteria);
Code structure
   Directory Layout:
   src/main/java/
   └── Service/
   ├── Impl/
   │   └── TransactionServiceImpl.java  # Service implementation
   └── TransactionService.java          # Service interface
   TransactionService.java:
   Defines the service interface with business-agnostic method signatures, enforcing decoupling 
   between business logic and implementation details.
   TransactionServiceImpl.java:
   Implements the concrete business logic while depending only on the interface-defined contract, maintaining loose coupling with the data access layer through dependency injection.


- AIService (Intelligent Analytics) Responsibilities: Generate budget recommendations based
on historical data, and detect cost-cutting recommendations for seasonal spending in China
(e.g. Spring Festival) (e.g. marking high-frequency small spending)


- **`AITransactionService`**

The central class that performs the full AI-driven transaction analysis. It:

- Loads transaction data from a CSV file via `CsvTransactionDao`.
- Filters transactions by user-specified time range (`startTimeStr`, `endTimeStr`).
- Aggregates data by counterparty (income/spending, transaction counts).
- Formats the result into concise summaries sent to the AI.
- Sends user questions and formatted data to the Volcengine Ark AI API.
- Returns a response within **400 characters** for efficient display.

Key methods:
- `analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr)`
  → Returns an AI-generated analysis result string.
- `runAiInThread(...)`
  → Runs the AI logic in a background thread (single-threaded executor).
- `formatTransactions(...)`
  → Groups transactions and summarizes them by counterparty and time range.
- `parseDateTime(...)`
  → Supports flexible input formats like `yyyy/MM/dd`, `yyyy/MM/dd HH:mm`, and more. - **`AIAnalyzerThread`** A `Runnable` implementation for threading scenarios (especially GUI usage). It calls `AITransactionService.analyzeTransactions(...)` and prints the result. UI developers can replace the console output with GUI updates using `SwingUtilities.invokeLater()`. --- ### Tests (`test/java/Service/AIservice/`) - **`AIserviceTest`** Unit tests for `AITransactionService`, verifying: - Correct loading and filtering of transactions. - Accurate AI response generation and formatting. - Graceful handling of edge cases (e.g., no transactions in range, invalid time formats). - **`AIAnalyzerThreadTest`** Validates threading logic: - Ensures `AIAnalyzerThread` executes `Runnable` correctly. - Demonstrates clean and concurrent AI analysis flow. - Simulates integration with a GUI environment. - **`AiFunctionTest`** Utility-level tests: - Ensures proper CSV parsing and data transformation. - Verifies output formatting before sending to the AI. - Tests various time formats and edge case behaviors

## DAO (File Storage)
- Responsibilities: Save transaction data in CSV or JSON format and provide interfaces for adding,
  deleting, and modifying in-memory data
### CsvTransactionDao Class

#### Package

`DAO`

#### Dependencies

* **`model.Transaction`**: The data model class representing a single transaction.
* **`DAO.TransactionDao`**: The interface this class is intended to implement (though the implementation is incomplete).
* **Apache Commons CSV (`org.apache.commons.csv.*`)**: Used for robust parsing and writing of CSV data.
* **Apache Commons IO (`org.apache.commons.io.input.BOMInputStream`)**: Used specifically to handle potential Byte Order Marks (BOM) often found in UTF-8 encoded files, particularly those edited in Windows.
* **Java Standard Libraries**: `java.io.*`, `java.nio.*`.

#### Key Features & Implementation Details

* **CSV Loading (`loadFromCSV`)**:
  * Reads data from a specified CSV file path.
  * Expects UTF-8 encoding.
  * Handles potential Byte Order Mark (BOM) at the beginning of the file.
  * Uses the first row of the CSV as the header to map columns to `Transaction` fields. Assumes specific header names (e.g., "交易时间", "交易类型", "金额(元)").
  * Parses transaction records into a `List<Transaction>`.
  * Includes basic caching using an internal `transactions` list and an `isLoad` flag to avoid redundant file reads within the same instance lifecycle (unless forced by methods like `deleteTransaction` or `changeInformation`).
* **Record Parsing (`parseRecord`)**:
  * Converts a `CSVRecord` object (from Apache Commons CSV) into a `Transaction` object.
  * Specifically handles the "金额(元)" (Amount) field by removing the leading "¥" symbol before parsing it as a `double`.
* **Adding Transactions (`addTransaction(String filePath, Transaction newTransaction)`)**:
  * **Appends** a new transaction record to the *end* of the specified CSV file.
  * Creates the file if it doesn't exist.
  * Writes the header row only if the file is new or was empty.
  * Formats the payment amount by prepending "¥".
* **Deleting Transactions (`deleteTransaction(String filePath, String orderNumber)`)**:
  * Loads data from the file if not already cached.
  * Filters the cached list to remove the transaction matching the given `orderNumber`.
  * **Overwrites** the *entire* original CSV file with the filtered list using `writeTransactionsToCSV`.
  * Returns `true` if a transaction was removed, `false` otherwise.
* **Updating Transactions (`changeInformation`)**:
  * Loads data if not already cached.
  * Finds the transaction by `orderNumber`.
  * Modifies the specified field (`head`) of the found transaction object in memory.
  * **Crucially, it attempts the update by first *deleting* the original record (using `deleteTransaction`, which overwrites the file) and then *adding* the modified record (using `addTransaction`, which appends to the file).** This logic is inefficient and potentially problematic due to the conflicting file write strategies (overwrite vs. append).
  * Error handling for invalid `head` parameters prints to `System.err`. The method often returns `true` even if the underlying delete/add fails.
* **CSV Writing (`writeTransactionsToCSV`)**:
  * Helper method used by `deleteTransaction`.
  * Writes a given `List<Transaction>` to the specified file path, **overwriting** any existing content.
  * Writes a standard header row.
  * Formats the payment amount by prepending "¥".

#### Important Issues & Considerations

1.  **Incomplete `TransactionDao` Implementation**: The methods declared in the `TransactionDao` interface (`getAllTransactions`, `addTransaction(Transaction)`, `deleteTransaction(String)`, `updateTransaction`, `getTransactionByOrderNumber`) are present but contain only placeholder/stub code. The actual working logic uses separate methods that require the `filePath` to be passed explicitly each time. **This class, in its current state, does not correctly function as a `TransactionDao` implementation.**
2.  **Inconsistent File Writing Strategy**: `addTransaction` *appends* to the file, while `deleteTransaction` and `writeTransactionsToCSV` (used by `deleteTransaction` and `changeInformation`) *overwrite* the entire file. This inconsistency can lead to unexpected behavior, especially within the `changeInformation` method.
3.  **Inefficient Updates/Deletes**: Rewriting the entire CSV file for every single deletion or modification (`changeInformation`) is highly inefficient, especially for large transaction files.
4.  **Flawed Update Logic (`changeInformation`)**: The delete-then-add approach for updates is problematic due to the inconsistent write strategies and potential race conditions or partial failures. The modified record will likely appear at the *end* of the file, not its original position.
5.  **Basic Caching**: The caching mechanism (`isLoad` flag) is simple and does not account for external modifications to the CSV file during the application's runtime.
6.  **Hardcoded Dependencies**: The code relies on specific header names (in Chinese) and the "¥" currency symbol format within the CSV data. Changes to the CSV format would require code modifications.

#### Usage Example (Using Functional Methods)

```java
import DAO.CsvTransactionDao; // Assuming TransactionDao interface exists but is not used directly here due to stub methods
import model.Transaction;
import java.io.IOException;
import java.util.List;

public class CsvDataManager {

    public static void main(String[] args) {
        // NOTE: Using the class directly, not via the TransactionDao interface
        // because the interface methods are not fully implemented.
        CsvTransactionDao csvDao = new CsvTransactionDao();
        String csvFilePath = "path/to/your/transactions.csv"; // <--- Specify your file path

        try {
            // --- Load Data ---
            System.out.println("Loading transactions...");
            List<Transaction> transactions = csvDao.loadFromCSV(csvFilePath);
            System.out.println("Loaded " + transactions.size() + " transactions.");
            // Display first transaction if available
            if (!transactions.isEmpty()) {
                 System.out.println("First transaction order number: " + transactions.get(0).getOrderNumber());
            }

            // --- Add a New Transaction (Appends) ---
            Transaction newTx = new Transaction(
                 "2025-04-20 08:14:00", "Test Add", "Counterparty", "Item", "支",
                 10.0, "支付宝", "交易成功", "NEW_ORDER_123", "MERCH_456", "Test via DAO add"
            );
            System.out.println("\nAdding new transaction (append): " + newTx.getOrderNumber());
            // csvDao.addTransaction(csvFilePath, newTx); // Uncomment to actually add
            System.out.println("Transaction potentially added.");

            // --- Delete a Transaction (Overwrites File) ---
            String orderToDelete = "SOME_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number from your file
            System.out.println("\nAttempting to delete transaction: " + orderToDelete);
            // boolean deleted = csvDao.deleteTransaction(csvFilePath, orderToDelete); // Uncomment to actually delete
            // if (deleted) {
            //     System.out.println("Transaction deleted successfully (File rewritten).");
            // } else {
            //     System.out.println("Transaction not found for deletion.");
            // }

            // --- Change Information (Overwrites then Appends - Use with Caution) ---
             String orderToChange = "ANOTHER_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number
             String fieldToChange = "remarks";
             String newValue = "Updated remark via changeInformation";
             System.out.println("\nAttempting to change info for: " + orderToChange);
             // boolean changed = csvDao.changeInformation(orderToChange, fieldToChange, newValue, csvFilePath); // Uncomment with caution
             // System.out.println("Change operation attempted (File rewritten and appended). Result: " + changed);


        } catch (IOException e) {
            System.err.println("Error interacting with CSV file: " + e.getMessage());
            e.printStackTrace();
        } catch (NumberFormatException e) {
            System.err.println("Error parsing amount in CSV: " + e.getMessage());
        }
    }
}
```

## Controller (Swing GUI)

Responsibilities: Manage user interface components (buttons, tables, text boxes) to listen for 
events (clicks, inputs) and call service layer methods to update the interface data display

## attention
encoding with UTF-8

```

`软工/Ai-Bill-Application-Group21 - 副本\README.txt`:

```txt
## Project Overview

This module is a transaction record management 
system in the Service layer of the project that connects 
with the Dao layer that provides CRUD (Create, Read, Update
, Delete) functionality and data processing for
transaction data. Core features include transaction 
creation, modification, deletion, and flexible querying,
all accessible through standardized interfaces.

## Structure and Function

Swing GUI (Controller) <- Service <- DAO <-data(CSV/JSON)<-model

##  Model 

### Overview

This Java class, located in the `model` package, serves 
as a Plain Old Java Object (POJO) or data model to 
represent a single financial transaction record. It 
encapsulates all the standard details associated with 
a transaction, such as its time, type, amount, parties 
involved, status, and unique identifiers.

This class is typically used in conjunction with Data 
Access Objects (DAOs) like `TransactionDao` and
`CsvTransactionDao` to load, save, and manipulate 
transaction data from a persistent store (e.g., a CSV 
file or database).

### Package

`model`

### Fields

The `Transaction` class contains the following fields:

* `transactionTime` (String): The date and time when the transaction occurred (e.g., "2023-10-27 15:30:00").
* `transactionType` (String): The category or type of the transaction (e.g., "在线支付" - Online Payment, "转账" - Transfer, "退款" - Refund).
* `counterparty` (String): The name or identifier of the other party involved in the transaction.
* `commodity` (String): A description of the goods, service, or reason for the transaction (e.g., "Coffee", "Salary", "Online Course Fee").
* `inOut` (String): Indicates the direction of the money flow relative to the account holder. Typically:
* `paymentAmount` (double): The monetary value of the transaction. The currency unit (e.g., Yuan) is implied by the context where this class is used (often indicated by header names like "金额(元)" in associated CSV files).
* `paymentMethod` (String): The method used for the payment (e.g., "支付宝" - Alipay, "微信支付" - WeChat Pay, "银行卡" - Bank Card, "现金" - Cash).
* `currentStatus` (String): The current processing status of the transaction (e.g., "交易成功" - Transaction Successful, "等待付款" - Awaiting Payment, "已关闭" - Closed, "退款成功" - Refund Successful).
* `orderNumber` (String): A unique identifier assigned to this specific transaction instance by the payment system or application. Often used as a primary key.
* `merchantNumber` (String): An order number or identifier associated with the merchant's system, often provided for reconciliation purposes. May be empty or null if not applicable.
* `remarks` (String): An optional field for any additional notes, comments, or user-provided descriptions about the transaction.

### Constructors

* **`public Transaction()`**
  * Default no-argument constructor. Creates an empty `Transaction` object with all fields initialized to their default values (null for String, 0.0 for double).

* **`public Transaction(String transactionTime, String transactionType, ..., String remarks)`**
  * Parameterized constructor that accepts values for all fields. Allows for quick instantiation of a fully populated `Transaction` object.

### Methods

The class provides standard public **getter** (`get...()`) and **setter** (`set...()`) methods for all its private fields. These methods allow controlled access and modification of the transaction's attributes from other parts of the application.

* `getTransactionTime()` / `setTransactionTime(String time)`
* `getTransactionType()` / `setTransactionType(String type)`
* `getCounterparty()` / `setCounterparty(String counterparty)`
* `getCommodity()` / `setCommodity(String commodity)`
* `getInOut()` / `setInOut(String inOut)`
* `getPaymentAmount()` / `setPaymentAmount(double amount)`
* `getPaymentMethod()` / `setPaymentMethod(String method)`
* `getCurrentStatus()` / `setCurrentStatus(String status)`
* `getOrderNumber()` / `setOrderNumber(String orderNumber)`
* `getMerchantNumber()` / `setMerchantNumber(String merchantNumber)`
* `getRemarks()` / `setRemarks(String remarks)`


### Service (Business logic)

- Responsibilities:
  Transaction CRUD operations, calling the DAO layer to read and write local files,
  User-defined classification logic (e.g. modifying transaction categories)
  (3) Operations:

Add Transaction:

Transaction t = new Transaction();
// Set field values
service.addTransaction(t);

Modify Transaction:

Transaction update = new Transaction();
update.setOrderNumber("ORD123");
// Set fields to update
service.changeTransaction(update);

Query Transactions:

Transaction criteria = new Transaction();
criteria.setCounterparty("Alipay");
List<Transaction> results = service.searchTransaction(criteria);
Code structure
   Directory Layout:
   src/main/java/
   └── Service/
   ├── Impl/
   │   └── TransactionServiceImpl.java  # Service implementation
   └── TransactionService.java          # Service interface
   TransactionService.java:
   Defines the service interface with business-agnostic method signatures, enforcing decoupling 
   between business logic and implementation details.
   TransactionServiceImpl.java:
   Implements the concrete business logic while depending only on the interface-defined contract, maintaining loose coupling with the data access layer through dependency injection.


- AIService (Intelligent Analytics) Responsibilities: Generate budget recommendations based
  on historical data, and detect cost-cutting recommendations for seasonal spending in China
  (e.g. Spring Festival) (e.g. marking high-frequency small spending)


- **`AITransactionService`**

The central class that performs the full AI-driven transaction analysis. It:

- Loads transaction data from a CSV file via `CsvTransactionDao`.
- Filters transactions by user-specified time range (`startTimeStr`, `endTimeStr`).
- Aggregates data by counterparty (income/spending, transaction counts).
- Formats the result into concise summaries sent to the AI.
- Sends user questions and formatted data to the Volcengine Ark AI API.
- Returns a response within **400 characters** for efficient display.

Key methods:

- `analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr)`
  → Returns an AI-generated analysis result string.
- `runAiInThread(...)`
  → Runs the AI logic in a background thread (single-threaded executor).
- `formatTransactions(...)`
  → Groups transactions and summarizes them by counterparty and time range.
- `parseDateTime(...)`
  → Supports flexible input formats like `yyyy/MM/dd`, `yyyy/MM/dd HH:mm`, and more. - **`AIAnalyzerThread`** A `Runnable` implementation for threading scenarios (especially GUI usage). It calls `AITransactionService.analyzeTransactions(...)` and prints the result. UI developers can replace the console output with GUI updates using `SwingUtilities.invokeLater()`. --- ### Tests (`test/java/Service/AIservice/`) - **`AIserviceTest`** Unit tests for `AITransactionService`, verifying: - Correct loading and filtering of transactions. - Accurate AI response generation and formatting. - Graceful handling of edge cases (e.g., no transactions in range, invalid time formats). - **`AIAnalyzerThreadTest`** Validates threading logic: - Ensures `AIAnalyzerThread` executes `Runnable` correctly. - Demonstrates clean and concurrent AI analysis flow. - Simulates integration with a GUI environment. - **`AiFunctionTest`** Utility-level tests: - Ensures proper CSV parsing and data transformation. - Verifies output formatting before sending to the AI. - Tests various time formats and edge case behaviors

## DAO (File Storage)

- Responsibilities: Save transaction data in CSV or JSON format and provide interfaces for adding,
  deleting, and modifying in-memory data

### CsvTransactionDao Class

#### Package

`DAO`

#### Dependencies

* **`model.Transaction`**: The data model class representing a single transaction.
* **`DAO.TransactionDao`**: The interface this class is intended to implement (though the implementation is incomplete).
* **Apache Commons CSV (`org.apache.commons.csv.*`)**: Used for robust parsing and writing of CSV data.
* **Apache Commons IO (`org.apache.commons.io.input.BOMInputStream`)**: Used specifically to handle potential Byte Order Marks (BOM) often found in UTF-8 encoded files, particularly those edited in Windows.
* **Java Standard Libraries**: `java.io.*`, `java.nio.*`.

#### Key Features & Implementation Details

* **CSV Loading (`loadFromCSV`)**:
  * Reads data from a specified CSV file path.
  * Expects UTF-8 encoding.
  * Handles potential Byte Order Mark (BOM) at the beginning of the file.
  * Uses the first row of the CSV as the header to map columns to `Transaction` fields. Assumes specific header names (e.g., "交易时间", "交易类型", "金额(元)").
  * Parses transaction records into a `List<Transaction>`.
  * Includes basic caching using an internal `transactions` list and an `isLoad` flag to avoid redundant file reads within the same instance lifecycle (unless forced by methods like `deleteTransaction` or `changeInformation`).
* **Record Parsing (`parseRecord`)**:
  * Converts a `CSVRecord` object (from Apache Commons CSV) into a `Transaction` object.
  * Specifically handles the "金额(元)" (Amount) field by removing the leading "¥" symbol before parsing it as a `double`.
* **Adding Transactions (`addTransaction(String filePath, Transaction newTransaction)`)**:
  * **Appends** a new transaction record to the *end* of the specified CSV file.
  * Creates the file if it doesn't exist.
  * Writes the header row only if the file is new or was empty.
  * Formats the payment amount by prepending "¥".
* **Deleting Transactions (`deleteTransaction(String filePath, String orderNumber)`)**:
  * Loads data from the file if not already cached.
  * Filters the cached list to remove the transaction matching the given `orderNumber`.
  * **Overwrites** the *entire* original CSV file with the filtered list using `writeTransactionsToCSV`.
  * Returns `true` if a transaction was removed, `false` otherwise.
* **Updating Transactions (`changeInformation`)**:
  * Loads data if not already cached.
  * Finds the transaction by `orderNumber`.
  * Modifies the specified field (`head`) of the found transaction object in memory.
  * **Crucially, it attempts the update by first *deleting* the original record (using `deleteTransaction`, which overwrites the file) and then *adding* the modified record (using `addTransaction`, which appends to the file).** This logic is inefficient and potentially problematic due to the conflicting file write strategies (overwrite vs. append).
  * Error handling for invalid `head` parameters prints to `System.err`. The method often returns `true` even if the underlying delete/add fails.
* **CSV Writing (`writeTransactionsToCSV`)**:
  * Helper method used by `deleteTransaction`.
  * Writes a given `List<Transaction>` to the specified file path, **overwriting** any existing content.
  * Writes a standard header row.
  * Formats the payment amount by prepending "¥".

#### Important Issues & Considerations

1.  **Incomplete `TransactionDao` Implementation**: The methods declared in the `TransactionDao` interface (`getAllTransactions`, `addTransaction(Transaction)`, `deleteTransaction(String)`, `updateTransaction`, `getTransactionByOrderNumber`) are present but contain only placeholder/stub code. The actual working logic uses separate methods that require the `filePath` to be passed explicitly each time. **This class, in its current state, does not correctly function as a `TransactionDao` implementation.**
2.  **Inconsistent File Writing Strategy**: `addTransaction` *appends* to the file, while `deleteTransaction` and `writeTransactionsToCSV` (used by `deleteTransaction` and `changeInformation`) *overwrite* the entire file. This inconsistency can lead to unexpected behavior, especially within the `changeInformation` method.
3.  **Inefficient Updates/Deletes**: Rewriting the entire CSV file for every single deletion or modification (`changeInformation`) is highly inefficient, especially for large transaction files.
4.  **Flawed Update Logic (`changeInformation`)**: The delete-then-add approach for updates is problematic due to the inconsistent write strategies and potential race conditions or partial failures. The modified record will likely appear at the *end* of the file, not its original position.
5.  **Basic Caching**: The caching mechanism (`isLoad` flag) is simple and does not account for external modifications to the CSV file during the application's runtime.
6.  **Hardcoded Dependencies**: The code relies on specific header names (in Chinese) and the "¥" currency symbol format within the CSV data. Changes to the CSV format would require code modifications.

#### Usage Example (Using Functional Methods)

```java
import DAO.CsvTransactionDao; // Assuming TransactionDao interface exists but is not used directly here due to stub methods
import model.Transaction;
import java.io.IOException;
import java.util.List;

public class CsvDataManager {

    public static void main(String[] args) {
        // NOTE: Using the class directly, not via the TransactionDao interface
        // because the interface methods are not fully implemented.
        CsvTransactionDao csvDao = new CsvTransactionDao();
        String csvFilePath = "path/to/your/transactions.csv"; // <--- Specify your file path

        try {
            // --- Load Data ---
            System.out.println("Loading transactions...");
            List<Transaction> transactions = csvDao.loadFromCSV(csvFilePath);
            System.out.println("Loaded " + transactions.size() + " transactions.");
            // Display first transaction if available
            if (!transactions.isEmpty()) {
                 System.out.println("First transaction order number: " + transactions.get(0).getOrderNumber());
            }

            // --- Add a New Transaction (Appends) ---
            Transaction newTx = new Transaction(
                 "2025-04-20 08:14:00", "Test Add", "Counterparty", "Item", "支",
                 10.0, "支付宝", "交易成功", "NEW_ORDER_123", "MERCH_456", "Test via DAO add"
            );
            System.out.println("\nAdding new transaction (append): " + newTx.getOrderNumber());
            // csvDao.addTransaction(csvFilePath, newTx); // Uncomment to actually add
            System.out.println("Transaction potentially added.");

            // --- Delete a Transaction (Overwrites File) ---
            String orderToDelete = "SOME_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number from your file
            System.out.println("\nAttempting to delete transaction: " + orderToDelete);
            // boolean deleted = csvDao.deleteTransaction(csvFilePath, orderToDelete); // Uncomment to actually delete
            // if (deleted) {
            //     System.out.println("Transaction deleted successfully (File rewritten).");
            // } else {
            //     System.out.println("Transaction not found for deletion.");
            // }

            // --- Change Information (Overwrites then Appends - Use with Caution) ---
             String orderToChange = "ANOTHER_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number
             String fieldToChange = "remarks";
             String newValue = "Updated remark via changeInformation";
             System.out.println("\nAttempting to change info for: " + orderToChange);
             // boolean changed = csvDao.changeInformation(orderToChange, fieldToChange, newValue, csvFilePath); // Uncomment with caution
             // System.out.println("Change operation attempted (File rewritten and appended). Result: " + changed);


        } catch (IOException e) {
            System.err.println("Error interacting with CSV file: " + e.getMessage());
            e.printStackTrace();
        } catch (NumberFormatException e) {
            System.err.println("Error parsing amount in CSV: " + e.getMessage());
        }
    }
}
```

## Controller (Swing GUI)

Responsibilities: Manage user interface components (buttons, tables, text boxes) to listen for 
events (clicks, inputs) and call service layer methods to update the interface data display

## attention

encoding with UTF-8
```

`软工/Ai-Bill-Application-Group21 - 副本\项目要求.txt`:

```txt
1. General Information 
In the next few weeks, your team will be required to develop a software application that 
will serve as a smart personal finance manager that helps users track expenses, set 
savings goals, and analyses spending habits using AI. Agile methods should be applied 
in all activities, from requirements through analysis/design, implementation, and testing. 
Iterations should be planned, and outcomes should be submitted. 
There are no restrictions on what you can include in the final product, and the given 
specification contains only high-level abstract requirements. It should be noted that 
determining the software requirements is one of the most important and complex phases 
in any development project. You should apply requirement-finding techniques and Agile 
methods to identify the actual requirements at an appropriate level. Most importantly, you 
need to prioritize the features that are implemented in accordance with both ease of 
implementation and meeting requirements. As in real software, you should define the 
project scope properly. Keep your design SIMPLE. Bear in mind that there is no absolute 
right answer – your solution may be perfectly appropriate.

2. Project Specification 
2.1 Basic Requirements 
Managing personal finances effectively is crucial in today’s digital economy, where 
transactions occur across multiple platforms like WeChat Pay, Alipay, and traditional 
banking. Many individuals struggle with tracking expenses, categorizing spending, and 
setting realistic budgets. An AI-powered personal finance tracker simplifies financial 
management by automatically classifying transactions, detecting spending patterns, and 
offering personalized savings recommendations. However, AI is not perfect – users must 
manually review to ensure accuracy. By integrating AI with manual validation, this 
software helps users make informed financial decisions while adapting to regional 
spending habits and economic conditions, improving financial literacy and budgeting 
skills. Here are some suggested functions to assist you in getting started. Suggested 
features can include the following, but not limited to: 
• Manual & Automated Data Entry: End users may input transactions manually or 
import structured CSV files from banking/financial apps. 
• Expense Categorisation (AI + Manual Correction): AI classifies transactions into 
categories (e.g., groceries, rent, entertainment), but end users can verify & correct 
misclassifications. 
• Spending Insights & Predictions: AI suggests monthly budgets, savings goals, and 
cost-cutting recommendations based on spending behaviour. 
• Local Financial Context: Customisable to China-specific budgeting habits, for 
example detects seasonal spending habits, such as higher expenses during Chinese 
New Year. 
A full prototype of the application should be produced. It is not required to implement the 
full working code for all functions in the prototype, however your team should implement 
core functions of your choice. 

2.2 Other Requirements 
• The software must be developed using Java as a stand-alone application running 
on computers. A simple graphic user interface (GUI) should be used. The recent 
Java Edition should be used. Do NOT build a Web-based application or Phone 
App. 
• All input and output data should be in simple text file format. You may use plain 
text (txt), CSV, JSON, or XML. Do NOT use a database. 
• Basic restrictions and error checking must be considered. 
• Your design must be flexible and extensible to adapt to future changes, e.g. 
modify existing features and add new features. When doing so, you should be 
able to reuse the existing components and make the least impact on the existing 
code. 
Page 2 of 8 
Your tasks are to define detailed requirements, design, develop and test the above software 
using Agile methods. Feel free to design the software as long as it satisfies the basic 
requirements, define the SCOPE properly.  

2.3 AI-Assisted Development 
To prevent over-reliance on AI, 
the following constraints apply: 
• Live Data Collection: AI cannot generate user-specific data patterns – you must 
gather real data. 请给出相应的数据搜集渠道（但是我们已经设计好了csv表，相应字段也设计了）
• Manual Data Cleaning and Validation: AI assistance is allowed, but the team must 
need to manually check for missing information, inconsistency, and inappropriate 
categorisation, etc. 
• Context-Specific Constraints: AI may struggle with domain-specific rules – you 
must implement real-world constraints (e.g. AI may count a WeChat Red Packet as a 
personal income where it is in fact a gift money and not a regular income.) 
• Oral Spot-Check: During the vivas, you will need to answer questions like “Why did 
AI make this recommendation?”, “How did you modify AI’s solution?”, etc, to 
demonstrate your understanding.
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>Ai-bill</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.knowm.xchart</groupId>
            <artifactId>xchart</artifactId>
            <version>3.8.4</version> <!-- Use the latest version -->
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.2</version>
            <scope>test</scope>
        </dependency>

        <!-- CSV 解析核心库 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-csv</artifactId>
            <version>1.10.0</version>
        </dependency>

        <!-- 文件操作工具 -->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>2.15.1</version>
        </dependency>

        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>5.10.0</version>
            <scope>test</scope>
        </dependency>

        <!-- 断言增强库 -->
        <dependency>
            <groupId>org.assertj</groupId>
            <artifactId>assertj-core</artifactId>
            <version>3.24.2</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.volcengine</groupId>
            <artifactId>volcengine-java-sdk-ark-runtime</artifactId>
            <version>LATEST</version>
        </dependency>
        <dependency>
            <groupId>javax.annotation</groupId>
            <artifactId>javax.annotation-api</artifactId>
            <version>1.3.2</version>
        </dependency>
        <!-- pom.xml -->



        <!-- JSON 处理 -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.15.2</version>
        </dependency>

        <!--        caffeine缓存中间件-->
        <dependency>
            <groupId>com.github.ben-manes.caffeine</groupId>
            <artifactId>caffeine</artifactId>
            <version>3.1.8</version> <!-- 使用最新版本 -->
        </dependency>

    </dependencies>

</project>
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Constants\CaffeineKeys.java`:

```java
package Constants;

public class CaffeineKeys {
    public static final String TRANSACTION_CAFFEINE_KEY = "transactions";

}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Constants\ConfigConstants.java`:

```java
package Constants;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

/**
 * 配置常量类（线程安全初始化）
 */
public final class ConfigConstants {
    private ConfigConstants() {} // 私有构造防止实例化

    // CSV路径常量
    public static final String CSV_PATH; // Original, may still be referenced in old code
    public static final String USERS_CSV_PATH; // User CSV path
    public static final String SUMMARY_CSV_PATH; // 新增汇总统计CSV路径


    // 静态初始化块（类加载时执行）
    static {
        Properties prop = new Properties();
        try (InputStream input = ConfigConstants.class.getClassLoader()
                .getResourceAsStream("config.properties")) {

            if (input == null) {
                throw new RuntimeException("配置文件 config.properties 未找到在 classpath 中");
            }

            prop.load(input);

            CSV_PATH = prop.getProperty("csv.path");
            USERS_CSV_PATH = prop.getProperty("csv.users_path");
            SUMMARY_CSV_PATH = prop.getProperty("csv.summary_path"); // 读取汇总统计CSV路径


            // Basic validation
            if (USERS_CSV_PATH == null || USERS_CSV_PATH.trim().isEmpty()) {
                throw new RuntimeException("'csv.users_path' not found or is empty in config.properties.");
            }
            if (SUMMARY_CSV_PATH == null || SUMMARY_CSV_PATH.trim().isEmpty()) {
                throw new RuntimeException("'csv.summary_path' not found or is empty in config.properties.");
            }

        } catch (IOException e) {
            throw new RuntimeException("加载配置文件失败", e); // 转换为运行时异常
        }
        System.out.println("Loaded USERS_CSV_PATH: " + USERS_CSV_PATH);
        System.out.println("Loaded SUMMARY_CSV_PATH: " + SUMMARY_CSV_PATH);
        if (CSV_PATH != null) System.out.println("Loaded CSV_PATH: " + CSV_PATH); // Optional print
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Constants\StandardCategories.java`:

```java
package Constants;

import java.util.List;
import java.util.ArrayList;
import java.util.Collections; // For immutable lists
import java.util.stream.Collectors;

public final class StandardCategories {
    private StandardCategories() {} // Prevent instantiation

    // Standard Expense Categories for analysis and filtering
    public static final List<String> EXPENSE_CATEGORIES = Collections.unmodifiableList(List.of(
            "餐饮",
            "食品杂货",
            "服饰",
            "日用品",
            "交通",
            "娱乐",
            "住房",
            "通信",
            "教育",
            "医疗",
            "金融服务",
            "其他支出" // General catch-all for expenses
    ));

    // Standard Income Categories
    public static final List<String> INCOME_CATEGORIES = Collections.unmodifiableList(List.of(
            "工资",
            "兼职收入",
            "投资收益",
            "其他收入" // General catch-all for income
    ));

    // Special Transaction Types (may not be strictly 'expense' or 'income' in analysis)
    public static final List<String> SPECIAL_TYPES = Collections.unmodifiableList(List.of(
            "转账", // Transfers between accounts or people
            "红包" // WeChat/Alipay Red Packets - often social, not regular income/expense
            // Add other special types as needed, e.g., Refund, Credit Card Repayment
    ));

    /**
     * Generates a comma-separated string of all standard categories for AI prompts.
     * @return String like "餐饮,食品杂货,服饰,..."
     */
    public static String getAllCategoriesString() {
        return ALL_KNOWN_TYPES.stream()
                .collect(Collectors.joining(","));
    }

    // All Known Transaction Types (combination of all the above + potentially user-defined ones initially)
    // This list might be used for dropdowns in UI, etc.
    public static final List<String> ALL_KNOWN_TYPES;

    static {
        List<String> allTypesMutable = new ArrayList<>();
        allTypesMutable.addAll(EXPENSE_CATEGORIES);
        allTypesMutable.addAll(INCOME_CATEGORIES);
        allTypesMutable.addAll(SPECIAL_TYPES);
        ALL_KNOWN_TYPES = Collections.unmodifiableList(allTypesMutable);
    }


    /**
     * Helper method to check if a transaction type is a standard expense category.
     * Handles potential variations like "支" vs "支出".
     */
    public static boolean isStandardExpenseCategory(String type) {
        if (type == null) return false;
        String trimmedType = type.trim();
        // First, check if it's directly in the list
        if (EXPENSE_CATEGORIES.contains(trimmedType)) {
            return true;
        }
        // Handle common aliases/variations if necessary, e.g., "交通费" -> "交通"
        // This might require a mapping logic if aliases are common and not handled by AI mapping.
        return false; // For now, strict check
    }

    /**
     * Helper method to get the standardized category for a given transaction type string.
     * This is where mapping from potentially messy user input or AI output to standard categories happens.
     * For now, a simple direct match is used. In the future, this could use AI recognition results
     * or manual mapping rules.
     * @param rawType The transaction type string from data.
     * @return The matched standard category, or the original rawType if no standard match, or "未知" for null/empty.
     */
    public static String getStandardCategory(String rawType) {
        if (rawType == null || rawType.trim().isEmpty()) {
            return "未知"; // Unknown category
        }
        String trimmedType = rawType.trim();
        // Check if it matches any standard category (case-insensitive might be better)
        // Let's do a simple case-sensitive check for now against the predefined lists.
        if (ALL_KNOWN_TYPES.contains(trimmedType)) {
            return trimmedType; // Direct match
        }

        // Future Improvement: Implement smarter mapping here, potentially using AI suggestions
        // or a configuration file for mapping common user inputs to standard categories.
        // E.g., if rawType is "吃饭", map to "餐饮". If "地铁票", map to "交通".

        return trimmedType; // If no standard match, return the original type.
        // We might want a dedicated "Other" if it doesn't fit any *known* type.
    }

    /**
     * Helper method to check if a transaction type is a standard income category.
     */
    public static boolean isStandardIncomeCategory(String type) {
        if (type == null) return false;
        return INCOME_CATEGORIES.contains(type.trim());
    }

    /**
     * Helper method to check if a transaction type is a special type.
     */
    public static boolean isSpecialType(String type) {
        if (type == null) return false;
        return SPECIAL_TYPES.contains(type.trim());
    }


}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Controller\ButtonEditor.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.TableCellEditor;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

class ButtonEditor extends AbstractCellEditor implements TableCellEditor {
    private final JPanel panel = new JPanel(new BorderLayout()); // 使用 BorderLayout
    private final JButton button = new JButton();
    private int rowIndex;
    private final MenuUI menuUI;

    public ButtonEditor(MenuUI menuUI) {
        this.menuUI = menuUI;

        // 设置按钮样式
        button.setFocusPainted(false); // 移除按钮的焦点边框
        button.setPreferredSize(new Dimension(80, 30)); // 设置按钮的固定尺寸

        // 添加按钮到面板
        panel.add(button, BorderLayout.CENTER);

        // 为按钮添加事件监听器
        button.addActionListener(e -> {
            System.out.println("按钮点击事件触发: " + button.getText());
            fireEditingStopped(); // 停止编辑
            String buttonText = button.getText();
            if ("Modify".equals(buttonText)) {
                menuUI.editRow(rowIndex); // 调用 MenuUI 的 editRow 方法
            } else if ("Delete".equals(buttonText)) {
                int confirm = JOptionPane.showConfirmDialog(panel, "确定要删除此行吗？", "确认删除", JOptionPane.YES_NO_OPTION);
                if (confirm == JOptionPane.YES_OPTION) {
                    menuUI.deleteRow(rowIndex); // 调用 MenuUI 的 deleteRow 方法
                }
            }
        });
    }

    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
        this.rowIndex = row; // 更新当前行索引
        button.setText(value != null ? value.toString() : ""); // 根据单元格的值设置按钮文本
        return panel;
    }

    @Override
    public Object getCellEditorValue() {
        return button.getText(); // 返回按钮的当前文本
    }
}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Controller\ButtonRenderer.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import java.awt.*;

class ButtonRenderer extends DefaultTableCellRenderer {
    private final JPanel panel = new JPanel(new BorderLayout()); // 使用 BorderLayout
    private final JButton button = new JButton();

    public ButtonRenderer() {
        button.setFocusPainted(false); // 移除按钮的焦点边框
        button.setPreferredSize(new Dimension(80, 30)); // 设置按钮的固定尺寸
        panel.add(button, BorderLayout.CENTER); // 将按钮添加到面板中心
    }

    @Override
    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
        // 根据单元格的值设置按钮文本
        button.setText(value != null ? value.toString() : "");
        return panel;
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Controller\HistogramExample.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;
import java.util.HashMap;
import java.util.Random;

// 数据生成类
class DataGenerator {
    public static int[] generateData(int numberOfDataPoints, int maxValue) {
        Random random = new Random();
        int[] data = new int[numberOfDataPoints];
        for (int i = 0; i < numberOfDataPoints; i++) {
            data[i] = random.nextInt(maxValue);
        }
        return data;
    }
}

// 直方图计算类
class Histogram {
    private int binSize;
    private int[] data;

    public Histogram(int[] data, int binSize) {
        this.data = data;
        this.binSize = binSize;
    }

    public HashMap<Integer, Integer> computeFrequency() {
        HashMap<Integer, Integer> frequencyMap = new HashMap<>();
        for (int number : data) {
            int bin = number / binSize;
            frequencyMap.put(bin, frequencyMap.getOrDefault(bin, 0) + 1);
        }
        return frequencyMap;
    }
}

// 直方图 GUI 绘制类
class HistogramPanel extends JPanel {
    HashMap<Integer, Integer> frequencyMap;

    public HistogramPanel() {
        this.frequencyMap = new HashMap<>();
    }

    public void updateData(HashMap<Integer, Integer> frequencyMap) {
        this.frequencyMap = frequencyMap;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        int barWidth = 40;
        int gap = 10;
        int maxFrequency = frequencyMap.values().stream().mapToInt(v -> v).max().orElse(1);

        int index = 0;
        for (Integer key : frequencyMap.keySet()) {
            int height = (int) ((frequencyMap.get(key) / (double) maxFrequency) * getHeight());
            g.setColor(Color.BLUE);
            g.fillRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.setColor(Color.BLACK);
            g.drawRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.drawString("Bin " + key, index * (barWidth + gap) + 5, getHeight() - 5);
            index++;
        }
    }
}


// 主窗口类
public class HistogramExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("数据分析界面");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });
    }
}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Controller\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}


```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Ai-Bill-Application-Prompt_2.txt`:

```txt
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Controller\MenuUI.java`:

```java
package Controller;

import Constants.ConfigConstants;
import Constants.StandardCategories; // Import StandardCategories if needed in UI
import DAO.TransactionDao; // Import if needed
import DAO.SummaryStatisticDao; // Import if needed
import Service.AIservice.AITransactionService; // Import AI services
import Service.AIservice.CollegeStudentNeeds;
import Service.Impl.TransactionServiceImpl;
import Service.Impl.SummaryStatisticService; // Import SummaryStatisticService
import Service.TransactionService;
import Utils.CacheManager;
import model.SummaryStatistic; // Import SummaryStatistic
import model.Transaction;
import model.User;
import Constants.StandardCategories;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.io.IOException;
import java.util.List;
import java.util.Vector;
import java.util.Comparator; // For sorting stats display

public class MenuUI extends JPanel { // Extend JPanel for easier use in Main (optional but common)

    private final User currentUser;
    private final TransactionService transactionService;
    private final SummaryStatisticService summaryStatisticService;
    private final AITransactionService aiTransactionService;
    private final CollegeStudentNeeds collegeStudentNeeds;

    private DefaultTableModel tableModel;

    // Fields for search input components
    private JTextField searchTransactionTimeField;
    private JTextField searchTransactionTypeField;
    private JTextField searchCounterpartyField;
    private JTextField searchCommodityField;
    private JComboBox<String> searchInOutComboBox;
    private JTextField searchPaymentMethodField;
    private JButton searchButton;

    private JTable table;
    // REMOVED: private HistogramPanelContainer histogramPanelContainer; // No longer needed

    private JPanel rightPanel;
    private CardLayout cardLayout;

    // UI components for AI panel (existing)
    private JTextArea aiResultArea;
    private JTextField aiStartTimeField;
    private JTextField aiEndTimeField;
    private JButton aiAnalyzeButton;
    private JButton aiBudgetButton;
    private JButton aiTipsButton;
    private JButton aiPersonalSummaryButton;
    private JButton aiSavingsGoalsButton;
    private JButton aiPersonalSavingTipsButton;


    // UI components for Admin Stats panel (existing)
    private JTextArea adminStatsArea;
    private JButton generateStatsButton;
    private JButton refreshDisplayButton;

    // New panel for Visualization
    private VisualizationPanel visualizationPanel; // Add instance field


    // Constructor now accepts all necessary service instances (same as before)
    public MenuUI(User authenticatedUser, TransactionService transactionService,
                  SummaryStatisticService summaryStatisticService,
                  AITransactionService aiTransactionService,
                  CollegeStudentNeeds collegeStudentNeeds) {

        this.currentUser = authenticatedUser;
        this.transactionService = transactionService;
        this.summaryStatisticService = summaryStatisticService;
        this.aiTransactionService = aiTransactionService;
        this.collegeStudentNeeds = collegeStudentNeeds;

        // Initialize table model (same as before)
        String[] columnNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注", "Modify", "Delete"};
        this.tableModel = new DefaultTableModel(columnNames, 0);
        this.table = new JTable(this.tableModel);

        // Initialize the main panel layout (same as before)
        setLayout(new BorderLayout());

        // Add the left panel (will be modified)
        add(createLeftPanel(), BorderLayout.WEST);

        // Add the right panel (will be modified)
        setupRightPanel();
        add(rightPanel, BorderLayout.CENTER);

        // Initial data load is done in createMainPanel (same as before)
        // loadCSVDataForCurrentUser("收入");

        System.out.println("MenuUI initialized for user: " + currentUser.getUsername() + " (" + currentUser.getRole() + ")");
    }

    public JPanel createMainPanel() {
        // MenuUI itself is the main panel, just add the initial data
        loadCSVDataForCurrentUser(""); // Load and display only income initially
        return this; // Return itself
    }


    // Method to load CSV data for the current user with optional initial filter
    // Same logic as before
    public void loadCSVDataForCurrentUser(String initialInOutFilter) {
        // ... existing implementation ...
        this.tableModel.setRowCount(0); // Clear the table model

        try {
            List<Transaction> transactions = transactionService.getAllTransactions();
            System.out.println("Loaded total " + transactions.size() + " transactions from service for user " + currentUser.getUsername());

            List<Transaction> filteredTransactions = new java.util.ArrayList<>();
            if (initialInOutFilter == null || initialInOutFilter.trim().isEmpty()) {
                filteredTransactions.addAll(transactions);
            } else {
                String filter = initialInOutFilter.trim();
                filteredTransactions = transactions.stream()
                        .filter(t -> t.getInOut() != null && (t.getInOut().equalsIgnoreCase(filter) ||
                                (filter.equalsIgnoreCase("收入") && t.getInOut().equalsIgnoreCase("收")) ||
                                (filter.equalsIgnoreCase("支出") && t.getInOut().equalsIgnoreCase("支")) ))
                        .collect(java.util.stream.Collectors.toList());
            }

            for (Transaction transaction : filteredTransactions) {
                Vector<String> row = createRowFromTransaction(transaction);
                this.tableModel.addRow(row);
            }
            System.out.println("Displayed " + filteredTransactions.size() + " transactions in the table.");

        } catch (Exception e) {
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, "加载用户交易数据失败！", "错误", JOptionPane.ERROR_MESSAGE);
        }
    }

    // Method to create the left panel (Menu/AI/Admin/Visualization buttons) - MODIFIED
    private JPanel createLeftPanel() {
        JPanel leftPanel = new JPanel();
        leftPanel.setLayout(new BoxLayout(leftPanel, BoxLayout.Y_AXIS));
        leftPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        JButton menuButton = new JButton("交易列表");
        JButton aiButton = new JButton("AI分析");
        JButton adminButton = new JButton("管理员统计");
        JButton visualizationButton = new JButton("可视化"); // NEW Visualization button

        // Set consistent size for buttons
        Dimension buttonSize = new Dimension(150, 40);
        menuButton.setMaximumSize(buttonSize);
        aiButton.setMaximumSize(buttonSize);
        adminButton.setMaximumSize(buttonSize);
        visualizationButton.setMaximumSize(buttonSize); // Set size for new button


        menuButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        aiButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        adminButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        visualizationButton.setAlignmentX(Component.CENTER_ALIGNMENT); // Align new button


        leftPanel.add(menuButton);
        leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        leftPanel.add(aiButton);
        leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));

        // Add Admin button only if the user is admin (same as before)
        if ("admin".equalsIgnoreCase(currentUser.getRole())) {
            leftPanel.add(adminButton);
            leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        }

        // Add Visualization button (visible for all users)
        leftPanel.add(visualizationButton); // Add the visualization button
        leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));


        // Add action listeners (existing for Menu, AI, Admin)
        menuButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Table");
            loadCSVDataForCurrentUser("收入");
        });

        aiButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "AI");
        });

        if ("admin".equalsIgnoreCase(currentUser.getRole())) {
            adminButton.addActionListener(e -> {
                cardLayout.show(rightPanel, "AdminStats");
                displaySummaryStatistics(); // Refresh stats display when switching
            });
        }

        // Add action listener for Visualization button - NEW
        visualizationButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Visualization"); // Switch to visualization view
            // Optional: Trigger initial chart load or setup in VisualizationPanel
            // visualizationPanel.loadAndDisplayCharts(); // Needs a method in VisualizationPanel
        });


        leftPanel.add(Box.createVerticalGlue());

        return leftPanel;
    }

    // Method to set up the right panel, adding different views - MODIFIED
    private void setupRightPanel() {
        this.cardLayout = new CardLayout();
        this.rightPanel = new JPanel(this.cardLayout);

        // Create and add different panels (views)
        JPanel tablePanel = createTablePanel(); // Table view
        JPanel aiPanel = createAIPanel(); // AI view
        JPanel adminStatsPanel = createAdminStatsPanel(); // Admin stats view
        this.visualizationPanel = new VisualizationPanel(this.transactionService); // NEW: Create VisualizationPanel, inject TransactionService


        rightPanel.add(tablePanel, "Table");
        rightPanel.add(aiPanel, "AI");
        if ("admin".equalsIgnoreCase(currentUser.getRole())) {
            rightPanel.add(adminStatsPanel, "AdminStats");
        }
        rightPanel.add(visualizationPanel, "Visualization"); // NEW: Add Visualization panel


        // Set the initially visible card (Table view)
        cardLayout.show(rightPanel, "Table");
    }

    // Method to create the table panel - same as before
    private JPanel createTablePanel() {
        JPanel tablePanel = new JPanel(new BorderLayout());

        JPanel inputPanel = createInputPanel(); // This method now initializes search fields
        tablePanel.add(inputPanel, BorderLayout.NORTH);

        JScrollPane tableScrollPane = new JScrollPane(this.table);
        tableScrollPane.setPreferredSize(new Dimension(1000, 250)); // Preferred size hint
        this.table.setFillsViewportHeight(true); // Make table fill the scroll pane height
        this.table.setRowHeight(30);

        tablePanel.add(tableScrollPane, BorderLayout.CENTER);

        // Set cell renderers and editors
        this.table.getColumnModel().getColumn(11).setCellRenderer(new ButtonRenderer());
        this.table.getColumnModel().getColumn(11).setCellEditor(new ButtonEditor(this));

        this.table.getColumnModel().getColumn(12).setCellRenderer(new ButtonRenderer());
        this.table.getColumnModel().getColumn(12).setCellEditor(new ButtonEditor(this));

        // Initial data load is done in the MenuUI constructor or createMainPanel
        // loadCSVDataForCurrentUser("收入"); // Moved to createMainPanel

        return tablePanel;
    }

    // Inside MenuUI class
    private JPanel createInputPanel() {
        JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));

        // Create input fields and capture references (existing code)
        searchTransactionTimeField = new JTextField(10);
        searchTransactionTypeField = new JTextField(10);
        searchCounterpartyField = new JTextField(10);
        searchCommodityField = new JTextField(10);
        searchInOutComboBox = new JComboBox<>(new String[]{"", "收入", "支出"});
        searchPaymentMethodField = new JTextField(10);

        // Add labels and input fields (existing code)
        inputPanel.add(new JLabel("交易时间:")); inputPanel.add(searchTransactionTimeField);
        inputPanel.add(new JLabel("交易类型:")); inputPanel.add(searchTransactionTypeField);
        inputPanel.add(new JLabel("交易对方:")); inputPanel.add(searchCounterpartyField);
        inputPanel.add(new JLabel("商品:")); inputPanel.add(searchCommodityField);
        inputPanel.add(new JLabel("收/支:")); inputPanel.add(searchInOutComboBox);
        inputPanel.add(new JLabel("支付方式:")); inputPanel.add(searchPaymentMethodField);

        // Create Search, Add, and Import buttons
        searchButton = new JButton("Search");
        JButton addButton = new JButton("Add");
        JButton importButton = new JButton("导入 CSV"); // 新增导入按钮

        // Add buttons
        inputPanel.add(searchButton);
        inputPanel.add(addButton);
        inputPanel.add(importButton); // 添加导入按钮

        // Add ActionListeners (existing code for Search and Add)
        searchButton.addActionListener(e -> triggerCurrentSearch());
        addButton.addActionListener(e -> showAddTransactionDialog());

        // Add ActionListener for Import button
        importButton.addActionListener(e -> {
            showImportDialog(); // Call a new method to handle import
        });

        return inputPanel;
    }

    // Inside MenuUI class
    private void showImportDialog() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("选择要导入的CSV文件");
        // Optional: Add file filter for .csv files
        fileChooser.setFileFilter(new javax.swing.filechooser.FileNameExtensionFilter("CSV Files (*.csv)", "csv"));

        int userSelection = fileChooser.showOpenDialog(this); // Show dialog relative to MenuUI panel

        if (userSelection == JFileChooser.APPROVE_OPTION) {
            java.io.File fileToImport = fileChooser.getSelectedFile();
            String filePath = fileToImport.getAbsolutePath();
            System.out.println("用户选择了导入文件: " + filePath);

            // Display "Importing..." message and disable button (optional UI feedback)
            // This needs a status area, maybe in the main panel or a separate progress dialog.
            // For simplicity now, we'll just show messages.

            // Run import in a background thread
            // Need to pass the file path and the current user's file path to the service
            new Thread(() -> {
                String message;
                try {
                    // Call the service method to handle the import logic
                    int importedCount = transactionService.importTransactionsFromCsv(currentUser.getTransactionFilePath(), filePath);

                    message = "成功导入 " + importedCount + " 条交易记录。";
                    System.out.println(message);

                    // Update UI on EDT after successful import
                    String finalMessage = message;
                    SwingUtilities.invokeLater(() -> {
                        loadCSVDataForCurrentUser(""); // Reload all data to show imported items
                        clearSearchFields(); // Clear search fields after reload
                        JOptionPane.showMessageDialog(this, finalMessage, "导入成功", JOptionPane.INFORMATION_MESSAGE);
                    });

                } catch (Exception ex) { // Catch exceptions from the service layer
                    message = "导入失败！\n" + ex.getMessage();
                    System.err.println("CSV Import failed: " + ex.getMessage());
                    ex.printStackTrace();
                    // Update UI on EDT with error message
                    String finalMessage1 = message;
                    SwingUtilities.invokeLater(() -> {
                        JOptionPane.showMessageDialog(this, finalMessage1, "导入错误", JOptionPane.ERROR_MESSAGE);
                    });
                }
            }).start();
        } else {
            System.out.println("用户取消了文件选择。");
        }
    }

    // Inside MenuUI class, showAddTransactionDialog method
    private void showAddTransactionDialog() {
        JDialog addDialog = new JDialog();
        addDialog.setTitle("添加交易");
        JPanel dialogPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.insets = new Insets(5, 5, 5, 5);

        JTextField transactionTimeField = new JTextField(15);
        JTextField transactionTypeField = new JTextField(15);
        JButton aiSuggestButton = new JButton("AI分类建议");
        // Removed aiStatusLabel as we use a separate waiting dialog


        JTextField counterpartyField = new JTextField(15);
        JTextField commodityField = new JTextField(15);
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"});
        JTextField paymentAmountField = new JTextField(15);
        JTextField paymentMethodField = new JTextField(15);
        JTextField currentStatusField = new JTextField(15);
        JTextField orderNumberField = new JTextField(15);
        JTextField merchantNumberField = new JTextField(15);
        JTextField remarksField = new JTextField(15);


        gbc.gridx = 0; gbc.gridy = 0; dialogPanel.add(new JLabel("交易时间:"), gbc);
        gbc.gridx = 1; gbc.gridy = 0; gbc.gridwidth = 2; dialogPanel.add(transactionTimeField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 1; dialogPanel.add(new JLabel("交易类型:"), gbc);
        gbc.gridx = 1; gbc.gridy = 1; gbc.weightx = 1.0; dialogPanel.add(transactionTypeField, gbc);
        gbc.gridx = 2; gbc.gridy = 1; gbc.weightx = 0.0; dialogPanel.add(aiSuggestButton, gbc);


        gbc.gridx = 0; gbc.gridy = 2; gbc.gridwidth = 1; dialogPanel.add(new JLabel("交易对方:"), gbc);
        gbc.gridx = 1; gbc.gridy = 2; gbc.gridwidth = 2; dialogPanel.add(counterpartyField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 3; gbc.gridwidth = 1; dialogPanel.add(new JLabel("商品:"), gbc);
        gbc.gridx = 1; gbc.gridy = 3; gbc.gridwidth = 2; dialogPanel.add(commodityField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 4; gbc.gridwidth = 1; dialogPanel.add(new JLabel("收/支:"), gbc);
        gbc.gridx = 1; gbc.gridy = 4; gbc.gridwidth = 2; dialogPanel.add(inOutComboBox, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 5; gbc.gridwidth = 1; dialogPanel.add(new JLabel("金额(元):"), gbc);
        gbc.gridx = 1; gbc.gridy = 5; gbc.gridwidth = 2; dialogPanel.add(paymentAmountField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 6; gbc.gridwidth = 1; dialogPanel.add(new JLabel("支付方式:"), gbc);
        gbc.gridx = 1; gbc.gridy = 6; gbc.gridwidth = 2; dialogPanel.add(paymentMethodField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 7; gbc.gridwidth = 1; dialogPanel.add(new JLabel("当前状态:"), gbc);
        gbc.gridx = 1; gbc.gridy = 7; gbc.gridwidth = 2; dialogPanel.add(currentStatusField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 8; gbc.gridwidth = 1; dialogPanel.add(new JLabel("交易单号:"));
        gbc.gridx = 1; gbc.gridy = 8; gbc.gridwidth = 2; dialogPanel.add(orderNumberField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 9; gbc.gridwidth = 1; dialogPanel.add(new JLabel("商户单号:"));
        gbc.gridx = 1; gbc.gridy = 9; gbc.gridwidth = 2; dialogPanel.add(merchantNumberField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 10; gbc.gridwidth = 1; dialogPanel.add(new JLabel("备注:"));
        gbc.gridx = 1; gbc.gridy = 10; gbc.gridwidth = 2; dialogPanel.add(remarksField, gbc); gbc.gridwidth = 1;


        // --- Define the modal waiting dialog ---
        JDialog waitingDialog = new JDialog(addDialog, "请稍候", true); // Modal dialog owned by addDialog
        waitingDialog.setLayout(new FlowLayout());
        waitingDialog.add(new JLabel("正在获取AI分类建议..."));
        waitingDialog.setSize(200, 100);
        waitingDialog.setResizable(false);
        // waitingDialog.setLocationRelativeTo(addDialog); // Set location later before showing
        // --- End waiting dialog definition ---


        // Add Confirm and Cancel buttons
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        JButton confirmButton = new JButton("确认");
        JButton cancelButton = new JButton("取消");
        buttonPanel.add(confirmButton);
        buttonPanel.add(cancelButton);

        gbc.gridx = 0; gbc.gridy = 11; gbc.gridwidth = 3; gbc.anchor = GridBagConstraints.CENTER; gbc.fill = GridBagConstraints.NONE; // Adjust gridy
        dialogPanel.add(buttonPanel, gbc);


        addDialog.add(dialogPanel, BorderLayout.CENTER);


        // Add AI Suggest button action listener - MODIFIED LOGIC FLOW
        aiSuggestButton.addActionListener(e -> {
            System.out.println("AI Suggest button clicked (EDT).");

            // 1. Disable button immediately on EDT
            aiSuggestButton.setEnabled(false);
            // confirmButton.setEnabled(false); // Optional: also disable confirm

            // 2. Build temporary transaction object from current fields
            Transaction tempTransaction = new Transaction(
                    emptyIfNull(transactionTimeField.getText().trim()),
                    emptyIfNull(transactionTypeField.getText().trim()), // Capture current potentially incomplete type
                    emptyIfNull(counterpartyField.getText().trim()),
                    emptyIfNull(commodityField.getText().trim()),
                    (String) inOutComboBox.getSelectedItem(),
                    safeParseDouble(paymentAmountField.getText().trim()),
                    emptyIfNull(paymentMethodField.getText().trim()),
                    emptyIfNull(currentStatusField.getText().trim()),
                    emptyIfNull(orderNumberField.getText().trim()),
                    emptyIfNull(merchantNumberField.getText().trim()),
                    emptyIfNull(remarksField.getText().trim())
            );

            // 3. Create and start the background thread FIRST
            new Thread(() -> {
                System.out.println("Background thread started for AI classification...");
                String aiSuggestion = null;
                try {
                    // Simulate delay for testing thread behavior
                    // Thread.sleep(3000); // Uncomment to simulate a 3-second delay
                    aiSuggestion = collegeStudentNeeds.RecognizeTransaction(tempTransaction);
                    System.out.println("AI Classification returned in background thread: " + aiSuggestion);
                } catch (Exception ex) {
                    System.err.println("Error in background AI thread: " + ex.getMessage());
                    ex.printStackTrace();
                    aiSuggestion = "Error: " + ex.getMessage(); // Capture error to display later
                }


                // 4. Schedule the UI update and dialog hiding on the EDT from the background thread
                String finalSuggestion = aiSuggestion; // Need a final variable for use in lambda
                SwingUtilities.invokeLater(() -> {
                    System.out.println("Updating UI on EDT from background thread.");
                    // --- Hide waiting dialog ---
                    waitingDialog.setVisible(false); // This is the call that unblocks the initial setVisible(true)

                    // --- Display AI suggestion ---
                    if (finalSuggestion != null && !finalSuggestion.isEmpty() && !finalSuggestion.startsWith("Error:")) {
                        // Safety Check: Although prompt asks for standard, AI might deviate.
                        // If AI *strictly* follows the prompt, this check might be redundant,
                        // but adding it makes the UI robust against unexpected AI output.
                        if (StandardCategories.ALL_KNOWN_TYPES.contains(finalSuggestion.trim())) {
                            transactionTypeField.setText(finalSuggestion.trim());
                        } else {
                            System.err.println("AI returned non-standard category despite prompt: " + finalSuggestion);
                            // Handle non-standard: Maybe use it anyway, or warn and clear.
                            // According to requirement: "分类严格符合所规定的那几类". If AI fails, we should not inject non-standard.
                            JOptionPane.showMessageDialog(addDialog, "AI返回了非预期的分类格式：\n" + finalSuggestion + "\n请手动输入。", "AI结果异常", JOptionPane.WARNING_MESSAGE);
                            transactionTypeField.setText(""); // Clear or set to default if AI fails strict adherence
                        }
                    } else if (finalSuggestion != null && finalSuggestion.startsWith("Error:")) {
                        // Handle the error case
                        JOptionPane.showMessageDialog(addDialog, "获取AI分类建议失败！\n" + finalSuggestion.substring(6), "AI错误", JOptionPane.ERROR_MESSAGE);
                        transactionTypeField.setText(""); // Clear the field on error
                    }
                    else { // AI returned null or empty
                        JOptionPane.showMessageDialog(addDialog, "AI未能提供分类建议。", "AI提示", JOptionPane.INFORMATION_MESSAGE);
                        transactionTypeField.setText("");
                    }

                    // 5. Re-enable buttons on EDT
                    aiSuggestButton.setEnabled(true);
                    // confirmButton.setEnabled(true);
                    System.out.println("UI update complete, buttons re-enabled.");
                });
            }).start();

            // --- 6. Show the modal waiting dialog LAST in the EDT block ---
            // This call will block the EDT until waitingDialog.setVisible(false) is called from the thread.
            System.out.println("Showing waiting dialog (EDT block continues here).");
            waitingDialog.setLocationRelativeTo(addDialog); // Center relative to add dialog before showing
            waitingDialog.setVisible(true); // THIS IS THE CALL THAT BLOCKS THE EDT
            System.out.println("waiting dialog is now hidden (EDT unblocked)."); // This line prints after dialog is hidden by the thread
        });


        // Add Confirm button action listener (existing validation logic)
        confirmButton.addActionListener(e -> {
            String transactionTime = emptyIfNull(transactionTimeField.getText().trim());
            String finalTransactionType = emptyIfNull(transactionTypeField.getText().trim());
            String counterparty = emptyIfNull(counterpartyField.getText().trim());
            String commodity = emptyIfNull(commodityField.getText().trim());
            String inOut = (String) inOutComboBox.getSelectedItem();
            String paymentAmountText = paymentAmountField.getText().trim();
            String paymentMethod = emptyIfNull(paymentMethodField.getText().trim());
            String currentStatus = emptyIfNull(currentStatusField.getText().trim());
            String orderNumber = emptyIfNull(orderNumberField.getText().trim());
            String merchantNumber = emptyIfNull(merchantNumberField.getText().trim());
            String remarks = emptyIfNull(remarksField.getText().trim());

            // --- Input Validation ---
            if (orderNumber.isEmpty()) {
                JOptionPane.showMessageDialog(addDialog, "交易单号不能为空！", "输入错误", JOptionPane.ERROR_MESSAGE);
                return;
            }

            if (finalTransactionType.isEmpty()) {
                JOptionPane.showMessageDialog(addDialog, "交易类型不能为空！", "输入错误", JOptionPane.ERROR_MESSAGE);
                return;
            }
            // Validate against standard categories if strict input is desired from user too
            if (!StandardCategories.ALL_KNOWN_TYPES.contains(finalTransactionType)) {
                JOptionPane.showMessageDialog(addDialog, "交易类型必须是标准类别之一！\n允许的类别:\n" + StandardCategories.getAllCategoriesString(), "输入错误", JOptionPane.ERROR_MESSAGE);
                return; // Enforce standard categories for manual input
            }


            double paymentAmount = 0.0;
            if (!paymentAmountText.isEmpty()) {
                try {
                    paymentAmount = Double.parseDouble(paymentAmountText);
                    // Optional: Check for non-negative amount for expenses/income
                    if (paymentAmount < 0) {
                        JOptionPane.showMessageDialog(addDialog, "金额不能为负数！", "输入错误", JOptionPane.ERROR_MESSAGE);
                        return;
                    }
                } catch (NumberFormatException ex) {
                    JOptionPane.showMessageDialog(addDialog, "金额格式不正确！请输入数字。", "输入错误", JOptionPane.ERROR_MESSAGE);
                    return;
                }
            }
            // --- End Validation ---


            Transaction newTransaction = new Transaction(
                    transactionTime,
                    finalTransactionType, // Use the final value from the field (now validated to be standard)
                    counterparty,
                    commodity,
                    inOut,
                    paymentAmount,
                    paymentMethod,
                    currentStatus,
                    orderNumber,
                    merchantNumber,
                    remarks
            );

            // Order number uniqueness check is better in service layer before saving

            try {
                // Optional: Check for duplicate order number in service layer before adding
                // if (!transactionService.isOrderNumberUnique(orderNumber)) {
                //      JOptionPane.showMessageDialog(addDialog, "交易单号 '" + orderNumber + "' 已存在！", "输入错误", JOptionPane.ERROR_MESSAGE);
                //      return;
                // }

                transactionService.addTransaction(newTransaction);

                loadCSVDataForCurrentUser(""); // Load all data after adding
                clearSearchFields();

                addDialog.dispose();
                JOptionPane.showMessageDialog(null, "交易添加成功！", "提示", JOptionPane.INFORMATION_MESSAGE);

            } catch (IOException ex) {
                ex.printStackTrace();
                // Change ERROR_ERROR to ERROR_MESSAGE
                JOptionPane.showMessageDialog(null, "交易添加失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
            } catch (Exception ex) {
                ex.printStackTrace();
                // Change ERROR_ERROR to ERROR_MESSAGE
                JOptionPane.showMessageDialog(null, "交易添加失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
            }
        });

        cancelButton.addActionListener(e -> addDialog.dispose());

        // --- Dialog setup and showing ---
        addDialog.pack(); // Pack the dialog to fit its components
        addDialog.setLocationRelativeTo(this); // Center relative to the MenuUI panel
        addDialog.setVisible(true); // Show the add dialog (this is the initial blocking call for the add dialog itself)
        // --- End Dialog setup ---
    }


    // Method to edit row - updated for AI integration and getting data from table model
    public void editRow(int rowIndex) {
        System.out.println("编辑行: " + rowIndex + " for user " + currentUser.getUsername());
        // Define JDialog, JPanel, GridBagConstraints at the start
        JDialog editDialog = new JDialog();
        JPanel dialogPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();


        if (rowIndex >= 0 && rowIndex < this.tableModel.getRowCount()) {
            Vector<String> rowData = new Vector<>();
            for (int i = 0; i <= 10; i++) { // Columns 0 to 10 are Transaction fields
                Object value = this.tableModel.getValueAt(rowIndex, i);
                rowData.add(value != null ? value.toString() : "");
            }
            System.out.println("Retrieved row data from table model for editing: " + rowData);

            String originalOrderNumber = rowData.get(8).trim();
            if (originalOrderNumber.isEmpty()) {
                JOptionPane.showMessageDialog(null, "无法编辑：交易单号为空！", "错误", JOptionPane.ERROR_MESSAGE);
                System.err.println("Attempted to edit row " + rowIndex + " but order number is empty.");
                // editDialog remains undefined here if this happens, might crash later if used.
                // Return immediately
                return;
            }


            editDialog.setTitle("修改交易信息 (订单号: " + originalOrderNumber + ")");
            editDialog.setModal(true);

            gbc.fill = GridBagConstraints.HORIZONTAL;
            gbc.insets = new Insets(5, 5, 5, 5);

            JTextField[] fields = new JTextField[11];
            String[] fieldNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"};
            JButton aiSuggestButton = new JButton("AI分类建议");


            for (int i = 0; i < fieldNames.length; i++) {
                gbc.gridx = 0; gbc.gridy = i; gbc.gridwidth = 1; gbc.weightx = 0.0; dialogPanel.add(new JLabel(fieldNames[i] + ":"), gbc);
                fields[i] = new JTextField(rowData.get(i));
                if (i == 1) { // Transaction Type field
                    gbc.gridx = 1; gbc.gridy = i; gbc.weightx = 1.0; dialogPanel.add(fields[i], gbc);
                    gbc.gridx = 2; gbc.gridy = i; gbc.weightx = 0.0; dialogPanel.add(aiSuggestButton, gbc);
                    gbc.gridwidth = 1;
                } else {
                    gbc.gridx = 1; gbc.gridy = i; gbc.gridwidth = 2; gbc.weightx = 1.0; dialogPanel.add(fields[i], gbc);
                    gbc.gridwidth = 1;
                }
            }

            fields[8].setEditable(false); // Disable editing OrderNumber field


            // --- Define the modal waiting dialog ---
            JDialog waitingDialog = new JDialog(editDialog, "请稍候", true); // Modal dialog owned by editDialog
            waitingDialog.setLayout(new FlowLayout());
            waitingDialog.add(new JLabel("正在获取AI分类建议..."));
            waitingDialog.setSize(200, 100);
            waitingDialog.setResizable(false);
            // waitingDialog.setLocationRelativeTo(editDialog); // Set location later before showing
            // --- End waiting dialog definition ---


            // Add Confirm and Cancel buttons
            JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
            JButton confirmButton = new JButton("确认");
            JButton cancelButton = new JButton("取消");
            buttonPanel.add(confirmButton);
            buttonPanel.add(cancelButton);

            gbc.gridx = 0; gbc.gridy = fieldNames.length; gbc.gridwidth = 3; gbc.anchor = GridBagConstraints.CENTER; gbc.fill = GridBagConstraints.NONE; dialogPanel.add(buttonPanel, gbc);


            editDialog.add(dialogPanel, BorderLayout.CENTER);


            // Add AI Suggest button action listener - MODIFIED LOGIC FLOW
            aiSuggestButton.addActionListener(e -> {
                System.out.println("AI Suggest button clicked (EDT) in edit dialog.");
                // 1. Disable button immediately on EDT
                aiSuggestButton.setEnabled(false);
                // confirmButton.setEnabled(false); // Optional: also disable confirm

                // 2. Build temporary transaction object from current fields
                Transaction tempTransaction = new Transaction(
                        fields[0].getText().trim(), fields[1].getText().trim(), fields[2].getText().trim(),
                        fields[3].getText().trim(), fields[4].getText().trim(), safeParseDouble(fields[5].getText().trim()),
                        fields[6].getText().trim(), fields[7].getText().trim(), fields[8].getText().trim(),
                        fields[9].getText().trim(), fields[10].getText().trim()
                );

                // 3. Create and start the background thread FIRST
                new Thread(() -> {
                    System.out.println("Background thread started for AI classification (edit dialog)...");
                    String aiSuggestion = null;
                    try {
                        // Simulate delay for testing thread behavior
                        // Thread.sleep(3000); // Uncomment to simulate a 3-second delay
                        aiSuggestion = collegeStudentNeeds.RecognizeTransaction(tempTransaction);
                        System.out.println("AI Classification returned in background thread (edit dialog): " + aiSuggestion);
                    } catch (Exception ex) {
                        System.err.println("Error in background AI thread (edit dialog): " + ex.getMessage());
                        ex.printStackTrace();
                        aiSuggestion = "Error: " + ex.getMessage(); // Capture error to display later
                    }


                    // 4. Schedule the UI update and dialog hiding on the EDT from the background thread
                    String finalSuggestion = aiSuggestion; // Need a final variable for use in lambda
                    SwingUtilities.invokeLater(() -> {
                        System.out.println("Updating UI on EDT from background thread (edit dialog).");
                        // --- Hide waiting dialog ---
                        waitingDialog.setVisible(false); // This is the call that unblocks the initial setVisible(true)

                        // --- Display AI suggestion ---
                        if (finalSuggestion != null && !finalSuggestion.isEmpty() && !finalSuggestion.startsWith("Error:")) {
                            // Safety Check: Although prompt asks for standard, AI might deviate.
                            if (StandardCategories.ALL_KNOWN_TYPES.contains(finalSuggestion.trim())) {
                                fields[1].setText(finalSuggestion.trim());
                            } else {
                                System.err.println("AI returned non-standard category despite prompt: " + finalSuggestion);
                                // Handle non-standard: Warn and clear/set to default
                                JOptionPane.showMessageDialog(editDialog, "AI返回了非预期的分类格式：\n" + finalSuggestion + "\n请手动输入。", "AI结果异常", JOptionPane.WARNING_MESSAGE);
                                fields[1].setText("");
                            }
                        } else if (finalSuggestion != null && finalSuggestion.startsWith("Error:")) {
                            // Handle the error case
                            JOptionPane.showMessageDialog(editDialog, "获取AI分类建议失败！\n" + finalSuggestion.substring(6), "AI错误", JOptionPane.ERROR_MESSAGE);
                            fields[1].setText("");
                        }
                        else { // AI returned null or empty
                            JOptionPane.showMessageDialog(editDialog, "AI未能提供分类建议。", "AI提示", JOptionPane.INFORMATION_MESSAGE);
                            fields[1].setText("");
                        }

                        // 5. Re-enable buttons on EDT
                        aiSuggestButton.setEnabled(true);
                        // confirmButton.setEnabled(true);
                        System.out.println("UI update complete, buttons re-enabled (edit dialog).");
                    });
                }).start();

                // --- 6. Show the modal waiting dialog LAST in the EDT block ---
                // This call will block the EDT until waitingDialog.setVisible(false) is called from the thread.
                System.out.println("Showing waiting dialog (EDT block continues here in edit dialog).");
                waitingDialog.setLocationRelativeTo(editDialog); // Center relative to edit dialog before showing
                waitingDialog.setVisible(true); // THIS IS THE CALL THAT BLOCKS THE EDT
                System.out.println("waiting dialog is now hidden (EDT unblocked in edit dialog)."); // This line prints after dialog is hidden by the thread
            });


            // Add Confirm and Cancel button listeners
            confirmButton.addActionListener(e -> {
                String transactionTime = fields[0].getText().trim();
                String finalTransactionType = fields[1].getText().trim();
                String counterparty = fields[2].getText().trim();
                String commodity = fields[3].getText().trim();
                String inOut = fields[4].getText().trim();
                String paymentAmountText = fields[5].getText().trim();
                String paymentMethod = fields[6].getText().trim();
                String currentStatus = fields[7].getText().trim();
                // Original ON is used from the variable 'originalOrderNumber' defined outside this listener
                String merchantNumber = fields[9].getText().trim();
                String remarks = fields[10].getText().trim();

                // --- Input Validation ---
                if (finalTransactionType.isEmpty()) {
                    JOptionPane.showMessageDialog(editDialog, "交易类型不能为空！", "输入错误", JOptionPane.ERROR_MESSAGE);
                    return;
                }
                // Validate against standard categories
                if (!StandardCategories.ALL_KNOWN_TYPES.contains(finalTransactionType)) {
                    JOptionPane.showMessageDialog(editDialog, "交易类型必须是标准类别之一！\n允许的类别:\n" + StandardCategories.getAllCategoriesString(), "输入错误", JOptionPane.ERROR_MESSAGE);
                    return; // Enforce standard categories for manual input
                }
                // Validate 收/支 is one of expected values
                if (!inOut.equals("收入") && !inOut.equals("支出") && !inOut.equals("收") && !inOut.equals("支")) {
                    JOptionPane.showMessageDialog(editDialog, "收/支字段必须是 '收入' 或 '支出'。", "输入错误", JOptionPane.ERROR_MESSAGE);
                    return;
                }

                double paymentAmount = 0.0;
                if (!paymentAmountText.isEmpty()) {
                    try {
                        paymentAmount = Double.parseDouble(paymentAmountText);
                        if (paymentAmount < 0) {
                            JOptionPane.showMessageDialog(editDialog, "金额不能为负数！", "输入错误", JOptionPane.ERROR_MESSAGE);
                            return;
                        }
                    } catch (NumberFormatException ex) {
                        JOptionPane.showMessageDialog(editDialog, "金额格式不正确！请输入数字。", "输入错误", JOptionPane.ERROR_MESSAGE);
                        return;
                    }
                }
                // --- End Validation ---


                Transaction updatedTransaction = new Transaction(
                        transactionTime, finalTransactionType, counterparty, commodity, inOut,
                        paymentAmount, paymentMethod, currentStatus, originalOrderNumber, // Use the correct originalOrderNumber
                        merchantNumber, remarks
                );


                try {
                    transactionService.changeTransaction(updatedTransaction);
                    System.out.println("Edit successful. Preparing to refresh display filtered by InOut: " + updatedTransaction.getInOut());
                    clearSearchFields();
                    String updatedInOut = updatedTransaction.getInOut();
                    boolean foundInOut = false;
                    for(int i=0; i < searchInOutComboBox.getItemCount(); i++) {
                        if (updatedInOut != null && updatedInOut.equals(searchInOutComboBox.getItemAt(i))) {
                            searchInOutComboBox.setSelectedItem(updatedInOut);
                            foundInOut = true;
                            break;
                        }
                    }
                    if (!foundInOut) { searchInOutComboBox.setSelectedItem(""); }

                    triggerCurrentSearch();

                    editDialog.dispose();
                    JOptionPane.showMessageDialog(null, "修改成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                    System.out.println("Edited row " + rowIndex + " for order number " + originalOrderNumber + " and refreshed display.");

                } catch (IllegalArgumentException ex) {
                    JOptionPane.showMessageDialog(editDialog, "修改失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
                    ex.printStackTrace();
                } catch (Exception ex) {
                    ex.printStackTrace();
                    // Change ERROR_ERROR to ERROR_MESSAGE
                    JOptionPane.showMessageDialog(editDialog, "修改失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
                }
            });

            cancelButton.addActionListener(e -> editDialog.dispose());

            // --- Dialog setup and showing ---
            editDialog.pack();
            editDialog.setLocationRelativeTo(this);
            editDialog.setVisible(true); // Show the edit dialog (this is the initial blocking call for the edit dialog itself)
            // --- End Dialog setup ---

        } else {
            // This block is for invalid rowIndex. The dialog shouldn't be shown.
            // Remove the confusing editDialog.pack/setLocation/setVisible calls here.
            System.err.println("Attempted to edit row with invalid index: " + rowIndex + ". Table row count: " + this.tableModel.getRowCount());
        }
        // Remove the final redundant pack/setLocation/setVisible calls outside the if block
        // if (editDialog != null) { editDialog.pack(); }
        // if (editDialog != null) { editDialog.setLocationRelativeTo(this); }
        // if (editDialog != null) { editDialog.setVisible(true); } // Redundant if dialog shown in the if block
    }

    // Method to create the AI panel - UPDATED
    private JPanel createAIPanel() {
        JPanel panel = new JPanel(new BorderLayout(10, 10));
        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // Panel for General AI Analysis
        JPanel generalAnalysisPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));
        JTextField userRequestField = new JTextField(40);
        aiStartTimeField = new JTextField(10);
        aiEndTimeField = new JTextField(10);
        aiAnalyzeButton = new JButton("通用分析 (按原始数据)"); // Clarify this uses raw data


        generalAnalysisPanel.add(new JLabel("通用分析要求:"));
        generalAnalysisPanel.add(userRequestField);
        generalAnalysisPanel.add(new JLabel("时间范围 (yyyy/MM/dd HH:mm): 从:"));
        generalAnalysisPanel.add(aiStartTimeField);
        generalAnalysisPanel.add(new JLabel("到:"));
        generalAnalysisPanel.add(aiEndTimeField);
        generalAnalysisPanel.add(aiAnalyzeButton);


        // Panel for Summary-Based AI Analysis (NEW)
        JPanel summaryAnalysisPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));
        aiPersonalSummaryButton = new JButton("个人消费总结"); // New button
        aiSavingsGoalsButton = new JButton("储蓄目标建议"); // New button
        aiPersonalSavingTipsButton = new JButton("个性化节约建议"); // New button

        summaryAnalysisPanel.add(new JLabel("基于月度总结分析:"));
        summaryAnalysisPanel.add(aiPersonalSummaryButton);
        summaryAnalysisPanel.add(aiSavingsGoalsButton);
        summaryAnalysisPanel.add(aiPersonalSavingTipsButton);


        // Panel for College Student Needs buttons (existing)
        JPanel csButtonsPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10)); // Align left for consistency
        aiBudgetButton = new JButton("预算建议 (学生)"); // Clarify this is student-specific
        aiTipsButton = new JButton("省钱技巧 (学生)"); // Clarify this is student-specific
        csButtonsPanel.add(new JLabel("大学生专属功能:"));
        csButtonsPanel.add(aiBudgetButton);
        csButtonsPanel.add(aiTipsButton);


        // Combine all control panels in a box layout
        JPanel topControlPanel = new JPanel();
        topControlPanel.setLayout(new BoxLayout(topControlPanel, BoxLayout.Y_AXIS));
        topControlPanel.add(generalAnalysisPanel);
        topControlPanel.add(Box.createRigidArea(new Dimension(0, 10))); // Spacing
        topControlPanel.add(summaryAnalysisPanel); // Add new panel
        topControlPanel.add(Box.createRigidArea(new Dimension(0, 10))); // Spacing
        topControlPanel.add(csButtonsPanel); // Add existing CS panel
        topControlPanel.add(Box.createRigidArea(new Dimension(0, 10))); // Spacing


        panel.add(topControlPanel, BorderLayout.NORTH);

        // Center area for displaying AI results - same as before
        aiResultArea = new JTextArea();
        aiResultArea.setFont(new Font("微软雅黑", Font.PLAIN, 14));
        aiResultArea.setLineWrap(true);
        aiResultArea.setWrapStyleWord(true);
        aiResultArea.setEditable(false);
        aiResultArea.setText("欢迎使用AI个人财务分析功能。\n\n" +
                "您可以尝试以下操作：\n" +
                "1. 在上方输入框提出通用分析要求（基于原始数据，可指定时间范围），点击\"通用分析\"。\n" +
                "2. 点击\"个人消费总结\"，获取基于您月度收支汇总的详细总结。\n" +
                "3. 点击\"储蓄目标建议\"，获取基于您收支情况的储蓄建议。\n" +
                "4. 点击\"个性化节约建议\"，获取基于您消费类别的节约建议。\n" +
                "5. 大学生用户可点击\"预算建议\"和\"省钱技巧\"获取专属建议。\n");


        JScrollPane resultScrollPane = new JScrollPane(aiResultArea);
        panel.add(resultScrollPane, BorderLayout.CENTER);


        // --- Add Action Listeners for NEW Buttons ---

        aiPersonalSummaryButton.addActionListener(e -> {
            aiResultArea.setText("--- 个人消费总结生成中 ---\n\n正在根据您的月度消费数据生成总结，请稍候...\n");
            setAIButtonsEnabled(false);

            new Thread(() -> {
                String result = aiTransactionService.generatePersonalSummary(currentUser.getTransactionFilePath()); // Call the new method

                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- 个人消费总结 ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        aiSavingsGoalsButton.addActionListener(e -> {
            aiResultArea.setText("--- 储蓄目标建议生成中 ---\n\n正在根据您的收支情况生成储蓄目标建议，请稍候...\n");
            setAIButtonsEnabled(false);

            new Thread(() -> {
                String result = aiTransactionService.suggestSavingsGoals(currentUser.getTransactionFilePath()); // Call the new method

                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- 储蓄目标建议 ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        aiPersonalSavingTipsButton.addActionListener(e -> {
            aiResultArea.setText("--- 个性化节约建议生成中 ---\n\n正在根据您的消费类别生成节约建议，请稍候...\n");
            setAIButtonsEnabled(false);

            new Thread(() -> {
                String result = aiTransactionService.givePersonalSavingTips(currentUser.getTransactionFilePath()); // Call the new method

                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- 个性化节约建议 ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });


        // --- Action Listeners for EXISTING Buttons (UPDATE PROMPTS/HEADERS) ---
        // Update existing listeners to use better headers/messages

        // General Analyze Button
        aiAnalyzeButton.addActionListener(e -> {
            String userRequest = userRequestField.getText().trim();
            String startTimeStr = aiStartTimeField.getText().trim();
            String endTimeStr = aiEndTimeField.getText().trim();

            if (userRequest.isEmpty()) {
                JOptionPane.showMessageDialog(this, "请输入AI通用分析要求。", "输入提示", JOptionPane.INFORMATION_MESSAGE);
                return;
            }
            if (startTimeStr.isEmpty() && !endTimeStr.isEmpty()) {
                JOptionPane.showMessageDialog(this, "请至少输入分析的开始时间。", "输入提示", JOptionPane.INFORMATION_MESSAGE);
                return;
            }


            aiResultArea.setText("--- 通用分析生成中 ---\n\n" + "正在进行AI通用分析，请稍候...\n");
            setAIButtonsEnabled(false);


            new Thread(() -> {
                String result = aiTransactionService.analyzeTransactions(userRequest, currentUser.getTransactionFilePath(), startTimeStr, endTimeStr);

                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- 通用分析结果 ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        // College Student Budget Button
        aiBudgetButton.addActionListener(e -> {
            aiResultArea.setText("--- 大学生预算建议生成中 ---\n\n正在根据您的历史支出生成预算建议，请稍候...\n");
            setAIButtonsEnabled(false);

            new Thread(() -> {
                String resultMessage;
                try {
                    double[] budgetRange = collegeStudentNeeds.generateBudget(currentUser.getTransactionFilePath());
                    if (budgetRange != null && budgetRange.length == 2 && budgetRange[0] != -1) {
                        resultMessage = String.format("根据您的消费记录，下周的建议预算范围是: [%.2f元, %.2f元]", budgetRange[0], budgetRange[1]);
                    } else if (budgetRange != null && budgetRange.length == 2 && budgetRange[0] == -1) {
                        resultMessage = "暂无足够的消费记录来计算周预算建议。";
                    }
                    else {
                        resultMessage = "生成预算建议失败，AI未能返回有效范围。";
                        System.err.println("AI Budget generation failed, invalid response format.");
                    }
                } catch (Exception ex) {
                    resultMessage = "生成预算建议失败！\n" + ex.getMessage();
                    System.err.println("Error generating AI budget:");
                    ex.printStackTrace();
                }

                String finalResultMessage = resultMessage;
                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- 大学生预算建议 ---\n\n" + finalResultMessage);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        // College Student Tips Button
        aiTipsButton.addActionListener(e -> {
            aiResultArea.setText("--- 大学生省钱技巧生成中 ---\n\n正在生成省钱技巧，请稍候...\n");
            setAIButtonsEnabled(false);

            new Thread(() -> {
                String resultMessage;
                try {
                    // Call the CollegeStudentNeeds method (now uses monthly summary)
                    resultMessage = collegeStudentNeeds.generateTipsForSaving(currentUser.getTransactionFilePath());

                } catch (Exception ex) {
                    resultMessage = "生成省钱技巧失败！\n" + ex.getMessage();
                    System.err.println("Error generating AI tips:");
                    ex.printStackTrace();
                }

                String finalResultMessage = resultMessage;
                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- 大学生省钱技巧 ---\n\n" + finalResultMessage);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });


        return panel;
    }

    // Helper method to enable/disable all AI related buttons - UPDATED
    private void setAIButtonsEnabled(boolean enabled) {
        if (aiAnalyzeButton != null) aiAnalyzeButton.setEnabled(enabled);
        if (aiBudgetButton != null) aiBudgetButton.setEnabled(enabled);
        if (aiTipsButton != null) aiTipsButton.setEnabled(enabled);
        // Enable/disable new buttons
        if (aiPersonalSummaryButton != null) aiPersonalSummaryButton.setEnabled(enabled);
        if (aiSavingsGoalsButton != null) aiSavingsGoalsButton.setEnabled(enabled);
        if (aiPersonalSavingTipsButton != null) aiPersonalSavingTipsButton.setEnabled(enabled);
    }


    // Method to create the Admin Stats panel (Implement the placeholder)
    private JPanel createAdminStatsPanel() {
        JPanel panel = new JPanel(new BorderLayout(10, 10));
        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        generateStatsButton = new JButton("生成/更新统计数据"); // Assign to instance field
        refreshDisplayButton = new JButton("刷新显示"); // Assign to instance field

        controlPanel.add(generateStatsButton);
        controlPanel.add(refreshDisplayButton);

        panel.add(controlPanel, BorderLayout.NORTH);

        adminStatsArea = new JTextArea(); // Assign to instance field
        adminStatsArea.setFont(new Font("微软雅黑", Font.PLAIN, 14));
        adminStatsArea.setEditable(false);
        adminStatsArea.setLineWrap(true); // Enable line wrapping
        adminStatsArea.setWrapStyleWord(true); // Wrap at word boundaries
        JScrollPane scrollPane = new JScrollPane(adminStatsArea);
        panel.add(scrollPane, BorderLayout.CENTER);


        generateStatsButton.addActionListener(e -> {
            adminStatsArea.setText("正在生成/更新汇总统计数据，请稍候...\n");
            generateStatsButton.setEnabled(false);
            refreshDisplayButton.setEnabled(false);

            new Thread(() -> {
                String message;
                try {
                    // Use the injected SummaryStatisticService
                    summaryStatisticService.generateAndSaveWeeklyStatistics();
                    message = "汇总统计数据生成/更新成功！\n请点击 '刷新显示' 查看最新数据。";
                    System.out.println(message);
                } catch (Exception ex) {
                    message = "汇总统计数据生成/更新失败！\n" + ex.getMessage();
                    System.err.println(message);
                    ex.printStackTrace();
                }

                String finalMessage = message;
                SwingUtilities.invokeLater(() -> {
                    adminStatsArea.setText(finalMessage);
                    generateStatsButton.setEnabled(true);
                    refreshDisplayButton.setEnabled(true);
                });
            }).start();
        });

        refreshDisplayButton.addActionListener(e -> {
            displaySummaryStatistics();
        });

        // Initial display when the panel is first shown (Optional)
        // Load existing stats when the panel is created, before it's potentially shown
        // This avoids a blank screen initially.
        new Thread(() -> {
            SwingUtilities.invokeLater(() -> adminStatsArea.setText("正在加载现有统计数据...\n"));
            try {
                List<SummaryStatistic> initialStats = summaryStatisticService.getAllSummaryStatistics();
                if (!initialStats.isEmpty()) {
                    // If initial stats exist, display them
                    SwingUtilities.invokeLater(this::displaySummaryStatistics);
                } else {
                    SwingUtilities.invokeLater(() -> adminStatsArea.setText("没有找到现有的汇总统计数据。\n请点击 '生成/更新统计数据' 按钮来生成。"));
                }
            } catch (IOException ex) {
                SwingUtilities.invokeLater(() -> adminStatsArea.setText("加载现有统计数据失败！\n" + ex.getMessage()));
                ex.printStackTrace();
            }
        }).start();


        return panel;
    }

    // Method to display summary statistics (Implement the placeholder)
    private void displaySummaryStatistics() {
        adminStatsArea.setText("正在加载汇总统计数据...\n");
        // Optional: Disable buttons while loading
        if(generateStatsButton != null) generateStatsButton.setEnabled(false);
        if(refreshDisplayButton != null) refreshDisplayButton.setEnabled(false);


        new Thread(() -> {
            String displayContent;
            try {
                List<SummaryStatistic> stats = summaryStatisticService.getAllSummaryStatistics();
                if (stats.isEmpty()) {
                    displayContent = "目前没有汇总统计数据。\n请先点击 '生成/更新统计数据' 按钮。";
                } else {
                    StringBuilder sb = new StringBuilder("===== 汇总统计数据 =====\n\n");
                    // Sort stats by week identifier (chronologically) before displaying
                    stats.sort(Comparator.comparing(SummaryStatistic::getWeekIdentifier));

                    // Display newest week first
                    for (int i = stats.size() - 1; i >= 0; i--) {
                        SummaryStatistic stat = stats.get(i);
                        sb.append("周标识: ").append(stat.getWeekIdentifier()).append("\n");
                        sb.append("  总收入: ").append(String.format("%.2f", stat.getTotalIncomeAllUsers())).append("元\n");
                        sb.append("  总支出: ").append(String.format("%.2f", stat.getTotalExpenseAllUsers())).append("元\n");
                        // Only show top category if there was actual expense in that category
                        if (stat.getTopExpenseCategoryAmount() > 0) {
                            sb.append("  最高支出类别: ").append(stat.getTopExpenseCategory()).append(" (").append(String.format("%.2f", stat.getTopExpenseCategoryAmount())).append("元)\n");
                        } else {
                            sb.append("  最高支出类别: 无显著支出类别\n"); // Or "无支出" if total expense is 0
                        }

                        sb.append("  参与用户数: ").append(stat.getNumberOfUsersWithTransactions()).append("\n");
                        sb.append("  生成时间: ").append(stat.getTimestampGenerated()).append("\n");
                        sb.append("--------------------\n");
                    }
                    displayContent = sb.toString();
                }
            } catch (IOException ex) {
                displayContent = "加载汇总统计数据失败！\n" + ex.getMessage();
                ex.printStackTrace();
            }

            String finalDisplayContent = displayContent;
            SwingUtilities.invokeLater(() -> {
                adminStatsArea.setText(finalDisplayContent);
                // Re-enable buttons
                if(generateStatsButton != null) generateStatsButton.setEnabled(true);
                if(refreshDisplayButton != null) refreshDisplayButton.setEnabled(true);
            });
        }).start();
    }

    // Method to delete row - get data from tableModel (remove allData usage)
    public void deleteRow(int rowIndex) {
        System.out.println("尝试删除行: " + rowIndex + " for user " + currentUser.getUsername());
        if (rowIndex >= 0 && rowIndex < this.tableModel.getRowCount()) { // Use tableModel row count

            // Get the order number directly from the displayed table row
            String orderNumber = (String) this.tableModel.getValueAt(rowIndex, 8); // OrderNumber is at index 8
            if (orderNumber == null || orderNumber.trim().isEmpty()) {
                JOptionPane.showMessageDialog(null, "无法删除：交易单号为空！", "错误", JOptionPane.ERROR_MESSAGE);
                System.err.println("Attempted to delete row " + rowIndex + " but order number is null or empty.");
                return; // Cannot delete without an order number
            }
            orderNumber = orderNumber.trim();
            System.out.println("Deleting transaction with order number: " + orderNumber);

            // Optional: Ask for confirmation before deleting
            int confirm = JOptionPane.showConfirmDialog(
                    this, // Parent component
                    "确定要删除订单号为 '" + orderNumber + "' 的交易吗？",
                    "确认删除",
                    JOptionPane.YES_NO_OPTION,
                    JOptionPane.QUESTION_MESSAGE
            );

            if (confirm == JOptionPane.YES_OPTION) {
                try {
                    // Use the injected transactionService instance
                    boolean deleted = transactionService.deleteTransaction(orderNumber);

                    if (deleted) {
                        // Data is removed from CSV and cache invalidated by service.
                        // Update the UI model directly by removing the row.
                        // This is faster than reloading all data for just one deletion.
                        this.tableModel.removeRow(rowIndex);

                        JOptionPane.showMessageDialog(null, "删除成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                        System.out.println("Deleted row " + rowIndex + " with order number " + orderNumber + " from UI.");

                        // After delete, refresh the view by re-applying the current search/filter criteria.
                        triggerCurrentSearch();

                    } else {
                        // This case means the service said it wasn't deleted (likely not found)
                        // This might happen if the underlying data changed between loading and deleting
                        JOptionPane.showMessageDialog(null, "删除失败：未找到对应的交易单号 " + orderNumber, "错误", JOptionPane.ERROR_MESSAGE);
                        System.err.println("Delete failed: order number " + orderNumber + " not found by service.");
                    }
                } catch (Exception ex) {
                    ex.printStackTrace();
                    JOptionPane.showMessageDialog(null, "删除失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
                    System.err.println("Error during deletion for order number " + orderNumber);
                }
            } else {
                System.out.println("Deletion cancelled by user for order number: " + orderNumber);
            }
        } else {
            System.err.println("Attempted to delete row with invalid index: " + rowIndex + ". Table row count: " + this.tableModel.getRowCount());
        }
    }

    // Method to create table row from Transaction object - no changes needed here
    private Vector<String> createRowFromTransaction(Transaction transaction) {
        Vector<String> row = new Vector<>();
        row.add(emptyIfNull(transaction.getTransactionTime()));
        row.add(emptyIfNull(transaction.getTransactionType()));
        row.add(emptyIfNull(transaction.getCounterparty()));
        row.add(emptyIfNull(transaction.getCommodity()));
        row.add(emptyIfNull(transaction.getInOut()));
        row.add(String.valueOf(transaction.getPaymentAmount()));
        row.add(emptyIfNull(transaction.getPaymentMethod()));
        row.add(emptyIfNull(transaction.getCurrentStatus()));
        row.add(emptyIfNull(transaction.getOrderNumber()));
        row.add(emptyIfNull(transaction.getMerchantNumber()));
        row.add(emptyIfNull(transaction.getRemarks()));
        row.add("Modify");
        row.add("Delete");
        return row;
    }

    // Method to search data - same as before
    public void searchData(String query1, String query2, String query3, String query4, String query6, String query5) {
        // ... existing implementation ...
        System.out.println("Searching with criteria: time='" + query1 + "', type='" + query2 + "', counterparty='" + query3 + "', commodity='" + query4 + "', inOut='" + query6 + "', paymentMethod='" + query5 + "'");
        this.tableModel.setRowCount(0);

        Transaction searchCriteria = new Transaction(
                query1, query2, query3, query4, query6,
                0,
                query5,
                "", "", "", ""
        );

        try {
            List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);
            System.out.println("Search results count: " + transactions.size());
            for (Transaction transaction : transactions) {
                Vector<String> row = createRowFromTransaction(transaction);
                this.tableModel.addRow(row);
            }

        } catch (Exception ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(null, "查询失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
        }
    }


    // ... safeParseDouble, clearSearchFields, triggerCurrentSearch, emptyIfNull, getTable methods ...
    private double safeParseDouble(String value) {
        if (value == null || value.trim().isEmpty()) return 0.0;
        try { return Double.parseDouble(value.trim()); }
        catch (NumberFormatException e) { System.err.println("Failed to parse double from string: '" + value + "'"); return 0.0; }
    }
    private void clearSearchFields() {
        searchTransactionTimeField.setText("");
        searchTransactionTypeField.setText("");
        searchCounterpartyField.setText("");
        searchCommodityField.setText("");
        searchInOutComboBox.setSelectedItem("");
        searchPaymentMethodField.setText("");
        System.out.println("Cleared search fields.");
    }
    private void triggerCurrentSearch() {
        searchData(
                searchTransactionTimeField.getText().trim(),
                searchTransactionTypeField.getText().trim(),
                searchCounterpartyField.getText().trim(),
                searchCommodityField.getText().trim(),
                (String) searchInOutComboBox.getSelectedItem(),
                searchPaymentMethodField.getText().trim()
        );
        System.out.println("Triggered search with current field values.");
    }
    private String emptyIfNull(String value) {
        return value == null ? "" : value;
    }
    public JTable getTable() {
        return table;
    }

}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Controller\VisualizationPanel.java`:

```java
package Controller;

import Service.TransactionService;
import model.MonthlySummary;

import java.awt.*;
import java.util.Map;
import java.util.List; // Import List
import java.util.ArrayList; // Import ArrayList
import java.util.HashMap; // Import HashMap
import java.util.Collections; // Import Collections for sorting
import java.util.Comparator; // Import Comparator

import javax.swing.*;

// Import XChart classes
import org.knowm.xchart.CategoryChart;
import org.knowm.xchart.CategoryChartBuilder;
import org.knowm.xchart.PieChart;
import org.knowm.xchart.PieChartBuilder;
import org.knowm.xchart.SwingWrapper; // Might be needed for Swing components
import org.knowm.xchart.XChartPanel; // Use XChartPanel for Swing display
import org.knowm.xchart.style.Styler.LegendPosition; // For chart styling


/**
 * Panel to display transaction data visualizations using XChart.
 */
public class VisualizationPanel extends JPanel {

    private final TransactionService transactionService;

    private JComboBox<String> monthSelector;
    private JComboBox<String> chartTypeSelector;
    private JButton generateChartButton;
    private JPanel chartDisplayPanel;


    /**
     * Constructor to inject the TransactionService.
     * @param transactionService The service to retrieve user transaction data.
     */
    public VisualizationPanel(TransactionService transactionService) {
        this.transactionService = transactionService;
        setLayout(new BorderLayout(10, 10));
        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // --- Control Panel (Top) ---
        JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 5));

        chartTypeSelector = new JComboBox<>(new String[]{"请选择图表类型", "月度支出分类饼图", "月度收支趋势柱状图"});
        controlPanel.add(new JLabel("图表类型:"));
        controlPanel.add(chartTypeSelector);

        monthSelector = new JComboBox<>();
        monthSelector.setEnabled(false);
        controlPanel.add(new JLabel("选择月份:"));
        controlPanel.add(monthSelector);


        generateChartButton = new JButton("生成图表");
        controlPanel.add(generateChartButton);

        add(controlPanel, BorderLayout.NORTH);


        // --- Chart Display Panel (Center) ---
        chartDisplayPanel = new JPanel(new BorderLayout());
        chartDisplayPanel.setBackground(Color.WHITE);
        add(chartDisplayPanel, BorderLayout.CENTER);


        // --- Action Listeners ---
        chartTypeSelector.addActionListener(e -> {
            String selectedType = (String) chartTypeSelector.getSelectedItem();
            boolean needsMonth = "月度支出分类饼图".equals(selectedType);
            monthSelector.setEnabled(needsMonth);
            // Populate months only when Pie Chart is selected
            if (needsMonth) {
                populateMonthSelector();
            } else {
                monthSelector.removeAllItems(); // Clear months if not needed
                monthSelector.addItem("请选择月份"); // Add default item back
            }
        });

        generateChartButton.addActionListener(e -> {
            generateAndDisplayChart();
        });

        // Initial state display
        displayPlaceholderChart("请选择一种图表类型和必要参数来生成图表。");

        // Initial data loading if needed on panel creation - Let's load months when Pie Chart is selected
        // populateMonthSelector(); // Removed, triggered by chart type selection
    }

    /**
     * Populates the month selector combo box with months from available data.
     */
    private void populateMonthSelector() {
        monthSelector.removeAllItems();
        monthSelector.addItem("请选择月份");

        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            if (summaries != null && !summaries.isEmpty()) {
                // Sort month identifiers chronologically
                summaries.keySet().stream().sorted().forEach(monthSelector::addItem);
                // monthSelector.setEnabled(true); // Enabled by chartTypeSelector listener
            } else {
                // monthSelector.setEnabled(false); // Disabled by chartTypeSelector listener
                JOptionPane.showMessageDialog(this, "没有找到月度交易数据来生成图表。", "数据不足", JOptionPane.INFORMATION_MESSAGE);
            }
        } catch (Exception e) {
            System.err.println("Error loading monthly summaries for month selector: " + e.getMessage());
            // monthSelector.setEnabled(false); // Disabled by chartTypeSelector listener
            JOptionPane.showMessageDialog(this, "加载月份数据失败！\n" + e.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
        }
    }


    /**
     * Generates and displays the selected chart based on user selection using XChart.
     */
    private void generateAndDisplayChart() {
        String selectedChartType = (String) chartTypeSelector.getSelectedItem();
        String selectedMonth = (String) monthSelector.getSelectedItem();

        // Clear previous chart
        chartDisplayPanel.removeAll();
        chartDisplayPanel.revalidate();
        chartDisplayPanel.repaint();

        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            if (summaries == null || summaries.isEmpty()) {
                displayPlaceholderChart("没有找到月度交易数据来生成图表。");
                return;
            }

            if ("月度支出分类饼图".equals(selectedChartType)) {
                if (selectedMonth == null || selectedMonth.equals("请选择月份") || selectedMonth.trim().isEmpty()) {
                    JOptionPane.showMessageDialog(this, "请选择要查看的月份。", "提示", JOptionPane.INFORMATION_MESSAGE);
                    displayPlaceholderChart("请选择一个有效的月份来生成饼图。");
                    return;
                }
                // --- Generate Pie Chart ---
                MonthlySummary selectedMonthSummary = summaries.get(selectedMonth);
                if (selectedMonthSummary == null || selectedMonthSummary.getExpenseByCategory().isEmpty()) {
                    displayPlaceholderChart(selectedMonth + " 月没有支出分类数据。");
                    return;
                }

                System.out.println("Generating Pie Chart for " + selectedMonth + "...");
                PieChart chart = new PieChartBuilder()
                        .width(chartDisplayPanel.getWidth())
                        .height(chartDisplayPanel.getHeight())
                        .title(selectedMonth + " 月支出分类")
                        .build();

                selectedMonthSummary.getExpenseByCategory().entrySet().stream()
                        .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                        .forEach(entry -> chart.addSeries(entry.getKey(), entry.getValue()));

                // Customize chart style (optional - COMMENT OUT lines causing errors)
                // chart.getStyler().setLegendVisible(true); // Keep if it works
                // chart.getStyler().setAnnotationType(org.knowm.xchart.style.Styler.AnnotationType.LabelAndPercentage); // COMMENT OUT or FIX
                // chart.getStyler().setDonutTogether(true); // COMMENT OUT or FIX

                // Add the chart to the display panel
                XChartPanel<PieChart> chartPanel = new XChartPanel<>(chart);
                chartDisplayPanel.add(chartPanel, BorderLayout.CENTER);
                System.out.println("Pie Chart generated and displayed.");


            } else if ("月度收支趋势柱状图".equals(selectedChartType)) {
                // --- Generate Bar Chart (Category Chart) ---
                System.out.println("Generating Monthly Income/Expense Trend Bar Chart...");

                List<String> months = new ArrayList<>();
                List<Double> totalIncomes = new ArrayList<>();
                List<Double> totalExpenses = new ArrayList<>();

                List<String> sortedMonths = new ArrayList<>(summaries.keySet());
                Collections.sort(sortedMonths);

                for (String month : sortedMonths) {
                    MonthlySummary ms = summaries.get(month);
                    months.add(month);
                    totalIncomes.add(ms.getTotalIncome());
                    totalExpenses.add(ms.getTotalExpense());
                }

                CategoryChart chart = new CategoryChartBuilder()
                        .width(chartDisplayPanel.getWidth())
                        .height(chartDisplayPanel.getHeight())
                        .title("月度收支趋势")
                        .xAxisTitle("月份")
                        .yAxisTitle("金额 (元)")
                        .build();

                chart.addSeries("总收入", months, totalIncomes);
                chart.addSeries("总支出", months, totalExpenses);

                // Customize chart style (optional - COMMENT OUT lines causing errors)
                // chart.getStyler().setLegendPosition(LegendPosition.OutsideS); // Keep if it works
                // chart.getStyler().setHasAnnotations(true); // COMMENT OUT or FIX
                // chart.getStyler().setStacked(false); // Keep if it works

                // Add the chart to the display panel
                XChartPanel<CategoryChart> chartPanel = new XChartPanel<>(chart);
                chartDisplayPanel.add(chartPanel, BorderLayout.CENTER);
                System.out.println("Bar Chart generated and displayed.");


            } else {
                displayPlaceholderChart("请选择一种图表类型和必要参数来生成图表。");
            }

        } catch (Exception e) {
            System.err.println("Error generating chart: " + selectedChartType);
            e.printStackTrace();
            displayPlaceholderChart("生成图表失败！\n" + e.getMessage());
            JOptionPane.showMessageDialog(this, "生成图表失败！\n" + e.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
        } finally {
            chartDisplayPanel.revalidate();
            chartDisplayPanel.repaint();
        }
    }

    /**
     * Helper method to display a placeholder message.
     */
    private void displayPlaceholderChart(String message) {
        // Clear previous content first
        chartDisplayPanel.removeAll();

        JLabel placeholderLabel = new JLabel(message, SwingConstants.CENTER);
        placeholderLabel.setFont(new Font("微软雅黑", Font.PLAIN, 16));
        chartDisplayPanel.add(placeholderLabel, BorderLayout.CENTER);

        chartDisplayPanel.revalidate();
        chartDisplayPanel.repaint();
    }

    // Optional: Method to trigger initial setup when panel is displayed
    // Call this from MenuUI's ActionListener for the Visualization button
    public void refreshPanelData() {
        System.out.println("VisualizationPanel refreshPanelData called.");
        // Populate month selector when the panel is visible
        // It's populated by the chartTypeSelector listener when Pie chart is selected.
        // So, no need to call populateMonthSelector here directly.

        // Reset chart type selector to default on refresh
        chartTypeSelector.setSelectedItem("请选择图表类型");
        // This action will trigger monthSelector logic

        // Display initial instruction message
        displayPlaceholderChart("请选择一种图表类型和必要参数来生成图表。");
    }

}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\DAO\Impl\CsvSummaryStatisticDao.java`:

```java
package DAO.Impl;

import DAO.SummaryStatisticDao;
import model.SummaryStatistic;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class CsvSummaryStatisticDao implements SummaryStatisticDao {

    // Define the header for the summary statistics CSV
    private static final String[] HEADERS = {
            "week_identifier", "total_income_all_users", "total_expense_all_users",
            "top_expense_category", "top_expense_category_amount",
            "number_of_users_with_transactions", "timestamp_generated"
    };

    @Override
    public List<SummaryStatistic> loadAllStatistics(String filePath) throws IOException {
        List<SummaryStatistic> statistics = new ArrayList<>();
        Path path = Paths.get(filePath);

        if (!Files.exists(path) || Files.size(path) == 0) {
            System.out.println("Summary statistics CSV file not found or is empty: " + filePath);
            return statistics;
        }

        try (Reader reader = new InputStreamReader(
                new BOMInputStream(Files.newInputStream(path)),
                StandardCharsets.UTF_8)) {

            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()
                    .withIgnoreHeaderCase(true)
                    .withTrim(true);

            try (CSVParser csvParser = new CSVParser(reader, format)) {
                Map<String, Integer> headerMap = csvParser.getHeaderMap();
                // Basic header validation
                List<String> requiredHeaders = List.of(HEADERS);
                if (headerMap == null || !headerMap.keySet().containsAll(requiredHeaders)) {
                    throw new IOException("Missing required headers in summary statistics CSV file: " + requiredHeaders +
                            " Found: " + (headerMap == null ? "null" : headerMap.keySet()));
                }

                for (CSVRecord record : csvParser) {
                    try {
                        SummaryStatistic stat = parseRecord(record);
                        if (stat != null) { // parseRecord might return null on error
                            statistics.add(stat);
                        }
                    } catch (Exception e) {
                        System.err.println("Skipping malformed summary statistic record at line " + record.getRecordNumber() + ": " + record.toString());
                        e.printStackTrace();
                    }
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading summary statistics from CSV: " + filePath);
            e.printStackTrace();
            throw e;
        }
        System.out.println("Successfully loaded " + statistics.size() + " summary statistics from " + filePath);
        return statistics;
    }

    // Helper to parse a single CSV record into a SummaryStatistic object
    private SummaryStatistic parseRecord(CSVRecord record) {
        // Defensive getting of values to prevent exceptions on missing columns
        String weekIdentifier = record.get("week_identifier");
        String totalIncomeStr = record.get("total_income_all_users");
        String totalExpenseStr = record.get("total_expense_all_users");
        String topExpenseCategory = record.get("top_expense_category");
        String topExpenseAmountStr = record.get("top_expense_category_amount");
        String numUsersStr = record.get("number_of_users_with_transactions");
        String timestampGenerated = record.get("timestamp_generated");

        // Basic validation for essential fields
        if (weekIdentifier == null || weekIdentifier.trim().isEmpty() ||
                totalIncomeStr == null || totalIncomeStr.trim().isEmpty() ||
                totalExpenseStr == null || totalExpenseStr.trim().isEmpty() ||
                numUsersStr == null || numUsersStr.trim().isEmpty() ||
                timestampGenerated == null || timestampGenerated.trim().isEmpty()) {
            System.err.println("Skipping summary record due to missing essential fields: " + record.toMap());
            return null; // Indicate parsing failed for this record
        }

        try {
            double totalIncome = Double.parseDouble(totalIncomeStr.trim());
            double totalExpense = Double.parseDouble(totalExpenseStr.trim());
            double topExpenseAmount = (topExpenseAmountStr != null && !topExpenseAmountStr.trim().isEmpty()) ? Double.parseDouble(topExpenseAmountStr.trim()) : 0.0;
            int numUsers = Integer.parseInt(numUsersStr.trim());

            return new SummaryStatistic(
                    weekIdentifier.trim(),
                    totalIncome,
                    totalExpense,
                    topExpenseCategory != null ? topExpenseCategory.trim() : "N/A", // Top category might be empty if no expenses
                    topExpenseAmount,
                    numUsers,
                    timestampGenerated.trim()
            );
        } catch (NumberFormatException e) {
            System.err.println("Skipping summary record due to number format error: " + record.toMap());
            e.printStackTrace();
            return null; // Indicate parsing failed
        }
    }


    @Override
    public void writeAllStatistics(String filePath, List<SummaryStatistic> statistics) throws IOException {
        Path path = Paths.get(filePath);
        // Ensure the directory exists
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }

        // Use a temporary file for atomic write
        File targetFile = path.toFile();
        File tempFile = File.createTempFile("summary_temp", ".csv", targetFile.getParentFile());

        try (BufferedWriter writer = Files.newBufferedWriter(tempFile.toPath(), StandardCharsets.UTF_8);
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(HEADERS).withTrim())) { // Always write header for overwrite

            for (SummaryStatistic stat : statistics) {
                csvPrinter.printRecord(
                        stat.getWeekIdentifier(),
                        stat.getTotalIncomeAllUsers(),
                        stat.getTotalExpenseAllUsers(),
                        stat.getTopExpenseCategory(),
                        stat.getTopExpenseCategoryAmount(),
                        stat.getNumberOfUsersWithTransactions(),
                        stat.getTimestampGenerated()
                );
            }
            // csvPrinter.flush(); // Auto-flushed on close
        } catch (IOException e) {
            tempFile.delete(); // Clean up temp file on failure
            System.err.println("Error writing summary statistics to temporary CSV file: " + tempFile.toPath());
            e.printStackTrace();
            throw e; // Re-throw
        }

        // Atomic replacement
        try {
            Files.move(tempFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
            System.out.println("Atomically replaced " + filePath + " with updated summary statistics.");
        } catch (IOException e) {
            System.err.println("Failed to atomically replace original summary file: " + targetFile.toPath());
            tempFile.delete(); // Clean up temp file
            e.printStackTrace();
            throw e; // Re-throw
        }
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\DAO\Impl\CsvTransactionDao.java`:

```java
package DAO.Impl; // Changed package

import Constants.ConfigConstants;
import DAO.TransactionDao; // Implement the interface
import model.Transaction;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional; // Using Optional for getTransactionByOrderNumber
import java.util.stream.Collectors;


public class CsvTransactionDao implements TransactionDao { // Implement TransactionDao interface

    // Remove the 'transactions' field and 'isLoad' flag, the cache/service layer will handle loading
    // private List<Transaction> transactions;
    // private boolean isLoad= false;

    // Keep the load method, it will be used by the cache loader
    @Override
    public List<Transaction> loadFromCSV(String filePath) throws IOException {
        List<Transaction> transactions = new ArrayList<>();
        Path path = Paths.get(filePath);

        // Check if file exists and is not empty before attempting to read
        if (!Files.exists(path) || Files.size(path) == 0) {
            System.out.println("CSV file not found or is empty: " + filePath);
            return transactions; // Return empty list if file doesn't exist or is empty
        }

        // Use BOMInputStream and InputStreamReader with UTF-8
        try (Reader reader = new InputStreamReader(
                new BOMInputStream(Files.newInputStream(path)), // Use path here directly
                StandardCharsets.UTF_8)) {

            // *** Simplified Header Handling: Let CSVParser handle the header detection ***
            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()    // Tell parser to treat the first line as header
                    .withIgnoreHeaderCase(true)  // Ignore case for robustness
                    .withTrim(true);             // Trim fields

            try (CSVParser csvParser = new CSVParser(reader, format)) {
                // After creating the parser with withFirstRecordAsHeader,
                // the header map should be available *if* a header was found.
                // Check if the required headers are present
                List<String> requiredHeaders = List.of(
                        "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)",
                        "支付方式", "当前状态", "交易单号", "商户单号", "备注"
                );

                // Now check the header map obtained *by the parser*
                Map<String, Integer> headerMap = csvParser.getHeaderMap();
                if (headerMap == null || !headerMap.keySet().containsAll(requiredHeaders)) {
                    // If headerMap is null (no header found) or incomplete
                    throw new IOException("Missing required headers in CSV file: " + requiredHeaders +
                            " Found: " + (headerMap == null ? "null" : headerMap.keySet()));
                }
                System.out.println("Successfully identified headers: " + headerMap.keySet() + " in file: " + filePath);


                for (CSVRecord record : csvParser) {
                    try {
                        transactions.add(parseRecord(record));
                    } catch (Exception e) {
                        System.err.println("Skipping malformed record at line " + record.getRecordNumber() + ": " + record.toString());
                        e.printStackTrace();
                    }
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading CSV file: " + filePath);
            e.printStackTrace();
            throw e;
        }
        System.out.println("Successfully loaded " + transactions.size() + " records from " + filePath);
        return transactions;
    }


    // Keep parseRecord private as it's an internal helper
    private Transaction parseRecord(CSVRecord record) {
        // Safely get and trim values, handle potential missing columns gracefully if needed
        String amountStr = record.get("金额(元)").trim();
        double paymentAmount = 0.0;
        try {
            if (amountStr.startsWith("¥")) {
                amountStr = amountStr.substring(1);
            }
            paymentAmount = Double.parseDouble(amountStr);
        } catch (NumberFormatException e) {
            System.err.println("Warning: Could not parse payment amount '" + record.get("金额(元)") + "' at line " + record.getRecordNumber());
            // Keep paymentAmount as 0.0 or handle as an error depending on strictness
        } catch (IllegalArgumentException e) {
            System.err.println("Warning: Missing '金额(元)' column or empty value at line " + record.getRecordNumber());
        }


        return new Transaction(
                record.get("交易时间").trim(),
                record.get("交易类型").trim(),
                record.get("交易对方").trim(),
                record.get("商品").trim(),
                record.get("收/支").trim(),
                paymentAmount, // Use parsed amount
                record.get("支付方式").trim(),
                record.get("当前状态").trim(),
                record.get("交易单号").trim(),
                record.get("商户单号").trim(),
                record.get("备注").trim()
        );
    }

    // Implement DAO interface methods properly
    public List<Transaction> getAllTransactions() throws IOException {
        // This method is now handled by the service layer using the cache.
        // The DAO should focus on direct file operations.
        // This interface method might be redundant if service layer always uses cache.
        // For clarity, let's make it load from CSV directly, but the service will prefer cache.
        // Note: This might re-read the file even if cached. Service layer needs to manage this.
        // Alternatively, this method could be removed from the interface/DAO if only cache loader uses loadFromCSV.
        // Let's keep it for now, assuming it's a direct file read fallback.
        System.out.println("DAO: Calling getAllTransactions directly from file (consider using service/cache)");
        // We need a way to know *which* file here. This method signature is problematic for multi-user.
        // The interface needs filePath, or the DAO instance needs to be created per file.
        // Let's adjust the interface/DAO to be file-specific or pass path to methods.
        // Option 1: DAO instance per file.
        // Option 2: Add filePath parameter to all relevant interface methods.
        // Option 2 seems more flexible for a single CsvTransactionDao class.
        // Let's add filePath to interface methods and implement here.

        // *** Decision: Modify TransactionDao interface to include filePath ***
        throw new UnsupportedOperationException("This method signature is not suitable for multi-user. Use the overloaded method with filePath.");
    }

    // Adding filePath parameter to relevant interface methods definition (will update interface next)
    // This implementation will be part of the updated DAO after interface change.
    public List<Transaction> getAllTransactions(String filePath) throws IOException {
        return loadFromCSV(filePath); // Simple implementation using the existing load method
    }


    // Add transaction
    public void addTransaction(Transaction newTransaction) throws IOException {
        throw new UnsupportedOperationException("This method signature is not suitable for multi-user. Use the overloaded method with filePath.");
    }

    public void addTransaction(String filePath, Transaction newTransaction) throws IOException {
        // Ensure the directory exists
        Path path = Paths.get(filePath);
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }

        boolean fileExists = Files.exists(path) && Files.size(path) > 0;

        // Define the header based on your CSV structure
        String[] headers = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"};

        // Use StandardOpenOption.CREATE and StandardOpenOption.APPEND
        // If the file doesn't exist, CREATE will create it. If it exists, APPEND will add to the end.
        // We need to handle writing the header only if the file is new or empty.
        try (BufferedWriter writer = Files.newBufferedWriter(path, StandardOpenOption.CREATE, StandardOpenOption.APPEND)) {

            // Check if header needs to be written. A simple way is to check file size before opening in APPEND mode.
            // However, opening in CREATE/APPEND and then checking size *after* opening might not work as expected if the file is created.
            // A better approach is to check size *before* getting the writer or read the first line after opening if needed.
            // The Apache CSVPrinter can handle writing headers IF the file is new.
            // Let's adapt the existing logic slightly. Check exists and non-empty *before* opening.

            // Re-check file state after potential creation by StandardOpenOption.CREATE
            boolean fileWasEmptyBeforeAppend = !fileExists; // Or check if file size is 0 after creation if needed

            // Configure CSV format - with header if file is new/empty, without if appending
            CSVFormat format;
            if (fileWasEmptyBeforeAppend) {
                format = CSVFormat.DEFAULT.withHeader(headers).withTrim();
            } else {
                format = CSVFormat.DEFAULT.withTrim(); // Assume header is already there
            }

            // Create CSVPrinter
            try (CSVPrinter csvPrinter = new CSVPrinter(writer, format)) {
                csvPrinter.printRecord(
                        newTransaction.getTransactionTime(),
                        newTransaction.getTransactionType(),
                        newTransaction.getCounterparty(),
                        newTransaction.getCommodity(),
                        newTransaction.getInOut(),
                        // Format amount with ¥ sign and two decimal places
                        String.format("¥%.2f", newTransaction.getPaymentAmount()),
                        newTransaction.getPaymentMethod(),
                        newTransaction.getCurrentStatus(),
                        newTransaction.getOrderNumber(),
                        newTransaction.getMerchantNumber(),
                        newTransaction.getRemarks()
                );
                // No need to flush immediately, writer will be closed by try-with-resources.
                // csvPrinter.flush();
            }
            System.out.println("Added transaction to " + filePath);
        } catch (IOException e) {
            System.err.println("Error adding transaction to CSV: " + filePath);
            e.printStackTrace();
            throw e; // Re-throw
        }
    }


    // Delete transaction by order number
    public boolean deleteTransaction(String orderNumber) throws IOException {
        throw new UnsupportedOperationException("This method signature is not suitable for multi-user. Use the overloaded method with filePath.");
    }

    public boolean deleteTransaction(String filePath, String orderNumber) throws IOException {
        // Load all transactions first
        List<Transaction> allTransactions = loadFromCSV(filePath);

        // Filter out the transaction to be deleted
        List<Transaction> updatedTransactions = allTransactions.stream()
                .filter(t -> !t.getOrderNumber().trim().equals(orderNumber.trim()))
                .collect(Collectors.toList());

        // Check if any transaction was actually removed
        boolean deleted = allTransactions.size() > updatedTransactions.size();

        if (deleted) {
            // Write the remaining transactions back to the CSV file
            writeTransactionsToCSV(filePath, updatedTransactions);
            System.out.println("Deleted transaction with order number " + orderNumber + " from " + filePath);
        } else {
            System.out.println("Transaction with order number " + orderNumber + " not found in " + filePath);
        }

        return deleted;
    }


    // Update a specific field (implementing the interface method)
    public boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException {
        // This interface method needs a filePath parameter to be useful in a multi-user context.
        // Let's add an overloaded method that includes filePath.
        throw new UnsupportedOperationException("This method signature is not suitable for multi-user. Use the overloaded method with filePath.");
    }

    public boolean updateTransaction(String filePath, String orderNumber, String fieldName, String newValue) throws IOException {
        // Load all transactions
        List<Transaction> allTransactions = loadFromCSV(filePath);

        // Find the transaction by order number
        Optional<Transaction> transactionToUpdateOpt = allTransactions.stream()
                .filter(t -> t.getOrderNumber().trim().equals(orderNumber.trim()))
                .findFirst();

        if (!transactionToUpdateOpt.isPresent()) {
            System.out.println("Transaction with order number " + orderNumber + " not found for update in " + filePath);
            return false; // Transaction not found
        }

        Transaction transactionToUpdate = transactionToUpdateOpt.get();
        boolean updated = false;

        // Use reflection or a switch/if-else block to update the specific field
        // A switch is more explicit and safer than reflection here.
        switch (fieldName) {
            case "transactionTime": transactionToUpdate.setTransactionTime(newValue); updated = true; break;
            case "transactionType": transactionToUpdate.setTransactionType(newValue); updated = true; break;
            case "counterparty": transactionToUpdate.setCounterparty(newValue); updated = true; break;
            case "commodity": transactionToUpdate.setCommodity(newValue); updated = true; break;
            case "inOut": transactionToUpdate.setInOut(newValue); updated = true; break;
            case "paymentAmount":
                try {
                    transactionToUpdate.setPaymentAmount(Double.parseDouble(newValue));
                    updated = true;
                } catch (NumberFormatException e) {
                    System.err.println("Invalid number format for paymentAmount update: " + newValue);
                    throw new NumberFormatException("Invalid number format for paymentAmount: " + newValue);
                }
                break;
            case "paymentMethod": transactionToUpdate.setPaymentMethod(newValue); updated = true; break;
            case "currentStatus": transactionToUpdate.setCurrentStatus(newValue); updated = true; break;
            case "orderNumber": transactionToUpdate.setOrderNumber(newValue); updated = true; break; // Caution: Updating ID can be tricky
            case "merchantNumber": transactionToUpdate.setMerchantNumber(newValue); updated = true; break;
            case "remarks": transactionToUpdate.setRemarks(newValue); updated = true; break;
            default:
                System.err.println("Invalid field name for update: " + fieldName);
                throw new IllegalArgumentException("Invalid field name: " + fieldName);
        }

        if (updated) {
            // Write the modified list back to the CSV file
            writeTransactionsToCSV(filePath, allTransactions);
            System.out.println("Updated transaction with order number " + orderNumber + " in " + filePath + " field: " + fieldName);
        }

        return updated;
    }


    // Keep writeTransactionsToCSV, ensure it uses the filePath parameter correctly
    // This method seems OK as it already accepts filePath.
    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
        // Ensure the directory exists
        Path path = Paths.get(filePath);
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }

        File targetFile = path.toFile();
        // Create temporary file in the same directory
        File tempFile = File.createTempFile("transaction_temp", ".csv", targetFile.getParentFile());

        // Define the header explicitly
        String[] headers = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"};

        try (BufferedWriter writer = Files.newBufferedWriter(tempFile.toPath(), StandardCharsets.UTF_8);
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(headers).withTrim())) { // Always write header for overwrite

            for (Transaction t : transactions) {
                csvPrinter.printRecord(
                        t.getTransactionTime(),
                        t.getTransactionType(),
                        t.getCounterparty(),
                        t.getCommodity(),
                        t.getInOut(),
                        String.format("¥%.2f", t.getPaymentAmount()), // Format amount
                        t.getPaymentMethod(),
                        t.getCurrentStatus(),
                        t.getOrderNumber(),
                        t.getMerchantNumber(),
                        t.getRemarks()
                );
            }
            // csvPrinter.flush(); // Auto-flushed on close
        } catch (IOException e) {
            tempFile.delete(); // Clean up temp file on failure
            System.err.println("Error writing transactions to temporary CSV file: " + tempFile.toPath());
            e.printStackTrace();
            throw e; // Re-throw
        }

        // Atomic replacement of the original file
        try {
            Files.move(tempFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
            System.out.println("Atomically replaced " + filePath + " with updated data.");
        } catch (IOException e) {
            System.err.println("Failed to atomically replace original file: " + targetFile.toPath() + " with " + tempFile.toPath());
            tempFile.delete(); // Clean up temp file
            e.printStackTrace();
            throw e; // Re-throw
        }
    }

    // Implement getTransactionByOrderNumber from the interface
    public Transaction getTransactionByOrderNumber(String orderNumber) throws IOException {
        throw new UnsupportedOperationException("This method signature is not suitable for multi-user. Use the overloaded method with filePath.");
    }

    public Transaction getTransactionByOrderNumber(String filePath, String orderNumber) throws IOException {
        // Load all transactions
        List<Transaction> allTransactions = loadFromCSV(filePath);

        // Find the transaction by order number
        Optional<Transaction> transactionOpt = allTransactions.stream()
                .filter(t -> t.getOrderNumber().trim().equals(orderNumber.trim()))
                .findFirst();

        return transactionOpt.orElse(null); // Return Transaction object or null
    }


    // Remove or update these old methods
    // private CSVFormat getCsvFormatWithHeader(String filePath) throws IOException { ... } // No longer needed with explicit headers
    // private CSVFormat getCsvFormatWithoutHeader() { ... } // No longer needed with explicit headers
    // boolean changeInformation(String orderNumber, String head, String value,String path) throws IOException // This is similar to updateTransaction, prefer the standard update method
    // Let's remove changeInformation and update the service to use updateTransaction

    // Removed changeInformation method based on the plan to use updateTransaction instead.
    // Removed getCsvFormatWithHeader/WithoutHeader as we now use explicit headers in writeTransactionsToCSV.
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\DAO\Impl\CsvUserDao.java`:

```java
package DAO.Impl;

import Constants.ConfigConstants;
import DAO.UserDao;
import model.User;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

public class CsvUserDao implements UserDao {

    private final String filePath;

    public CsvUserDao(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public List<User> getAllUsers() throws IOException {
        List<User> users = new ArrayList<>();
        // Use BOMInputStream to handle potential Byte Order Mark issues
        try (Reader reader = new InputStreamReader(
                new BOMInputStream(Files.newInputStream(Paths.get(filePath))),
                StandardCharsets.UTF_8)) {

            // Configure CSVFormat to handle headers
            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()
                    .withIgnoreHeaderCase(true) // Ignore header case for robustness
                    .withTrim(true); // Trim leading/trailing whitespace

            try (CSVParser csvParser = new CSVParser(reader, format)) {
                // Check if the required headers are present
                List<String> requiredHeaders = List.of("username", "password", "role", "transaction_csv_path");
                if (!csvParser.getHeaderMap().keySet().containsAll(requiredHeaders)) {
                    throw new IOException("Missing required headers in users CSV file: " + requiredHeaders);
                }

                for (CSVRecord record : csvParser) {
                    // Basic error handling for potentially missing fields in a row
                    String username = record.get("username");
                    String password = record.get("password");
                    String role = record.get("role");
                    String transactionFilePath = record.get("transaction_csv_path");

                    if (username == null || username.trim().isEmpty() || password == null || password.trim().isEmpty() || role == null || role.trim().isEmpty() || transactionFilePath == null || transactionFilePath.trim().isEmpty()) {
                        System.err.println("Skipping malformed user record: " + record.toMap());
                        continue; // Skip this row
                    }

                    User user = new User(username.trim(), password.trim(), role.trim(), transactionFilePath.trim());
                    users.add(user);
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading users from CSV file: " + filePath);
            e.printStackTrace();
            throw e; // Re-throw the exception after logging
        }
        return users;
    }

    // Helper method to parse a single record (optional, can be in getAllUsers)
    // private User parseRecord(CSVRecord record) { ... }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\DAO\SummaryStatisticDao.java`:

```java
package DAO;

import model.SummaryStatistic;

import java.io.IOException;
import java.util.List;

public interface SummaryStatisticDao {

    /**
     * Loads all summary statistics from the configured data source.
     * @param filePath The path to the summary statistics CSV file.
     * @return A list of all summary statistics.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<SummaryStatistic> loadAllStatistics(String filePath) throws IOException;

    /**
     * Writes a list of summary statistics to the configured data source, overwriting existing data.
     * @param filePath The path to the summary statistics CSV file.
     * @param statistics The list of statistics to write.
     * @throws IOException If an I/O error occurs during saving.
     */
    void writeAllStatistics(String filePath, List<SummaryStatistic> statistics) throws IOException;

    // Optional: Add method to get statistic by week identifier if needed
    // SummaryStatistic getStatisticByWeek(String filePath, String weekIdentifier) throws IOException;
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\DAO\TransactionDao.java`:

```java
package DAO;

import model.Transaction;

import java.io.IOException;
import java.util.List;

/**
 * Interface for Data Access Object (DAO) operations related to Transactions.
 * Defines the contract for loading, adding, deleting, and updating transaction data.
 */
public interface TransactionDao {

    // Keep loadFromCSV - used by cache loader
    List<Transaction> loadFromCSV(String filePath) throws IOException;

    /**
     * Loads all transactions from the specified data source file.
     * @param filePath The path to the user's CSV file.
     * @return A list of all transactions.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<Transaction> getAllTransactions(String filePath) throws IOException;


    /**
     * Adds a new transaction to the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param transaction The new transaction to add.
     * @throws IOException If an I/O error occurs during saving.
     */
    void addTransaction(String filePath, Transaction transaction) throws IOException;

    /**
     * Deletes a transaction identified by its order number from the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param orderNumber The unique order number of the transaction to delete.
     * @return true if a transaction was found and deleted, false otherwise.
     * @throws IOException If an I/O error occurs during loading or saving.
     */
    boolean deleteTransaction(String filePath, String orderNumber) throws IOException;

    /**
     * Updates a specific field of an existing transaction identified by its order number
     * in the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param orderNumber The unique order number of the transaction to update.
     * @param fieldName   The name of the field to update (e.g., "transactionType", "paymentAmount").
     * @param newValue    The new value for the specified field.
     * @return true if the transaction was found and updated, false otherwise.
     * @throws IOException             If an I/O error occurs during loading or saving.
     * @throws NumberFormatException   If updating 'paymentAmount' and newValue is not a valid double.
     * @throws IllegalArgumentException If the fieldName is invalid.
     */
    boolean updateTransaction(String filePath, String orderNumber, String fieldName, String newValue) throws IOException;

    /**
     * Retrieves a transaction by its unique order number from the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param orderNumber The unique order number.
     * @return The Transaction object if found, null otherwise.
     * @throws IOException If an I/O error occurs during loading.
     */
    Transaction getTransactionByOrderNumber(String filePath, String orderNumber) throws IOException;

    void writeTransactionsToCSV(String currentUserTransactionFilePath, List<Transaction> updatedList) throws IOException;

    // Remove the old methods without filePath parameter from the interface
    // List<Transaction> getAllTransactions() throws IOException; // Removed
    // void addTransaction(Transaction transaction) throws IOException; // Removed
    // boolean deleteTransaction(String orderNumber) throws IOException; // Removed
    // boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException; // Removed
    // Transaction getTransactionByOrderNumber(String orderNumber) throws IOException; // Removed
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\DAO\UserDao.java`:

```java
package DAO;

import model.User;

import java.io.IOException;
import java.util.List;

/**
 * Interface for Data Access Object (DAO) operations related to Users.
 */
public interface UserDao {

    /**
     * Loads all users from the configured data source.
     *
     * @return A list of all users.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<User> getAllUsers() throws IOException;

    // Add other user-related methods if needed later (e.g., addUser, deleteUser)
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Interceptor\Login\LoginDialog.java`:

```java
package Interceptor.Login;

import Service.User.UserService; // Import the new UserService
import model.User;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class LoginDialog extends JDialog {
    private User authenticatedUser = null; // Change from boolean flag to User object
    private JTextField usernameField;
    private JPasswordField passwordField;
    // UserService should ideally be injected, but for simplicity in LoginDialog,
    // we might initialize it here or pass it from Main. Let's pass it from Main.
    private final UserService userService;

    // Constructor now accepts UserService
    public LoginDialog(UserService userService) {
        this.userService = userService; // Inject UserService

        setTitle("用户登录");
        setLayout(new GridLayout(3, 2));
        setModal(true);
        setSize(300, 150);
        setResizable(false); // Prevent resizing

        // Input components
        usernameField = new JTextField();
        passwordField = new JPasswordField();
        JButton loginButton = new JButton("登录");
        JButton cancelButton = new JButton("取消");

        // Add components
        add(new JLabel("用户名:"));
        add(usernameField);
        add(new JLabel("密码:"));
        add(passwordField);
        add(loginButton);
        add(cancelButton);

        // Login button logic
        loginButton.addActionListener(e -> {
            String username = usernameField.getText().trim();
            String password = new String(passwordField.getPassword()).trim();

            authenticatedUser = userService.authenticate(username, password); // Use new authenticate method

            if (authenticatedUser != null) { // Check if a User object was returned
                dispose(); // Close dialog
            } else {
                JOptionPane.showMessageDialog(
                        this,
                        "用户名或密码错误！",
                        "登录失败",
                        JOptionPane.ERROR_MESSAGE
                );
                clearFields(); // Clear fields on failure
            }
        });

        // Cancel button logic
        cancelButton.addActionListener(e -> {
            authenticatedUser = null; // Ensure no user is set on cancel
            dispose();
            System.exit(0); // Exit application on cancel
        });

        setLocationRelativeTo(null); // Center dialog
    }

    // Method to clear input fields
    private void clearFields() {
        usernameField.setText("");
        passwordField.setText("");
        usernameField.requestFocusInWindow(); // Focus back to username field
    }

    /**
     * Shows the login dialog and returns the authenticated user upon successful login.
     * Blocking call.
     * @return The authenticated User object, or null if login failed or was cancelled.
     */
    public User showDialogAndGetResult() {
        setVisible(true); // Show the dialog (this call is blocking because modal is true)
        return authenticatedUser; // Return the result after dialog is closed
    }

    // Remove isLoginSuccessful() as we now return the User object
    // public boolean isLoginSuccessful() { return loginSuccessful; }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Main.java`:

```java
import javax.swing.*;

import Controller.MenuUI;
import DAO.Impl.CsvTransactionDao;
import DAO.Impl.CsvUserDao;
import DAO.Impl.CsvSummaryStatisticDao;
import DAO.UserDao;
import DAO.TransactionDao;
import DAO.SummaryStatisticDao;
import Interceptor.Login.LoginDialog;
import Service.Impl.TransactionServiceImpl;
import Service.Impl.SummaryStatisticService;
import Service.AIservice.AITransactionService; // Import AI Service classes
import Service.AIservice.CollegeStudentNeeds;
import Service.TransactionService;
import Service.User.UserService;
import model.User;
import Constants.ConfigConstants;

public class Main {
    public static void main(String[] args) {
        // Ensure ConfigConstants is loaded first
        String usersCsvPath = ConfigConstants.USERS_CSV_PATH;
        String summaryCsvPath = ConfigConstants.SUMMARY_CSV_PATH;
        System.out.println("Attempting to load users from: " + usersCsvPath);
        System.out.println("Summary statistics will be saved to: " + summaryCsvPath);


        // Initialize DAOs
        UserDao userDao = new CsvUserDao(usersCsvPath);
        TransactionDao transactionDao = new CsvTransactionDao();
        SummaryStatisticDao summaryStatisticDao = new CsvSummaryStatisticDao();


        // Initialize Services
        UserService userService = new UserService(userDao);
        // TransactionServiceImpl is initialized per user in MenuUI -> NO, initialize it here and pass it!
        // The TransactionServiceImpl instance *is* user-specific, so it's better to create it *after* login.
        // But AI Services need it *before* MenuUI is fully constructed and shows the panel.
        // Option 1: Pass TransactionService to MenuUI constructor and AI/CS services are initialized in MenuUI. (Current approach)
        // Option 2: Create AI/CS services here in Main and pass them to MenuUI. They would need the user-specific TS instance.
        // Let's stick with Option 1 for now, initializing AI/CS in MenuUI after getting TS.

        SummaryStatisticService summaryStatisticService = new SummaryStatisticService(userDao, transactionDao, summaryStatisticDao);


        // In the event dispatch thread (EDT) start GUI
        SwingUtilities.invokeLater(() -> {
            LoginDialog loginDialog = new LoginDialog(userService);
            User authenticatedUser = loginDialog.showDialogAndGetResult();

            if (authenticatedUser != null) {
                System.out.println("Logged in as: " + authenticatedUser.getUsername() + " (" + authenticatedUser.getRole() + ")");
                System.out.println("User's transaction file: " + authenticatedUser.getTransactionFilePath());

                // Initialize TransactionServiceImpl *for the logged-in user*
                TransactionService transactionServiceForCurrentUser = new TransactionServiceImpl(authenticatedUser.getTransactionFilePath());

                // Initialize AI Services *with* the user-specific TransactionService
                // This is where AI/CS services are created with their dependency injected
                AITransactionService aiTransactionService = new AITransactionService(transactionServiceForCurrentUser);
                CollegeStudentNeeds collegeStudentNeeds = new CollegeStudentNeeds(transactionServiceForCurrentUser);


                // Pass the authenticated user, their transaction service, summary statistic service, AND AI services to MenuUI
                MenuUI menuUI = new MenuUI(authenticatedUser, transactionServiceForCurrentUser, summaryStatisticService, aiTransactionService, collegeStudentNeeds); // Modify MenuUI constructor


                JFrame frame = new JFrame("交易管理系统 - " + authenticatedUser.getUsername());
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.setSize(1200, 600);
                frame.setLocationRelativeTo(null);
                frame.add(menuUI.createMainPanel());
                frame.setVisible(true);
            } else {
                System.out.println("Login failed or cancelled. Exiting.");
                System.exit(0);
            }
        });
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\AIservice\AIAnalyzerThread.java`:

```java
package Service.AIservice;

// Add required imports
import Service.TransactionService; // Import if analyzeTransactions throws Exception


public class AIAnalyzerThread implements Runnable {
    private final String userRequest;
    private final String filePath; // Still needed for analyzeTransactions method signature
    private final String startTimeStr;
    private final String endTimeStr;

    // Field to hold the injected AITransactionService service instance
    private final AITransactionService aiTransactionService;


    /**
     * Constructor now accepts the AITransactionService service instance
     * and the parameters for the analysis request.
     *
     * @param aiTransactionService The AITransactionService service instance to use.
     * @param userRequest The user's natural language request.
     * @param filePath The path to the user's transaction data file.
     * @param startTimeStr The start time string for filtering.
     * @param endTimeStr The end time string for filtering.
     */
    public AIAnalyzerThread(AITransactionService aiTransactionService, String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        this.aiTransactionService = aiTransactionService; // Inject the service
        this.userRequest = userRequest;
        this.filePath = filePath; // Still needed for analyzeTransactions call
        this.startTimeStr = startTimeStr;
        this.endTimeStr = endTimeStr;
        System.out.println("AIAnalyzerThread initialized for file: " + filePath);
    }

    @Override
    public void run() {
        System.out.println("AIAnalyzerThread started for analysis request: '" + userRequest + "' on file: " + filePath);
        try {
            // Call the analyzeTransactions method on the injected service instance
            String result = aiTransactionService.analyzeTransactions(userRequest, filePath, startTimeStr, endTimeStr);

            // Print the result or handle it as needed by the test/caller that starts this thread
            System.out.println("AI analysis result from thread: " + result);

            // TODO: If this thread is used by a UI program, use SwingUtilities.invokeLater() to update a UI component with 'result'
            // This indicates this class might be intended for background tasks separate from the main UI refresh cycle handled in MenuUI.
        } catch (Exception e) { // Catch Exception as analyzeTransactions throws Exception
            System.err.println("Error during AI analysis in thread for file " + filePath + ": " + e.getMessage());
            e.printStackTrace();
            // You might want to pass this error back to the caller if it's a UI context.
        }
        System.out.println("AIAnalyzerThread finished for file: " + filePath);
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\AIservice\AITransactionService.java`:

```java
package Service.AIservice;
// Remove import Service.Impl.TransactionServiceImpl;
// Remove import Service.TransactionService;
// Remove import Constants.ConfigConstants; // ConfigConstants might still be needed for API key logic if not elsewhere
// Remove import DAO.CsvTransactionDao; // No longer directly used
// Remove import Utils.CacheUtil; // No longer directly used

import DAO.TransactionDao; // Use the interface
import DAO.Impl.CsvTransactionDao; // Use the implementation to create instance for loader
import Service.TransactionService;
import Utils.CacheManager; // Import CacheManager
import model.MonthlySummary;
import model.Transaction; // Import Transaction

import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;

import java.io.IOException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;
import java.util.concurrent.*;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
// Remove import static Constants.ConfigConstants.CSV_PATH; // No longer use static CSV_PATH

public class AITransactionService {
    // Keep static ArkService as it's typically thread-safe and stateless
    private static final String API_KEY = System.getenv("ARK_API_KEY"); // Or load from config.properties
    private static final ArkService service = ArkService.builder()
            .timeout(Duration.ofSeconds(1800))
            .connectTimeout(Duration.ofSeconds(20))
            .baseUrl("https://ark.cn-beijing.volces.com/api/v3")
            .apiKey(API_KEY) // Ensure API_KEY is loaded
            .build();

    // Need access to TransactionService to get monthly summaries
    private final TransactionService transactionService; // Inject TransactionService


    /**
     * Constructor now accepts TransactionService instance.
     */
    public AITransactionService(TransactionService transactionService) {
        this.transactionService = transactionService; // Inject the service
        System.out.println("AITransactionService initialized with TransactionService.");
    }

    /**
     * Analyzes transactions from a specific user's file based on user request and time range.
     *
     * @param userRequest The user's natural language request.
     * @param filePath The path to the user's transaction CSV file.
     * @param startTimeStr The start time string for filtering.
     * @param endTimeStr The end time string for filtering.
     * @return AI analysis result as a String.
     */
    public String analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        try {
            // Get transactions for the specified file path using CacheManager
            // Need to pass a DAO instance for the CacheManager's loader if it needs to load from file.
            TransactionDao transactionDaoForLoading = new CsvTransactionDao(); // Create a DAO instance for loading
            List<Transaction> transactions = CacheManager.getTransactions(filePath, transactionDaoForLoading);
            System.out.println("AI Service: Retrieved " + transactions.size() + " transactions for file: " + filePath);


            // Format filtered transactions for the AI prompt
            List<String> transactionDetails = formatTransactions(transactions, startTimeStr, endTimeStr);
            System.out.println("AI Service: Formatted " + transactionDetails.size() + " transactions for AI.");


            // Check if any transactions were found after filtering
            if (transactionDetails.isEmpty() || (transactionDetails.size() == 1 && transactionDetails.get(0).startsWith("该时间段内没有交易记录"))) {
                return "在该时间段内没有找到符合条件的交易记录，无法进行分析。请检查时间和交易数据。";
            }

            String aiPrompt = userRequest + "\n" + "以下是我的账单信息：\n" + String.join("\n", transactionDetails);
            System.out.println("AI Service: Sending prompt to AI. Prompt length: " + aiPrompt.length());
            return askAi(aiPrompt);
        } catch (IllegalArgumentException e) {
            System.err.println("AI analysis failed due to invalid time format: " + e.getMessage());
            return "AI分析失败: 时间格式不正确。" + e.getMessage();
        }
        catch (Exception e) {
            System.err.println("AI analysis failed during data retrieval or AI call for file: " + filePath);
            e.printStackTrace();
            return "AI分析失败: 获取数据或调用AI服务时发生错误。" + e.getMessage();
        }
    }


    // Keep formatTransactions, parseDateTime, askAi methods. Ensure parseDateTime is robust.
    // The formatTransactions method relies on parseDateTime, ensure consistency with TransactionServiceImpl's parser.

    public List<String> formatTransactions(List<Transaction> transactions, String startTimeStr, String endTimeStr) {
        LocalDateTime startTime = parseDateTime(startTimeStr);
        // If end time is empty, use current time
        LocalDateTime endTime = (endTimeStr == null || endTimeStr.trim().isEmpty())
                ? LocalDateTime.now()
                : parseDateTime(endTimeStr);

        if (startTime == null) {
            // Handle the case where start time is invalid.
            // Depending on requirements, you might throw an exception or return an error message list.
            // Throwing IllegalArgumentException is better for analyzeTransactions to catch.
            throw new IllegalArgumentException("起始时间格式不正确: " + startTimeStr);
        }
        // If endTime parsing fails, treat it as current time as per original logic if endTimeStr was not empty
        if ((endTimeStr != null && !endTimeStr.trim().isEmpty()) && endTime == null) {
            throw new IllegalArgumentException("结束时间格式不正确: " + endTimeStr);
        }
        // If endTimeStr was empty, endTime is already LocalDateTime.now() which is not null.

        System.out.println("Filtering transactions from " + startTime + " to " + endTime);


        List<Transaction> filtered = transactions.stream()
                .filter(t -> {
                    LocalDateTime tTime = parseDateTime(t.getTransactionTime());
                    // Include transactions exactly at startTime, exclude transactions exactly at endTime (standard range behavior [start, end))
                    // If endTime should be inclusive, change isBefore(startTime) to !isAfter(startTime) and isAfter(endTime) to !isBefore(endTime)
                    // Or use isBefore(startTime) || isAfter(endTime) and negate.
                    // Let's use !isBefore(startTime) && !isAfter(endTime) as it seems more intuitive for a date range, inclusive.
                    return tTime != null && !tTime.isBefore(startTime) && !tTime.isAfter(endTime); // Range [startTime, endTime]
                })
                .collect(Collectors.toList());
        System.out.println("Filtered down to " + filtered.size() + " transactions within range.");


        // Group by Counterparty and summarize net amount and count
        Map<String, double[]> grouped = new HashMap<>(); // double[0] = net amount, double[1] = count
        for (Transaction t : filtered) {
            String counterparty = t.getCounterparty();
            double amount = t.getPaymentAmount();
            if (t.getInOut().equals("支出") || t.getInOut().equals("支")) { // Normalize "支" to "支出" internally if needed, but compare against source
                amount = -amount;
            } else if (!t.getInOut().equals("收入") && !t.getInOut().equals("收")) {
                System.err.println("Warning: Unknown 收/支 type for transaction: " + t.getOrderNumber() + " - " + t.getInOut());
                // Decide how to handle unknown types - ignore from analysis? Treat as 0?
                continue; // Skip unknown types for aggregation
            }

            grouped.putIfAbsent(counterparty, new double[]{0.0, 0});
            grouped.get(counterparty)[0] += amount;
            grouped.get(counterparty)[1] += 1;
        }
        System.out.println("Grouped transactions by counterparty. Found " + grouped.size() + " counterparties.");


        List<String> results = grouped.entrySet().stream()
                .map(e -> {
                    String cp = e.getKey();
                    double net = e.getValue()[0];
                    int count = (int) e.getValue()[1];
                    String inOut = net >= 0 ? "总收入" : "总支出"; // Changed label to reflect aggregate
                    if (Math.abs(net) < 0.01 && count > 0) { // If net is near zero but there were transactions
                        inOut = "净零"; // Or specify "收支相抵"
                    }
                    return String.format("交易对方: %s, 净%s: %.2f元，交易次数: %d",
                            cp, inOut, Math.abs(net), count);
                })
                .collect(Collectors.toList());
        System.out.println("Formatted grouped results.");


        // Add time range information to the results list
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm");
        String rangeInfo = String.format("分析交易时间范围：%s - %s",
                formatter.format(startTime), formatter.format(endTime));
        results.add(0, rangeInfo); // Add range info at the beginning

        return results.isEmpty() ? List.of(rangeInfo, "该时间段内没有交易记录。") : results; // Ensure range info is always included
    }


    // Keep parseDateTime method - ensure it matches the one in TransactionServiceImpl
    private LocalDateTime parseDateTime(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // Clean whitespace
        timeStr = timeStr.trim().replaceAll("\\s+", " ");

        // Append time if only date
        if (timeStr.matches("\\d{4}/\\d{1,2}/\\d{1,2}")) {
            timeStr += " 00:00"; // Assuming minutes format
        } else if (timeStr.matches("\\d{4}-\\d{1,2}-\\d{1,2}")) {
            timeStr += " 00:00:00"; // Assuming seconds format
        }


        // Try parsing with multiple formats
        List<String> patterns = List.of(
                "yyyy/M/d H:mm", "yyyy/M/d HH:mm",
                "yyyy/MM/d H:mm", "yyyy/MM/d HH:mm",
                "yyyy/M/dd H:mm", "yyyy/M/dd HH:mm",
                "yyyy/MM/dd H:mm", "yyyy/MM/dd HH:mm",
                "yyyy/MM/dd HH:mm:ss", // Added seconds format
                "yyyy-MM-dd HH:mm:ss", // Added dash format
                "yyyy/MM/dd" // Date only (handled above)
                // Add more patterns if needed based on your CSV data
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDateTime.parse(timeStr, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern and try the next
            }
        }
        System.err.println("AI Service: Failed to parse date string: " + timeStr);
        return null; // Return null if no pattern matches
    }


    // Keep askAi method
    public String askAi(String prompt) {
        try {
            if (API_KEY == null || API_KEY.trim().isEmpty()) {
                System.err.println("ARK_API_KEY environment variable is not set.");
                return "AI服务配置错误: ARK_API_KEY 未设置。";
            }
            // Ensure the static service instance is properly built with the key
            // This might be better done once at application startup if API_KEY is loaded from config.
            // For now, relying on the static final initialization is acceptable if the env var is set before class loading.


            List<ChatMessage> messages = List.of(
                    ChatMessage.builder().role(ChatMessageRole.USER).content(prompt).build()
            );

            ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
                    .model("ep-20250308174053-7pbkq") // Use your model name
                    .messages(messages)
                    .build();

            System.out.println("AI Service: Sending request to VolcEngine Ark...");
            // Use the static service instance
            String responseContent = (String) service.createChatCompletion(chatCompletionRequest)
                    .getChoices().get(0).getMessage().getContent();
            System.out.println("AI Service: Received response from AI.");
            return responseContent;

        } catch (Exception e) {
            System.err.println("AI Service: AI request failed.");
            e.printStackTrace();
            return "AI请求失败: " + e.getMessage();
        }
    }

    // Keep runAiInThread method, ensure it uses the correct analyzeTransactions method
    public void runAiInThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        // ExecutorService should ideally be managed at a higher level in a larger app,
        // but a simple single thread executor per request is acceptable for this scale.
        // However, this creates a new thread and executor every time.
        // A fixed thread pool managed statically or by a dedicated AI Service Manager would be more efficient.
        // For now, let's keep it simple as in the original code.

        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            // Call the instance method analyzeTransactions
            String result = this.analyzeTransactions(userRequest, filePath,startTimeStr, endTimeStr);
            System.out.println("AI analysis thread finished. Result: " + result);
            // TODO: How to pass the result back to the UI?
            // This thread doesn't have access to the UI components directly.
            // Need a mechanism like a callback or SwingUtilities.invokeLater.
            // This will be addressed when integrating AI output into the UI (Step 10).
        });
        // Consider shutting down the executor more gracefully, e.g., when the app exits.
        // executor.shutdown(); // Shutting down immediately might cancel the task
        // A better approach is `executor.shutdown()` after submitting, but manage the executor lifecycle elsewhere.
    }

    /**
     * Generates a personal consumption summary based on monthly data.
     * @param userFilePath The path to the user's transaction CSV file. (Might not be strictly needed if service handles context)
     * @return AI analysis result as a String.
     */
    public String generatePersonalSummary(String userFilePath) {
        try {
            // Get monthly summary data from TransactionService
            // Note: TransactionService already operates on the current user's data implicitly if passed correctly.
            // We might not need userFilePath explicitly in this method signature if the service instance is user-specific.
            // Let's assume the injected transactionService is already scoped to the current user.
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("AI Service: Retrieved " + summaries.size() + " months of summary data.");

            if (summaries.isEmpty()) {
                return "没有找到足够的交易数据来生成个人消费总结。";
            }

            // Format the summary data for the AI prompt
            StringBuilder summaryPromptBuilder = new StringBuilder();
            summaryPromptBuilder.append("请根据以下月度消费总结数据，生成一份个人消费习惯总结，分析主要开销类别、月度变化趋势，并评估我的消费健康度：\n\n");

            // Sort months chronologically for better trend analysis by AI
            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                summaryPromptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                summaryPromptBuilder.append("  总收入: ").append(String.format("%.2f", ms.getTotalIncome())).append("元\n");
                summaryPromptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                summaryPromptBuilder.append("  支出明细:\n");
                if (ms.getExpenseByCategory().isEmpty()) {
                    summaryPromptBuilder.append("    (无支出)\n");
                } else {
                    // Sort categories by amount descending for AI to easily see major categories
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    summaryPromptBuilder.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                            );
                }
                summaryPromptBuilder.append("\n"); // Add space between months
            }

            String aiPrompt = summaryPromptBuilder.toString();
            System.out.println("AI Service: Sending personal summary prompt to AI. Prompt length: " + aiPrompt.length());

            return askAi(aiPrompt); // Call the generic AI method
        } catch (Exception e) {
            System.err.println("AI Service: Failed to generate personal summary.");
            e.printStackTrace();
            return "生成个人消费总结失败: " + e.getMessage();
        }
    }

    /**
     * Generates suggestions for savings goals based on monthly data.
     * @param userFilePath The path to the user's transaction CSV file. (Might not be strictly needed)
     * @return AI suggestions as a String.
     */
    public String suggestSavingsGoals(String userFilePath) {
        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("AI Service: Retrieved " + summaries.size() + " months of summary data for savings goal suggestion.");

            if (summaries.isEmpty()) {
                return "没有找到足够的交易数据来建议储蓄目标。";
            }

            StringBuilder promptBuilder = new StringBuilder();
            promptBuilder.append("请根据以下月度收支总结数据，为我这个消费习惯提供一些合理的储蓄目标建议：\n\n");

            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  总收入: ").append(String.format("%.2f", ms.getTotalIncome())).append("元\n");
                promptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                double net = ms.getTotalIncome() - ms.getTotalExpense();
                promptBuilder.append("  月度净收支: ").append(String.format("%.2f", net)).append("元\n");
                promptBuilder.append("\n");
            }

            String aiPrompt = promptBuilder.toString();
            System.out.println("AI Service: Sending savings goals prompt to AI. Prompt length: " + aiPrompt.length());

            return askAi(aiPrompt);
        } catch (Exception e) {
            System.err.println("AI Service: Failed to suggest savings goals.");
            e.printStackTrace();
            return "建议储蓄目标失败: " + e.getMessage();
        }
    }

    /**
     * Generates personalized cost-cutting recommendations based on monthly data.
     * @param userFilePath The path to the user's transaction CSV file. (Might not be strictly needed)
     * @return AI recommendations as a String.
     */
    public String givePersonalSavingTips(String userFilePath) {
        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("AI Service: Retrieved " + summaries.size() + " months of summary data for saving tips.");

            if (summaries.isEmpty()) {
                return "没有找到足够的交易数据来提供个性化节约建议。";
            }

            StringBuilder promptBuilder = new StringBuilder();
            promptBuilder.append("请根据以下月度消费总结数据，为我提供一些针对性的节约开销建议：\n\n");

            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                promptBuilder.append("  支出明细:\n");
                if (ms.getExpenseByCategory().isEmpty()) {
                    promptBuilder.append("    (无支出)\n");
                } else {
                    // Sort categories by amount descending
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    promptBuilder.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                            );
                }
                promptBuilder.append("\n");
            }

            String aiPrompt = promptBuilder.toString();
            System.out.println("AI Service: Sending personal saving tips prompt to AI. Prompt length: " + aiPrompt.length());

            return askAi(aiPrompt);
        } catch (Exception e) {
            System.err.println("AI Service: Failed to give personal saving tips.");
            e.printStackTrace();
            return "生成个性化节约建议失败: " + e.getMessage();
        }
    }


    // ... Keep other methods like analyzeTransactions, formatTransactions, parseDateTime, askAi ...

    // The existing CollegeStudentNeeds class also has budget and tips methods.
    // We need to decide: should AITransactionService offer general AI for anyone,
    // and CollegeStudentNeeds offer student-specific prompts/logic?
    // Or should AITransactionService be the main AI interaction point,
    // and CollegeStudentNeeds just holds student-specific logic/prompts used by AITransactionService?
    // Given the project structure, it might be better to keep student logic in CollegeStudentNeeds
    // and call it from MenuUI or a wrapper service.
    // Let's adjust: generatePersonalSummary, suggestSavingsGoals, givePersonalSavingTips will use monthly summary.
    // CollegeStudentNeeds.generateBudget and generateTipsForSaving can remain using their current logic
    // (budget uses weekly expenses, tips is generic for now).
    // The prompt for CollegeStudentNeeds.generateBudget might need to be updated to use the monthly summary data too for better context.
    // Let's refine CollegeStudentNeeds methods in the next step.

    // For now, the three new methods above will use the monthly summary.
    // The existing analyzeTransactions method in AITransactionService and the methods in CollegeStudentNeeds remain as is for now,
    // but their usage in UI might change slightly.

}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\AIservice\ColledgeStudentThread.java`:

```java
package Service.AIservice;

// Add required imports
import Service.TransactionService; // Keep import if generateBudget throws Exception
// import java.io.IOException; // Removed specific IOException import if using general Exception


public class ColledgeStudentThread implements Runnable{
    // Remove the old budgetRange field, it's not used here
    // public String budgetRange;

    // Field to hold the injected CollegeStudentNeeds service instance
    private final CollegeStudentNeeds collegeStudentNeeds;
    // The file path is still needed to pass to the generateBudget method
    private final String filePath;


    /**
     * Constructor now accepts the CollegeStudentNeeds service instance and the file path.
     * The injected service instance already contains the necessary TransactionService.
     *
     * @param collegeStudentNeeds The CollegeStudentNeeds service instance to use for generating the budget.
     * @param filePath The path to the user's transaction data file.
     */
    public ColledgeStudentThread(CollegeStudentNeeds collegeStudentNeeds, String filePath) {
        this.collegeStudentNeeds = collegeStudentNeeds;
        this.filePath = filePath;
        System.out.println("ColledgeStudentThread initialized for file: " + filePath);
    }

    @Override
    public void run(){
        System.out.println("ColledgeStudentThread started for file: " + filePath);
        try {
            // Call the generateBudget method on the injected service instance
            double[] budget = collegeStudentNeeds.generateBudget(filePath);

            // Print the result or handle it as needed by the test/caller that starts this thread
            if (budget != null && budget.length == 2 && budget[0] != -1) {
                System.out.println("Budget generated in thread for file " + filePath + ": [" + budget[0] + ", " + budget[1] + "]");
            } else {
                // handle the case where budget generation failed or returned -1
                System.out.println("Budget generation in thread finished, but no valid budget was returned for file " + filePath + ".");
                // You might want to distinguish between "no data" (-1,-1) and other exceptions here.
            }
        } catch (Exception e) { // Catch Exception as generateBudget throws Exception
            System.err.println("Error generating budget in thread for file " + filePath + ": " + e.getMessage());
            e.printStackTrace();
        }
        System.out.println("ColledgeStudentThread finished for file: " + filePath);
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\AIservice\CollegeStudentNeeds.java`:

```java
package Service.AIservice;

// ... existing imports ...
import Constants.StandardCategories;
import DAO.TransactionDao;
import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheManager;
import model.Transaction;
import model.MonthlySummary; // Import MonthlySummary
import Service.TransactionService; // Import TransactionService interface


import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.Map; // Import Map
import java.util.Collections; // For sorting map entries
import java.util.Optional;
import java.util.stream.Collectors;


public class CollegeStudentNeeds {
    // Keep existing prompts, maybe refine them to mention using the data provided
    private final String requestBudge="我是一名预算有限的大学生，请根据下面我给出的历史周花费和月度收支总结，帮助我给下周预算范围，必须以[最低预算，最高预算],的方式给出回答，不能有多余的回复。";
    private final String requestTips="我是一名预算有限的大学生，请结合下面我给出的月度消费总结数据，为我推荐一些有针对性的省钱方法。"; // Refined prompt
    // Add the missing constant:
    private final String requestRecognition =
            "请根据以下账单信息推测最合适的交易类型。返回的类型必须精确匹配以下列表中的一个条目：\n" +
                    StandardCategories.getAllCategoriesString() + "\n" + // Include the list of valid categories
                    "如果无法确定，请返回 '其他支出' 或 '其他收入'（取决于收支方向）。只返回类型字符串，不要包含额外文本或解释。账单信息：";
    // AITransactionService is used for asking AI, can be an instance or created on demand
    // private final AITransactionService aiService = new AITransactionService(); // This instance won't have injected TransactionService

    // Need a way to get TransactionService here to generate monthly summaries
    // Option 1: Inject TransactionService into CollegeStudentNeeds constructor
    private final TransactionService transactionService; // Inject TransactionService

    /**
     * Constructor now accepts TransactionService instance.
     */
    public CollegeStudentNeeds(TransactionService transactionService) {
        this.transactionService = transactionService; // Inject the service
        System.out.println("CollegeStudentNeeds initialized with TransactionService.");
    }


    /**
     * Recognizes the spending category of a single transaction using AI. (Keep as is, uses raw transaction)
     *
     * @param transaction The transaction to recognize.
     * @return The AI's suggested category.
     */
    public String RecognizeTransaction(Transaction transaction){
        if (transaction == null) {
            return "无法识别空交易信息";
        }
        StringBuilder sb=new StringBuilder();
        sb.append("交易类型:").append(transaction.getTransactionType()).append(",")
                .append("交易对方:").append(transaction.getCounterparty()).append(",")
                .append("商品:").append(transaction.getCommodity()).append(",")
                .append("收/支:").append(transaction.getInOut()).append(",")
                .append("金额(元):").append(String.format("%.2f", transaction.getPaymentAmount())).append(",") // Format amount
                .append("支付方式:").append(transaction.getPaymentMethod()).append(",")
                .append("备注:").append(transaction.getRemarks());

        System.out.println("CollegeStudentNeeds: Sending recognition request to AI: " + sb.toString());
        // Need a separate AITransactionService instance or method call that doesn't depend on injected TransactionService
        // Option 2: Create a local AITransactionService instance just for askAi calls
        AITransactionService localAiService = new AITransactionService(null); // Pass null for TransactionService as it's not needed by askAi
        return  localAiService.askAi(requestRecognition + sb.toString());
    }

    /**
     * Generates saving tips for college students using AI, now based on monthly summary.
     * @param userFilePath The path to the user's transaction CSV file. (Not strictly needed if service is user-scoped)
     * @return AI's suggested saving tips.
     */
    // Refined to use monthly summary data
    public String generateTipsForSaving(String userFilePath){ // Keep filePath parameter for consistency or remove if service is user-scoped
        try {
            // Get monthly summary data from TransactionService
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary(); // Use injected service
            System.out.println("CollegeStudentNeeds: Retrieved " + summaries.size() + " months of summary data for tips.");

            if (summaries.isEmpty()) {
                return "没有找到足够的交易数据来提供个性化节约建议。";
            }

            StringBuilder promptBuilder = new StringBuilder();
            promptBuilder.append(requestTips).append("\n\n以下是我的月度消费总结数据：\n\n");

            // Sort months chronologically
            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                promptBuilder.append("  支出明细:\n");
                if (ms.getExpenseByCategory().isEmpty()) {
                    promptBuilder.append("    (无支出)\n");
                } else {
                    // Sort categories by amount descending
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    promptBuilder.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                            );
                }
                promptBuilder.append("\n");
            }

            String aiPrompt = promptBuilder.toString();
            System.out.println("CollegeStudentNeeds: Sending saving tips prompt to AI. Prompt length: " + aiPrompt.length());

            // Need a separate AITransactionService instance or method call that doesn't depend on injected TransactionService
            AITransactionService localAiService = new AITransactionService(null); // Pass null for TransactionService
            return localAiService.askAi(aiPrompt);

        } catch (Exception e) {
            System.err.println("CollegeStudentNeeds: Failed to generate saving tips.");
            e.printStackTrace();
            return "生成个性化节约建议失败: " + e.getMessage();
        }
    }

    /**
     * Analyzes weekly spending and asks AI for a budget range, now also includes monthly summary context.
     * @param filePath The path to the user's transaction CSV file.
     * @return A double array [minBudget, maxBudget] parsed from AI response, or [-1, -1] on failure.
     * @throws Exception If there's an error accessing the transaction data.
     */
    // Inside CollegeStudentNeeds class, modify the generateBudget method:

    public double[] generateBudget(String filePath) throws Exception {
        List<Transaction> transactions;
        Map<String, MonthlySummary> summaries; // Declare the summaries variable here

        try {
            // Get transactions using CacheManager
            TransactionDao transactionDaoForLoading = new CsvTransactionDao();
            transactions = CacheManager.getTransactions(filePath, transactionDaoForLoading);
            System.out.println("CollegeStudentNeeds: Retrieved " + transactions.size() + " transactions for budget analysis from: " + filePath);

            // Get monthly summary data for context
            summaries = transactionService.getMonthlyTransactionSummary(); // Assign to the declared variable
            System.out.println("CollegeStudentNeeds: Retrieved " + summaries.size() + " months of summary data for budget context.");

        } catch (Exception e) {
            System.err.println("CollegeStudentNeeds: Error retrieving transactions or summary for budget analysis: " + filePath);
            e.printStackTrace();
            throw e;
        }

        int size = transactions.size();
        if (size == 0) {
            System.out.println("CollegeStudentNeeds: No transactions found for budget analysis.");
            // If no transactions, prompt AI using only the monthly summary (if available)
            if (!summaries.isEmpty()) {
                // Build prompt with only monthly summary
                StringBuilder promptBuilder = new StringBuilder();
                promptBuilder.append("以下是我的月度收支总结数据：\n\n");
                // ... (Code to format monthly summaries for prompt - copy from generatePersonalSummary or generateTipsForSaving) ...
                List<String> sortedMonths = new ArrayList<>(summaries.keySet());
                Collections.sort(sortedMonths);
                for (String month : sortedMonths) {
                    MonthlySummary ms = summaries.get(month);
                    promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                    promptBuilder.append("  总收入: ").append(String.format("%.2f", ms.getTotalIncome())).append("元\n");
                    promptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                    double net = ms.getTotalIncome() - ms.getTotalExpense();
                    promptBuilder.append("  月度净收支: ").append(String.format("%.2f", net)).append("元\n");
                    promptBuilder.append("  主要支出类别:\n"); // Include expense category details
                    if (ms.getExpenseByCategory().isEmpty()) {
                        promptBuilder.append("    (无支出)\n");
                    } else {
                        ms.getExpenseByCategory().entrySet().stream()
                                .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                                .forEach(entry ->
                                        promptBuilder.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                                );
                    }
                    promptBuilder.append("\n");
                }
                // Use the local AI service instance to ask AI
                String answer = new AITransactionService(null).askAi(requestBudge + "\n\n没有找到周支出数据。\n" + promptBuilder.toString());
                return parseDoubleArrayFromString(answer);

            }
            return new double[]{-1, -1}; // No data at all
        }

        // Filter for '支出' transactions and sort them by date (newest first)
        List<Transaction> expenseTransactions = transactions.stream()
                .filter(t -> t.getInOut() != null && (t.getInOut().equals("支出") || t.getInOut().equals("支")))
                .sorted((t1, t2) -> {
                    LocalDate date1 = parseDateSafe(t1.getTransactionTime());
                    LocalDate date2 = parseDateSafe(t2.getTransactionTime());
                    if (date1 != null && date2 != null) { return date2.compareTo(date1); } else if (date1 == null && date2 == null) { return 0; } else if (date1 == null) { return 1; } else { return -1; }
                })
                .collect(Collectors.toList());
        System.out.println("CollegeStudentNeeds: Filtered " + expenseTransactions.size() + " expense transactions for budget analysis.");


        if (expenseTransactions.isEmpty()) {
            System.out.println("CollegeStudentNeeds: No expense transactions found for budget analysis.");
            // Still provide monthly summary context to AI if available
            if (!summaries.isEmpty()) {
                // Build prompt with only monthly summary
                StringBuilder promptBuilder = new StringBuilder();
                promptBuilder.append("以下是我的月度收支总结数据：\n\n");
                // ... (Code to format monthly summaries for prompt - copy from above) ...
                List<String> sortedMonths = new ArrayList<>(summaries.keySet());
                Collections.sort(sortedMonths);
                for (String month : sortedMonths) {
                    MonthlySummary ms = summaries.get(month);
                    promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                    promptBuilder.append("  总收入: ").append(String.format("%.2f", ms.getTotalIncome())).append("元\n");
                    promptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                    double net = ms.getTotalIncome() - ms.getTotalExpense();
                    promptBuilder.append("  月度净收支: ").append(String.format("%.2f", net)).append("元\n");
                    promptBuilder.append("  主要支出类别:\n"); // Include expense category details
                    if (ms.getExpenseByCategory().isEmpty()) {
                        promptBuilder.append("    (无支出)\n");
                    } else {
                        ms.getExpenseByCategory().entrySet().stream()
                                .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                                .forEach(entry ->
                                        promptBuilder.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                                );
                    }
                    promptBuilder.append("\n");
                }
                String answer = new AITransactionService(null).askAi(requestBudge + "\n\n没有找到周支出数据。\n" + promptBuilder.toString());
                return parseDoubleArrayFromString(answer);
            }
            return new double[]{-1, -1}; // No expense data and no summary data
        }

        // --- Weekly Expense Calculation (Keep existing logic) ---
        List<Double> weeklyExpenses = new ArrayList<>();
        LocalDate currentWeekStart = null;
        double currentWeekTotal = 0;

        for (Transaction expense : expenseTransactions) {
            LocalDate transactionDate = parseDateSafe(expense.getTransactionTime());
            if (transactionDate == null) continue;

            if (currentWeekStart == null) {
                currentWeekStart = transactionDate;
            }

            long daysDifference = ChronoUnit.DAYS.between(transactionDate, currentWeekStart);

            if (daysDifference >= 0 && daysDifference < 7) {
                currentWeekTotal += expense.getPaymentAmount();
            } else if (daysDifference >= 7) {
                weeklyExpenses.add(currentWeekTotal);
                currentWeekStart = transactionDate;
                currentWeekTotal = expense.getPaymentAmount();
            }
        }
        if (currentWeekTotal > 0 || currentWeekStart != null) {
            weeklyExpenses.add(currentWeekTotal);
        }
        System.out.println("CollegeStudentNeeds: Calculated weekly expenses for " + weeklyExpenses.size() + " weeks: " + weeklyExpenses);


        // --- Format Prompt including Weekly Expenses and Monthly Summary ---
        StringBuilder promptBuilder = new StringBuilder();
        promptBuilder.append(requestBudge).append("\n\n"); // Start with the budget request prompt

        // Add Weekly Expenses Section
        promptBuilder.append("以下是我最近的每周花费数据：\n");
        if (weeklyExpenses.isEmpty()) {
            promptBuilder.append("(没有找到足够周期的支出数据)\n");
        } else {
            for (int i = 0; i < weeklyExpenses.size(); i++) {
                promptBuilder.append("第");
                promptBuilder.append(weeklyExpenses.size() - 1 - i);
                promptBuilder.append("周:花费");
                promptBuilder.append(String.format("%.2f", weeklyExpenses.get(i)));
                promptBuilder.append("元; ");
            }
            promptBuilder.append("\n");
        }

        // Add Monthly Summary Section
        promptBuilder.append("\n同时，以下是我的月度收支总结数据：\n\n");
        if (summaries.isEmpty()) {
            promptBuilder.append("(没有找到月度总结数据)\n");
        } else {
            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  总收入: ").append(String.format("%.2f", ms.getTotalIncome())).append("元\n");
                promptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                double net = ms.getTotalIncome() - ms.getTotalExpense();
                promptBuilder.append("  月度净收支: ").append(String.format("%.2f", net)).append("元\n");
                promptBuilder.append("  主要支出类别:\n"); // Include expense category details
                if (ms.getExpenseByCategory().isEmpty()) {
                    promptBuilder.append("    (无支出)\n");
                } else {
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    promptBuilder.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                            );
                }
                promptBuilder.append("\n");
            }
        }


        String aiPrompt = promptBuilder.toString(); // This now contains the full prompt
        System.out.println("CollegeStudentNeeds: Sending budget request to AI. Prompt length: " + aiPrompt.length());

        // Use the local AI service instance to ask AI
        String answer = new AITransactionService(null).askAi(aiPrompt); // Pass null as askAi doesn't need TransactionService
        System.out.println("CollegeStudentNeeds: Received budget response from AI: " + answer);

        double[] ret = parseDoubleArrayFromString(answer);
        if (ret == null || ret.length != 2) {
            System.err.println("CollegeStudentNeeds: Failed to parse budget array from AI response: " + answer + ". Full AI Response: " + answer); // Log the full response
            return new double[]{-1, -1};
        }

        return ret;
    }

    // Helper method to safely parse date from transaction time string (must be consistent!)
    private LocalDate parseDateSafe(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // Clean whitespace and potential hyphens if the expected format is slash-separated
        String datePart = timeStr.split(" ")[0]; // Get the date part

        datePart = datePart.trim().replace('-', '/').replaceAll("\\s+", "");

        List<String> patterns = List.of(
                "yyyy/M/d", "yyyy/MM/d", "yyyy/M/dd", "yyyy/MM/dd",
                "yyyy-MM-dd" // Add dash format just in case
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDate.parse(datePart, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern
            }
        }
        System.err.println("CollegeStudentNeeds: Failed to parse date part '" + datePart + "' from transaction time: " + timeStr);
        return null; // Return null if no pattern matches
    }

    // Keep parseDoubleArrayFromString method - ensure robustness
    public double[] parseDoubleArrayFromString(String input) {
        // ... existing robust implementation ...
        if (input == null) { return null; }
        String trimmedInput = input.trim();
        System.out.println("CollegeStudentNeeds: Attempting to parse budget string: '" + trimmedInput + "'");
        int startIndex = trimmedInput.indexOf('[');
        int endIndex = trimmedInput.lastIndexOf(']');
        if (startIndex == -1 || endIndex == -1 || endIndex < startIndex) {
            System.err.println("CollegeStudentNeeds: Budget string does not contain valid []. Input: " + trimmedInput);
            return null;
        }
        String content = trimmedInput.substring(startIndex + 1, endIndex).trim();
        String[] numberStrings = content.split("\\s*,\\s*");
        if (numberStrings.length != 2) {
            System.err.println("CollegeStudentNeeds: Budget string content does not contain exactly two numbers separated by comma. Content: " + content);
            return null;
        }
        double[] result = new double[2];
        try {
            result[0] = Double.parseDouble(numberStrings[0].trim());
            result[1] = Double.parseDouble(numberStrings[1].trim());
            System.out.println("CollegeStudentNeeds: Successfully parsed budget: [" + result[0] + ", " + result[1] + "]");
            return result;
        } catch (NumberFormatException e) {
            System.err.println("CollegeStudentNeeds: Error parsing numbers from budget string: " + content);
            e.printStackTrace();
            return null;
        }
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\Impl\SummaryStatisticService.java`:

```java
package Service.Impl;

import Constants.StandardCategories; // Import StandardCategories
import DAO.TransactionDao; // Import TransactionDao interface
import DAO.UserDao; // Import UserDao interface
import DAO.SummaryStatisticDao; // Import SummaryStatisticDao interface
import model.SummaryStatistic;
import model.Transaction;
import model.User;
import Utils.CacheManager; // Import CacheManager
import Constants.ConfigConstants; // Import ConfigConstants for summary file path

import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.temporal.WeekFields; // For getting week of year
import java.util.*;
import java.util.stream.Collectors;
import java.time.format.DateTimeFormatter; // For generating timestamp

public class SummaryStatisticService {

    private final UserDao userDao;
    private final TransactionDao transactionDao; // Need a DAO instance for CacheManager loading
    private final SummaryStatisticDao summaryStatisticDao;
    private final String summaryFilePath;

    /**
     * Constructor to inject dependencies.
     * @param userDao DAO for user data.
     * @param transactionDao DAO for transaction data (used by CacheManager loader).
     * @param summaryStatisticDao DAO for summary statistics data.
     */
    public SummaryStatisticService(UserDao userDao, TransactionDao transactionDao, SummaryStatisticDao summaryStatisticDao) {
        this.userDao = userDao;
        this.transactionDao = transactionDao; // Injected for use in CacheManager loader
        this.summaryStatisticDao = summaryStatisticDao;
        this.summaryFilePath = ConfigConstants.SUMMARY_CSV_PATH; // Get summary file path from config
        System.out.println("SummaryStatisticService initialized. Summary file: " + summaryFilePath);
    }

    /**
     * Helper method to load all transactions from all user files.
     * Uses CacheManager to benefit from caching.
     * @param users List of all users.
     * @return A single list containing all transactions from all users.
     * @throws Exception If loading from any user file fails.
     */
    private List<Transaction> loadAllTransactionsFromAllUsers(List<User> users) throws Exception {
        List<Transaction> allTransactions = new ArrayList<>();
        for (User user : users) {
            String userFilePath = user.getTransactionFilePath();
            if (userFilePath != null && !userFilePath.trim().isEmpty()) {
                try {
                    // Use CacheManager to get transactions for this user's file
                    // Pass the transactionDao instance for the loader
                    List<Transaction> userTransactions = CacheManager.getTransactions(userFilePath, transactionDao);
                    allTransactions.addAll(userTransactions);
                    System.out.println("Loaded " + userTransactions.size() + " transactions for user: " + user.getUsername() + " from " + userFilePath);
                } catch (Exception e) {
                    System.err.println("Error loading transactions for user " + user.getUsername() + " from " + userFilePath + ". Skipping this user.");
                    e.printStackTrace();
                    // Decide whether to stop or continue if one user's file fails.
                    // Continuing is more robust for aggregate statistics.
                    // throw e; // Uncomment to stop processing if any user file fails
                }
            } else {
                System.out.println("User " + user.getUsername() + " has no transaction file path configured. Skipping.");
            }
        }
        return allTransactions;
    }


    /**
     * Helper method to group transactions by week identifier (YYYY-Www).
     * @param transactions The list of transactions.
     * @return A map where keys are week identifiers and values are lists of transactions in that week.
     */
    private Map<String, List<Transaction>> groupTransactionsByWeek(List<Transaction> transactions) {
        WeekFields weekFields = WeekFields.ISO; // ISO 8601 week numbering (Monday is the first day of the week)
        DateTimeFormatter weekFormatter = DateTimeFormatter.ofPattern("yyyy-'W'ww"); // Format as "YYYY-Www"

        return transactions.stream()
                .filter(t -> t.getTransactionTime() != null && !t.getTransactionTime().trim().isEmpty()) // Filter out transactions with no time
                .collect(Collectors.groupingBy(t -> {
                    try {
                        // Safely parse the transaction date (only date part is needed for week)
                        // Need to ensure the parser is consistent with the one in TransactionServiceImpl/AITransactionService
                        // Let's re-use the safe parsing logic or ensure consistency.
                        // Simplest: Use a helper method for date parsing just for this service, matching expected formats.
                        LocalDate date = parseDateFromTransactionTime(t.getTransactionTime());
                        if (date != null) {
                            return date.format(weekFormatter); // Format date to week identifier
                        }
                    } catch (Exception e) {
                        System.err.println("Failed to parse date for week grouping: " + t.getTransactionTime() + ". Skipping transaction.");
                        // Transaction with unparseable date will be grouped under 'null' or skipped by filter
                    }
                    return "未知周"; // Group unparseable dates under an 'unknown' key
                }));
    }

    // Helper method to parse date from transaction time string (should match other parsers)
    private LocalDate parseDateFromTransactionTime(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // Clean whitespace and potential hyphens if the expected format is slash-separated
        // Assume the format used in CSV/Transaction model is one of the parsers in other services
        // Let's use a robust set of date patterns matching parseDateTimeSafe in TransactionServiceImpl
        String datePart = timeStr.split(" ")[0]; // Get the date part

        datePart = datePart.trim().replace('-', '/').replaceAll("\\s+", "");


        // Try parsing with multiple slash formats
        List<String> patterns = List.of(
                "yyyy/M/d", "yyyy/MM/d", "yyyy/M/dd", "yyyy/MM/dd",
                "yyyy-MM-dd" // Add dash format just in case
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDate.parse(datePart, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern
            }
        }
        System.err.println("SummaryStatisticService: Failed to parse date part '" + datePart + "' from transaction time: " + timeStr);
        return null; // Return null if no pattern matches
    }


    /**
     * Retrieves all summary statistics from the data source.
     * @return List of summary statistics.
     * @throws IOException If loading fails.
     */
    public List<SummaryStatistic> getAllSummaryStatistics() throws IOException {
        // Simply delegate to the DAO
        return summaryStatisticDao.loadAllStatistics(summaryFilePath);
    }


    // --- Revised Plan for generateAndSaveWeeklyStatistics ---
    // The previous approach of loading all transactions and then grouping by week
    // doesn't easily allow counting unique users per week unless we augment the Transaction object
    // or wrap it with User info during loading.
    // A better approach for unique user count is to process user by user.

    public void generateAndSaveWeeklyStatistics() throws Exception {
        System.out.println("Generating weekly summary statistics (Revised approach)...");
        List<User> allUsers = userDao.getAllUsers();
        System.out.println("Loaded " + allUsers.size() + " users.");

        // Map to hold weekly stats per user (WeekId -> Map<UserId, UserWeeklyStats>)
        // This intermediate structure is complex.

        // Map to hold aggregated stats for each week (WeekId -> AggregatedWeeklyStats)
        Map<String, Double> totalIncomeByWeek = new HashMap<>();
        Map<String, Double> totalExpenseByWeek = new HashMap<>();
        Map<String, Map<String, Double>> expenseByCategoryByWeek = new HashMap<>(); // WeekId -> (Category -> Amount)
        Map<String, Set<String>> usersByWeek = new HashMap<>(); // WeekId -> Set<Username>

        WeekFields weekFields = WeekFields.ISO;
        DateTimeFormatter weekFormatter = DateTimeFormatter.ofPattern("yyyy-'W'ww");


        // Iterate through each user
        for (User user : allUsers) {
            String userFilePath = user.getTransactionFilePath();
            String username = user.getUsername();

            if (userFilePath != null && !userFilePath.trim().isEmpty()) {
                try {
                    // Load transactions for this user
                    List<Transaction> userTransactions = CacheManager.getTransactions(userFilePath, transactionDao);
                    System.out.println("Processing " + userTransactions.size() + " transactions for user: " + username);

                    // Iterate through transactions for this user
                    for (Transaction t : userTransactions) {
                        if (t.getTransactionTime() == null || t.getTransactionTime().trim().isEmpty()) {
                            System.err.println("Skipping transaction with no time for user " + username + ": " + t.getOrderNumber());
                            continue; // Skip transactions with no time
                        }

                        LocalDate date = parseDateFromTransactionTime(t.getTransactionTime());
                        if (date == null) {
                            System.err.println("Skipping transaction with unparseable date for user " + username + ": " + t.getTransactionTime());
                            continue; // Skip transactions with invalid date
                        }

                        String weekIdentifier = date.format(weekFormatter);

                        // Add user to the set for this week
                        usersByWeek.computeIfAbsent(weekIdentifier, k -> new HashSet<>()).add(username);

                        // Aggregate income/expense
                        if (t.getInOut() != null) {
                            String inOut = t.getInOut().trim();
                            if (inOut.equals("收入") || inOut.equals("收")) {
                                totalIncomeByWeek.put(weekIdentifier, totalIncomeByWeek.getOrDefault(weekIdentifier, 0.0) + t.getPaymentAmount());
                            } else if (inOut.equals("支出") || inOut.equals("支")) {
                                totalExpenseByWeek.put(weekIdentifier, totalExpenseByWeek.getOrDefault(weekIdentifier, 0.0) + t.getPaymentAmount());

                                // Aggregate expense by standard category
                                String rawType = t.getTransactionType();
                                String standardCategory = StandardCategories.getStandardCategory(rawType);
                                // Only aggregate standard expense categories for the top category calculation
                                if (StandardCategories.isStandardExpenseCategory(standardCategory) || !StandardCategories.ALL_KNOWN_TYPES.contains(standardCategory)) {
                                    String effectiveExpenseCategoryForTop = StandardCategories.isStandardExpenseCategory(standardCategory) ? standardCategory : "其他支出";
                                    expenseByCategoryByWeek.computeIfAbsent(weekIdentifier, k -> new HashMap<>())
                                            .put(effectiveExpenseCategoryForTop, expenseByCategoryByWeek.get(weekIdentifier).getOrDefault(effectiveExpenseCategoryForTop, 0.0) + t.getPaymentAmount());
                                }
                            }
                        }
                    }
                } catch (Exception e) {
                    System.err.println("Error loading transactions for user " + user.getUsername() + " from " + userFilePath + ". Skipping this user's data for statistics.");
                    e.printStackTrace();
                    // Continue processing other users
                }
            } else {
                System.out.println("User " + user.getUsername() + " has no transaction file path configured. Skipping for statistics.");
            }
        }
        System.out.println("Completed aggregation across all users by week.");


        // 5. Consolidate aggregated data into SummaryStatistic objects
        List<SummaryStatistic> calculatedStatistics = new ArrayList<>();
        DateTimeFormatter timestampFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String timestamp = LocalDateTime.now().format(timestampFormatter);

        // Iterate through all week identifiers found
        Set<String> allWeeks = new HashSet<>();
        allWeeks.addAll(totalIncomeByWeek.keySet());
        allWeeks.addAll(totalExpenseByWeek.keySet());
        allWeeks.addAll(usersByWeek.keySet());
        allWeeks.addAll(expenseByCategoryByWeek.keySet());

        List<String> sortedWeekIdentifiers = allWeeks.stream().sorted().collect(Collectors.toList());

        for (String weekIdentifier : sortedWeekIdentifiers) {
            double totalIncome = totalIncomeByWeek.getOrDefault(weekIdentifier, 0.0);
            double totalExpense = totalExpenseByWeek.getOrDefault(weekIdentifier, 0.0);
            int numberOfUsers = usersByWeek.getOrDefault(weekIdentifier, Collections.emptySet()).size();

            // Find top expense category for this week
            Map<String, Double> weeklyExpenseByCategory = expenseByCategoryByWeek.getOrDefault(weekIdentifier, Collections.emptyMap());
            String topExpenseCategory = "无支出";
            double topExpenseCategoryAmount = 0.0;

            Optional<Map.Entry<String, Double>> maxEntry = weeklyExpenseByCategory.entrySet().stream()
                    .max(Map.Entry.comparingByValue());

            if (maxEntry.isPresent()) {
                topExpenseCategory = maxEntry.get().getKey();
                topExpenseCategoryAmount = maxEntry.get().getValue();
            }

            calculatedStatistics.add(new SummaryStatistic(
                    weekIdentifier,
                    totalIncome,
                    totalExpense,
                    topExpenseCategory,
                    topExpenseCategoryAmount,
                    numberOfUsers,
                    timestamp // Timestamp is when the stats were generated, not per week
            ));
        }
        System.out.println("Created " + calculatedStatistics.size() + " SummaryStatistic objects.");


        // 6. Load existing statistics
        List<SummaryStatistic> existingStatistics = getAllSummaryStatistics();
        System.out.println("Loaded " + existingStatistics.size() + " existing summary statistics.");

        // 7. Merge existing and newly calculated statistics (overwrite new weeks, keep old)
        Map<String, SummaryStatistic> finalStatisticsMap = new HashMap<>();
        for(SummaryStatistic stat : existingStatistics) {
            finalStatisticsMap.put(stat.getWeekIdentifier(), stat);
        }
        for(SummaryStatistic stat : calculatedStatistics) {
            finalStatisticsMap.put(stat.getWeekIdentifier(), stat); // New calculation replaces old for the week
        }

        // 8. Sort merged statistics by week identifier (chronologically)
        List<SummaryStatistic> finalStatistics = finalStatisticsMap.values().stream()
                .sorted(Comparator.comparing(SummaryStatistic::getWeekIdentifier))
                .collect(Collectors.toList());

        // 9. Save the final list
        summaryStatisticDao.writeAllStatistics(summaryFilePath, finalStatistics);
        System.out.println("Weekly summary statistics generated and saved successfully to " + summaryFilePath);
    }


}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\Impl\TransactionServiceImpl.java`:

```java
package Service.Impl;

import Constants.StandardCategories;
import DAO.TransactionDao; // Import the interface
import DAO.Impl.CsvTransactionDao; // Import the implementation
import Service.TransactionService;
import Utils.CacheManager; // Import the new CacheManager
import model.MonthlySummary;
import model.Transaction;

import javax.swing.*;
import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.YearMonth;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors; // Needed for search

// Remove static field
// public static CsvTransactionDao csvTransactionDao;

// Remove direct CacheUtil instance
// public final CacheUtil<String, List<Transaction>, Exception> cache;

public class TransactionServiceImpl implements TransactionService {

    private final String currentUserTransactionFilePath; // Store the user's file path
    // TransactionDao instance needed to load data if cache misses
    private final TransactionDao transactionDao;

    /**
     * Constructor now accepts the user's transaction file path.
     *
     * @param currentUserTransactionFilePath The file path for the current user's transactions.
     */
    public TransactionServiceImpl(String currentUserTransactionFilePath) {
        this.currentUserTransactionFilePath = currentUserTransactionFilePath;
        // Create a DAO instance for this service instance.
        this.transactionDao = new CsvTransactionDao(); // One DAO instance per service instance
        System.out.println("TransactionServiceImpl initialized for file: " + currentUserTransactionFilePath);
        // Cache is managed by CacheManager, not directly by this instance.
    }

    @Override // Implement the new interface method
    public List<Transaction> getAllTransactions() throws Exception {
        // Simply call the internal method that uses the cache
        return getAllTransactionsForCurrentUser();
    }

    /**
     * Imports transactions from a given CSV file path into the current user's transactions.
     * Reads the import file, merges with existing data, and saves back.
     *
     * @param userFilePath The file path for the current user's transactions (target).
     * @param importFilePath The file path of the CSV to import from (source).
     * @return The number of transactions successfully imported.
     * @throws Exception If an error occurs during reading, parsing, or saving.
     */
    @Override // Implement the new interface method
    public int importTransactionsFromCsv(String userFilePath, String importFilePath) throws Exception {
        System.out.println("Starting import from " + importFilePath + " to user file " + userFilePath);
        List<Transaction> existingTransactions;
        List<Transaction> transactionsToImport;

        try {
            // 1. Load existing transactions for the current user (from cache/file)
            // Use the method that uses the CacheManager
            existingTransactions = getAllTransactions(); // Already uses CacheManager

            // 2. Read and parse transactions from the import file
            // Use the DAO's loadFromCSV method with the import file path
            // Need a *separate* DAO instance or method call that targets the import file
            TransactionDao importDao = new CsvTransactionDao(); // Create a temporary DAO for reading the import file
            transactionsToImport = importDao.loadFromCSV(importFilePath); // Load from the selected file
            System.out.println("Read " + transactionsToImport.size() + " transactions from import file.");

        } catch (IOException e) {
            System.err.println("Error loading files during import process.");
            e.printStackTrace();
            throw new Exception("读取交易数据失败！", e); // Wrap and re-throw
        }

        // 3. Merge imported transactions with existing ones
        // Simple merge: add all imported transactions.
        // Handle potential duplicates: check if order number exists.
        // If order numbers are not guaranteed unique in imported file or against existing,
        // consider generating new unique IDs for imported items if their ON is empty or conflicts.
        List<Transaction> mergedTransactions = new ArrayList<>(existingTransactions);
        int importedCount = 0;

        for (Transaction importedTx : transactionsToImport) {
            // Basic Check: Ensure imported transaction has an order number or generate one
            if (importedTx.getOrderNumber() == null || importedTx.getOrderNumber().trim().isEmpty()) {
                // Generate a unique ID for transactions without one
                String uniqueId = "IMPORT_" + UUID.randomUUID().toString();
                importedTx.setOrderNumber(uniqueId);
                System.out.println("Generated unique order number for imported transaction: " + uniqueId);
            } else {
                // Check for potential duplicate order number against existing transactions
                boolean duplicate = existingTransactions.stream()
                        .anyMatch(t -> t.getOrderNumber().trim().equals(importedTx.getOrderNumber().trim()));
                if (duplicate) {
                    System.err.println("Skipping imported transaction due to duplicate order number: " + importedTx.getOrderNumber());
                    // Decide: skip, overwrite, or generate new ID. Skipping for now.
                    JOptionPane.showMessageDialog(null, "发现重复交易单号: " + importedTx.getOrderNumber() + ", 已跳过。", "导入警告", JOptionPane.WARNING_MESSAGE);
                    continue; // Skip this duplicate transaction
                }
            }

            // Add the transaction to the merged list
            mergedTransactions.add(importedTx);
            importedCount++;
        }
        System.out.println("Merged transactions. Total after merge: " + mergedTransactions.size() + ". Successfully imported count: " + importedCount);


        // 4. Save the merged list back to the current user's file
        try {
            // Use the DAO instance associated with this service (which knows the user's file implicitly via CacheManager interactions, but writeAllStatistics needs the path explicitly)
            // The transactionDao field is initialized as CsvTransactionDao, which has writeAllStatistics.
            transactionDao.writeTransactionsToCSV(userFilePath, mergedTransactions);
            System.out.println("Saved merged transactions to user file: " + userFilePath);

            // 5. Invalidate or update the cache for the current user's file
            // Invalidation is simpler: forces CacheManager to reload from the updated file next time.
            CacheManager.invalidateTransactionCache(userFilePath);
            System.out.println("Cache invalidated for user file: " + userFilePath);


        } catch (IOException e) {
            System.err.println("Error saving merged transactions after import.");
            e.printStackTrace();
            // Consider leaving the original file untouched on save failure
            throw new Exception("保存导入的交易数据失败！", e); // Wrap and re-throw
        }

        System.out.println("Import process finished.");
        return importedCount; // Return the count of transactions actually added
    }

    /**
     * Gets all transactions for the current user from the cache (loading if necessary).
     * Made protected or public if needed by subclasses, but private is fine for now.
     * @return List of transactions.
     * @throws Exception If an error occurs during loading.
     */
    private List<Transaction> getAllTransactionsForCurrentUser() throws Exception { // Kept as private or change if needed
        // Get transactions using the CacheManager for the current user's file
        return CacheManager.getTransactions(currentUserTransactionFilePath, transactionDao);
    }


//    /**
//     * Gets all transactions for the current user from the cache (loading if necessary).
//     *
//     * @return List of transactions.
//     * @throws Exception If an error occurs during loading.
//     */
//    private List<Transaction> getAllTransactionsForCurrentUser() throws Exception {
//        // Get transactions using the CacheManager for the current user's file
//        return CacheManager.getTransactions(currentUserTransactionFilePath, transactionDao);
//    }


    /**
     * Add transaction for the current user.
     *
     * @param transaction The new transaction to add.
     */
    @Override
    public void addTransaction(Transaction transaction) throws IOException {
        // Set transaction time to current time if not already set
        if (transaction.getTransactionTime() == null || transaction.getTransactionTime().isEmpty()) {
            LocalDateTime now = LocalDateTime.now();
            // Using a flexible format, match parseDateTime in AITransactionService
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
            String currentTime = now.format(formatter);
            transaction.setTransactionTime(currentTime);
        }

        try {
            // Call DAO layer to add transaction to the user's specific file
            transactionDao.addTransaction(currentUserTransactionFilePath, transaction);

            // After adding, invalidate the cache for this user's file
            // Or, ideally, reload the data and put the new list into the cache.
            // Invalidation is simpler for now, forcing a reload on next get.
            CacheManager.invalidateTransactionCache(currentUserTransactionFilePath);
            System.out.println("Transaction added and cache invalidated for " + currentUserTransactionFilePath);

        } catch (IOException e) {
            System.err.println("Error adding transaction for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e; // Re-throw
        }
    }

    /**
     * Change transaction information for the current user.
     *
     * @param updatedTransaction The transaction object with updated information.
     */
    @Override
    public void changeTransaction(Transaction updatedTransaction) throws Exception {
        try {
            // Load existing transactions (from cache/file)
            List<Transaction> allTransactions = getAllTransactionsForCurrentUser();

            // Find and update the target transaction in the list
            boolean foundAndUpdatedInMemory = false;
            List<Transaction> updatedList = new ArrayList<>(allTransactions.size()); // Create a new list or modify in place
            for (Transaction t : allTransactions) {
                if (t.getOrderNumber().trim().equals(updatedTransaction.getOrderNumber().trim())) {
                    // Found the transaction, apply updates
                    updateTransactionFields(t, updatedTransaction); // Helper method to apply updates
                    updatedList.add(t); // Add the modified transaction
                    foundAndUpdatedInMemory = true;
                    System.out.println("Transaction with order number " + updatedTransaction.getOrderNumber() + " found and updated in memory.");
                } else {
                    updatedList.add(t); // Add unchanged transactions
                }
            }


            if (!foundAndUpdatedInMemory) {
                throw new IllegalArgumentException("未找到交易单号: " + updatedTransaction.getOrderNumber() + " 在文件 " + currentUserTransactionFilePath + " 中");
            }

            // Write the entire updated list back to the CSV file
            transactionDao.writeTransactionsToCSV(currentUserTransactionFilePath, updatedList);
            System.out.println("Updated transaction with order number " + updatedTransaction.getOrderNumber() + " and wrote back to file.");

            // Update the cache with the modified list
            CacheManager.putTransactions(currentUserTransactionFilePath, updatedList, transactionDao);
            System.out.println("Cache updated with the modified transaction list for " + currentUserTransactionFilePath);

        } catch (IOException e) {
            System.err.println("Error changing transaction for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e;
        } catch (Exception e) { // Catch exception from getAllTransactionsForCurrentUser
            System.err.println("Error loading transactions for change operation: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e;
        }
    }

    /**
     * Helper method: Updates non-empty fields from source to target.
     */
    private void updateTransactionFields(Transaction target, Transaction source) {
        // Assuming orderNumber is the key and shouldn't be updated this way
        // Add checks for null and empty strings before updating
        if (source.getTransactionTime() != null && !source.getTransactionTime().trim().isEmpty()) {
            target.setTransactionTime(source.getTransactionTime().trim());
        }
        if (source.getTransactionType() != null && !source.getTransactionType().trim().isEmpty()) {
            target.setTransactionType(source.getTransactionType().trim());
        }
        if (source.getCounterparty() != null && !source.getCounterparty().trim().isEmpty()) {
            target.setCounterparty(source.getCounterparty().trim());
        }
        if (source.getCommodity() != null && !source.getCommodity().trim().isEmpty()) {
            target.setCommodity(source.getCommodity().trim());
        }
        // Handle InOut specifically if it's from a ComboBox with predefined options
        if (source.getInOut() != null && !source.getInOut().trim().isEmpty()) {
            String inOut = source.getInOut().trim();
            if (inOut.equals("收入") || inOut.equals("支出") || inOut.equals("支") || inOut.equals("收")) { // Be flexible with input
                target.setInOut(inOut);
            } else {
                System.err.println("Warning: Invalid value for 收/支: " + source.getInOut() + ". Keeping original.");
                // Optionally throw an IllegalArgumentException
            }
        }
        // Handle paymentAmount - 0.0 might be a valid amount, check if it was explicitly set
        // A better approach for primitive types is to check if the source object
        // represents a "partial update" and how unset primitives are marked.
        // For simplicity here, let's assume 0.0 *is* a valid amount that can be set.
        // If you need to differentiate "not set" from "set to 0.0", the source object
        // would need flags or use wrapper types (Double) and check for null.
        // Let's refine this: Only update if the source amount is NOT 0.0, or if the source object signals it's a full update.
        // Assuming the UI passes a new Transaction object where primitive 0.0 means 'not updated'.
        // This is a common pattern but needs careful handling.
        // If the UI explicitly allows setting 0.0, this logic needs adjustment.
        // For now, let's assume 0.0 is treated as 'no update' UNLESS the original transaction amount was also 0.0.
        // A safer way: If the user edited the amount field in the dialog, we *should* update it, even to 0.0.
        // The MenuUI's editRow extracts values into fields, so we can assume the value from fields[5].getText()
        // represents the user's intended new value. The Double.parseDouble already happened in MenuUI.
        // So, if the source object has a non-zero amount, update. What if the user wants to set it to 0?
        // The current dialog doesn't distinguish. Let's assume for now that any double value from the dialog
        // should be applied. This might need refinement based on UI behavior.
        target.setPaymentAmount(source.getPaymentAmount()); // Simply update the amount


        if (source.getPaymentMethod() != null && !source.getPaymentMethod().trim().isEmpty()) {
            target.setPaymentMethod(source.getPaymentMethod().trim());
        }
        if (source.getCurrentStatus() != null && !source.getCurrentStatus().trim().isEmpty()) {
            target.setCurrentStatus(source.getCurrentStatus().trim());
        }
        // OrderNumber is typically the key, updating it is risky and often disallowed.
        // If allowed, need to ensure uniqueness and handle file operations carefully.
        // Let's assume OrderNumber should NOT be changed via this method.
        // if (source.getOrderNumber() != null && !source.getOrderNumber().trim().isEmpty()) {
        //     target.setOrderNumber(source.getOrderNumber().trim()); // Potential issue if new ON conflicts
        // }
        if (source.getMerchantNumber() != null && !source.getMerchantNumber().trim().isEmpty()) {
            target.setMerchantNumber(source.getMerchantNumber().trim());
        }
        if (source.getRemarks() != null && !source.getRemarks().trim().isEmpty()) {
            target.setRemarks(source.getRemarks().trim());
        }
        System.out.println("Applied updates to transaction: " + target.getOrderNumber());
    }


    /**
     * Delete transaction for the current user by order number.
     *
     * @param orderNumber The unique order number of the transaction to delete.
     * @return true if deletion was successful.
     * @throws Exception If an error occurs or transaction is not found.
     */
    @Override
    public boolean deleteTransaction(String orderNumber) throws Exception {
        try {
            // Call DAO layer to delete transaction from the user's specific file
            boolean deleted = transactionDao.deleteTransaction(currentUserTransactionFilePath, orderNumber);

            if (deleted) {
                // After deleting, invalidate the cache for this user's file
                CacheManager.invalidateTransactionCache(currentUserTransactionFilePath);
                System.out.println("Transaction with order number " + orderNumber + " deleted and cache invalidated for " + currentUserTransactionFilePath);
            } else {
                // If DAO returns false, it means the order number was not found.
                System.out.println("Transaction with order number " + orderNumber + " not found for deletion in " + currentUserTransactionFilePath);
            }
            return deleted; // Return true if deletion occurred, false if not found

        } catch (IOException e) {
            System.err.println("Error deleting transaction for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e; // Re-throw
        }
        // No need for explicit "未找到交易单号" exception here if DAO returns false,
        // MenuUI can check the boolean result and show a message.
    }

    /**
     * Search transactions for the current user based on criteria.
     *
     * @param searchCriteria The Transaction object containing search criteria.
     * @return List of matched transactions.
     */
    @Override
    public List<Transaction> searchTransaction(Transaction searchCriteria) {
        try {
            // 1. Get all transactions for the current user (from cache/file)
            List<Transaction> allTransactions = getAllTransactionsForCurrentUser();
            System.out.println("Searching through " + allTransactions.size() + " transactions for user " + currentUserTransactionFilePath);


            // 2. Filter transactions based on criteria
            // Use stream().filter() for conciseness and potential parallelism (though unlikely needed here)
            List<Transaction> matched = allTransactions.stream()
                    .filter(t -> matchesCriteria(t, searchCriteria))
                    .collect(Collectors.toList());
            System.out.println("Found " + matched.size() + " matching transactions.");


            // 3. Sort matched transactions by time, newest first
            matched.sort((t1, t2) -> {
                // Safely parse and compare dates, fall back to string comparison if parsing fails
                LocalDateTime time1 = parseDateTimeSafe(t1.getTransactionTime());
                LocalDateTime time2 = parseDateTimeSafe(t2.getTransactionTime());

                if (time1 != null && time2 != null) {
                    return time2.compareTo(time1); // Newest first
                } else if (time1 == null && time2 == null) {
                    return 0; // Both unparseable, treat as equal
                } else if (time1 == null) {
                    return 1; // Unparseable times come later
                } else { // time2 == null
                    return -1; // Unparseable times come later
                }
            });
            System.out.println("Matched transactions sorted.");

            return matched;
        } catch (Exception e) { // Catch exception from getAllTransactionsForCurrentUser
            System.err.println("Error during search operation for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            // Depending on UI, you might want to return an empty list or propagate the exception
            // For search, returning empty list and logging error is often user-friendly.
            return List.of();
        }
    }

    /**
     * Helper method: Checks if a single transaction matches the search criteria.
     */
    private boolean matchesCriteria(Transaction transaction, Transaction criteria) {
        // Criteria fields are implicitly ANDed. Null/empty criteria fields match everything.
        return containsIgnoreCase(transaction.getTransactionTime(), criteria.getTransactionTime())
                && containsIgnoreCase(transaction.getTransactionType(), criteria.getTransactionType())
                && containsIgnoreCase(transaction.getCounterparty(), criteria.getCounterparty())
                && containsIgnoreCase(transaction.getCommodity(), criteria.getCommodity())
                && matchesInOutCriteria(transaction.getInOut(), criteria.getInOut()) // Specific check for In/Out
                && containsIgnoreCase(transaction.getPaymentMethod(), criteria.getPaymentMethod());
        // Note: paymentAmount is not used as a search criterion in MenuUI's search panel currently.
        // If needed, add logic here, e.g., checking if criteria.getPaymentAmount() is set
        // and if transaction.getPaymentAmount() falls within a range or matches exactly.
    }

    /**
     * Helper method: Fuzzy match string, ignoring case and trimming whitespace.
     * An empty/null target criteria matches everything.
     */
    private boolean containsIgnoreCase(String source, String target) {
        if (target == null || target.trim().isEmpty()) {
            return true; // Empty criteria matches everything
        }
        if (source == null) {
            return false; // Source is null, cannot contain non-empty target
        }
        return source.trim().toLowerCase().contains(target.trim().toLowerCase());
    }

    /**
     * Helper method: Matches In/Out criteria. Handles cases like "收入" vs "收", "支出" vs "支".
     * An empty/null target criteria matches everything.
     */
    private boolean matchesInOutCriteria(String source, String target) {
        if (target == null || target.trim().isEmpty()) {
            return true; // Empty criteria matches everything
        }
        if (source == null) {
            return false; // Source is null
        }
        String sourceTrimmed = source.trim();
        String targetTrimmed = target.trim();

        if (targetTrimmed.equalsIgnoreCase("收入") || targetTrimmed.equalsIgnoreCase("收")) {
            return sourceTrimmed.equalsIgnoreCase("收入") || sourceTrimmed.equalsIgnoreCase("收");
        }
        if (targetTrimmed.equalsIgnoreCase("支出") || targetTrimmed.equalsIgnoreCase("支")) {
            return sourceTrimmed.equalsIgnoreCase("支出") || sourceTrimmed.equalsIgnoreCase("支");
        }
        // If target is something else, do a simple contains check
        return sourceTrimmed.toLowerCase().contains(targetTrimmed.toLowerCase());
    }


    /**
     * Helper method: Safely parses a time string into LocalDateTime.
     * Returns null if parsing fails.
     * Should match the formats used in AITransactionService.parseDateTime.
     */
    private LocalDateTime parseDateTimeSafe(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // 中文空格等统一清理
        timeStr = timeStr.trim().replaceAll("\\s+", " ");

        // If only date is present, append 00:00
        if (timeStr.matches("\\d{4}/\\d{1,2}/\\d{1,2}")) {
            timeStr += " 00:00";
        } else if (timeStr.matches("\\d{4}-\\d{1,2}-\\d{1,2}")) {
            timeStr += " 00:00:00"; // Assuming yyyy-MM-dd uses seconds format
        }


        // Try parsing with multiple formats
        List<String> patterns = List.of(
                "yyyy/M/d H:mm", "yyyy/M/d HH:mm",
                "yyyy/MM/d H:mm", "yyyy/MM/d HH:mm",
                "yyyy/M/dd H:mm", "yyyy/M/dd HH:mm",
                "yyyy/MM/dd H:mm", "yyyy/MM/dd HH:mm",
                "yyyy/MM/dd HH:mm:ss", // Added seconds format
                "yyyy-MM-dd HH:mm:ss", // Added dash format
                "yyyy/MM/dd" // Added date only format (already handled by adding 00:00)
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDateTime.parse(timeStr, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern and try the next
            }
        }
        System.err.println("Failed to parse date string: " + timeStr);
        return null; // Return null if no pattern matches
    }

    /**
     * Aggregates transactions for the current user by month and standard category.
     *
     * @return A map where keys are month identifiers (e.g., "YYYY-MM") and values are MonthlySummary objects.
     * @throws Exception If an error occurs during data retrieval.
     */
    @Override // Implement the new interface method
    public Map<String, MonthlySummary> getMonthlyTransactionSummary() throws Exception {
        System.out.println("Generating monthly transaction summary for user file: " + currentUserTransactionFilePath);
        List<Transaction> allTransactions;
        try {
            // 1. Get all transactions for the current user (from cache/file)
            allTransactions = getAllTransactions(); // Uses CacheManager
            System.out.println("Retrieved " + allTransactions.size() + " transactions for summary.");

        } catch (Exception e) {
            System.err.println("Error retrieving transactions for summary generation.");
            e.printStackTrace();
            throw new Exception("获取交易数据失败！", e);
        }

        // 2. Aggregate transactions by month and category
        Map<String, MonthlySummary> monthlySummaries = new HashMap<>();
        DateTimeFormatter monthFormatter = DateTimeFormatter.ofPattern("yyyy-MM"); // Format for month identifier


        for (Transaction t : allTransactions) {
            if (t.getTransactionTime() == null || t.getTransactionTime().trim().isEmpty()) {
                System.err.println("Skipping transaction with no time for summary aggregation: " + t.getOrderNumber());
                continue; // Skip transactions with no time
            }

            // Safely parse the transaction date to get the month
            LocalDate date = parseDateFromTransactionTimeSafe(t.getTransactionTime()); // Use a robust date parser
            if (date == null) {
                System.err.println("Skipping transaction with unparseable date for summary aggregation: " + t.getTransactionTime() + " - " + t.getOrderNumber());
                continue; // Skip transactions with invalid date
            }

            // Get month identifier (e.g., "2025-03")
            String monthIdentifier = YearMonth.from(date).format(monthFormatter);

            // Get or create the MonthlySummary object for this month
            monthlySummaries.putIfAbsent(monthIdentifier, new MonthlySummary(monthIdentifier));
            MonthlySummary currentMonthSummary = monthlySummaries.get(monthIdentifier);

            // Add transaction amount to the summary based on type (Income/Expense)
            if (t.getInOut() != null) {
                String inOut = t.getInOut().trim();
                if (inOut.equals("收入") || inOut.equals("收")) {
                    currentMonthSummary.addIncome(t.getPaymentAmount());
                } else if (inOut.equals("支出") || inOut.equals("支")) {
                    // Get the standard category for the expense
                    String rawType = t.getTransactionType();
                    // Use the helper to map to a standard category, defaulting to "其他支出" if no direct standard match
                    String standardCategory = StandardCategories.getStandardCategory(rawType);
                    // For aggregation, we might want to map any non-standard expense type to "其他支出"
                    String effectiveExpenseCategoryForSummary = StandardCategories.isStandardExpenseCategory(standardCategory) ? standardCategory : "其他支出";

                    currentMonthSummary.addExpense(t.getPaymentAmount(), effectiveExpenseCategoryForSummary);
                }
                // Ignore special types (like Transfer, Red Packet) for simple income/expense summary, or handle them separately if needed
            }
        }
        System.out.println("Generated summary for " + monthlySummaries.size() + " months.");

        return monthlySummaries; // Return the map of monthly summaries
    }

    // Helper method to parse date from transaction time string safely
    // This should be consistent across all services/DAOs that parse dates.
    // Let's use a consistent, robust parser.
    // This method is similar to parseDateTimeSafe in this class and parseDateFromTransactionTime in SummaryStatisticService.
    // Consider extracting this to a shared Util class if many places need it.
    // For now, keep a consistent copy.
    private LocalDate parseDateFromTransactionTimeSafe(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // Clean whitespace and replace potential hyphens with slashes if the expected format is slash-separated
        String datePart = timeStr.split(" ")[0]; // Get the date part

        datePart = datePart.trim().replace('-', '/').replaceAll("\\s+", "");


        // Try parsing with multiple slash formats
        List<String> patterns = List.of(
                "yyyy/M/d", "yyyy/MM/d", "yyyy/M/dd", "yyyy/MM/dd",
                "yyyy-MM-dd" // Add dash format just in case
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDate.parse(datePart, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern
            }
        }
        System.err.println("TransactionServiceImpl: Failed to parse date part '" + datePart + "' from transaction time: " + timeStr);
        return null; // Return null if no pattern matches
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\TransactionService.java`:

```java
package Service;

import model.MonthlySummary;
import model.Transaction;

import java.io.IOException;
import java.util.List;
import java.util.Map;

public interface TransactionService {

    /**
     * Gets all transactions for the current user.
     * @return List of all transactions.
     * @throws Exception If data retrieval fails (e.g., IO error, cache issue).
     */
    List<Transaction> getAllTransactions() throws Exception; // Added this method


    /**
     * 新增交易
     * @param transaction
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * 修改交易
     * @param transaction
     * @throws Exception If modification fails.
     */
    void changeTransaction(Transaction transaction) throws Exception;

    /**
     * 根据订单号删除交易
     * @param orderNumber
     * @return true if deletion was successful, false if transaction not found.
     * @throws Exception If deletion fails (e.g., IO error).
     */
    boolean deleteTransaction(String orderNumber) throws Exception; // Changed return type to boolean

    /**
     * 根据用户输入信息查询交易
     * @param transaction Search criteria.
     * @return List of matched transactions.
     */
    List<Transaction> searchTransaction(Transaction transaction);

    /**
     * Imports transactions from a given CSV file path into the current user's transactions.
     *
     * @param userFilePath The file path for the current user's transactions (target).
     * @param importFilePath The file path of the CSV to import from (source).
     * @return The number of transactions successfully imported.
     * @throws Exception If an error occurs during reading, parsing, or saving.
     */
    int importTransactionsFromCsv(String userFilePath, String importFilePath) throws Exception; // Added this method


    /**
     * Aggregates transactions for the current user by month and standard category.
     *
     * @return A map where keys are month identifiers (e.g., "YYYY-MM") and values are MonthlySummary objects.
     * @throws Exception If an error occurs during data retrieval.
     */
    Map<String, MonthlySummary> getMonthlyTransactionSummary() throws Exception; // Added this method
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\User\UserService.java`:

```java
package Service.User; // Changed package

import DAO.UserDao;
import model.User;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class UserService {
    private final UserDao userDao;
    private final Map<String, User> userCache = new HashMap<>(); // Cache users in memory

    public UserService(UserDao userDao) {
        this.userDao = userDao;
        loadUsers(); // Load users when the service is initialized
    }

    private void loadUsers() {
        try {
            List<User> users = userDao.getAllUsers();
            userCache.clear(); // Clear previous cache
            for (User user : users) {
                userCache.put(user.getUsername(), user);
            }
            System.out.println("Loaded " + userCache.size() + " users into cache.");
        } catch (IOException e) {
            System.err.println("Failed to load users from data source.");
            e.printStackTrace();
            // Depending on requirements, you might want to exit or handle this more gracefully
            // For now, we'll allow the app to run with an empty user list, though login will fail.
        }
    }

    /**
     * Authenticates a user.
     *
     * @param username The username.
     * @param password The password.
     * @return The authenticated User object if successful, null otherwise.
     */
    public User authenticate(String username, String password) {
        if (username == null || username.trim().isEmpty() || password == null || password.trim().isEmpty()) {
            return null;
        }

        User user = userCache.get(username.trim());
        if (user != null && user.getPassword().equals(password.trim())) { // Simple password check
            System.out.println("Authentication successful for user: " + username);
            return user; // Authentication successful, return the User object
        }
        System.out.println("Authentication failed for username: " + username);
        return null; // Authentication failed
    }

    /**
     * Retrieves a user by username from the cache.
     * @param username The username.
     * @return The User object or null if not found.
     */
    public User getUserByUsername(String username) {
        if (username == null || username.trim().isEmpty()) {
            return null;
        }
        return userCache.get(username.trim());
    }


    // Add other user management methods if needed (e.g., registerUser, deleteUser)
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\deepseek\ChatCompletionsExample.java`:

```java
package Service.deepseek;

import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;
import okhttp3.ConnectionPool;
import okhttp3.Dispatcher;
import org.apache.commons.lang.StringUtils;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
public class ChatCompletionsExample {
    static String apiKey = System.getenv("ARK_API_KEY");
    static ConnectionPool connectionPool = new ConnectionPool(5, 1, TimeUnit.SECONDS);
    static Dispatcher dispatcher = new Dispatcher();
    // The output time of the reasoning model is relatively long. Please increase the timeout period.//
    static ArkService service = ArkService.builder().timeout(Duration.ofSeconds(1800)).connectTimeout(Duration.ofSeconds(20)).dispatcher(dispatcher).connectionPool(connectionPool).baseUrl("https://ark.cn-beijing.volces.com/api/v3").apiKey(apiKey).build();

//    public static void main(String[] args) {
//        System.out.println(" [Recommended]----- streaming request -----");
//        final List<ChatMessage> streamMessages = new ArrayList<>();
//        final ChatMessage streamUserMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("请回答15.11和15.9哪个大？").build();
//        streamMessages.add(streamUserMessage);
//        ChatCompletionRequest streamChatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(streamMessages)
//                .build();
//        service.streamChatCompletion(streamChatCompletionRequest)
//                .doOnError(Throwable::printStackTrace)
//                .blockingForEach(
//                        delta -> {
//                            if (!delta.getChoices().isEmpty()) {
//                                if (StringUtils.isNotEmpty(delta.getChoices().get(0).getMessage().getReasoningContent())) {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getReasoningContent());
//                                } else {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getContent());
//                                }
//                            }
//                        }
//                );
//        System.out.println(" ----- standard request -----");
//        final List<ChatMessage> messages = new ArrayList<>();
//        final ChatMessage userMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("常见的十字花科植物有哪些？").build();
//        messages.add(userMessage);
//        ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(messages)
//                .build();
//        service.createChatCompletion(chatCompletionRequest).getChoices().forEach(
//                choice -> {
//                    System.out.println(choice.getMessage().getReasoningContent());
//                    System.out.println(choice.getMessage().getContent());
//                }
//        );
//        // shutdown service after all requests is finished
//        service.shutdownExecutor();
//    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Utils\CacheManager.java`:

```java
package Utils;

import Constants.CaffeineKeys;
import DAO.Impl.CsvTransactionDao; // Assuming CsvTransactionDao is in DAO.Impl
import DAO.TransactionDao; // Assuming TransactionDao interface is in DAO
import model.Transaction;
import com.github.benmanes.caffeine.cache.Cache; // Use general Cache interface
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.LoadingCache;

import java.io.IOException;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

/**
 * Manages Caffeine caches for different transaction data files (per user).
 * Uses the file path as the cache key.
 */
public class CacheManager {

    // Use a map to hold caches, keyed by file path
    // The value is the Caffeine LoadingCache for that specific file path
    private static final ConcurrentHashMap<String, LoadingCache<String, List<Transaction>>> fileCaches = new ConcurrentHashMap<>();

    // Define default cache parameters
    private static final int DEFAULT_MAX_SIZE = 1; // Only cache one instance (the list of transactions) per file
    private static final long DEFAULT_EXPIRE_AFTER_WRITE_MINUTES = 10; // Cache entry expires after 10 minutes
    private static final long DEFAULT_REFRESH_AFTER_WRITE_MINUTES = 1; // Refresh entry after 1 minute

    // Private constructor to prevent instantiation
    private CacheManager() {}

    /**
     * Gets or creates a LoadingCache for the specified transaction file path.
     * The cache loads List<Transaction> from the file using TransactionDao.
     *
     * @param filePath The path to the user's transaction CSV file.
     * @param transactionDao The TransactionDao instance to use for loading.
     * @return The LoadingCache instance for the given file path.
     */
    public static LoadingCache<String, List<Transaction>> getTransactionCache(String filePath, TransactionDao transactionDao) {
        // Use computeIfAbsent to get or create the cache atomically
        return fileCaches.computeIfAbsent(filePath, key -> {
            System.out.println("CacheManager: Creating new cache for file: " + filePath);
            // Create a new LoadingCache for this specific file path
            return Caffeine.newBuilder()
                    .maximumSize(DEFAULT_MAX_SIZE)
                    .expireAfterWrite(DEFAULT_EXPIRE_AFTER_WRITE_MINUTES, TimeUnit.MINUTES)
                    .refreshAfterWrite(DEFAULT_REFRESH_AFTER_WRITE_MINUTES, TimeUnit.MINUTES)
                    // Define the loader function: how to load data when cache is missed or refreshed
                    .build(cacheKey -> {
                        System.out.println("CacheManager: Loading transactions from file: " + filePath + " (Cache Miss/Refresh)");
                        try {
                            // The cacheKey here will likely be a constant like "transactions"
                            // We use the outer filePath variable to load from the correct file
                            return transactionDao.loadFromCSV(filePath);
                        } catch (IOException e) {
                            System.err.println("CacheManager: Error loading data for file " + filePath);
                            e.printStackTrace();
                            throw new RuntimeException("Error loading transactions from " + filePath, e); // Wrap IOException in RuntimeException for Caffeine loader
                        }
                    });
        });
    }

    /**
     * Invalidates the cache for a specific transaction file path.
     * @param filePath The path to the user's transaction CSV file.
     */
    public static void invalidateTransactionCache(String filePath) {
        LoadingCache<String, List<Transaction>> cache = fileCaches.get(filePath);
        if (cache != null) {
            System.out.println("CacheManager: Invalidating cache for file: " + filePath);
            // The cache key for List<Transaction> is likely a constant like "transactions"
            cache.invalidate(CaffeineKeys.TRANSACTION_CAFFEINE_KEY); // Invalidate the entry storing the transaction list
        }
        // Optionally, remove the cache itself if the file is no longer needed
        // fileCaches.remove(filePath); // Might do this on user logout, etc.
    }

    /**
     * Gets the transaction list from the cache for the specified file path.
     * Loads data if not present or expired. Handles exceptions thrown by the loader.
     *
     * @param filePath The path to the user's transaction CSV file.
     * @param transactionDao The TransactionDao instance to use for loading if cache misses.
     * @return The list of transactions.
     * @throws Exception If an error occurs during loading (e.g., IOException).
     */
    public static List<Transaction> getTransactions(String filePath, TransactionDao transactionDao) throws Exception {
        LoadingCache<String, List<Transaction>> cache = getTransactionCache(filePath, transactionDao);
        // The cache key for the list of transactions from a specific file is a constant.
        // This constant key maps to the *entire list* of transactions for that file.
        return cache.get(CaffeineKeys.TRANSACTION_CAFFEINE_KEY);
    }

    /**
     * Manually puts a list of transactions into the cache for a specific file path.
     * This is useful after a write operation (add, delete, update) to refresh the cache.
     *
     * @param filePath The path to the user's transaction CSV file.
     * @param transactions The updated list of transactions.
     * @param transactionDao The TransactionDao instance (needed to get/create cache if not exists).
     */
    public static void putTransactions(String filePath, List<Transaction> transactions, TransactionDao transactionDao) {
        LoadingCache<String, List<Transaction>> cache = getTransactionCache(filePath, transactionDao);
        cache.put(CaffeineKeys.TRANSACTION_CAFFEINE_KEY, transactions);
        System.out.println("CacheManager: Manually updated cache for file: " + filePath);
    }

    /**
     * Shutdown any resources if necessary (though Caffeine typically manages its threads).
     */
    public static void shutdown() {
        // Caffeine cache doesn't require explicit shutdown in most cases
        // If using custom executors, they might need shutdown.
        System.out.println("CacheManager: Shutdown completed.");
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Utils\CacheUtil.java`:

```java
package Utils;

import com.github.benmanes.caffeine.cache.*;

import java.util.concurrent.TimeUnit;
import java.util.function.Function;

import com.github.benmanes.caffeine.cache.Caffeine;

/**
 * 通用缓存工具类（支持泛型和异常传播）
 * @param <K> 键类型
 * @param <V> 值类型
 * @param <E> 异常类型（如 IOException）
 */
public class CacheUtil<K, V, E extends Exception> {
    private final LoadingCache<K, V> cache;

    public CacheUtil(Function<K, V> loader,
                     int maxSize,
                     long expireAfterWrite,
                     long refreshAfterWrite) {

        this.cache = Caffeine.newBuilder()
                .maximumSize(maxSize)
                .expireAfterWrite(expireAfterWrite, TimeUnit.MINUTES)
                .refreshAfterWrite(refreshAfterWrite, TimeUnit.MINUTES)
                .build(loader::apply); // 关键修改：使用build(loader)创建LoadingCache
    }

    /**
     * 获取缓存值
     */
    public V get(K key) {
        return cache.get(key);
    }

    /**
     * 手动更新缓存
     */
    public void put(K key, V value) {
        cache.put(key, value);
    }

    /**
     * 手动移除缓存
     */
    public void invalidate(K key) {
        cache.invalidate(key);
    }
}



```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\model\MonthlySummary.java`:

```java
package model;

import java.util.HashMap;
import java.util.Map;

// Represents a summary of transactions for a specific month
public class MonthlySummary {
    private String monthIdentifier; // e.g., "2025-03"
    private double totalIncome;
    private double totalExpense;
    // Map from standard expense category to total amount spent in that category
    private Map<String, Double> expenseByCategory;

    public MonthlySummary(String monthIdentifier) {
        this.monthIdentifier = monthIdentifier;
        this.totalIncome = 0.0;
        this.totalExpense = 0.0;
        this.expenseByCategory = new HashMap<>();
    }

    // Getters
    public String getMonthIdentifier() {
        return monthIdentifier;
    }

    public double getTotalIncome() {
        return totalIncome;
    }

    public double getTotalExpense() {
        return totalExpense;
    }

    public Map<String, Double> getExpenseByCategory() {
        return expenseByCategory;
    }

    // Methods to add transaction amounts
    public void addIncome(double amount) {
        this.totalIncome += amount;
    }

    public void addExpense(double amount, String standardCategory) {
        this.totalExpense += amount;
        // Aggregate by standard category
        expenseByCategory.put(standardCategory, expenseByCategory.getOrDefault(standardCategory, 0.0) + amount);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Month: ").append(monthIdentifier).append("\n");
        sb.append("  Total Income: ").append(String.format("%.2f", totalIncome)).append("元\n");
        sb.append("  Total Expense: ").append(String.format("%.2f", totalExpense)).append("元\n");
        sb.append("  Expenses by Category:\n");
        if (expenseByCategory.isEmpty()) {
            sb.append("    (None)\n");
        } else {
            // Sort categories alphabetically for consistent output
            expenseByCategory.entrySet().stream()
                    .sorted(Map.Entry.comparingByKey())
                    .forEach(entry ->
                            sb.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                    );
        }
        return sb.toString();
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\model\SummaryStatistic.java`:

```java
package model;

// Represents a summary statistic for a specific week across all users
public class SummaryStatistic {
    private String weekIdentifier; // e.g., "2025-W14"
    private double totalIncomeAllUsers;
    private double totalExpenseAllUsers;
    private String topExpenseCategory; // e.g., "餐饮"
    private double topExpenseCategoryAmount; // Amount spent in the top category
    private int numberOfUsersWithTransactions; // Number of users who had any transaction this week
    private String timestampGenerated; // When this statistic record was created

    // Constructors
    public SummaryStatistic() {
    }

    public SummaryStatistic(String weekIdentifier, double totalIncomeAllUsers, double totalExpenseAllUsers, String topExpenseCategory, double topExpenseCategoryAmount, int numberOfUsersWithTransactions, String timestampGenerated) {
        this.weekIdentifier = weekIdentifier;
        this.totalIncomeAllUsers = totalIncomeAllUsers;
        this.totalExpenseAllUsers = totalExpenseAllUsers;
        this.topExpenseCategory = topExpenseCategory;
        this.topExpenseCategoryAmount = topExpenseCategoryAmount;
        this.numberOfUsersWithTransactions = numberOfUsersWithTransactions;
        this.timestampGenerated = timestampGenerated;
    }

    // Getters
    public String getWeekIdentifier() {
        return weekIdentifier;
    }

    public double getTotalIncomeAllUsers() {
        return totalIncomeAllUsers;
    }

    public double getTotalExpenseAllUsers() {
        return totalExpenseAllUsers;
    }

    public String getTopExpenseCategory() {
        return topExpenseCategory;
    }

    public double getTopExpenseCategoryAmount() {
        return topExpenseCategoryAmount;
    }

    public int getNumberOfUsersWithTransactions() {
        return numberOfUsersWithTransactions;
    }

    public String getTimestampGenerated() {
        return timestampGenerated;
    }

    // Setters (if needed for creation/population)
    public void setWeekIdentifier(String weekIdentifier) {
        this.weekIdentifier = weekIdentifier;
    }

    public void setTotalIncomeAllUsers(double totalIncomeAllUsers) {
        this.totalIncomeAllUsers = totalIncomeAllUsers;
    }

    public void setTotalExpenseAllUsers(double totalExpenseAllUsers) {
        this.totalExpenseAllUsers = totalExpenseAllUsers;
    }

    public void setTopExpenseCategory(String topExpenseCategory) {
        this.topExpenseCategory = topExpenseCategory;
    }

    public void setTopExpenseCategoryAmount(double topExpenseCategoryAmount) {
        this.topExpenseCategoryAmount = topExpenseCategoryAmount;
    }

    public void setNumberOfUsersWithTransactions(int numberOfUsersWithTransactions) {
        this.numberOfUsersWithTransactions = numberOfUsersWithTransactions;
    }

    public void setTimestampGenerated(String timestampGenerated) {
        this.timestampGenerated = timestampGenerated;
    }

    @Override
    public String toString() {
        return "SummaryStatistic{" +
                "weekIdentifier='" + weekIdentifier + '\'' +
                ", totalIncomeAllUsers=" + totalIncomeAllUsers +
                ", totalExpenseAllUsers=" + totalExpenseAllUsers +
                ", topExpenseCategory='" + topExpenseCategory + '\'' +
                ", topExpenseCategoryAmount=" + topExpenseCategoryAmount +
                ", numberOfUsersWithTransactions=" + numberOfUsersWithTransactions +
                ", timestampGenerated='" + timestampGenerated + '\'' +
                '}';
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\model\Transaction.java`:

```java
package model;
//Transaction time, transaction type, transaction counterparty,
// commodity receipt/payment amount (yuan), payment method, current status,
// transaction order number, merchant order number, remarks
public class Transaction {
    private String transactionTime;
    private String transactionType;
    private String counterparty;
    private String commodity;
    private String inOut;
    private double paymentAmount;
    private String paymentMethod;
    private String currentStatus;
    private String orderNumber;
    private String merchantNumber;
    private String remarks;

    public Transaction() {
    }

    public Transaction(String transactionTime, String transactionType, String counterparty, String commodity, String inOut, double paymentAmount, String paymentMethod, String currentStatus, String orderNumber, String merchantNumber, String remarks) {
        this.transactionTime = transactionTime;
        this.transactionType = transactionType;
        this.counterparty = counterparty;
        this.commodity = commodity;
        this.inOut = inOut;
        this.paymentAmount = paymentAmount;
        this.paymentMethod = paymentMethod;
        this.currentStatus = currentStatus;
        this.orderNumber = orderNumber;
        this.merchantNumber = merchantNumber;
        this.remarks = remarks;
    }

    public String getInOut() {
        return inOut;
    }

    public void setInOut(String inOut) {
        this.inOut = inOut;
    }

    public void setTransactionTime(String transactionTime) {
        this.transactionTime = transactionTime;
    }

    public void setTransactionType(String transactionType) {
        this.transactionType = transactionType;
    }

    public void setCounterparty(String counterparty) {
        this.counterparty = counterparty;
    }

    public void setCommodity(String commodity) {
        this.commodity = commodity;
    }

    public void setPaymentAmount(double paymentAmount) {
        this.paymentAmount = paymentAmount;
    }

    public void setPaymentMethod(String paymentMethod) {
        this.paymentMethod = paymentMethod;
    }

    public void setCurrentStatus(String currentStatus) {
        this.currentStatus = currentStatus;
    }

    public void setOrderNumber(String orderNumbe) {
        this.orderNumber = orderNumbe;
    }

    public void setMerchantNumber(String merchantNumber) {
        this.merchantNumber = merchantNumber;
    }

    public void setRemarks(String remarks) {
        this.remarks = remarks;
    }

    public String getTransactionTime() {
        return transactionTime;
    }

    public String getTransactionType() {
        return transactionType;
    }

    public String getCounterparty() {
        return counterparty;
    }

    public String getCommodity() {
        return commodity;
    }

    public double getPaymentAmount() {
        return paymentAmount;
    }

    public String getPaymentMethod() {
        return paymentMethod;
    }

    public String getCurrentStatus() {
        return currentStatus;
    }

    public String getOrderNumber() {
        return orderNumber;
    }

    public String getMerchantNumber() {
        return merchantNumber;
    }

    public String getRemarks() {
        return remarks;
    }
}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\model\User.java`:

```java
package model;

// 用户模型类
public class User {
    private String username;
    private String password;
    private String role; // e.g., "user", "admin"
    private String transactionFilePath; // Path to the user's transaction CSV file

    // Constructors
    public User() {
    }

    public User(String username, String password, String role, String transactionFilePath) {
        this.username = username;
        this.password = password;
        this.role = role;
        this.transactionFilePath = transactionFilePath;
    }

    // Getters and Setters
    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }

    public String getTransactionFilePath() {
        return transactionFilePath;
    }

    public void setTransactionFilePath(String transactionFilePath) {
        this.transactionFilePath = transactionFilePath;
    }

    @Override
    public String toString() {
        return "User{" +
                "username='" + username + '\'' +
                ", role='" + role + '\'' +
                ", transactionFilePath='" + transactionFilePath + '\'' +
                '}';
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\resources\CSVForm\stats\summary_statistics.csv`:

```csv
week_identifier,total_income_all_users,total_expense_all_users,top_expense_category,top_expense_category_amount,number_of_users_with_transactions,timestamp_generated
2022-W37,0.0,5000.0,其他支出,5000.0,1,2025-05-22 23:34:23
2025-W09,10000.0,20000.0,无支出,0.0,3,2025-05-22 23:34:23
2025-W10,0.0,751.5,其他支出,751.5,3,2025-05-22 23:34:23
2025-W11,0.0,257.25,餐饮,107.25,3,2025-05-22 23:34:23
2025-W12,0.0,15000.0,其他支出,10000.0,3,2025-05-22 23:34:23

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\resources\CSVForm\transactions\admin_transactions.csv`:

```csv
交易时间,交易类型,交易对方,商品,收/支,金额(元),支付方式,当前状态,交易单号,商户单号,备注
2025/03/01 09:00:00,工资,公司A,三月工资,收入,¥10000.00,银行卡,已入账,SALARY_MAR_A,PAYROLL_A_001,本月基本工资
2025/03/05 14:30:00,购物,超市B,食品杂货,支出,¥250.50,支付宝,已完成,SHOP_B_001,ALIPAY_12345,周末采购
2025/03/15 11:00:00,餐饮,餐厅C,午餐外卖,支出,¥35.75,美团支付,已完成,MEAL_C_001,MEITUAN_11223,工作日午餐
2025/03/20 16:00:00,金融服务,股票账户,购入股票,支出,¥5000.00,美团支付,已完成,INVEST_STOCK_001,BANK_99887,长期投资
2022/09/10 16:00:00,投资,股票账户,购入股票,支出,¥5000.00,同花顺,未完成,INVEST_STOCK_002,BANK_99887,短线投资
2025/03/10 10:00:00,转账,用户1,报销午餐,支出,¥50.00,微信支付,已完成,TRANSFER_U1_001,WECHAT_56789,归还午餐费

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\resources\CSVForm\transactions\user1_transactions.csv`:

```csv
交易时间,交易类型,交易对方,商品,收/支,金额(元),支付方式,当前状态,交易单号,商户单号,备注
2025/03/01 09:00:00,工资,公司A,三月工资,支出,¥10000.00,银行卡,已入账,SALARY_MAR_A,PAYROLL_A_001,本月基本工资
2025/03/05 14:30:00,购物,超市B,食品杂货,支出,¥250.50,支付宝,已完成,SHOP_B_001,ALIPAY_12345,周末采购
2025/03/10 10:00:00,转账,用户1,报销午餐,支出,¥50.00,微信支付,已完成,TRANSFER_U1_001,WECHAT_56789,归还午餐费
2025/03/15 11:00:00,餐饮,餐厅C,午餐外卖,支出,¥35.75,美团支付,已完成,MEAL_C_001,MEITUAN_11223,工作日午餐
2025/03/20 16:00:00,投资,股票账户,购入股票,支出,¥5000.00,银行转账,已完成,INVEST_STOCK_001,BANK_99887,长期投资

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\resources\CSVForm\transactions\user2_transactions.csv`:

```csv
交易时间,交易类型,交易对方,商品,收/支,金额(元),支付方式,当前状态,交易单号,商户单号,备注
2025/03/01 09:00:00,工资,公司A,三月工资,支出,¥10000.00,银行卡,已入账,SALARY_MAR_A,PAYROLL_A_001,本月基本工资
2025/03/05 14:30:00,购物,超市B,食品杂货,支出,¥250.50,支付宝,已完成,SHOP_B_001,ALIPAY_12345,周末采购
2025/03/10 10:00:00,转账,用户1,报销午餐,支出,¥50.00,微信支付,已完成,TRANSFER_U1_001,WECHAT_56789,归还午餐费
2025/03/15 11:00:00,餐饮,餐厅C,午餐外卖,支出,¥35.75,美团支付,已完成,MEAL_C_001,MEITUAN_11223,工作日午餐
2025/03/20 16:00:00,投资,股票账户,购入股票,支出,¥5000.00,银行转账,已完成,INVEST_STOCK_001,BANK_99887,长期投资
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\resources\CSVForm\users\users.csv`:

```csv
username,password,role,transaction_csv_path
admin,admin123,admin,Ai Bill Application/src/main/resources/CSVForm/transactions/admin_transactions.csv
user1,pass123,user,Ai Bill Application/src/main/resources/CSVForm/transactions/user1_transactions.csv
user2,securepwd,user,Ai Bill Application/src/main/resources/CSVForm/transactions/user2_transactions.csv

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\resources\config.properties`:

```properties
# config.properties
#csv.path=Ai Bill Application/src/main/resources/CSVForm/0001.csv
csv.path=Ai Bill Application/src/main/resources/CSVForm/transactions/admin_transactions.csv
csv.users_path=Ai Bill Application/src/main/resources/CSVForm/users/users.csv
csv.summary_path=Ai Bill Application/src/main/resources/CSVForm/stats/summary_statistics.csv
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\ControllerTest\AITest.java`:

```java
package ControllerTest;

import Controller.HistogramPanelContainer;
import org.junit.Test;

import javax.swing.*;
import java.awt.*;

public class AITest {

    @Test
    public void testHistogramPanel() throws Exception {
        EventQueue.invokeAndWait(() -> {
            JFrame frame = new JFrame("数据分析界面 - 测试");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });




        // 保持窗口显示一段时间，防止测试结束时窗口立即关闭
        Thread.sleep(5000);
    }

}




```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\ControllerTest\MenuUITest.java`:

```java
package ControllerTest;

import model.User;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.io.IOException;
import Controller.MenuUI;

import Service.Impl.TransactionServiceImpl;

import DAO.Impl.CsvTransactionDao;

public class MenuUITest {

    private MenuUI menuUI;

    @BeforeEach
    public void setUp() {
//        menuUI = new MenuUI(new User());

        // 手动初始化 TransactionServiceImpl 的 csvTransactionDao
//        TransactionServiceImpl.csvTransactionDao = new CsvTransactionDao();
    }

    @Test
    public void testSearchFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取输入字段和搜索按钮
        JTextField transactionTimeField = findTextField(inputPanel, 0);
        JTextField transactionTypeField = findTextField(inputPanel, 1);
        JTextField counterpartyField = findTextField(inputPanel, 2);
        JTextField commodityField = findTextField(inputPanel, 3);
        JComboBox<String> inOutComboBox = findComboBox(inputPanel);
        JTextField paymentMethodField = findTextField(inputPanel, 4);
        JButton searchButton = findButton(inputPanel,"Search");

        assertNotNull(transactionTimeField, "交易时间输入字段不应为空");
        assertNotNull(transactionTypeField, "交易类型输入字段不应为空");
        assertNotNull(counterpartyField, "交易对方输入字段不应为空");
        assertNotNull(commodityField, "商品输入字段不应为空");
        assertNotNull(inOutComboBox, "收/支下拉框不应为空");
        assertNotNull(paymentMethodField, "支付方式输入字段不应为空");
        assertNotNull(searchButton, "搜索按钮不应为空");

        // 设置搜索条件
        transactionTimeField.setText("2025/3/14 11:48"); // 交易时间
        transactionTypeField.setText("商户消费");       // 交易类型
        counterpartyField.setText("物美WUMART");         // 交易对方
        commodityField.setText("扫码支付");            // 商品
        inOutComboBox.setSelectedItem("支出");     // 收/支
        paymentMethodField.setText("零钱");    // 支付方式

        // 模拟点击搜索按钮
        searchButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证搜索结果是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);

            // 验证每一行数据是否符合搜索条件
            assertTrue(rowTransactionTime.contains("2025/3/14 11:48"), "交易时间应符合搜索条件");
            assertTrue(rowTransactionType.contains("商户消费"), "交易类型应符合搜索条件");
            assertTrue(rowCounterparty.contains("物美WUMART"), "交易对方应符合搜索条件");
            assertTrue(rowCommodity.contains("扫码支付"), "商品应符合搜索条件");
            assertTrue(rowInOut.contains("支出"), "收/支应符合搜索条件");
            assertTrue(rowPaymentMethod.contains("零钱"), "支付方式应符合搜索条件");
        }
    }

    @Test
    public void testDeleteFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 获取初始行数
        int initialRowCount = tableModel.getRowCount();

        // 模拟删除第一行
        menuUI.deleteRow(0);

        // 验证行数是否减少
        assertEquals(initialRowCount - 1, tableModel.getRowCount(), "删除后行数应减少");

        // 验证删除后的数据是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            assertNotEquals("2025/3/14 11:48", rowTransactionTime, "删除的行不应再出现在表格中");
        }
    }

    @Test
    public void testEditFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 模拟编辑第一行
        menuUI.editRow(0);

        // 验证编辑后的数据是否正确
        String editedTransactionTime = (String) tableModel.getValueAt(0, 0);
        String editedTransactionType = (String) tableModel.getValueAt(0, 1);
        String editedCounterparty = (String) tableModel.getValueAt(0, 2);
        String editedCommodity = (String) tableModel.getValueAt(0, 3);
        String editedInOut = (String) tableModel.getValueAt(0, 4);
        String editedPaymentMethod = (String) tableModel.getValueAt(0, 6);

        // 验证编辑后的数据是否符合预期
        assertNotNull(editedTransactionTime, "编辑后的交易时间不应为空");
        assertNotNull(editedTransactionType, "编辑后的交易类型不应为空");
        assertNotNull(editedCounterparty, "编辑后的交易对方不应为空");
        assertNotNull(editedCommodity, "编辑后的商品不应为空");
        assertNotNull(editedInOut, "编辑后的收/支不应为空");
        assertNotNull(editedPaymentMethod, "编辑后的支付方式不应为空");
    }

    @Test
    public void testAddFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取 Add 按钮
        JButton addButton = findButton(inputPanel, "Add");
        assertNotNull(addButton, "Add 按钮不应为空");

        // 模拟点击 Add 按钮
        addButton.doClick();

        // 获取对话框
        Window[] windows = Window.getWindows();
        JDialog addDialog = null;
        for (Window window : windows) {
            if (window instanceof JDialog && "添加交易".equals(((JDialog) window).getTitle())) {
                addDialog = (JDialog) window;
                break;
            }
        }
        assertNotNull(addDialog, "添加交易的对话框应弹出");

        // 获取对话框中的输入字段
        JTextField transactionTimeField = findTextField(addDialog.getContentPane(), 0);
        JTextField transactionTypeField = findTextField(addDialog.getContentPane(), 1);
        JTextField counterpartyField = findTextField(addDialog.getContentPane(), 2);
        JTextField commodityField = findTextField(addDialog.getContentPane(), 3);
        JComboBox<String> inOutComboBox = findComboBox(addDialog.getContentPane());
        JTextField paymentAmountField = findTextField(addDialog.getContentPane(), 4);
        JTextField paymentMethodField = findTextField(addDialog.getContentPane(), 5);
        JTextField currentStatusField = findTextField(addDialog.getContentPane(), 6);
        JTextField orderNumberField = findTextField(addDialog.getContentPane(), 7);
        JTextField merchantNumberField = findTextField(addDialog.getContentPane(), 8);
        JTextField remarksField = findTextField(addDialog.getContentPane(), 9);

        // 设置新交易的输入值
        transactionTimeField.setText("2025/3/15 12:00"); // 交易时间
        transactionTypeField.setText("转账");            // 交易类型
        counterpartyField.setText("张三");               // 交易对方
        commodityField.setText("转账");                 // 商品
        inOutComboBox.setSelectedItem("支出");          // 收/支
        paymentAmountField.setText("100.0");            // 金额(元)
        paymentMethodField.setText("银行卡");           // 支付方式
        currentStatusField.setText("已完成");           // 当前状态
        orderNumberField.setText("123456789");          // 交易单号
        merchantNumberField.setText("987654321");       // 商户单号
        remarksField.setText("测试备注");               // 备注

        // 获取确认按钮
        JButton confirmButton = findButton(addDialog.getContentPane(), "确认");
        assertNotNull(confirmButton, "确认按钮不应为空");

        // 模拟点击确认按钮
        confirmButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证新交易是否添加到表格中
        boolean isTransactionAdded = false;
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentAmount = (String) tableModel.getValueAt(i, 5);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);
            String rowCurrentStatus = (String) tableModel.getValueAt(i, 7);
            String rowOrderNumber = (String) tableModel.getValueAt(i, 8);
            String rowMerchantNumber = (String) tableModel.getValueAt(i, 9);
            String rowRemarks = (String) tableModel.getValueAt(i, 10);

            if (rowTransactionTime.equals("2025/3/15 12:00") &&
                    rowTransactionType.equals("转账") &&
                    rowCounterparty.equals("张三") &&
                    rowCommodity.equals("转账") &&
                    rowInOut.equals("支出") &&
                    rowPaymentAmount.equals("100.0") &&
                    rowPaymentMethod.equals("银行卡") &&
                    rowCurrentStatus.equals("已完成") &&
                    rowOrderNumber.equals("123456789") &&
                    rowMerchantNumber.equals("987654321") &&
                    rowRemarks.equals("测试备注")) {
                isTransactionAdded = true;
                break;
            }
        }

        // 验证新交易是否成功添加
        assertTrue(isTransactionAdded, "新交易应成功添加到表格中");
    }

    /**
     * 显示界面以便手动验证
     *
     * @param panel 要显示的面板
     */
    private void showUI(JPanel panel) {
        JFrame frame = new JFrame("MenuUI Test");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(1200, 600);
        frame.add(panel);
        frame.setVisible(true);

        // 保持界面显示一段时间（5秒）
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        frame.dispose(); // 关闭界面
    }

    /**
     * 查找输入面板
     *
     * @param mainPanel 主面板
     * @return 输入面板
     */
    private JPanel findInputPanel(JPanel mainPanel) {
        // 获取右边的面板
        Component[] components = mainPanel.getComponents();
        JPanel rightPanel = null;
        for (Component component : components) {
            if (component instanceof JPanel && ((JPanel) component).getComponentCount() > 0) {
                rightPanel = (JPanel) component;
                break;
            }
        }

        if (rightPanel != null) {
            // 在右边面板中查找输入面板
            for (Component component : rightPanel.getComponents()) {
                if (component instanceof JPanel) {
                    JPanel panel = (JPanel) component;
                    System.out.println("Panel found: " + panel.getName()); // 打印面板名称
                    if (panel.getComponentCount() > 0 && panel.getComponent(0) instanceof JLabel) {
                        return panel; // 输入面板通常包含 JLabel
                    }
                }
            }
        }
        return null;
    }

    /**
     * 查找输入字段
     *
     * @param container     输入面板
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0;
        for (Component component : container.getComponents()) {
            if (component instanceof JTextField) {
                if (count == index) {
                    return (JTextField) component;
                }
                count++;
            }
        }
        return null;
    }


    /**
     * 查找下拉框
     *
     * @param container 输入面板
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) {
            if (component instanceof JComboBox) {
                return (JComboBox<String>) component;
            }
        }
        return null;
    }

    /**
     * 查找按钮
     *
     * @param panel 输入面板
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container  容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    private JButton findButton(Container container, String buttonText) {
        for (Component component : container.getComponents()) {
            if (component instanceof JButton) {
                JButton button = (JButton) component;
                if (button.getText().equals(buttonText)) {
                    return button;
                }
            }
        }
        return null;
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\DAOTest\CsvTransactionDaoTest.java`:

```java
package DAOTest;

import DAO.Impl.CsvTransactionDao;
import model.Transaction;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static Constants.ConfigConstants.CSV_PATH;
import static org.junit.Assert.*;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;


class CsvTransactionDaoTest {
    private static final String TEST_ADMIN_CSV_PATH = "Ai Bill Application/src/test/resources/CSVForm/transactions/admin_transactions.csv"; //

    // 测试文件路径（根据实际结构调整）
    private static final String TEST_CSV_PATH = CSV_PATH;
    private static CsvTransactionDao dao;

    @Test
    void testLoadFromCSV_ValidFile_ReturnsTransactions() throws Exception {
        // Given
        CsvTransactionDao dao = new CsvTransactionDao();

        // When
        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);

        // 验证第一条记录的字段
        for (int i = 0; i < transactions.size(); i++) {
            System.out.println(transactions.get(i).getRemarks());
            System.out.println(transactions.get(i).getCommodity());
        }


    }
    @Test
    void testAddTransaction() throws IOException {
        dao=new CsvTransactionDao();
        Transaction newTx = new Transaction(
                "2025-03-09 10:00",
                "转账",
                "小明",
                "书籍",
                "支",
                99.99,
                "微信",
                "已完成",
                "TX123456",
                "M789012",
                "");

        dao.addTransaction("src/test/resources/001.csv", newTx);

        List<Transaction> transactions = dao.loadFromCSV(TEST_CSV_PATH);

    }

    @BeforeEach
        // This runs before each test method
    void setUp() {
        // Initialize DAO before each test
        dao = new CsvTransactionDao();
        // Ensure the test file exists - maybe create it programmatically here for reliable testing
        // or rely on it being present in src/test/resources and copied to classpath
    }

    @Test
    void testLoadAdminCSV() throws IOException {
        System.out.println("Attempting to load test CSV: " + TEST_ADMIN_CSV_PATH);
        Path csvPath = Paths.get(TEST_ADMIN_CSV_PATH);
        assertTrue("Test CSV file should exist at " + TEST_ADMIN_CSV_PATH, Files.exists(csvPath));
        assertTrue("Test CSV file should not be empty.", Files.size(csvPath) > 0);


        // When loading the specific admin CSV
        List<Transaction> transactions = dao.loadFromCSV(TEST_ADMIN_CSV_PATH);

        // Then assert that loading was successful and data is present
        assertNotNull(transactions.toString(), "Loaded transactions list should not be null");
        assertFalse("Loaded transactions list should not be empty", transactions.isEmpty());
        assertEquals(String.valueOf(5), transactions.size(), "Should load 5 transaction records"); // Assuming 5 rows plus header

        // Optional: Verify content of a specific row
        Transaction firstTx = transactions.get(0);
        assertEquals("公司A", firstTx.getCounterparty());
        assertEquals("三月工资", firstTx.getCommodity());
        assertEquals(10000.00, firstTx.getPaymentAmount(), 0.01); // Use delta for double comparison
    }

    // Add other tests like testAddTransaction, testDeleteTransaction, testChangeInformation etc.
    // Ensure these tests also use the correct file paths and verify file content changes.
    // For modification/deletion tests, you might need to create a temporary CSV file
    // or use a file specifically for testing that can be modified without affecting other tests.

    // Example of a helper method to create a test CSV file programmatically
    // This is more reliable than relying on manual copying/pasting for tests.
    private void createTestCsvFile(String filePath, List<Transaction> transactions) throws IOException {
        Path path = Paths.get(filePath);
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }
        // Delete old file if it exists
        if (Files.exists(path)) {
            Files.delete(path);
        }

        String[] headers = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"};
        try (BufferedWriter writer = Files.newBufferedWriter(path, StandardCharsets.UTF_8);
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(headers).withTrim())) {

            for (Transaction t : transactions) {
                csvPrinter.printRecord(
                        t.getTransactionTime(),
                        t.getTransactionType(),
                        t.getCounterparty(),
                        t.getCommodity(),
                        t.getInOut(),
                        String.format("¥%.2f", t.getPaymentAmount()),
                        t.getPaymentMethod(),
                        t.getCurrentStatus(),
                        t.getOrderNumber(),
                        t.getMerchantNumber(),
                        t.getRemarks()
                );
            }
        }
    }

    @Test
    void testAddTransactionToFile() throws IOException {
        // Create a temporary test file path or use a dedicated test file name
        String tempFilePath = "Ai Bill Application/src/main/resources/CSVForm/transactions/test_add.csv";
        // Create an empty or initial test file
        createTestCsvFile(tempFilePath, List.of()); // Start with an empty file

        CsvTransactionDao testDao = new CsvTransactionDao(); // Or reuse the instance from BeforeEach if path is managed

        Transaction newTx = new Transaction(
                "2025/04/11 08:00:00", "测试类型", "测试对方", "测试商品", "收入",
                123.45, "测试方式", "测试状态", "TEST001", "MERCHANT001", "测试备注"
        );

        // Add the transaction
        testDao.addTransaction(tempFilePath, newTx);

        // Load the file back and verify
        List<Transaction> transactions = testDao.loadFromCSV(tempFilePath);

        assertNotNull(transactions);
        assertEquals(1, transactions.size());
        Transaction addedTx = transactions.get(0);
        assertEquals("TEST001", addedTx.getOrderNumber());
        assertEquals(123.45, addedTx.getPaymentAmount(), 0.01);

        // Clean up the test file (optional but good practice)
        Files.deleteIfExists(Paths.get(tempFilePath));
    }

    @Test
    void testDeleteTransaction() throws IOException {
        dao=new CsvTransactionDao();

        dao.deleteTransaction("CSV_RELATIVE_PATH", "4200057899202502250932735481");

        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);
    }
//    @Test
//    void testChangeInfo() throws IOException{
//        dao=new CsvTransactionDao();
//        dao.changeInformation("TX123456","remarks","测试修改信息",TEST_CSV_PATH);
//        dao.changeInformation("TX123456","paymentAmount","116156",TEST_CSV_PATH);
//    }

}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\Service\AIAnalyzerThreadTest.java`:

```java
package Service;



import Service.AIservice.AIAnalyzerThread;
import org.junit.jupiter.api.Test;

public class AIAnalyzerThreadTest {

//    @Test
//    public void testRunAIAnalyzerThread() throws InterruptedException {
//        String userRequest = "请帮我分析最近的交易收支情况";
//        String filePath = "src/test/resources/sample_transactions.csv";
//        String startTimeStr = "2025/03/20";
//        String endTimeStr = "";
//
//        // 启动线程
//        Thread thread = new Thread(new AIAnalyzerThread(userRequest, filePath, startTimeStr, endTimeStr));
//        thread.start();
//
//        // 等待线程执行完成
//        thread.join();
//    }
}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\Service\AIserviceTest.java`:

```java
package Service;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

public class AIserviceTest {

    @Test
    public void testAnalyzeTransactions() {
        AITransactionService service = new AITransactionService();

        String userRequest = "请帮我分析这个月的收支情况";
        String filePath = "src/test/resources/sample_transactions.csv";

        String result = service.analyzeTransactions(userRequest, filePath,"2025/03/20","");

        assertNotNull(result, "AI分析结果不能为空");
        System.out.println("AI分析结果: " + result);
    }


}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\Service\AiFunctionTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.Test;
import Service.AIservice.AITransactionService;

import java.io.IOException;
import java.util.List;

public class AiFunctionTest {

    @Test
    public void testAnalyzeTransactions() throws IOException {

        String filePath = "src/test/resources/sample_transactions.csv";
        CsvTransactionDao transactionDao = new CsvTransactionDao();

        List<Transaction> transactions = transactionDao.loadFromCSV(filePath);

        // 实例化服务类
        AITransactionService service = new AITransactionService();

        // 调用合并格式化函数
        List<String> result = service.formatTransactions(transactions,"2025/03/29","2025/04/10");

        // 输出结果
        result.forEach(System.out::println);
    }




}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\Service\CacheTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import model.Transaction;
import org.junit.jupiter.api.Test;

import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;

public class CacheTest {

//    TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());
//
//    @Test
//    void DeleteCache(){
//        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;
//        cache.invalidate(TRANSACTION_CAFFEINE_KEY);
//    }

}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\Service\CollegeStudentNeedsTest.java`:

```java
//package Service;
//
//import Service.AIservice.ColledgeStudentThread;
//import Service.AIservice.CollegeStudentNeeds;
//import org.junit.jupiter.api.*;
//
//import java.io.IOException;
//import java.net.URISyntaxException;
//import java.net.URL;
//import java.nio.file.Files;
//import java.nio.file.Path;
//import java.nio.file.Paths;
//import java.util.Arrays;
//
//import static org.junit.jupiter.api.Assertions.*;
//
//// No @ExtendWith needed as we are not using Mockito extensions
//class CollegeStudentNeedsTest {
//
//
//
//    private CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
//    private static final String TEST_CSV_FILENAME = "src/test/resources/001.csv";
//    @Test
//    public void testGenerateBudget() throws IOException, InterruptedException {
//        Thread t=new Thread( new ColledgeStudentThread(TEST_CSV_FILENAME));
//        t.start();
//        t.join();
////        collegeStudentNeeds.generateBudget(TEST_CSV_FILENAME);
//    }
//    @Test
//    public void testParseStringToDouble(){
//        String s="asdas[369.39,1090.1]das";
//        double[] arr=collegeStudentNeeds.parseDoubleArrayFromString(s);
//        System.out.println(arr[0]+" "+arr[1]);
//    }
//
//
//}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\Service\TransactionServiceTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import model.Transaction;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.io.IOException;
import java.util.List;

class TransactionServiceTest {
    private TransactionService transactionService;

    @BeforeEach
    void setUp() {
//        // 初始化 DAO 和 Service
//        CsvTransactionDao csvTransactionDao = new CsvTransactionDao();
//        transactionService = new TransactionServiceImpl(csvTransactionDao);
    }

    @Test
    void testAddTransaction() throws IOException {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );

        // 执行添加操作
        transactionService.addTransaction(transaction);

        // 验证是否添加成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertFalse(transactions.isEmpty());
        assertEquals("T123456789", transactions.get(0).getOrderNumber());
    }

    @Test
    void testChangeTransaction() throws Exception {
        // 准备测试数据
        Transaction originalTransaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(originalTransaction);

        // 准备更新数据
        Transaction updatedTransaction = new Transaction(
                null, "充值", null, null, null, 0.0, "微信支付", null, "T123456789", null, "更新备注"
        );

        // 执行更新操作
        transactionService.changeTransaction(updatedTransaction);

        // 验证是否更新成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertEquals("充值", transactions.get(0).getTransactionType());
        assertEquals("微信支付", transactions.get(0).getPaymentMethod());
        assertEquals("更新备注", transactions.get(0).getRemarks());
    }

    @Test
    void testDeleteTransaction() throws Exception {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(transaction);

        // 执行删除操作
        boolean result = transactionService.deleteTransaction("T123456789");

        // 验证是否删除成功
        assertTrue(result);
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertTrue(transactions.isEmpty());
    }

    @Test
    void testSearchTransaction() throws IOException {

        // 设置搜索条件
        Transaction searchCriteria = new Transaction();
        searchCriteria.setCounterparty("支付宝");

        // 执行搜索操作
        List<Transaction> result = transactionService.searchTransaction(searchCriteria);

        // 验证搜索结果
        result.forEach(res -> System.out.println(res.getCommodity()));
    }


}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\resources\CSVForm\transactions\admin_transactions.csv`:

```csv
交易时间,交易类型,交易对方,商品,收/支,金额(元),支付方式,当前状态,交易单号,商户单号,备注
2025/03/01 09:00:00,工资,公司A,"三月工资",收入,"¥10000.00",银行卡,已入账,SALARY_MAR_A,PAYROLL_A_001,"本月基本工资"
2025/03/05 14:30:00,购物,超市B,"食品杂货",支出,"¥250.50",支付宝,已完成,SHOP_B_001,ALIPAY_12345,"周末采购"
2025/03/10 10:00:00,转账,用户1,"报销午餐",支出,"¥50.00",微信支付,已完成,TRANSFER_U1_001,WECHAT_56789,"归还午餐费"
2025/03/15 11:00:00,餐饮,餐厅C,"午餐外卖",支出,"¥35.75",美团支付,已完成,MEAL_C_001,MEITUAN_11223,"工作日午餐"
2025/03/20 16:00:00,投资,股票账户,"购入股票",支出,"¥5000.00",银行转账,已完成,INVEST_STOCK_001,BANK_99887,"长期投资"
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\resources\CSVForm\users\users.csv`:

```csv
username,password,role,transaction_csv_path
admin,admin123,admin,Ai Bill Application/src/main/resources/CSVForm/transactions/admin_transactions.csv
user1,pass123,user,Ai Bill Application/src/main/resources/CSVForm/transactions/user1_transactions.csv
user2,securepwd,user,Ai Bill Application/src/main/resources/CSVForm/transactions/user2_transactions.csv

```

`软工/Ai-Bill-Application-Group21\Ai-Bill-Application-Prompt.txt`:

```txt
Project Path: Ai-Bill-Application-Group21

Source Tree:

```txt
Ai-Bill-Application-Group21
└── Ai Bill Application
    ├── HistogramPanelContainer.java
    └── src
        ├── main
        │   └── java
        │       ├── Constants
        │       │   ├── CaffeineKeys.java
        │       │   └── ConfigConstants.java
        │       ├── Controller
        │       │   ├── ButtonEditor.java
        │       │   ├── ButtonRenderer.java
        │       │   ├── HistogramExample.java
        │       │   ├── HistogramPanelContainer.java
        │       │   └── MenuUI.java
        │       ├── DAO
        │       │   ├── CsvTransactionDao.java
        │       │   └── TransactionDao.java
        │       ├── Interceptor
        │       │   └── Login
        │       │       ├── LoginDialog.java
        │       │       └── UserService.java
        │       ├── Main.java
        │       ├── Service
        │       │   ├── AIservice
        │       │   │   ├── AIAnalyzerThread.java
        │       │   │   ├── AITransactionService.java
        │       │   │   ├── ColledgeStudentThread.java
        │       │   │   └── CollegeStudentNeeds.java
        │       │   ├── Impl
        │       │   │   └── TransactionServiceImpl.java
        │       │   ├── TransactionService.java
        │       │   └── deepseek
        │       │       └── ChatCompletionsExample.java
        │       ├── Utils
        │       │   └── CacheUtil.java
        │       └── model
        │           └── Transaction.java
        └── test
            └── java
                ├── ControllerTest
                │   ├── AITest.java
                │   └── MenuUITest.java
                ├── DAOTest
                │   └── CsvTransactionDaoTest.java
                └── Service
                    ├── AIAnalyzerThreadTest.java
                    ├── AIserviceTest.java
                    ├── AiFunctionTest.java
                    ├── CacheTest.java
                    ├── CollegeStudentNeedsTest.java
                    └── TransactionServiceTest.java

```

`Ai-Bill-Application-Group21/Ai Bill Application\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Constants\CaffeineKeys.java`:

```java
package Constants;

public class CaffeineKeys {
    public static final String TRANSACTION_CAFFEINE_KEY = "transactions";

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Constants\ConfigConstants.java`:

```java
package Constants;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

/**
 * 配置常量类（线程安全初始化）
 */
public final class ConfigConstants {
    // 私有构造防止实例化
    private ConfigConstants() {}

    /**
     * transactionCSV路径加载逻辑
     */
    // CSV路径常量
    public static final String CSV_PATH;
    // 静态初始化块（类加载时执行）
    static {
        Properties prop = new Properties();
        try (InputStream input = ConfigConstants.class.getClassLoader()
                .getResourceAsStream("config.properties")) {

            prop.load(input);
            CSV_PATH = prop.getProperty("csv.path");
        } catch (IOException e) {
            throw new RuntimeException("加载配置文件失败", e); // 转换为运行时异常
        }
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\ButtonEditor.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.TableCellEditor;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

class ButtonEditor extends AbstractCellEditor implements TableCellEditor {
    private final JPanel panel = new JPanel(new BorderLayout()); // 使用 BorderLayout
    private final JButton button = new JButton();
    private int rowIndex;
    private final MenuUI menuUI;

    public ButtonEditor(MenuUI menuUI) {
        this.menuUI = menuUI;

        // 设置按钮样式
        button.setFocusPainted(false); // 移除按钮的焦点边框
        button.setPreferredSize(new Dimension(80, 30)); // 设置按钮的固定尺寸

        // 添加按钮到面板
        panel.add(button, BorderLayout.CENTER);

        // 为按钮添加事件监听器
        button.addActionListener(e -> {
            System.out.println("按钮点击事件触发: " + button.getText());
            fireEditingStopped(); // 停止编辑
            String buttonText = button.getText();
            if ("Modify".equals(buttonText)) {
                menuUI.editRow(rowIndex); // 调用 MenuUI 的 editRow 方法
            } else if ("Delete".equals(buttonText)) {
                int confirm = JOptionPane.showConfirmDialog(panel, "确定要删除此行吗？", "确认删除", JOptionPane.YES_NO_OPTION);
                if (confirm == JOptionPane.YES_OPTION) {
                    menuUI.deleteRow(rowIndex); // 调用 MenuUI 的 deleteRow 方法
                }
            }
        });
    }

    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
        this.rowIndex = row; // 更新当前行索引
        button.setText(value != null ? value.toString() : ""); // 根据单元格的值设置按钮文本
        return panel;
    }

    @Override
    public Object getCellEditorValue() {
        return button.getText(); // 返回按钮的当前文本
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\ButtonRenderer.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import java.awt.*;

class ButtonRenderer extends DefaultTableCellRenderer {
    private final JPanel panel = new JPanel(new BorderLayout()); // 使用 BorderLayout
    private final JButton button = new JButton();

    public ButtonRenderer() {
        button.setFocusPainted(false); // 移除按钮的焦点边框
        button.setPreferredSize(new Dimension(80, 30)); // 设置按钮的固定尺寸
        panel.add(button, BorderLayout.CENTER); // 将按钮添加到面板中心
    }

    @Override
    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
        // 根据单元格的值设置按钮文本
        button.setText(value != null ? value.toString() : "");
        return panel;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\HistogramExample.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;
import java.util.HashMap;
import java.util.Random;

// 数据生成类
class DataGenerator {
    public static int[] generateData(int numberOfDataPoints, int maxValue) {
        Random random = new Random();
        int[] data = new int[numberOfDataPoints];
        for (int i = 0; i < numberOfDataPoints; i++) {
            data[i] = random.nextInt(maxValue);
        }
        return data;
    }
}

// 直方图计算类
class Histogram {
    private int binSize;
    private int[] data;

    public Histogram(int[] data, int binSize) {
        this.data = data;
        this.binSize = binSize;
    }

    public HashMap<Integer, Integer> computeFrequency() {
        HashMap<Integer, Integer> frequencyMap = new HashMap<>();
        for (int number : data) {
            int bin = number / binSize;
            frequencyMap.put(bin, frequencyMap.getOrDefault(bin, 0) + 1);
        }
        return frequencyMap;
    }
}

// 直方图 GUI 绘制类
class HistogramPanel extends JPanel {
    HashMap<Integer, Integer> frequencyMap;

    public HistogramPanel() {
        this.frequencyMap = new HashMap<>();
    }

    public void updateData(HashMap<Integer, Integer> frequencyMap) {
        this.frequencyMap = frequencyMap;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        int barWidth = 40;
        int gap = 10;
        int maxFrequency = frequencyMap.values().stream().mapToInt(v -> v).max().orElse(1);

        int index = 0;
        for (Integer key : frequencyMap.keySet()) {
            int height = (int) ((frequencyMap.get(key) / (double) maxFrequency) * getHeight());
            g.setColor(Color.BLUE);
            g.fillRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.setColor(Color.BLACK);
            g.drawRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.drawString("Bin " + key, index * (barWidth + gap) + 5, getHeight() - 5);
            index++;
        }
    }
}


// 主窗口类
public class HistogramExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("数据分析界面");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\MenuUI.java`:

```java
package Controller;

import Constants.ConfigConstants;
import DAO.Impl.CsvTransactionDao;

import Service.Impl.TransactionServiceImpl;

import Service.Impl.TransactionServiceImpl;

import Utils.CacheUtil;
import model.Transaction;

import javax.swing.*;
import java.awt.*;
import java.io.IOException;
import java.util.List;
import java.util.Vector;
import javax.swing.table.DefaultTableModel;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class MenuUI {
    private static final String FILE_PATH = CSV_PATH;
    private static DefaultTableModel tableModel;
    private static Vector<Vector<String>> allData = new Vector<>();
    private static TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());
    private JTable table;  // 把table定义为静态字段
    private HistogramPanelContainer histogramPanelContainer; // 添加 HistogramPanelContainer 实例
    private JPanel rightPanel; // 右边的面板，用于显示搜索和表格界面或 AI 界面
    private CardLayout cardLayout; // 用于管理界面切换的布局

    public MenuUI(){
        String[] columnNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注", "Modify", "Delete"};
        tableModel = new DefaultTableModel(columnNames, 0);
        table = new JTable(tableModel);

        histogramPanelContainer = new HistogramPanelContainer(); // 初始化 HistogramPanelContainer
        cardLayout = new CardLayout(); // 初始化 CardLayout
        rightPanel = new JPanel(cardLayout); // 初始化 rightPanel
    }

    public JPanel createMainPanel() {
        // 主面板，使用 BorderLayout
        JPanel mainPanel = new JPanel(new BorderLayout());

        // 左边的面板，包含 Menu 和 AI 按钮
        JPanel leftPanel = createLeftPanel();
        mainPanel.add(leftPanel, BorderLayout.WEST);

        // 右边的面板，用于显示搜索和表格界面或 AI 界面
        setupRightPanel();
        mainPanel.add(rightPanel, BorderLayout.CENTER);

        return mainPanel;
    }

    // 创建左边的面板，包含 Menu 和 AI 按钮
    private JPanel createLeftPanel() {
        JPanel leftPanel = new JPanel(new GridLayout(2, 1));
        JButton menuButton = new JButton("Menu");
        JButton aiButton = new JButton("AI");

        leftPanel.add(menuButton);
        leftPanel.add(aiButton);

        // 为 Menu 按钮添加 ActionListener
        menuButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Table"); // 切换到表格界面
        });

        // 为 AI 按钮添加 ActionListener
        aiButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Histogram"); // 切换到直方图界面
        });

        return leftPanel;
    }

    // 设置右边的面板，包含搜索和表格界面或 AI 界面
    private void setupRightPanel() {
        // 创建搜索和表格的面板
        JPanel tablePanel = createTablePanel();

        // 将表格面板和直方图面板添加到 rightPanel
        rightPanel.add(tablePanel, "Table");
        rightPanel.add(histogramPanelContainer, "Histogram");
    }

    // 创建搜索和表格的面板
    private JPanel createTablePanel() {
        JPanel tablePanel = new JPanel(new BorderLayout());

        // 创建输入面板
        JPanel inputPanel = createInputPanel();
        tablePanel.add(inputPanel, BorderLayout.NORTH);

        // 创建表格的滚动面板
        JScrollPane tableScrollPane = new JScrollPane(table);
        tableScrollPane.setPreferredSize(new Dimension(1000, 250));
        table.setRowHeight(30); // 设置表格的行高

        tablePanel.add(tableScrollPane, BorderLayout.CENTER);

        // 为 Modify 列设置渲染器和编辑器
        table.getColumnModel().getColumn(11).setCellRenderer(new ButtonRenderer());
        table.getColumnModel().getColumn(11).setCellEditor(new ButtonEditor(this));

        // 为 Delete 列设置渲染器和编辑器
        table.getColumnModel().getColumn(12).setCellRenderer(new ButtonRenderer());
        table.getColumnModel().getColumn(12).setCellEditor(new ButtonEditor(this));

        // 加载 CSV 数据
        loadCSVData(FILE_PATH);

        return tablePanel;
    }

    // 创建输入面板
    private JPanel createInputPanel() {
        JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));

        // 创建输入字段
        JTextField transactionTimeField = new JTextField(10); // 交易时间输入框
        JTextField transactionTypeField = new JTextField(10); // 交易类型输入框
        JTextField counterpartyField = new JTextField(10);    // 交易对方输入框
        JTextField commodityField = new JTextField(10);      // 商品输入框
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"}); // 收/支下拉框
        JTextField paymentMethodField = new JTextField(10);  // 支付方式输入框

        // 添加标签和输入字段到输入面板
        inputPanel.add(new JLabel("交易时间:"));
        inputPanel.add(transactionTimeField);
        inputPanel.add(new JLabel("交易类型:"));
        inputPanel.add(transactionTypeField);
        inputPanel.add(new JLabel("交易对方:"));
        inputPanel.add(counterpartyField);
        inputPanel.add(new JLabel("商品:"));
        inputPanel.add(commodityField);
        inputPanel.add(new JLabel("收/支:"));
        inputPanel.add(inOutComboBox);
        inputPanel.add(new JLabel("支付方式:"));
        inputPanel.add(paymentMethodField);

        // 创建 Search 和 Add 按钮
        JButton searchButton = new JButton("Search");
        JButton addButton = new JButton("Add");

        // 将按钮添加到输入面板
        inputPanel.add(searchButton);
        inputPanel.add(addButton);

        // 为 Search 按钮添加 ActionListener
        searchButton.addActionListener(e -> {
            // 获取输入字段的值
            searchData(
                    transactionTimeField.getText().trim(),
                    transactionTypeField.getText().trim(),
                    counterpartyField.getText().trim(),
                    commodityField.getText().trim(),
                    (String) inOutComboBox.getSelectedItem(),
                    paymentMethodField.getText().trim()
            );
        });

        // 为 Add 按钮添加 ActionListener
        addButton.addActionListener(e -> {
            // 弹出对话框，输入交易信息
            showAddTransactionDialog();
        });

        return inputPanel;
    }

    // 弹出对话框，输入交易信息
    private void showAddTransactionDialog() {
        // 创建对话框
        JDialog addDialog = new JDialog();
        addDialog.setTitle("添加交易");
        addDialog.setLayout(new GridLayout(12, 2)); // 11 个字段 + 1 个按钮行

        // 创建输入字段
        JTextField transactionTimeField = new JTextField();
        JTextField transactionTypeField = new JTextField();
        JTextField counterpartyField = new JTextField();
        JTextField commodityField = new JTextField();
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"});
        JTextField paymentAmountField = new JTextField();
        JTextField paymentMethodField = new JTextField();
        JTextField currentStatusField = new JTextField();
        JTextField orderNumberField = new JTextField();
        JTextField merchantNumberField = new JTextField();
        JTextField remarksField = new JTextField();

        // 添加标签和输入字段到对话框
        addDialog.add(new JLabel("交易时间:"));
        addDialog.add(transactionTimeField);
        addDialog.add(new JLabel("交易类型:"));
        addDialog.add(transactionTypeField);
        addDialog.add(new JLabel("交易对方:"));
        addDialog.add(counterpartyField);
        addDialog.add(new JLabel("商品:"));
        addDialog.add(commodityField);
        addDialog.add(new JLabel("收/支:"));
        addDialog.add(inOutComboBox);
        addDialog.add(new JLabel("金额(元):"));
        addDialog.add(paymentAmountField);
        addDialog.add(new JLabel("支付方式:"));
        addDialog.add(paymentMethodField);
        addDialog.add(new JLabel("当前状态:"));
        addDialog.add(currentStatusField);
        addDialog.add(new JLabel("交易单号:"));
        addDialog.add(orderNumberField);
        addDialog.add(new JLabel("商户单号:"));
        addDialog.add(merchantNumberField);
        addDialog.add(new JLabel("备注:"));
        addDialog.add(remarksField);

        // 添加确认按钮
        JButton confirmButton = new JButton("确认");
        confirmButton.addActionListener(e -> {
            // 获取输入字段的值，若为空则设置为默认值
            String transactionTime = emptyIfNull(transactionTimeField.getText().trim());
            String transactionType = emptyIfNull(transactionTypeField.getText().trim());
            String counterparty = emptyIfNull(counterpartyField.getText().trim());
            String commodity = emptyIfNull(commodityField.getText().trim());
            String inOut = (String) inOutComboBox.getSelectedItem();
            String paymentAmountText = paymentAmountField.getText().trim();
            double paymentAmount = paymentAmountText.isEmpty() ? 0.0 : Double.parseDouble(paymentAmountText); // 处理空字符串
            String paymentMethod = emptyIfNull(paymentMethodField.getText().trim());
            String currentStatus = emptyIfNull(currentStatusField.getText().trim());
            String orderNumber = emptyIfNull(orderNumberField.getText().trim());
            String merchantNumber = emptyIfNull(merchantNumberField.getText().trim());
            String remarks = emptyIfNull(remarksField.getText().trim());

            // 创建 Transaction 对象
            Transaction newTransaction = new Transaction(
                    transactionTime,
                    transactionType,
                    counterparty,
                    commodity,
                    inOut,
                    paymentAmount,
                    paymentMethod,
                    currentStatus,
                    orderNumber,
                    merchantNumber,
                    remarks
            );

            try {
                // 调用 TransactionServiceImpl 的 addTransaction 方法
                transactionService.addTransaction(newTransaction);

                // 重新加载 CSV 数据以更新表格
                loadCSVData(TRANSACTION_CAFFEINE_KEY);

                // 关闭对话框
                addDialog.dispose();

                JOptionPane.showMessageDialog(null, "交易添加成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(null, "交易添加失败！", "错误", JOptionPane.ERROR_MESSAGE);
            }
        });

        addDialog.add(confirmButton);

        // 设置对话框大小并显示
        addDialog.setSize(400, 300);
        addDialog.setModal(true); // 设置为模态对话框
        addDialog.setVisible(true);
    }

    // 加载 CSV 数据
    public void loadCSVData(String caffeineKey) {
        allData.clear();
        tableModel.setRowCount(0);

        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;

//        CsvTransactionDao csvTransactionDao = new CsvTransactionDao();

        List<Transaction> transactions = cache.get(caffeineKey);
        for (Transaction transaction : transactions) {
            Vector<String> row = createRowFromTransaction(transaction);
            allData.add(row);
            tableModel.addRow(row);
        }
    }

    // 搜索数据
    public void searchData(String query1, String query2, String query3, String query4, String query6, String query5) {
        tableModel.setRowCount(0);
        Transaction searchCriteria = new Transaction(query1, query2, query3, query4, query6, 0, query5, "", "", "", "");

        try {
            List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);
            for (Transaction transaction : transactions) {
                Vector<String> row = createRowFromTransaction(transaction);
                tableModel.addRow(row);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(null, "查询失败！", "错误", JOptionPane.ERROR_MESSAGE);
        }
    }

    // 从 Transaction 对象创建表格行
    private Vector<String> createRowFromTransaction(Transaction transaction) {
        Vector<String> row = new Vector<>();
        row.add(transaction.getTransactionTime());
        row.add(transaction.getTransactionType());
        row.add(transaction.getCounterparty());
        row.add(transaction.getCommodity());
        row.add(transaction.getInOut());
        row.add(String.valueOf(transaction.getPaymentAmount()));
        row.add(transaction.getPaymentMethod());
        row.add(transaction.getCurrentStatus());
        row.add(transaction.getOrderNumber());
        row.add(transaction.getMerchantNumber());
        row.add(transaction.getRemarks());
        row.add("Modify"); // Modify 按钮
        row.add("Delete"); // 添加 Delete 按钮
        return row;
    }

    // 删除行
    public void deleteRow(int rowIndex) {
        if (rowIndex >= 0 && rowIndex < allData.size()) {
            String orderNumber = allData.get(rowIndex).get(8).trim();
            System.out.println("尝试删除的交易单号: " + orderNumber); // 打印交易单号

            try {
                if (transactionService.deleteTransaction(orderNumber)) {
                    allData.remove(rowIndex);
                    tableModel.removeRow(rowIndex);
                    JOptionPane.showMessageDialog(null, "删除成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                } else {
                    JOptionPane.showMessageDialog(null, "删除失败：未找到对应的交易单号", "错误", JOptionPane.ERROR_MESSAGE);
                }
            } catch (IOException ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(null, "删除失败！", "错误", JOptionPane.ERROR_MESSAGE);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    // 编辑行
    public void editRow(int rowIndex) {
        System.out.println("编辑行: " + rowIndex);
        if (rowIndex >= 0 && rowIndex < allData.size()) {
            Vector<String> rowData = allData.get(rowIndex);

            // 创建一个面板用于显示编辑字段
            JPanel panel = new JPanel(new GridLayout(rowData.size() - 2, 2)); // 排除最后两列

            // 创建字段数组，用于存储用户输入的值
            JTextField[] fields = new JTextField[rowData.size() - 2]; // 排除最后两列

            // 遍历 rowData，跳过最后两列（"Modify" 和 "Delete"）
            for (int i = 0; i < rowData.size() - 2; i++) {
                panel.add(new JLabel(tableModel.getColumnName(i))); // 添加列名标签
                fields[i] = new JTextField(rowData .get(i)); // 添加输入字段
                panel.add(fields[i]);
            }

            // 弹出对话框，让用户修改数据
            int result = JOptionPane.showConfirmDialog(null, panel, "修改交易信息", JOptionPane.OK_CANCEL_OPTION);
            if (result == JOptionPane.OK_OPTION) {
                // 用户点击了确认按钮，更新交易信息
                Transaction transaction = new Transaction(
                        fields[0].getText().trim(), // 交易时间
                        fields[1].getText().trim(), // 交易类型
                        fields[2].getText().trim(), // 交易对方
                        fields[3].getText().trim(), // 商品
                        fields[4].getText().trim(), // 收/支
                        Double.parseDouble(fields[5].getText().trim()), // 金额(元)
                        fields[6].getText().trim(), // 支付方式
                        fields[7].getText().trim(), // 当前状态
                        fields[8].getText().trim(), // 交易单号
                        fields[9].getText().trim(), // 商户单号
                        fields[10].getText().trim() // 备注
                );

                try {
                    // 调用 TransactionServiceImpl 的 changeTransaction 方法更新交易
                    transactionService.changeTransaction(transaction);

                    // 重新加载 CSV 数据以更新表格
                    loadCSVData(TRANSACTION_CAFFEINE_KEY);

                    JOptionPane.showMessageDialog(null, "修改成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                } catch (Exception ex) {
                    ex.printStackTrace();
                    JOptionPane.showMessageDialog(null, "修改失败！", "错误", JOptionPane.ERROR_MESSAGE);
                }
            }
        }
    }

    /**
     * 查找对话框中的输入字段
     *
     * @param dialog 对话框
     * @param index  输入字段的索引
     * @return 输入字段
     */
    /**
     * 查找容器中的输入字段
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0;
        for (Component component : container.getComponents()) {
            if (component instanceof JTextField) {
                if (count == index) {
                    return (JTextField) component;
                }
                count++;
            }
        }
        return null;
    }

    /**
     * 查找对话框中的下拉框
     *
     * @param dialog 对话框
     * @return 下拉框
     */
    /**
     * 查找容器中的下拉框
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) {
            if (component instanceof JComboBox) {
                return (JComboBox<String>) component;
            }
        }
        return null;
    }

    /**
     * 如果字段为 null，则返回空文本
     *
     * @param value 字段值
     * @return 非 null 的字段值
     */
    private String emptyIfNull(String value) {
        return value == null ? "" : value;
    }

    // 添加此方法以便测试时可以获取table
    public JTable getTable() {
        return table;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\DAO\CsvTransactionDao.java`:

```java
package DAO;

import Constants.ConfigConstants;
import model.Transaction;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static Constants.ConfigConstants.CSV_PATH;

public class CsvTransactionDao implements TransactionDao {
    //避免每次都调用loadFromCSV() 方法
    private List<Transaction> transactions;
    private boolean isLoad= false;
//HEAD 交易时间	交易类型	交易对方	商品	收/支	金额(元)	支付方式	当前状态	交易单号	商户单号	备注
    //
    @Override
    public List<Transaction> loadFromCSV(String filePath) throws IOException {
        try (
                Reader reader = new InputStreamReader(
                        new BOMInputStream(Files.newInputStream(Paths.get(filePath))),
                        StandardCharsets.UTF_8)) {
            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()    //根据首行的内容设置为表格的头
                    .withIgnoreHeaderCase(false)  // 禁用忽略大小写
                    .withTrim(false);             // 禁用自动trim（防止意外空格问题）

            try (CSVParser csvParser = new CSVParser(reader, format)) {

                List<Transaction> transactions = new ArrayList<>();
                for (CSVRecord record : csvParser) {
                    Transaction transaction = parseRecord(record);
                    transactions.add(transaction);
                }
                reader.close();
                this.transactions = transactions;
                this.isLoad=true;
                return transactions;
            }
        }
    }


    private Transaction parseRecord(CSVRecord record) {
        return new Transaction(
                record.get("交易时间"),
                record.get("交易类型"),
                record.get("交易对方"),
                record.get("商品"),
                record.get("收/支"),
                Double.parseDouble(record.get("金额(元)").substring(1)),
                record.get("支付方式"),
                record.get("当前状态"),
                record.get("交易单号"),
                record.get("商户单号"),
                record.get("备注")
        );
    }

    // 根据交易单号删除交易记录
    public boolean deleteTransaction(String filePath, String orderNumber) throws IOException {
        if(!isLoad){ loadFromCSV(filePath);}

        List<Transaction> updatedTransactions = transactions.stream()
                .filter(t -> !t.getOrderNumber().trim().equals(orderNumber))
                .collect(Collectors.toList());

        if (transactions.size() == updatedTransactions.size()) {
            return false;
        }

        writeTransactionsToCSV(filePath, updatedTransactions);
        return true;
    }

    // 添加交易
    public void addTransaction(String filePath, Transaction newTransaction) throws IOException {
        boolean fileExists = Files.exists(Paths.get(filePath)) && Files.size(Paths.get(filePath)) > 0;

        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(filePath), StandardOpenOption.CREATE, StandardOpenOption.APPEND);
             CSVPrinter csvPrinter = new CSVPrinter(writer, fileExists ? getCsvFormatWithoutHeader() : getCsvFormatWithHeader(filePath))) {

            csvPrinter.printRecord(
                    newTransaction.getTransactionTime(),
                    newTransaction.getTransactionType(),
                    newTransaction.getCounterparty(),
                    newTransaction.getCommodity(),
                    newTransaction.getInOut(),
                    "¥" + newTransaction.getPaymentAmount(),
                    newTransaction.getPaymentMethod(),
                    newTransaction.getCurrentStatus(),
                    newTransaction.getOrderNumber(),
                    newTransaction.getMerchantNumber(),
                    newTransaction.getRemarks()
            );

            csvPrinter.flush();
        }
    }

    // 统一写回 CSV
    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
        // 1. 创建临时文件（确保与原文件同目录）
        File targetFile = new File(filePath);
        File tempFile = File.createTempFile("transaction_temp", ".csv", targetFile.getParentFile());

        // 2. 写入数据到临时文件（使用 try-with-resources 确保资源释放）
        try (BufferedWriter writer = Files.newBufferedWriter(tempFile.toPath());
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(
                     "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"))) {

            for (Transaction t : transactions) {
                csvPrinter.printRecord(
                        t.getTransactionTime(),
                        t.getTransactionType(),
                        t.getCounterparty(),
                        t.getCommodity(),
                        t.getInOut(),
                        "¥" + t.getPaymentAmount(),
                        t.getPaymentMethod(),
                        t.getCurrentStatus(),
                        t.getOrderNumber(),
                        t.getMerchantNumber(),
                        t.getRemarks()
                );
            }
            csvPrinter.flush(); // 强制刷盘
        } catch (IOException e) {
            tempFile.delete(); // 失败时删除临时文件
            throw e;
        }

        // 3. 原子性替换原文件
        Path source = tempFile.toPath();
        Path target = Paths.get(filePath);
        try {
            Files.move(source, target, StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            System.err.println("移动失败原因: " + e.getMessage());
        }
    }

//    // 统一写回 CSV
//    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
//        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(filePath));
//             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(
//                     "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注")))  {
//
//            for (Transaction t : transactions) {
//                csvPrinter.printRecord(
//                        t.getTransactionTime(),
//                        t.getTransactionType(),
//                        t.getCounterparty(),
//                        t.getCommodity(),
//                        t.getInOut(),
//                        "¥" + t.getPaymentAmount(),
//                        t.getPaymentMethod(),
//                        t.getCurrentStatus(),
//                        t.getOrderNumber(),
//                        t.getMerchantNumber(),
//                        t.getRemarks()
//                );
//            }
//        }
//    }

    // 获取 CSV 格式（包含表头）
    private CSVFormat getCsvFormatWithHeader(String filePath) throws IOException {
        try (BufferedReader reader = Files.newBufferedReader(Paths.get(filePath))) {
            String headerLine = reader.readLine();
            if (headerLine == null || headerLine.trim().isEmpty()) {
                // 如果文件为空或不存在，返回默认表头
                return CSVFormat.DEFAULT.withHeader(
                        "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"
                );
            }
            return CSVFormat.DEFAULT.withHeader(headerLine.split(",")).withTrim();
        }
    }

    // 获取 CSV 格式（不包含表头）
    private CSVFormat getCsvFormatWithoutHeader() {
        return CSVFormat.DEFAULT.withTrim();
    }

    public boolean changeInformation(String orderNumber, String head, String value,String path) throws IOException{
        if(isLoad==false){ loadFromCSV(path);}
        for (int i = 0; i < transactions.size(); i++) {
            if(transactions.get(i).getOrderNumber().trim().equals(orderNumber)){
                Transaction newTransaction=transactions.get(i);
                switch (head){
                    case "transactionTime" :{
                        newTransaction.setTransactionTime(value);
                        break;}
                    case "transactionType" :{
                        newTransaction.setTransactionType(value);
                        break;
                    }
                    case "counterparty" :{
                        newTransaction.setCounterparty(value);
                        break;
                    } case "commodity" :{
                        newTransaction.setCommodity(value);
                        break;
                    } case "inOut" :{
                        newTransaction.setInOut(value);
                        break;
                    } case "paymentAmount" :{
                        newTransaction.setPaymentAmount(Double.parseDouble(value));
                        break;
                    } case "paymentMethod" :{
                        newTransaction.setPaymentMethod(value);
                        break;
                    } case "currentStatus" :{
                        newTransaction.setCurrentStatus(value);
                        break;
                    } case "orderNumber" :{
                        newTransaction.setOrderNumber(value);
                        break;
                    } case "merchantNumber" :{
                        newTransaction.setMerchantNumber(value);
                        break;
                    } case "remarks" :{
                        newTransaction.setRemarks(value);
                        break;
                    } default:{
                        System.err.println("error head");
                    }
                }

                boolean flag=deleteTransaction(path,transactions.get(i).getOrderNumber());
                if(flag) {
                    addTransaction(path,newTransaction);
                    System.out.println("success to delete");
                }
                else System.err.println("failed to delete");
            }
        }
        return true;
    }

    @Override
    public List<Transaction> getAllTransactions() throws IOException {
        return List.of();
    }

    @Override
    public void addTransaction(Transaction transaction) throws IOException {

    }

    @Override
    public boolean deleteTransaction(String orderNumber) throws IOException {
        return false;
    }

    @Override
    public boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException {
        return false;
    }

    @Override
    public Transaction getTransactionByOrderNumber(String orderNumber) throws IOException {
        return null;
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\DAO\TransactionDao.java`:

```java
package DAO;

import model.Transaction;

import java.io.IOException;
import java.util.List;

/**
 * Interface for Data Access Object (DAO) operations related to Transactions.
 * Defines the contract for loading, adding, deleting, and updating transaction data.
 */
public interface
TransactionDao {

    //HEAD 交易时间	交易类型	交易对方	商品	收/支	金额(元)	支付方式	当前状态	交易单号	商户单号	备注
        //
    List<Transaction> loadFromCSV(String filePath) throws IOException;

    /**
     * Loads all transactions from the configured data source.
     *
     * @return A list of all transactions.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<Transaction> getAllTransactions() throws IOException;

    /**
     * Adds a new transaction to the data source.
     *
     * @param transaction The new transaction to add.
     * @throws IOException If an I/O error occurs during saving.
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * Deletes a transaction identified by its order number.
     *
     * @param orderNumber The unique order number of the transaction to delete.
     * @return true if a transaction was found and deleted, false otherwise.
     * @throws IOException If an I/O error occurs during loading or saving.
     */
    boolean deleteTransaction(String orderNumber) throws IOException;

    /**
     * Updates a specific field of an existing transaction identified by its order number.
     *
     * @param orderNumber The unique order number of the transaction to update.
     * @param fieldName   The name of the field to update (e.g., "transactionType", "paymentAmount").
     * @param newValue    The new value for the specified field.
     * @return true if the transaction was found and updated, false otherwise.
     * @throws IOException             If an I/O error occurs during loading or saving.
     * @throws NumberFormatException   If updating 'paymentAmount' and newValue is not a valid double.
     * @throws IllegalArgumentException If the fieldName is invalid.
     */
    boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException;

    /**
     * Retrieves a transaction by its unique order number.
     * (Optional but often useful)
     *
     * @param orderNumber The unique order number.
     * @return The Transaction object if found, null otherwise.
     * @throws IOException If an I/O error occurs during loading.
     */
    Transaction getTransactionByOrderNumber(String orderNumber) throws IOException;

}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Interceptor\Login\LoginDialog.java`:

```java
package Interceptor.Login;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class LoginDialog extends JDialog {
    private boolean loginSuccessful = false;
    private JTextField usernameField;
    private JPasswordField passwordField;
    private UserService userService = new UserService();

    public LoginDialog() {
        setTitle("用户登录");
        setLayout(new GridLayout(3, 2));
        setModal(true);
        setSize(300, 150);

        // 输入组件
        usernameField = new JTextField();
        passwordField = new JPasswordField();
        JButton loginButton = new JButton("登录");
        JButton cancelButton = new JButton("取消");

        // 添加组件
        add(new JLabel("用户名:"));
        add(usernameField);
        add(new JLabel("密码:"));
        add(passwordField);
        add(loginButton);
        add(cancelButton);

        // 登录按钮逻辑
        loginButton.addActionListener(e -> {
            String username = usernameField.getText().trim();
            String password = new String(passwordField.getPassword()).trim();

            if (userService.authenticate(username, password)) {
                loginSuccessful = true;
                dispose(); // 关闭对话框
            } else {
                JOptionPane.showMessageDialog(
                        this,
                        "用户名或密码错误！",
                        "登录失败",
                        JOptionPane.ERROR_MESSAGE
                );
                clearFields(); // 登录失败后清空文本框
            }
        });

        // 取消按钮逻辑
        cancelButton.addActionListener(e -> {
            dispose();
            System.exit(0);
        });

        setLocationRelativeTo(null); // 居中显示
    }

    // 清空文本框的方法
    private void clearFields() {
        usernameField.setText("");
        passwordField.setText("");
        usernameField.requestFocus(); // 焦点回到用户名输入框
    }

    public boolean isLoginSuccessful() {
        return loginSuccessful;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Interceptor\Login\UserService.java`:

```java
package Interceptor.Login;

import java.util.HashMap;
import java.util.Map;

public class UserService {
    // 模拟用户数据库（用户名 -> 密码哈希值）
    private static final Map<String, String> userDatabase = new HashMap<>();

    public UserService() {
        // 初始化测试用户（密码为 "admin123" 的 SHA-256 哈希）
        userDatabase.put("admin", "admin123");
    }

    public boolean authenticate(String username, String password) {
        if (username.isEmpty() || password.isEmpty()) return false;
        String storedHash = userDatabase.get(username);
        return password.equals(storedHash);
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Main.java`:

```java
import javax.swing.*;

import Controller.MenuUI;
import DAO.Impl.CsvTransactionDao;
import Interceptor.Login.LoginDialog;
import Service.Impl.TransactionServiceImpl;

public class Main {
    public static void main(String[] args) {
        // 初始化服务（依赖注入）
        TransactionServiceImpl.csvTransactionDao = new CsvTransactionDao();

        // 在事件调度线程中启动 GUI（Swing 规范）
        SwingUtilities.invokeLater(() -> {
            // 1. 显示登录对话框
            LoginDialog loginDialog = new LoginDialog();
            loginDialog.setVisible(true);

            // 2. 登录成功后再显示主界面
            if (loginDialog.isLoginSuccessful()) {
                MenuUI menuUI = new MenuUI();
                JPanel mainPanel = menuUI.createMainPanel();
                showMainUI(mainPanel);
            } else {
                System.exit(0); // 登录失败退出
            }
        });
    }

    /**
     * 显示主界面窗口
     */
    private static void showMainUI(JPanel panel) {
        JFrame frame = new JFrame("交易管理系统");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(1200, 600);
        frame.setLocationRelativeTo(null); // 窗口居中
        frame.add(panel);
        frame.setVisible(true);
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\AIAnalyzerThread.java`:

```java
package Service.AIservice;

public class AIAnalyzerThread implements Runnable {
    private final String userRequest;
    private final String filePath;
    private final String startTimeStr;
    private final String endTimeStr;

    public AIAnalyzerThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        this.userRequest = userRequest;
        this.filePath = filePath;
        this.startTimeStr = startTimeStr;
        this.endTimeStr = endTimeStr;
    }

    @Override
    public void run() {
        String result = new AITransactionService().analyzeTransactions(userRequest, filePath, startTimeStr, endTimeStr);
        System.out.println("AI分析结果: " + result);
        // TODO: 如果是UI程序，可用 SwingUtilities.invokeLater() 更新UI组件
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\AITransactionService.java`:

```java
package Service.AIservice;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Constants.ConfigConstants;
import DAO.Impl.CsvTransactionDao;
import Utils.CacheUtil;
import model.Transaction;
import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;

import java.io.IOException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;
import java.util.concurrent.*;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class AITransactionService {
    private static final String API_KEY = System.getenv("ARK_API_KEY");
    private static final ArkService service = ArkService.builder()
            .timeout(Duration.ofSeconds(1800))
            .connectTimeout(Duration.ofSeconds(20))
            .baseUrl("https://ark.cn-beijing.volces.com/api/v3")
            .apiKey(API_KEY)
            .build();

    private final CsvTransactionDao transactionDao = new CsvTransactionDao();

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    private final CacheUtil<String, List<Transaction>, Exception> cache;
    /**
     * 重构构造器初始化Caffeine
     */
    public AITransactionService()  {
        // 1. 注入Dao层接口
        TransactionServiceImpl.csvTransactionDao = transactionDao;
        // 2. 初始化CacheUtil
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return transactionDao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );
    }

    public String analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        try {
            List<Transaction> transactions = cache.get(TRANSACTION_CAFFEINE_KEY);
            List<String> transactionDetails = formatTransactions(transactions, startTimeStr, endTimeStr);

            String aiPrompt = userRequest + "\n" + "以下是我的账单信息：\n" + String.join("\n", transactionDetails);
            return askAi(aiPrompt);
        } catch (Exception e) {
            e.printStackTrace();
            return "AI分析失败: " + e.getMessage();
        }
    }


    //private List<String> formatTransactions(List<Transaction> transactions) {
        //return transactions.stream().map(t -> String.format(
               // "交易时间: %s, 商品: %s, 收/支: %s, 金额: %.2f元",
               // t.getTransactionTime(),
               // t.getCommodity(),
               // t.getInOut(),
               // t.getPaymentAmount()
        //)).collect(Collectors.toList());
    //}

    public List<String> formatTransactions(List<Transaction> transactions, String startTimeStr, String endTimeStr) {
        LocalDateTime startTime = parseDateTime(startTimeStr);
        LocalDateTime endTime = (endTimeStr == null || endTimeStr.isEmpty())
                ? LocalDateTime.now()
                : parseDateTime(endTimeStr);

        if (startTime == null) {
            throw new IllegalArgumentException("起始时间格式不正确");
        }

        List<Transaction> filtered = transactions.stream()
                .filter(t -> {
                    LocalDateTime tTime = parseDateTime(t.getTransactionTime());
                    return tTime != null && !tTime.isBefore(startTime) && !tTime.isAfter(endTime);
                })
                .collect(Collectors.toList());

        Map<String, double[]> grouped = new HashMap<>();
        for (Transaction t : filtered) {
            String counterparty = t.getCounterparty();
            double amount = t.getInOut().equals("支出") ? -t.getPaymentAmount() : t.getPaymentAmount();
            grouped.putIfAbsent(counterparty, new double[]{0.0, 0});
            grouped.get(counterparty)[0] += amount;
            grouped.get(counterparty)[1] += 1;
        }

        List<String> results = grouped.entrySet().stream()
                .map(e -> {
                    String cp = e.getKey();
                    double net = e.getValue()[0];
                    int count = (int) e.getValue()[1];
                    String inOut = net >= 0 ? "收入" : "支出";
                    return String.format("交易对方: %s, 收/支: %s, 金额: %.2f元，交易次数: %d",
                            cp, inOut, Math.abs(net), count);
                })
                .collect(Collectors.toList());

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm");
        results.add(String.format("交易时间范围：%s - %s",
                formatter.format(startTime), formatter.format(endTime)));

        return results.isEmpty() ? List.of("该时间段内没有交易记录。") : results;
    }




    //private LocalDateTime parseDateTime(String timeStr) {
        // 你可以按实际情况支持不同格式，比如 yyyy/MM/dd HH:mm 或 yyyy-MM-dd HH:mm:ss
        //List<String> patterns = Arrays.asList("yyyy/MM/dd HH:mm","yyyy/MM/dd H:mm", "yyyy/M/dd H:mm","yyyy/M/dd HH:mm","yyyy/M/d H:mm","yyyy/M/d HH:mm","yyyy-MM-dd HH:mm:ss", "yyyy/MM/dd");

        //for (String pattern : patterns) {
            //try {
                //DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                //return LocalDateTime.parse(timeStr, formatter);
            //} catch (Exception ignored) {}
        //}
        //return null;
    //}
        private LocalDateTime parseDateTime(String timeStr) {
            if (timeStr == null || timeStr.trim().isEmpty()) return null;

            // 中文空格等统一清理
            timeStr = timeStr.trim().replaceAll("\\s+", " ");

            // 如果只有日期，补 00:00
            if (timeStr.matches("\\d{4}/\\d{1,2}/\\d{1,2}")) {
                timeStr += " 00:00";
            }

            // 多种时间格式尝试解析
            List<String> patterns = Arrays.asList(
                    "yyyy/M/d H:mm", "yyyy/M/d HH:mm",
                    "yyyy/MM/d H:mm", "yyyy/MM/d HH:mm",
                    "yyyy/M/dd H:mm", "yyyy/M/dd HH:mm",
                    "yyyy/MM/dd H:mm", "yyyy/MM/dd HH:mm",
                    "yyyy-MM-dd HH:mm:ss",
                    "yyyy/MM/dd"
            );

            for (String pattern : patterns) {
                try {
                    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                    return LocalDateTime.parse(timeStr, formatter);
                } catch (Exception ignored) {}
            }

            return null;
        }






    public String askAi(String prompt) {
        try {
            List<ChatMessage> messages = List.of(
                    ChatMessage.builder().role(ChatMessageRole.USER).content(prompt).build()
            );

            ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
                    .model("ep-20250308174053-7pbkq")
                    .messages(messages)
                    .build();

            return (String) service.createChatCompletion(chatCompletionRequest)
                    .getChoices().get(0).getMessage().getContent();
        } catch (Exception e) {
            e.printStackTrace();
            return "AI请求失败: " + e.getMessage();
        }
    }

    public void runAiInThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            String result = analyzeTransactions(userRequest, filePath,startTimeStr, endTimeStr);
            System.out.println("AI分析结果: " + result);
        });
        executor.shutdown();
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\ColledgeStudentThread.java`:

```java
package Service.AIservice;

import java.io.IOException;

public class ColledgeStudentThread implements Runnable{
//    private final int userRequest;
    private final String filePath;
    public String budgetRange;
    public ColledgeStudentThread( String filePath) {
//        this.userRequest = userRequest;
        this.filePath = filePath;
    }

    @Override
    public void run(){
        CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
        try {
            collegeStudentNeeds.generateBudget(filePath);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\CollegeStudentNeeds.java`:

```java
package Service.AIservice;

import Constants.ConfigConstants;
import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import model.Transaction;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class CollegeStudentNeeds {
    private final String requestBudge="我是一名预算有限的大学生，请根据下面我给出的花费，帮助我给下周预算范围，必须以[最低预算，最高预算],的方式给出回答，不能有多余的回复。";
    private final String requestTips="我是一名预算有限的大学生，请给我推荐一些省钱方法。";

    private final String requestRecognition="下面我将给你一些账单的信息，请推测这个账单是什么方面的消费: ";
    CsvTransactionDao dao;

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    private final CacheUtil<String, List<Transaction>, Exception> cache;

    public CollegeStudentNeeds() {
        TransactionServiceImpl.csvTransactionDao = dao;
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return dao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );

    }
    public String RecognizeTransaction(Transaction transaction){
        StringBuilder sb=new StringBuilder();
        sb.append("交易类型:").append(transaction.getTransactionType()+",").append("交易对方").append(transaction.getCounterparty()+",")
                .append("商品:").append(transaction.getCommodity()+",").append("收/支:").append(transaction.getInOut()+",")
                        .append("金额(元):").append(transaction.getPaymentAmount()+",").append("支付方式").append(transaction.getPaymentMethod()+",").append("备注:").append(transaction.getRemarks());
        return  new AITransactionService().askAi(requestRecognition+sb.toString());
    }

    public String generateTipsForSaving(){
        return  new AITransactionService().askAi(requestTips);
    }
    //按周统计已有的支出，依靠ai得到下周的预算
    public double[] generateBudget(String path) throws IOException {
        List<Transaction> transactions=cache.get(TRANSACTION_CAFFEINE_KEY);

        int size=transactions.size();
        if(size==0||size==1) return new double[]{-1,-1};
        int count=1;
        int base=0;
        int index=0;//指示首个适合当基准的时间点
        for (index = 0; index < size; index++) {
            int data=convertDateToNumber(transactions.get(index).getTransactionTime().split(" ")[0]);
            if(data>0){
                base=data;
                break;
            }
        }
        List<Double> list=new ArrayList<>();
        double weekConsumption=0;
        for (int i = 0; i < size; i++) {
            int data=convertDateToNumber(transactions.get(i).getTransactionTime().split(" ")[0]);
            if(data<0) continue;
            if((base-data>=0&&base-data<7)&&transactions.get(i).getInOut().equals("支出")){
                weekConsumption+=transactions.get(i).getPaymentAmount();
            }else if(base-data>=7){
                base=data;
                list.add(weekConsumption);
                count++;
                weekConsumption=0;
                if(transactions.get(i).getInOut().equals("支出")){
                    weekConsumption+=transactions.get(i).getPaymentAmount();
                }
            }
        }
        StringBuilder stringBuilder=new StringBuilder();
        for (int i = 0; i < count-1; i++) {
            stringBuilder.append("第");
            stringBuilder.append(i);
            stringBuilder.append("周:花费");
            stringBuilder.append(list.get(i));
            stringBuilder.append("元;");
        }
        String answer=new AITransactionService().askAi(requestBudge+stringBuilder.toString());
        System.out.println(answer);
        double[] ret=new double[2];
        ret=parseDoubleArrayFromString(answer);
        return ret;
    }

    private int convertDateToNumber(String date) {
        // format yyyy/MM/dd
        String[] parts = date.split("/");
        if (parts.length != 3) {
            return -1; // Invalid date format
        }
        try {
            int year = Integer.parseInt(parts[0]);
            int month = Integer.parseInt(parts[1]);
            int day = Integer.parseInt(parts[2]);
            int days = day;
            int[] daysInMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // Days in each month
            if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
                daysInMonth[2] = 29; // February has 29 days in a leap year
            }
            for (int i = 1; i < month; i++) {
                days += daysInMonth[i];
            }
            return year * 365 + (year / 4 - year / 100 + year / 400) + days;
        } catch (NumberFormatException e) {
            return -1;
        }
    }
    public double[] parseDoubleArrayFromString(String input) {
        int length=input.length();
        int l=0,rightindex=input.length();
        // 1. 去除首尾括号
        for (int i = 0; i < length; i++) {
            if(input.charAt(i)<58&&input.charAt(i)>47){
                l=i;
                break;
            }
        }
        for (int r =length-1 ; r >0; r--) {
            if(input.charAt(r)<58&&input.charAt(r)>47){
                rightindex=r;
                break;
            }
        }
        String content = input.substring(l, rightindex+1 ); // 获取 "1.1, 11.0" 或 " 2.5 ,3.14 , -0.5 "

        // 2. 按逗号分割
        String[] numberStrings1 = content.split("，"); // 得到 ["1.1", " 11.0"] 或 [" 2.5 ", "3.14 ", " -0.5 "]
        String[] numberStrings2 = content.split(","); // 得到 ["1.1", " 11.0"] 或 [" 2.5 ", "3.14 ", " -0.5 "]
        String[] numberStrings= numberStrings1.length> numberStrings2.length?numberStrings1:numberStrings2;
//        System.out.println(numberStrings[0]);
//        System.out.println(numberStrings[1]);
        // 3. & 4. 遍历、清理、解析并存储
        List<Double> numberList = new ArrayList<>();
        try {
            for (String numStr : numberStrings) {
                String trimmedStr = numStr.trim(); // 去除首尾空格
                if (!trimmedStr.isEmpty()) { // 避免分割后产生空字符串（例如 "[1.1, , 2.2]"）
                    numberList.add(Double.parseDouble(trimmedStr)); // 解析为 double
                }
            }
        } catch (NumberFormatException e) {
            System.err.println("错误：字符串无法解析为 double 类型。");
            return null; // 或者抛出异常
        }

        // 将 List<Double> 转换为 double[]
        double[] result = new double[numberList.size()];
        for (int i = 0; i < numberList.size(); i++) {
            result[i] = numberList.get(i);
        }
        return result;
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\Impl\TransactionServiceImpl.java`:

```java
package Service.Impl;

import Constants.ConfigConstants;
import DAO.Impl.CsvTransactionDao;
import Service.TransactionService;
import Utils.CacheUtil;
import model.Transaction;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class TransactionServiceImpl implements TransactionService {
    public static CsvTransactionDao csvTransactionDao;

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    public final CacheUtil<String, List<Transaction>, Exception> cache;

    /**
     * 通过构造函数注入路径和csvTransactionDao
     * @param csvTransactionDao
     * @throws IOException
     */
    public TransactionServiceImpl(CsvTransactionDao csvTransactionDao)  {
        // 1. 注入Dao层接口
        TransactionServiceImpl.csvTransactionDao = csvTransactionDao;
        // 2. 初始化CacheUtil
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return csvTransactionDao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );
    }

    /**
     * 从transactions缓存中读取transactions如果没有则从csv文件中找
     * @return
     * @throws IOException
     */
    private List<Transaction> getAllTransactions() throws Exception {
        return cache.get(TRANSACTION_CAFFEINE_KEY);
    }


    /**
     * 新增交易
     * @param transaction
     */
    @Override
    public void addTransaction(Transaction transaction) throws IOException {
        // 设置交易时间为当前时间
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
        String currentTime = now.format(formatter);
        transaction.setTransactionTime(currentTime);

        // 调用 DAO 层方法添加交易
        csvTransactionDao.addTransaction(CSV_PATH, transaction);
    }

    @Override
    public void changeTransaction(Transaction updatedTransaction) throws Exception {
        // 1. 加载所有交易记录 先加载 caffeine存储的缓存
        List<Transaction> allTransactions = getAllTransactions();

        // 2. 查找并修改目标交易
        boolean found = false;
        for (int i = 0; i < allTransactions.size(); i++) {
            Transaction t = allTransactions.get(i);
            // 根据交易单号匹配记录（唯一标识）
            if (t.getOrderNumber().equals(updatedTransaction.getOrderNumber())) {
                // 3. 更新非空字段
                updateTransactionFields(t, updatedTransaction);
                found = true;
                break;
            }
        }
        if (!found) {
            throw new IllegalArgumentException("未找到交易单号: " + updatedTransaction.getOrderNumber());
        }
        // 使用事务将写后数据写回csv文件
        csvTransactionDao.writeTransactionsToCSV(CSV_PATH, allTransactions);
        // 修改后使缓存失效 （删缓存）
        cache.invalidate("transactions");
    }

    /**
     *  辅助方法：更新非空字段
     * @param target
     * @param source
     */
    private void updateTransactionFields(Transaction target, Transaction source) {
        if (source.getTransactionTime() != null && !source.getTransactionTime().isEmpty()) {
            target.setTransactionTime(source.getTransactionTime());
        }
        if (source.getTransactionType() != null && !source.getTransactionType().isEmpty()) {
            target.setTransactionType(source.getTransactionType());
        }
        if (source.getCounterparty() != null && !source.getCounterparty().isEmpty()) {
            target.setCounterparty(source.getCounterparty());
        }
        if (source.getCommodity() != null && !source.getCommodity().isEmpty()) {
            target.setCommodity(source.getCommodity());
        }
        if (source.getInOut() != null && !source.getInOut().isEmpty()) {
            target.setInOut(source.getInOut());
        }
        if (source.getPaymentAmount() != 0.0) { // 假设金额为0表示未修改
            target.setPaymentAmount(source.getPaymentAmount());
        }
        if (source.getPaymentMethod() != null && !source.getPaymentMethod().isEmpty()) {
            target.setPaymentMethod(source.getPaymentMethod());
        }
        if (source.getCurrentStatus() != null && !source.getCurrentStatus().isEmpty()) {
            target.setCurrentStatus(source.getCurrentStatus());
        }
        if (source.getMerchantNumber() != null && !source.getMerchantNumber().isEmpty()) {
            target.setMerchantNumber(source.getMerchantNumber());
        }
        if (source.getRemarks() != null && !source.getRemarks().isEmpty()) {
            target.setRemarks(source.getRemarks());
        }
    }

    /**
     * 根据订单号删除交易 (若成功则返回true)
     * @param orderNumber
     */
    @Override
    public boolean deleteTransaction(String orderNumber) throws Exception {
        boolean result = csvTransactionDao.deleteTransaction(CSV_PATH, orderNumber);
        if (!result) {
            throw new Exception("未找到交易单号: " + orderNumber); // 或记录日志
        }
        cache.invalidate("transactions");
        return result;
    }

    /**
     * 按照查询条件查询交易信息
     * @param searchCriteria
     * @return
     */
    @Override
    public List<Transaction> searchTransaction(Transaction searchCriteria) {
        try {
            // 1. 读取所有交易记录 首先读取caffeine
            List<Transaction> allTransactions = getAllTransactions();

            // 2. 动态模糊匹配
            List<Transaction> matched = new ArrayList<>();
            for (Transaction t : allTransactions) {
                if (matchesCriteria(t, searchCriteria)) {
                    matched.add(t);
                }
            }

            // 3. 按交易时间倒序排序
            matched.sort((t1, t2) -> compareTransactionTime(t2.getTransactionTime(), t1.getTransactionTime()));

            return matched;
        } catch (IOException e) {
            e.printStackTrace();
            return List.of(); // 实际应用中应处理异常
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * 辅助方法:判断单个交易记录是否匹配条件
     * @param transaction
     * @param criteria
     * @return
     */
    private boolean matchesCriteria(Transaction transaction, Transaction criteria) {
        return (criteria.getTransactionTime() == null || containsIgnoreCase(transaction.getTransactionTime(), criteria.getTransactionTime()))
                && (criteria.getTransactionType() == null || containsIgnoreCase(transaction.getTransactionType(), criteria.getTransactionType()))
                && (criteria.getCounterparty() == null || containsIgnoreCase(transaction.getCounterparty(), criteria.getCounterparty()))
                && (criteria.getCommodity() == null || containsIgnoreCase(transaction.getCommodity(), criteria.getCommodity()))
                && (criteria.getInOut() == null || containsIgnoreCase(transaction.getInOut(), criteria.getInOut()))
                && (criteria.getPaymentMethod() == null || containsIgnoreCase(transaction.getPaymentMethod(), criteria.getPaymentMethod()));
    }

    /**
     * 辅助方法：字符串模糊匹配（空条件视为匹配）
     * @param source
     * @param target
     * @return
     */
    private boolean containsIgnoreCase(String source, String target) {
        if (target == null || target.trim().isEmpty()) return true; // 空条件不参与筛选
        if (source == null) return false;
        return source.toLowerCase().contains(target.toLowerCase().trim());
    }

    /**
     * 辅助方法：安全的时间比较（处理 null 值）
     * @param time1
     * @param time2
     * @return
     */
    private int compareTransactionTime(String time1, String time2) {
        if (time1 == null && time2 == null) return 0;
        if (time1 == null) return -1;
        if (time2 == null) return 1;
        return time2.compareTo(time1); // 倒序排序
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\TransactionService.java`:

```java
package Service;

import model.Transaction;

import java.io.IOException;
import java.util.List;

public interface TransactionService {

    /**
     * 新增交易
     * @param transaction
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * 修改交易
     * @param transaction
     */
    void changeTransaction(Transaction transaction) throws Exception;

    /**
     * 根据订单号删除交易
     * @param orderNumber
     */
    boolean deleteTransaction(String orderNumber) throws Exception;

    /**
     * 根据用户输入信息查询交易
     * @param transaction
     * @return
     */
    List<Transaction> searchTransaction(Transaction transaction);

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\deepseek\ChatCompletionsExample.java`:

```java
package Service.deepseek;

import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;
import okhttp3.ConnectionPool;
import okhttp3.Dispatcher;
import org.apache.commons.lang.StringUtils;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
public class ChatCompletionsExample {
    static String apiKey = System.getenv("ARK_API_KEY");
    static ConnectionPool connectionPool = new ConnectionPool(5, 1, TimeUnit.SECONDS);
    static Dispatcher dispatcher = new Dispatcher();
    // The output time of the reasoning model is relatively long. Please increase the timeout period.//
    static ArkService service = ArkService.builder().timeout(Duration.ofSeconds(1800)).connectTimeout(Duration.ofSeconds(20)).dispatcher(dispatcher).connectionPool(connectionPool).baseUrl("https://ark.cn-beijing.volces.com/api/v3").apiKey(apiKey).build();

//    public static void main(String[] args) {
//        System.out.println(" [Recommended]----- streaming request -----");
//        final List<ChatMessage> streamMessages = new ArrayList<>();
//        final ChatMessage streamUserMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("请回答15.11和15.9哪个大？").build();
//        streamMessages.add(streamUserMessage);
//        ChatCompletionRequest streamChatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(streamMessages)
//                .build();
//        service.streamChatCompletion(streamChatCompletionRequest)
//                .doOnError(Throwable::printStackTrace)
//                .blockingForEach(
//                        delta -> {
//                            if (!delta.getChoices().isEmpty()) {
//                                if (StringUtils.isNotEmpty(delta.getChoices().get(0).getMessage().getReasoningContent())) {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getReasoningContent());
//                                } else {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getContent());
//                                }
//                            }
//                        }
//                );
//        System.out.println(" ----- standard request -----");
//        final List<ChatMessage> messages = new ArrayList<>();
//        final ChatMessage userMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("常见的十字花科植物有哪些？").build();
//        messages.add(userMessage);
//        ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(messages)
//                .build();
//        service.createChatCompletion(chatCompletionRequest).getChoices().forEach(
//                choice -> {
//                    System.out.println(choice.getMessage().getReasoningContent());
//                    System.out.println(choice.getMessage().getContent());
//                }
//        );
//        // shutdown service after all requests is finished
//        service.shutdownExecutor();
//    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Utils\CacheUtil.java`:

```java
package Utils;

import com.github.benmanes.caffeine.cache.*;

import java.util.concurrent.TimeUnit;
import java.util.function.Function;

import com.github.benmanes.caffeine.cache.Caffeine;

/**
 * 通用缓存工具类（支持泛型和异常传播）
 * @param <K> 键类型
 * @param <V> 值类型
 * @param <E> 异常类型（如 IOException）
 */
public class CacheUtil<K, V, E extends Exception> {
    private final LoadingCache<K, V> cache;

    public CacheUtil(Function<K, V> loader,
                     int maxSize,
                     long expireAfterWrite,
                     long refreshAfterWrite) {

        this.cache = Caffeine.newBuilder()
                .maximumSize(maxSize)
                .expireAfterWrite(expireAfterWrite, TimeUnit.MINUTES)
                .refreshAfterWrite(refreshAfterWrite, TimeUnit.MINUTES)
                .build(loader::apply); // 关键修改：使用build(loader)创建LoadingCache
    }

    /**
     * 获取缓存值
     */
    public V get(K key) {
        return cache.get(key);
    }

    /**
     * 手动更新缓存
     */
    public void put(K key, V value) {
        cache.put(key, value);
    }

    /**
     * 手动移除缓存
     */
    public void invalidate(K key) {
        cache.invalidate(key);
    }
}



```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\model\Transaction.java`:

```java
package model;
//Transaction time, transaction type, transaction counterparty,
// commodity receipt/payment amount (yuan), payment method, current status,
// transaction order number, merchant order number, remarks
public class Transaction {
    private String transactionTime;
    private String transactionType;
    private String counterparty;
    private String commodity;
    private String inOut;
    private double paymentAmount;
    private String paymentMethod;
    private String currentStatus;
    private String orderNumber;
    private String merchantNumber;
    private String remarks;

    public Transaction() {
    }

    public Transaction(String transactionTime, String transactionType, String counterparty, String commodity, String inOut, double paymentAmount, String paymentMethod, String currentStatus, String orderNumber, String merchantNumber, String remarks) {
        this.transactionTime = transactionTime;
        this.transactionType = transactionType;
        this.counterparty = counterparty;
        this.commodity = commodity;
        this.inOut = inOut;
        this.paymentAmount = paymentAmount;
        this.paymentMethod = paymentMethod;
        this.currentStatus = currentStatus;
        this.orderNumber = orderNumber;
        this.merchantNumber = merchantNumber;
        this.remarks = remarks;
    }

    public String getInOut() {
        return inOut;
    }

    public void setInOut(String inOut) {
        this.inOut = inOut;
    }

    public void setTransactionTime(String transactionTime) {
        this.transactionTime = transactionTime;
    }

    public void setTransactionType(String transactionType) {
        this.transactionType = transactionType;
    }

    public void setCounterparty(String counterparty) {
        this.counterparty = counterparty;
    }

    public void setCommodity(String commodity) {
        this.commodity = commodity;
    }

    public void setPaymentAmount(double paymentAmount) {
        this.paymentAmount = paymentAmount;
    }

    public void setPaymentMethod(String paymentMethod) {
        this.paymentMethod = paymentMethod;
    }

    public void setCurrentStatus(String currentStatus) {
        this.currentStatus = currentStatus;
    }

    public void setOrderNumber(String orderNumbe) {
        this.orderNumber = orderNumbe;
    }

    public void setMerchantNumber(String merchantNumber) {
        this.merchantNumber = merchantNumber;
    }

    public void setRemarks(String remarks) {
        this.remarks = remarks;
    }

    public String getTransactionTime() {
        return transactionTime;
    }

    public String getTransactionType() {
        return transactionType;
    }

    public String getCounterparty() {
        return counterparty;
    }

    public String getCommodity() {
        return commodity;
    }

    public double getPaymentAmount() {
        return paymentAmount;
    }

    public String getPaymentMethod() {
        return paymentMethod;
    }

    public String getCurrentStatus() {
        return currentStatus;
    }

    public String getOrderNumber() {
        return orderNumber;
    }

    public String getMerchantNumber() {
        return merchantNumber;
    }

    public String getRemarks() {
        return remarks;
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\ControllerTest\AITest.java`:

```java
package ControllerTest;

import Controller.HistogramPanelContainer;
import org.junit.Test;

import javax.swing.*;
import java.awt.*;

public class AITest {

    @Test
    public void testHistogramPanel() throws Exception {
        EventQueue.invokeAndWait(() -> {
            JFrame frame = new JFrame("数据分析界面 - 测试");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });




        // 保持窗口显示一段时间，防止测试结束时窗口立即关闭
        Thread.sleep(5000);
    }

}




```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\ControllerTest\MenuUITest.java`:

```java
package ControllerTest;

import Controller.HistogramExample;
import Controller.HistogramPanelContainer;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.io.IOException;
import Controller.MenuUI;

import Service.Impl.TransactionServiceImpl;

import Service.Impl.TransactionServiceImpl;

import DAO.Impl.CsvTransactionDao;

public class MenuUITest {

    private MenuUI menuUI;

    @BeforeEach
    public void setUp() {
        menuUI = new MenuUI();

        // 手动初始化 TransactionServiceImpl 的 csvTransactionDao
        TransactionServiceImpl.csvTransactionDao = new CsvTransactionDao();
    }

    @Test
    public void testSearchFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取输入字段和搜索按钮
        JTextField transactionTimeField = findTextField(inputPanel, 0);
        JTextField transactionTypeField = findTextField(inputPanel, 1);
        JTextField counterpartyField = findTextField(inputPanel, 2);
        JTextField commodityField = findTextField(inputPanel, 3);
        JComboBox<String> inOutComboBox = findComboBox(inputPanel);
        JTextField paymentMethodField = findTextField(inputPanel, 4);
        JButton searchButton = findButton(inputPanel,"Search");

        assertNotNull(transactionTimeField, "交易时间输入字段不应为空");
        assertNotNull(transactionTypeField, "交易类型输入字段不应为空");
        assertNotNull(counterpartyField, "交易对方输入字段不应为空");
        assertNotNull(commodityField, "商品输入字段不应为空");
        assertNotNull(inOutComboBox, "收/支下拉框不应为空");
        assertNotNull(paymentMethodField, "支付方式输入字段不应为空");
        assertNotNull(searchButton, "搜索按钮不应为空");

        // 设置搜索条件
        transactionTimeField.setText("2025/3/14 11:48"); // 交易时间
        transactionTypeField.setText("商户消费");       // 交易类型
        counterpartyField.setText("物美WUMART");         // 交易对方
        commodityField.setText("扫码支付");            // 商品
        inOutComboBox.setSelectedItem("支出");     // 收/支
        paymentMethodField.setText("零钱");    // 支付方式

        // 模拟点击搜索按钮
        searchButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证搜索结果是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);

            // 验证每一行数据是否符合搜索条件
            assertTrue(rowTransactionTime.contains("2025/3/14 11:48"), "交易时间应符合搜索条件");
            assertTrue(rowTransactionType.contains("商户消费"), "交易类型应符合搜索条件");
            assertTrue(rowCounterparty.contains("物美WUMART"), "交易对方应符合搜索条件");
            assertTrue(rowCommodity.contains("扫码支付"), "商品应符合搜索条件");
            assertTrue(rowInOut.contains("支出"), "收/支应符合搜索条件");
            assertTrue(rowPaymentMethod.contains("零钱"), "支付方式应符合搜索条件");
        }
    }

    @Test
    public void testDeleteFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 获取初始行数
        int initialRowCount = tableModel.getRowCount();

        // 模拟删除第一行
        menuUI.deleteRow(0);

        // 验证行数是否减少
        assertEquals(initialRowCount - 1, tableModel.getRowCount(), "删除后行数应减少");

        // 验证删除后的数据是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            assertNotEquals("2025/3/14 11:48", rowTransactionTime, "删除的行不应再出现在表格中");
        }
    }

    @Test
    public void testEditFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 模拟编辑第一行
        menuUI.editRow(0);

        // 验证编辑后的数据是否正确
        String editedTransactionTime = (String) tableModel.getValueAt(0, 0);
        String editedTransactionType = (String) tableModel.getValueAt(0, 1);
        String editedCounterparty = (String) tableModel.getValueAt(0, 2);
        String editedCommodity = (String) tableModel.getValueAt(0, 3);
        String editedInOut = (String) tableModel.getValueAt(0, 4);
        String editedPaymentMethod = (String) tableModel.getValueAt(0, 6);

        // 验证编辑后的数据是否符合预期
        assertNotNull(editedTransactionTime, "编辑后的交易时间不应为空");
        assertNotNull(editedTransactionType, "编辑后的交易类型不应为空");
        assertNotNull(editedCounterparty, "编辑后的交易对方不应为空");
        assertNotNull(editedCommodity, "编辑后的商品不应为空");
        assertNotNull(editedInOut, "编辑后的收/支不应为空");
        assertNotNull(editedPaymentMethod, "编辑后的支付方式不应为空");
    }

    @Test
    public void testAddFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取 Add 按钮
        JButton addButton = findButton(inputPanel, "Add");
        assertNotNull(addButton, "Add 按钮不应为空");

        // 模拟点击 Add 按钮
        addButton.doClick();

        // 获取对话框
        Window[] windows = Window.getWindows();
        JDialog addDialog = null;
        for (Window window : windows) {
            if (window instanceof JDialog && "添加交易".equals(((JDialog) window).getTitle())) {
                addDialog = (JDialog) window;
                break;
            }
        }
        assertNotNull(addDialog, "添加交易的对话框应弹出");

        // 获取对话框中的输入字段
        JTextField transactionTimeField = findTextField(addDialog.getContentPane(), 0);
        JTextField transactionTypeField = findTextField(addDialog.getContentPane(), 1);
        JTextField counterpartyField = findTextField(addDialog.getContentPane(), 2);
        JTextField commodityField = findTextField(addDialog.getContentPane(), 3);
        JComboBox<String> inOutComboBox = findComboBox(addDialog.getContentPane());
        JTextField paymentAmountField = findTextField(addDialog.getContentPane(), 4);
        JTextField paymentMethodField = findTextField(addDialog.getContentPane(), 5);
        JTextField currentStatusField = findTextField(addDialog.getContentPane(), 6);
        JTextField orderNumberField = findTextField(addDialog.getContentPane(), 7);
        JTextField merchantNumberField = findTextField(addDialog.getContentPane(), 8);
        JTextField remarksField = findTextField(addDialog.getContentPane(), 9);

        // 设置新交易的输入值
        transactionTimeField.setText("2025/3/15 12:00"); // 交易时间
        transactionTypeField.setText("转账");            // 交易类型
        counterpartyField.setText("张三");               // 交易对方
        commodityField.setText("转账");                 // 商品
        inOutComboBox.setSelectedItem("支出");          // 收/支
        paymentAmountField.setText("100.0");            // 金额(元)
        paymentMethodField.setText("银行卡");           // 支付方式
        currentStatusField.setText("已完成");           // 当前状态
        orderNumberField.setText("123456789");          // 交易单号
        merchantNumberField.setText("987654321");       // 商户单号
        remarksField.setText("测试备注");               // 备注

        // 获取确认按钮
        JButton confirmButton = findButton(addDialog.getContentPane(), "确认");
        assertNotNull(confirmButton, "确认按钮不应为空");

        // 模拟点击确认按钮
        confirmButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证新交易是否添加到表格中
        boolean isTransactionAdded = false;
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentAmount = (String) tableModel.getValueAt(i, 5);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);
            String rowCurrentStatus = (String) tableModel.getValueAt(i, 7);
            String rowOrderNumber = (String) tableModel.getValueAt(i, 8);
            String rowMerchantNumber = (String) tableModel.getValueAt(i, 9);
            String rowRemarks = (String) tableModel.getValueAt(i, 10);

            if (rowTransactionTime.equals("2025/3/15 12:00") &&
                    rowTransactionType.equals("转账") &&
                    rowCounterparty.equals("张三") &&
                    rowCommodity.equals("转账") &&
                    rowInOut.equals("支出") &&
                    rowPaymentAmount.equals("100.0") &&
                    rowPaymentMethod.equals("银行卡") &&
                    rowCurrentStatus.equals("已完成") &&
                    rowOrderNumber.equals("123456789") &&
                    rowMerchantNumber.equals("987654321") &&
                    rowRemarks.equals("测试备注")) {
                isTransactionAdded = true;
                break;
            }
        }

        // 验证新交易是否成功添加
        assertTrue(isTransactionAdded, "新交易应成功添加到表格中");
    }

    /**
     * 显示界面以便手动验证
     *
     * @param panel 要显示的面板
     */
    private void showUI(JPanel panel) {
        JFrame frame = new JFrame("MenuUI Test");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(1200, 600);
        frame.add(panel);
        frame.setVisible(true);

        // 保持界面显示一段时间（5秒）
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        frame.dispose(); // 关闭界面
    }

    /**
     * 查找输入面板
     *
     * @param mainPanel 主面板
     * @return 输入面板
     */
    private JPanel findInputPanel(JPanel mainPanel) {
        // 获取右边的面板
        Component[] components = mainPanel.getComponents();
        JPanel rightPanel = null;
        for (Component component : components) {
            if (component instanceof JPanel && ((JPanel) component).getComponentCount() > 0) {
                rightPanel = (JPanel) component;
                break;
            }
        }

        if (rightPanel != null) {
            // 在右边面板中查找输入面板
            for (Component component : rightPanel.getComponents()) {
                if (component instanceof JPanel) {
                    JPanel panel = (JPanel) component;
                    System.out.println("Panel found: " + panel.getName()); // 打印面板名称
                    if (panel.getComponentCount() > 0 && panel.getComponent(0) instanceof JLabel) {
                        return panel; // 输入面板通常包含 JLabel
                    }
                }
            }
        }
        return null;
    }

    /**
     * 查找输入字段
     *
     * @param container     输入面板
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0;
        for (Component component : container.getComponents()) {
            if (component instanceof JTextField) {
                if (count == index) {
                    return (JTextField) component;
                }
                count++;
            }
        }
        return null;
    }


    /**
     * 查找下拉框
     *
     * @param container 输入面板
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) {
            if (component instanceof JComboBox) {
                return (JComboBox<String>) component;
            }
        }
        return null;
    }

    /**
     * 查找按钮
     *
     * @param panel 输入面板
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container  容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    private JButton findButton(Container container, String buttonText) {
        for (Component component : container.getComponents()) {
            if (component instanceof JButton) {
                JButton button = (JButton) component;
                if (button.getText().equals(buttonText)) {
                    return button;
                }
            }
        }
        return null;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\DAOTest\CsvTransactionDaoTest.java`:

```java
package DAOTest;

import DAO.Impl.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static Constants.ConfigConstants.CSV_PATH;
import static org.assertj.core.api.Assertions.*;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

class CsvTransactionDaoTest {
    // 测试文件路径（根据实际结构调整）
    private static final String TEST_CSV_PATH = CSV_PATH;
    private static CsvTransactionDao dao;

    @Test
    void testLoadFromCSV_ValidFile_ReturnsTransactions() throws Exception {
        // Given
        CsvTransactionDao dao = new CsvTransactionDao();

        // When
        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);

        // 验证第一条记录的字段
        for (int i = 0; i < transactions.size(); i++) {
            System.out.println(transactions.get(i).getRemarks());
            System.out.println(transactions.get(i).getCommodity());
        }


    }
    @Test
    void testAddTransaction() throws IOException {
        dao=new CsvTransactionDao();
        Transaction newTx = new Transaction(
                "2025-03-09 10:00",
                "转账",
                "小明",
                "书籍",
                "支",
                99.99,
                "微信",
                "已完成",
                "TX123456",
                "M789012",
                "");

        dao.addTransaction("src/test/resources/001.csv", newTx);

        List<Transaction> transactions = dao.loadFromCSV(TEST_CSV_PATH);

    }

    @Test
    void testDeleteTransaction() throws IOException {
        dao=new CsvTransactionDao();

        dao.deleteTransaction("CSV_RELATIVE_PATH", "4200057899202502250932735481");

        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);
    }
    @Test
    void testChangeInfo() throws IOException{
        dao=new CsvTransactionDao();
        dao.changeInformation("TX123456","remarks","测试修改信息",TEST_CSV_PATH);
        dao.changeInformation("TX123456","paymentAmount","116156",TEST_CSV_PATH);
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\AIAnalyzerThreadTest.java`:

```java
package Service;



import Service.AIservice.AIAnalyzerThread;
import org.junit.jupiter.api.Test;

public class AIAnalyzerThreadTest {

    @Test
    public void testRunAIAnalyzerThread() throws InterruptedException {
        String userRequest = "请帮我分析最近的交易收支情况";
        String filePath = "src/test/resources/sample_transactions.csv";
        String startTimeStr = "2025/03/20";
        String endTimeStr = "";

        // 启动线程
        Thread thread = new Thread(new AIAnalyzerThread(userRequest, filePath, startTimeStr, endTimeStr));
        thread.start();

        // 等待线程执行完成
        thread.join();
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\AIserviceTest.java`:

```java
package Service;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

public class AIserviceTest {

    @Test
    public void testAnalyzeTransactions() {
        AITransactionService service = new AITransactionService();

        String userRequest = "请帮我分析这个月的收支情况";
        String filePath = "src/test/resources/sample_transactions.csv";

        String result = service.analyzeTransactions(userRequest, filePath,"2025/03/20","");

        assertNotNull(result, "AI分析结果不能为空");
        System.out.println("AI分析结果: " + result);
    }


}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\AiFunctionTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

import java.io.IOException;
import java.util.List;

public class AiFunctionTest {

    @Test
    public void testAnalyzeTransactions() throws IOException {

        String filePath = "src/test/resources/sample_transactions.csv";
        CsvTransactionDao transactionDao = new CsvTransactionDao();

        List<Transaction> transactions = transactionDao.loadFromCSV(filePath);

        // 实例化服务类
        AITransactionService service = new AITransactionService();

        // 调用合并格式化函数
        List<String> result = service.formatTransactions(transactions,"2025/03/29","2025/04/10");

        // 输出结果
        result.forEach(System.out::println);
    }




}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\CacheTest.java`:

```java
package Service;

import Constants.CaffeineKeys;
import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import com.github.benmanes.caffeine.cache.Caffeine;
import model.Transaction;
import org.junit.jupiter.api.Test;

import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;

public class CacheTest {

    TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());

    @Test
    void DeleteCache(){
        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;
        cache.invalidate(TRANSACTION_CAFFEINE_KEY);
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\CollegeStudentNeedsTest.java`:

```java
package Service;

import Service.AIservice.ColledgeStudentThread;
import Service.AIservice.CollegeStudentNeeds;
import org.junit.jupiter.api.*;

import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.*;

// No @ExtendWith needed as we are not using Mockito extensions
class CollegeStudentNeedsTest {



    private CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
    private static final String TEST_CSV_FILENAME = "src/test/resources/001.csv";
    @Test
    public void testGenerateBudget() throws IOException, InterruptedException {
        Thread t=new Thread( new ColledgeStudentThread(TEST_CSV_FILENAME));
        t.start();
        t.join();
//        collegeStudentNeeds.generateBudget(TEST_CSV_FILENAME);
    }
    @Test
    public void testParseStringToDouble(){
        String s="asdas[369.39,1090.1]das";
        double[] arr=collegeStudentNeeds.parseDoubleArrayFromString(s);
        System.out.println(arr[0]+" "+arr[1]);
    }


}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\TransactionServiceTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import model.Transaction;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.io.IOException;
import java.util.List;

class TransactionServiceTest {
    private TransactionService transactionService;

    @BeforeEach
    void setUp() {
        // 初始化 DAO 和 Service
        CsvTransactionDao csvTransactionDao = new CsvTransactionDao();
        transactionService = new TransactionServiceImpl(csvTransactionDao);
    }

    @Test
    void testAddTransaction() throws IOException {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );

        // 执行添加操作
        transactionService.addTransaction(transaction);

        // 验证是否添加成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertFalse(transactions.isEmpty());
        assertEquals("T123456789", transactions.get(0).getOrderNumber());
    }

    @Test
    void testChangeTransaction() throws Exception {
        // 准备测试数据
        Transaction originalTransaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(originalTransaction);

        // 准备更新数据
        Transaction updatedTransaction = new Transaction(
                null, "充值", null, null, null, 0.0, "微信支付", null, "T123456789", null, "更新备注"
        );

        // 执行更新操作
        transactionService.changeTransaction(updatedTransaction);

        // 验证是否更新成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertEquals("充值", transactions.get(0).getTransactionType());
        assertEquals("微信支付", transactions.get(0).getPaymentMethod());
        assertEquals("更新备注", transactions.get(0).getRemarks());
    }

    @Test
    void testDeleteTransaction() throws Exception {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(transaction);

        // 执行删除操作
        boolean result = transactionService.deleteTransaction("T123456789");

        // 验证是否删除成功
        assertTrue(result);
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertTrue(transactions.isEmpty());
    }

    @Test
    void testSearchTransaction() throws IOException {

        // 设置搜索条件
        Transaction searchCriteria = new Transaction();
        searchCriteria.setCounterparty("支付宝");

        // 执行搜索操作
        List<Transaction> result = transactionService.searchTransaction(searchCriteria);

        // 验证搜索结果
        result.forEach(res -> System.out.println(res.getCommodity()));
    }


}
```
```

`软工/Ai-Bill-Application-Group21\README.md`:

```md
## Project Overview
This module is a transaction record management 
system in the Service layer of the project that connects 
with the Dao layer that provides CRUD (Create, Read, Update
, Delete) functionality and data processing for
transaction data. Core features include transaction 
creation, modification, deletion, and flexible querying,
all accessible through standardized interfaces.

## Structure and Function
Swing GUI (Controller) <- Service <- DAO <-data(CSV/JSON)<-model

##  Model 

### Overview

This Java class, located in the `model` package, serves 
as a Plain Old Java Object (POJO) or data model to 
represent a single financial transaction record. It 
encapsulates all the standard details associated with 
a transaction, such as its time, type, amount, parties 
involved, status, and unique identifiers.

This class is typically used in conjunction with Data 
Access Objects (DAOs) like `TransactionDao` and
`CsvTransactionDao` to load, save, and manipulate 
transaction data from a persistent store (e.g., a CSV 
file or database).

### Package

`model`

### Fields

The `Transaction` class contains the following fields:

* `transactionTime` (String): The date and time when the transaction occurred (e.g., "2023-10-27 15:30:00").
* `transactionType` (String): The category or type of the transaction (e.g., "在线支付" - Online Payment, "转账" - Transfer, "退款" - Refund).
* `counterparty` (String): The name or identifier of the other party involved in the transaction.
* `commodity` (String): A description of the goods, service, or reason for the transaction (e.g., "Coffee", "Salary", "Online Course Fee").
* `inOut` (String): Indicates the direction of the money flow relative to the account holder. Typically:
* `paymentAmount` (double): The monetary value of the transaction. The currency unit (e.g., Yuan) is implied by the context where this class is used (often indicated by header names like "金额(元)" in associated CSV files).
* `paymentMethod` (String): The method used for the payment (e.g., "支付宝" - Alipay, "微信支付" - WeChat Pay, "银行卡" - Bank Card, "现金" - Cash).
* `currentStatus` (String): The current processing status of the transaction (e.g., "交易成功" - Transaction Successful, "等待付款" - Awaiting Payment, "已关闭" - Closed, "退款成功" - Refund Successful).
* `orderNumber` (String): A unique identifier assigned to this specific transaction instance by the payment system or application. Often used as a primary key.
* `merchantNumber` (String): An order number or identifier associated with the merchant's system, often provided for reconciliation purposes. May be empty or null if not applicable.
* `remarks` (String): An optional field for any additional notes, comments, or user-provided descriptions about the transaction.

### Constructors

* **`public Transaction()`**
    * Default no-argument constructor. Creates an empty `Transaction` object with all fields initialized to their default values (null for String, 0.0 for double).

* **`public Transaction(String transactionTime, String transactionType, ..., String remarks)`**
    * Parameterized constructor that accepts values for all fields. Allows for quick instantiation of a fully populated `Transaction` object.

### Methods

The class provides standard public **getter** (`get...()`) and **setter** (`set...()`) methods for all its private fields. These methods allow controlled access and modification of the transaction's attributes from other parts of the application.

* `getTransactionTime()` / `setTransactionTime(String time)`
* `getTransactionType()` / `setTransactionType(String type)`
* `getCounterparty()` / `setCounterparty(String counterparty)`
* `getCommodity()` / `setCommodity(String commodity)`
* `getInOut()` / `setInOut(String inOut)`
* `getPaymentAmount()` / `setPaymentAmount(double amount)`
* `getPaymentMethod()` / `setPaymentMethod(String method)`
* `getCurrentStatus()` / `setCurrentStatus(String status)`
* `getOrderNumber()` / `setOrderNumber(String orderNumber)`
* `getMerchantNumber()` / `setMerchantNumber(String merchantNumber)`
* `getRemarks()` / `setRemarks(String remarks)`

 
### Service (Business logic)
- Responsibilities:
Transaction CRUD operations, calling the DAO layer to read and write local files,
User-defined classification logic (e.g. modifying transaction categories)
  (3) Operations:

Add Transaction:

Transaction t = new Transaction();
// Set field values
service.addTransaction(t);

Modify Transaction:

Transaction update = new Transaction();
update.setOrderNumber("ORD123");
// Set fields to update
service.changeTransaction(update);

Query Transactions:

Transaction criteria = new Transaction();
criteria.setCounterparty("Alipay");
List<Transaction> results = service.searchTransaction(criteria);
Code structure
   Directory Layout:
   src/main/java/
   └── Service/
   ├── Impl/
   │   └── TransactionServiceImpl.java  # Service implementation
   └── TransactionService.java          # Service interface
   TransactionService.java:
   Defines the service interface with business-agnostic method signatures, enforcing decoupling 
   between business logic and implementation details.
   TransactionServiceImpl.java:
   Implements the concrete business logic while depending only on the interface-defined contract, maintaining loose coupling with the data access layer through dependency injection.


- AIService (Intelligent Analytics) Responsibilities: Generate budget recommendations based
on historical data, and detect cost-cutting recommendations for seasonal spending in China
(e.g. Spring Festival) (e.g. marking high-frequency small spending)


- **`AITransactionService`**

The central class that performs the full AI-driven transaction analysis. It:

- Loads transaction data from a CSV file via `CsvTransactionDao`.
- Filters transactions by user-specified time range (`startTimeStr`, `endTimeStr`).
- Aggregates data by counterparty (income/spending, transaction counts).
- Formats the result into concise summaries sent to the AI.
- Sends user questions and formatted data to the Volcengine Ark AI API.
- Returns a response within **400 characters** for efficient display.

Key methods:
- `analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr)`
  → Returns an AI-generated analysis result string.
- `runAiInThread(...)`
  → Runs the AI logic in a background thread (single-threaded executor).
- `formatTransactions(...)`
  → Groups transactions and summarizes them by counterparty and time range.
- `parseDateTime(...)`
  → Supports flexible input formats like `yyyy/MM/dd`, `yyyy/MM/dd HH:mm`, and more. - **`AIAnalyzerThread`** A `Runnable` implementation for threading scenarios (especially GUI usage). It calls `AITransactionService.analyzeTransactions(...)` and prints the result. UI developers can replace the console output with GUI updates using `SwingUtilities.invokeLater()`. --- ### Tests (`test/java/Service/AIservice/`) - **`AIserviceTest`** Unit tests for `AITransactionService`, verifying: - Correct loading and filtering of transactions. - Accurate AI response generation and formatting. - Graceful handling of edge cases (e.g., no transactions in range, invalid time formats). - **`AIAnalyzerThreadTest`** Validates threading logic: - Ensures `AIAnalyzerThread` executes `Runnable` correctly. - Demonstrates clean and concurrent AI analysis flow. - Simulates integration with a GUI environment. - **`AiFunctionTest`** Utility-level tests: - Ensures proper CSV parsing and data transformation. - Verifies output formatting before sending to the AI. - Tests various time formats and edge case behaviors

## DAO (File Storage)
- Responsibilities: Save transaction data in CSV or JSON format and provide interfaces for adding,
  deleting, and modifying in-memory data
### CsvTransactionDao Class

#### Package

`DAO`

#### Dependencies

* **`model.Transaction`**: The data model class representing a single transaction.
* **`DAO.TransactionDao`**: The interface this class is intended to implement (though the implementation is incomplete).
* **Apache Commons CSV (`org.apache.commons.csv.*`)**: Used for robust parsing and writing of CSV data.
* **Apache Commons IO (`org.apache.commons.io.input.BOMInputStream`)**: Used specifically to handle potential Byte Order Marks (BOM) often found in UTF-8 encoded files, particularly those edited in Windows.
* **Java Standard Libraries**: `java.io.*`, `java.nio.*`.

#### Key Features & Implementation Details

* **CSV Loading (`loadFromCSV`)**:
  * Reads data from a specified CSV file path.
  * Expects UTF-8 encoding.
  * Handles potential Byte Order Mark (BOM) at the beginning of the file.
  * Uses the first row of the CSV as the header to map columns to `Transaction` fields. Assumes specific header names (e.g., "交易时间", "交易类型", "金额(元)").
  * Parses transaction records into a `List<Transaction>`.
  * Includes basic caching using an internal `transactions` list and an `isLoad` flag to avoid redundant file reads within the same instance lifecycle (unless forced by methods like `deleteTransaction` or `changeInformation`).
* **Record Parsing (`parseRecord`)**:
  * Converts a `CSVRecord` object (from Apache Commons CSV) into a `Transaction` object.
  * Specifically handles the "金额(元)" (Amount) field by removing the leading "¥" symbol before parsing it as a `double`.
* **Adding Transactions (`addTransaction(String filePath, Transaction newTransaction)`)**:
  * **Appends** a new transaction record to the *end* of the specified CSV file.
  * Creates the file if it doesn't exist.
  * Writes the header row only if the file is new or was empty.
  * Formats the payment amount by prepending "¥".
* **Deleting Transactions (`deleteTransaction(String filePath, String orderNumber)`)**:
  * Loads data from the file if not already cached.
  * Filters the cached list to remove the transaction matching the given `orderNumber`.
  * **Overwrites** the *entire* original CSV file with the filtered list using `writeTransactionsToCSV`.
  * Returns `true` if a transaction was removed, `false` otherwise.
* **Updating Transactions (`changeInformation`)**:
  * Loads data if not already cached.
  * Finds the transaction by `orderNumber`.
  * Modifies the specified field (`head`) of the found transaction object in memory.
  * **Crucially, it attempts the update by first *deleting* the original record (using `deleteTransaction`, which overwrites the file) and then *adding* the modified record (using `addTransaction`, which appends to the file).** This logic is inefficient and potentially problematic due to the conflicting file write strategies (overwrite vs. append).
  * Error handling for invalid `head` parameters prints to `System.err`. The method often returns `true` even if the underlying delete/add fails.
* **CSV Writing (`writeTransactionsToCSV`)**:
  * Helper method used by `deleteTransaction`.
  * Writes a given `List<Transaction>` to the specified file path, **overwriting** any existing content.
  * Writes a standard header row.
  * Formats the payment amount by prepending "¥".

#### Important Issues & Considerations

1.  **Incomplete `TransactionDao` Implementation**: The methods declared in the `TransactionDao` interface (`getAllTransactions`, `addTransaction(Transaction)`, `deleteTransaction(String)`, `updateTransaction`, `getTransactionByOrderNumber`) are present but contain only placeholder/stub code. The actual working logic uses separate methods that require the `filePath` to be passed explicitly each time. **This class, in its current state, does not correctly function as a `TransactionDao` implementation.**
2.  **Inconsistent File Writing Strategy**: `addTransaction` *appends* to the file, while `deleteTransaction` and `writeTransactionsToCSV` (used by `deleteTransaction` and `changeInformation`) *overwrite* the entire file. This inconsistency can lead to unexpected behavior, especially within the `changeInformation` method.
3.  **Inefficient Updates/Deletes**: Rewriting the entire CSV file for every single deletion or modification (`changeInformation`) is highly inefficient, especially for large transaction files.
4.  **Flawed Update Logic (`changeInformation`)**: The delete-then-add approach for updates is problematic due to the inconsistent write strategies and potential race conditions or partial failures. The modified record will likely appear at the *end* of the file, not its original position.
5.  **Basic Caching**: The caching mechanism (`isLoad` flag) is simple and does not account for external modifications to the CSV file during the application's runtime.
6.  **Hardcoded Dependencies**: The code relies on specific header names (in Chinese) and the "¥" currency symbol format within the CSV data. Changes to the CSV format would require code modifications.

#### Usage Example (Using Functional Methods)

```java
import DAO.Impl.CsvTransactionDao; // Assuming TransactionDao interface exists but is not used directly here due to stub methods
import model.Transaction;
import java.io.IOException;
import java.util.List;

public class CsvDataManager {

    public static void main(String[] args) {
        // NOTE: Using the class directly, not via the TransactionDao interface
        // because the interface methods are not fully implemented.
        CsvTransactionDao csvDao = new CsvTransactionDao();
        String csvFilePath = "path/to/your/transactions.csv"; // <--- Specify your file path

        try {
            // --- Load Data ---
            System.out.println("Loading transactions...");
            List<Transaction> transactions = csvDao.loadFromCSV(csvFilePath);
            System.out.println("Loaded " + transactions.size() + " transactions.");
            // Display first transaction if available
            if (!transactions.isEmpty()) {
                 System.out.println("First transaction order number: " + transactions.get(0).getOrderNumber());
            }

            // --- Add a New Transaction (Appends) ---
            Transaction newTx = new Transaction(
                 "2025-04-20 08:14:00", "Test Add", "Counterparty", "Item", "支",
                 10.0, "支付宝", "交易成功", "NEW_ORDER_123", "MERCH_456", "Test via DAO add"
            );
            System.out.println("\nAdding new transaction (append): " + newTx.getOrderNumber());
            // csvDao.addTransaction(csvFilePath, newTx); // Uncomment to actually add
            System.out.println("Transaction potentially added.");

            // --- Delete a Transaction (Overwrites File) ---
            String orderToDelete = "SOME_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number from your file
            System.out.println("\nAttempting to delete transaction: " + orderToDelete);
            // boolean deleted = csvDao.deleteTransaction(csvFilePath, orderToDelete); // Uncomment to actually delete
            // if (deleted) {
            //     System.out.println("Transaction deleted successfully (File rewritten).");
            // } else {
            //     System.out.println("Transaction not found for deletion.");
            // }

            // --- Change Information (Overwrites then Appends - Use with Caution) ---
             String orderToChange = "ANOTHER_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number
             String fieldToChange = "remarks";
             String newValue = "Updated remark via changeInformation";
             System.out.println("\nAttempting to change info for: " + orderToChange);
             // boolean changed = csvDao.changeInformation(orderToChange, fieldToChange, newValue, csvFilePath); // Uncomment with caution
             // System.out.println("Change operation attempted (File rewritten and appended). Result: " + changed);


        } catch (IOException e) {
            System.err.println("Error interacting with CSV file: " + e.getMessage());
            e.printStackTrace();
        } catch (NumberFormatException e) {
            System.err.println("Error parsing amount in CSV: " + e.getMessage());
        }
    }
}
```

## Controller (Swing GUI)

Responsibilities: Manage user interface components (buttons, tables, text boxes) to listen for 
events (clicks, inputs) and call service layer methods to update the interface data display

## attention
encoding with UTF-8

```

`软工/Ai-Bill-Application-Group21\README.txt`:

```txt
## Project Overview

This module is a transaction record management 
system in the Service layer of the project that connects 
with the Dao layer that provides CRUD (Create, Read, Update
, Delete) functionality and data processing for
transaction data. Core features include transaction 
creation, modification, deletion, and flexible querying,
all accessible through standardized interfaces.

## Structure and Function

Swing GUI (Controller) <- Service <- DAO <-data(CSV/JSON)<-model

##  Model 

### Overview

This Java class, located in the `model` package, serves 
as a Plain Old Java Object (POJO) or data model to 
represent a single financial transaction record. It 
encapsulates all the standard details associated with 
a transaction, such as its time, type, amount, parties 
involved, status, and unique identifiers.

This class is typically used in conjunction with Data 
Access Objects (DAOs) like `TransactionDao` and
`CsvTransactionDao` to load, save, and manipulate 
transaction data from a persistent store (e.g., a CSV 
file or database).

### Package

`model`

### Fields

The `Transaction` class contains the following fields:

* `transactionTime` (String): The date and time when the transaction occurred (e.g., "2023-10-27 15:30:00").
* `transactionType` (String): The category or type of the transaction (e.g., "在线支付" - Online Payment, "转账" - Transfer, "退款" - Refund).
* `counterparty` (String): The name or identifier of the other party involved in the transaction.
* `commodity` (String): A description of the goods, service, or reason for the transaction (e.g., "Coffee", "Salary", "Online Course Fee").
* `inOut` (String): Indicates the direction of the money flow relative to the account holder. Typically:
* `paymentAmount` (double): The monetary value of the transaction. The currency unit (e.g., Yuan) is implied by the context where this class is used (often indicated by header names like "金额(元)" in associated CSV files).
* `paymentMethod` (String): The method used for the payment (e.g., "支付宝" - Alipay, "微信支付" - WeChat Pay, "银行卡" - Bank Card, "现金" - Cash).
* `currentStatus` (String): The current processing status of the transaction (e.g., "交易成功" - Transaction Successful, "等待付款" - Awaiting Payment, "已关闭" - Closed, "退款成功" - Refund Successful).
* `orderNumber` (String): A unique identifier assigned to this specific transaction instance by the payment system or application. Often used as a primary key.
* `merchantNumber` (String): An order number or identifier associated with the merchant's system, often provided for reconciliation purposes. May be empty or null if not applicable.
* `remarks` (String): An optional field for any additional notes, comments, or user-provided descriptions about the transaction.

### Constructors

* **`public Transaction()`**
  * Default no-argument constructor. Creates an empty `Transaction` object with all fields initialized to their default values (null for String, 0.0 for double).

* **`public Transaction(String transactionTime, String transactionType, ..., String remarks)`**
  * Parameterized constructor that accepts values for all fields. Allows for quick instantiation of a fully populated `Transaction` object.

### Methods

The class provides standard public **getter** (`get...()`) and **setter** (`set...()`) methods for all its private fields. These methods allow controlled access and modification of the transaction's attributes from other parts of the application.

* `getTransactionTime()` / `setTransactionTime(String time)`
* `getTransactionType()` / `setTransactionType(String type)`
* `getCounterparty()` / `setCounterparty(String counterparty)`
* `getCommodity()` / `setCommodity(String commodity)`
* `getInOut()` / `setInOut(String inOut)`
* `getPaymentAmount()` / `setPaymentAmount(double amount)`
* `getPaymentMethod()` / `setPaymentMethod(String method)`
* `getCurrentStatus()` / `setCurrentStatus(String status)`
* `getOrderNumber()` / `setOrderNumber(String orderNumber)`
* `getMerchantNumber()` / `setMerchantNumber(String merchantNumber)`
* `getRemarks()` / `setRemarks(String remarks)`


### Service (Business logic)

- Responsibilities:
  Transaction CRUD operations, calling the DAO layer to read and write local files,
  User-defined classification logic (e.g. modifying transaction categories)
  (3) Operations:

Add Transaction:

Transaction t = new Transaction();
// Set field values
service.addTransaction(t);

Modify Transaction:

Transaction update = new Transaction();
update.setOrderNumber("ORD123");
// Set fields to update
service.changeTransaction(update);

Query Transactions:

Transaction criteria = new Transaction();
criteria.setCounterparty("Alipay");
List<Transaction> results = service.searchTransaction(criteria);
Code structure
   Directory Layout:
   src/main/java/
   └── Service/
   ├── Impl/
   │   └── TransactionServiceImpl.java  # Service implementation
   └── TransactionService.java          # Service interface
   TransactionService.java:
   Defines the service interface with business-agnostic method signatures, enforcing decoupling 
   between business logic and implementation details.
   TransactionServiceImpl.java:
   Implements the concrete business logic while depending only on the interface-defined contract, maintaining loose coupling with the data access layer through dependency injection.


- AIService (Intelligent Analytics) Responsibilities: Generate budget recommendations based
  on historical data, and detect cost-cutting recommendations for seasonal spending in China
  (e.g. Spring Festival) (e.g. marking high-frequency small spending)


- **`AITransactionService`**

The central class that performs the full AI-driven transaction analysis. It:

- Loads transaction data from a CSV file via `CsvTransactionDao`.
- Filters transactions by user-specified time range (`startTimeStr`, `endTimeStr`).
- Aggregates data by counterparty (income/spending, transaction counts).
- Formats the result into concise summaries sent to the AI.
- Sends user questions and formatted data to the Volcengine Ark AI API.
- Returns a response within **400 characters** for efficient display.

Key methods:

- `analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr)`
  → Returns an AI-generated analysis result string.
- `runAiInThread(...)`
  → Runs the AI logic in a background thread (single-threaded executor).
- `formatTransactions(...)`
  → Groups transactions and summarizes them by counterparty and time range.
- `parseDateTime(...)`
  → Supports flexible input formats like `yyyy/MM/dd`, `yyyy/MM/dd HH:mm`, and more. - **`AIAnalyzerThread`** A `Runnable` implementation for threading scenarios (especially GUI usage). It calls `AITransactionService.analyzeTransactions(...)` and prints the result. UI developers can replace the console output with GUI updates using `SwingUtilities.invokeLater()`. --- ### Tests (`test/java/Service/AIservice/`) - **`AIserviceTest`** Unit tests for `AITransactionService`, verifying: - Correct loading and filtering of transactions. - Accurate AI response generation and formatting. - Graceful handling of edge cases (e.g., no transactions in range, invalid time formats). - **`AIAnalyzerThreadTest`** Validates threading logic: - Ensures `AIAnalyzerThread` executes `Runnable` correctly. - Demonstrates clean and concurrent AI analysis flow. - Simulates integration with a GUI environment. - **`AiFunctionTest`** Utility-level tests: - Ensures proper CSV parsing and data transformation. - Verifies output formatting before sending to the AI. - Tests various time formats and edge case behaviors

## DAO (File Storage)

- Responsibilities: Save transaction data in CSV or JSON format and provide interfaces for adding,
  deleting, and modifying in-memory data

### CsvTransactionDao Class

#### Package

`DAO`

#### Dependencies

* **`model.Transaction`**: The data model class representing a single transaction.
* **`DAO.TransactionDao`**: The interface this class is intended to implement (though the implementation is incomplete).
* **Apache Commons CSV (`org.apache.commons.csv.*`)**: Used for robust parsing and writing of CSV data.
* **Apache Commons IO (`org.apache.commons.io.input.BOMInputStream`)**: Used specifically to handle potential Byte Order Marks (BOM) often found in UTF-8 encoded files, particularly those edited in Windows.
* **Java Standard Libraries**: `java.io.*`, `java.nio.*`.

#### Key Features & Implementation Details

* **CSV Loading (`loadFromCSV`)**:
  * Reads data from a specified CSV file path.
  * Expects UTF-8 encoding.
  * Handles potential Byte Order Mark (BOM) at the beginning of the file.
  * Uses the first row of the CSV as the header to map columns to `Transaction` fields. Assumes specific header names (e.g., "交易时间", "交易类型", "金额(元)").
  * Parses transaction records into a `List<Transaction>`.
  * Includes basic caching using an internal `transactions` list and an `isLoad` flag to avoid redundant file reads within the same instance lifecycle (unless forced by methods like `deleteTransaction` or `changeInformation`).
* **Record Parsing (`parseRecord`)**:
  * Converts a `CSVRecord` object (from Apache Commons CSV) into a `Transaction` object.
  * Specifically handles the "金额(元)" (Amount) field by removing the leading "¥" symbol before parsing it as a `double`.
* **Adding Transactions (`addTransaction(String filePath, Transaction newTransaction)`)**:
  * **Appends** a new transaction record to the *end* of the specified CSV file.
  * Creates the file if it doesn't exist.
  * Writes the header row only if the file is new or was empty.
  * Formats the payment amount by prepending "¥".
* **Deleting Transactions (`deleteTransaction(String filePath, String orderNumber)`)**:
  * Loads data from the file if not already cached.
  * Filters the cached list to remove the transaction matching the given `orderNumber`.
  * **Overwrites** the *entire* original CSV file with the filtered list using `writeTransactionsToCSV`.
  * Returns `true` if a transaction was removed, `false` otherwise.
* **Updating Transactions (`changeInformation`)**:
  * Loads data if not already cached.
  * Finds the transaction by `orderNumber`.
  * Modifies the specified field (`head`) of the found transaction object in memory.
  * **Crucially, it attempts the update by first *deleting* the original record (using `deleteTransaction`, which overwrites the file) and then *adding* the modified record (using `addTransaction`, which appends to the file).** This logic is inefficient and potentially problematic due to the conflicting file write strategies (overwrite vs. append).
  * Error handling for invalid `head` parameters prints to `System.err`. The method often returns `true` even if the underlying delete/add fails.
* **CSV Writing (`writeTransactionsToCSV`)**:
  * Helper method used by `deleteTransaction`.
  * Writes a given `List<Transaction>` to the specified file path, **overwriting** any existing content.
  * Writes a standard header row.
  * Formats the payment amount by prepending "¥".

#### Important Issues & Considerations

1.  **Incomplete `TransactionDao` Implementation**: The methods declared in the `TransactionDao` interface (`getAllTransactions`, `addTransaction(Transaction)`, `deleteTransaction(String)`, `updateTransaction`, `getTransactionByOrderNumber`) are present but contain only placeholder/stub code. The actual working logic uses separate methods that require the `filePath` to be passed explicitly each time. **This class, in its current state, does not correctly function as a `TransactionDao` implementation.**
2.  **Inconsistent File Writing Strategy**: `addTransaction` *appends* to the file, while `deleteTransaction` and `writeTransactionsToCSV` (used by `deleteTransaction` and `changeInformation`) *overwrite* the entire file. This inconsistency can lead to unexpected behavior, especially within the `changeInformation` method.
3.  **Inefficient Updates/Deletes**: Rewriting the entire CSV file for every single deletion or modification (`changeInformation`) is highly inefficient, especially for large transaction files.
4.  **Flawed Update Logic (`changeInformation`)**: The delete-then-add approach for updates is problematic due to the inconsistent write strategies and potential race conditions or partial failures. The modified record will likely appear at the *end* of the file, not its original position.
5.  **Basic Caching**: The caching mechanism (`isLoad` flag) is simple and does not account for external modifications to the CSV file during the application's runtime.
6.  **Hardcoded Dependencies**: The code relies on specific header names (in Chinese) and the "¥" currency symbol format within the CSV data. Changes to the CSV format would require code modifications.

#### Usage Example (Using Functional Methods)

```java
import DAO.Impl.CsvTransactionDao; // Assuming TransactionDao interface exists but is not used directly here due to stub methods
import model.Transaction;
import java.io.IOException;
import java.util.List;

public class CsvDataManager {

    public static void main(String[] args) {
        // NOTE: Using the class directly, not via the TransactionDao interface
        // because the interface methods are not fully implemented.
        CsvTransactionDao csvDao = new CsvTransactionDao();
        String csvFilePath = "path/to/your/transactions.csv"; // <--- Specify your file path

        try {
            // --- Load Data ---
            System.out.println("Loading transactions...");
            List<Transaction> transactions = csvDao.loadFromCSV(csvFilePath);
            System.out.println("Loaded " + transactions.size() + " transactions.");
            // Display first transaction if available
            if (!transactions.isEmpty()) {
                 System.out.println("First transaction order number: " + transactions.get(0).getOrderNumber());
            }

            // --- Add a New Transaction (Appends) ---
            Transaction newTx = new Transaction(
                 "2025-04-20 08:14:00", "Test Add", "Counterparty", "Item", "支",
                 10.0, "支付宝", "交易成功", "NEW_ORDER_123", "MERCH_456", "Test via DAO add"
            );
            System.out.println("\nAdding new transaction (append): " + newTx.getOrderNumber());
            // csvDao.addTransaction(csvFilePath, newTx); // Uncomment to actually add
            System.out.println("Transaction potentially added.");

            // --- Delete a Transaction (Overwrites File) ---
            String orderToDelete = "SOME_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number from your file
            System.out.println("\nAttempting to delete transaction: " + orderToDelete);
            // boolean deleted = csvDao.deleteTransaction(csvFilePath, orderToDelete); // Uncomment to actually delete
            // if (deleted) {
            //     System.out.println("Transaction deleted successfully (File rewritten).");
            // } else {
            //     System.out.println("Transaction not found for deletion.");
            // }

            // --- Change Information (Overwrites then Appends - Use with Caution) ---
             String orderToChange = "ANOTHER_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number
             String fieldToChange = "remarks";
             String newValue = "Updated remark via changeInformation";
             System.out.println("\nAttempting to change info for: " + orderToChange);
             // boolean changed = csvDao.changeInformation(orderToChange, fieldToChange, newValue, csvFilePath); // Uncomment with caution
             // System.out.println("Change operation attempted (File rewritten and appended). Result: " + changed);


        } catch (IOException e) {
            System.err.println("Error interacting with CSV file: " + e.getMessage());
            e.printStackTrace();
        } catch (NumberFormatException e) {
            System.err.println("Error parsing amount in CSV: " + e.getMessage());
        }
    }
}
```

## Controller (Swing GUI)

Responsibilities: Manage user interface components (buttons, tables, text boxes) to listen for 
events (clicks, inputs) and call service layer methods to update the interface data display

## attention

encoding with UTF-8
```

`软工/Ai-Bill-Application-Group21\项目要求.txt`:

```txt
1. General Information 
In the next few weeks, your team will be required to develop a software application that 
will serve as a smart personal finance manager that helps users track expenses, set 
savings goals, and analyses spending habits using AI. Agile methods should be applied 
in all activities, from requirements through analysis/design, implementation, and testing. 
Iterations should be planned, and outcomes should be submitted. 
There are no restrictions on what you can include in the final product, and the given 
specification contains only high-level abstract requirements. It should be noted that 
determining the software requirements is one of the most important and complex phases 
in any development project. You should apply requirement-finding techniques and Agile 
methods to identify the actual requirements at an appropriate level. Most importantly, you 
need to prioritize the features that are implemented in accordance with both ease of 
implementation and meeting requirements. As in real software, you should define the 
project scope properly. Keep your design SIMPLE. Bear in mind that there is no absolute 
right answer – your solution may be perfectly appropriate.

2. Project Specification 
2.1 Basic Requirements 
Managing personal finances effectively is crucial in today’s digital economy, where 
transactions occur across multiple platforms like WeChat Pay, Alipay, and traditional 
banking. Many individuals struggle with tracking expenses, categorizing spending, and 
setting realistic budgets. An AI-powered personal finance tracker simplifies financial 
management by automatically classifying transactions, detecting spending patterns, and 
offering personalized savings recommendations. However, AI is not perfect – users must 
manually review to ensure accuracy. By integrating AI with manual validation, this 
software helps users make informed financial decisions while adapting to regional 
spending habits and economic conditions, improving financial literacy and budgeting 
skills. Here are some suggested functions to assist you in getting started. Suggested 
features can include the following, but not limited to: 
• Manual & Automated Data Entry: End users may input transactions manually or 
import structured CSV files from banking/financial apps. 
• Expense Categorisation (AI + Manual Correction): AI classifies transactions into 
categories (e.g., groceries, rent, entertainment), but end users can verify & correct 
misclassifications. 
• Spending Insights & Predictions: AI suggests monthly budgets, savings goals, and 
cost-cutting recommendations based on spending behaviour. 
• Local Financial Context: Customisable to China-specific budgeting habits, for 
example detects seasonal spending habits, such as higher expenses during Chinese 
New Year. 
A full prototype of the application should be produced. It is not required to implement the 
full working code for all functions in the prototype, however your team should implement 
core functions of your choice. 

2.2 Other Requirements 
• The software must be developed using Java as a stand-alone application running 
on computers. A simple graphic user interface (GUI) should be used. The recent 
Java Edition should be used. Do NOT build a Web-based application or Phone 
App. 
• All input and output data should be in simple text file format. You may use plain 
text (txt), CSV, JSON, or XML. Do NOT use a database. 
• Basic restrictions and error checking must be considered. 
• Your design must be flexible and extensible to adapt to future changes, e.g. 
modify existing features and add new features. When doing so, you should be 
able to reuse the existing components and make the least impact on the existing 
code. 
Page 2 of 8 
Your tasks are to define detailed requirements, design, develop and test the above software 
using Agile methods. Feel free to design the software as long as it satisfies the basic 
requirements, define the SCOPE properly.  

2.3 AI-Assisted Development 
To prevent over-reliance on AI, 
the following constraints apply: 
• Live Data Collection: AI cannot generate user-specific data patterns – you must 
gather real data. 请给出相应的数据搜集渠道（但是我们已经设计好了csv表，相应字段也设计了）
• Manual Data Cleaning and Validation: AI assistance is allowed, but the team must 
need to manually check for missing information, inconsistency, and inappropriate 
categorisation, etc. 
• Context-Specific Constraints: AI may struggle with domain-specific rules – you 
must implement real-world constraints (e.g. AI may count a WeChat Red Packet as a 
personal income where it is in fact a gift money and not a regular income.) 
• Oral Spot-Check: During the vivas, you will need to answer questions like “Why did 
AI make this recommendation?”, “How did you modify AI’s solution?”, etc, to 
demonstrate your understanding.
```

`软工/Submission\Labs\lab5\lab5.iml`:

```iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="GENERAL_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="module-library">
      <library name="JUnit4">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/junit/junit/4.13.1/junit-4.13.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="JUnit5.8.1">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter/5.8.1/junit-jupiter-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-api/5.8.1/junit-jupiter-api-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/opentest4j/opentest4j/1.2.0/opentest4j-1.2.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-commons/1.8.1/junit-platform-commons-1.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-params/5.8.1/junit-jupiter-params-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-engine/5.8.1/junit-jupiter-engine-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-engine/1.8.1/junit-platform-engine-1.8.1.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
  </component>
</module>
```

`软工/Submission\Labs\lab5\out\production\lab5\lab5.iml`:

```iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="GENERAL_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="module-library">
      <library name="JUnit4">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/junit/junit/4.13.1/junit-4.13.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="JUnit5.8.1">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter/5.8.1/junit-jupiter-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-api/5.8.1/junit-jupiter-api-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/opentest4j/opentest4j/1.2.0/opentest4j-1.2.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-commons/1.8.1/junit-platform-commons-1.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-params/5.8.1/junit-jupiter-params-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-engine/5.8.1/junit-jupiter-engine-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-engine/1.8.1/junit-platform-engine-1.8.1.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
  </component>
</module>
```

`软工/Submission\Labs\lab5\src\main\java\DegreeClassifier.java`:

```java
package src.main.java;

public class DegreeClassifier {
    /**
     * Classifies a degree based on the average mark.
     *
     * @param averageMark The average mark of the degree.
     * @return The classification of the degree.
     */
    public String classify(double averageMark) {
        if (averageMark >= 70) {
            return "First-Class";
        } else if (averageMark >= 60) {
            return "Upper Second-Class";
        } else if (averageMark >= 50) {
            return "Lower Second-Class";
        } else if (averageMark >= 40) {
            return "Third-Class";
        } else {
            return "Non-Honours";
        }
    }
}
```

`软工/Submission\Labs\lab5\src\test\java\DegreeClassifierTest.java`:

```java
package src.test.java;

import org.junit.jupiter.api.Test;
import src.main.java.DegreeClassifier;

import static org.junit.jupiter.api.Assertions.*;

public class DegreeClassifierTest {
    // We can see that all the test examples ran successfully !
    @Test
    public void testFirstClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("First-Class", classifier.classify(85));
    }

    @Test
    public void testUpperSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Upper Second-Class", classifier.classify(65));
    }

    @Test
    public void testLowerSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Lower Second-Class", classifier.classify(55));
    }

    @Test
    public void testThirdClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Third-Class", classifier.classify(45));
    }

    @Test
    public void testNonHonours() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Non-Honours", classifier.classify(35));
    }
}
```

`软工/Submission\Labs\lab6\lab6.iml`:

```iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="GENERAL_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="module-library">
      <library name="JUnit4">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/junit/junit/4.13.1/junit-4.13.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="JUnit5.8.1">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter/5.8.1/junit-jupiter-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-api/5.8.1/junit-jupiter-api-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/opentest4j/opentest4j/1.2.0/opentest4j-1.2.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-commons/1.8.1/junit-platform-commons-1.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-params/5.8.1/junit-jupiter-params-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-engine/5.8.1/junit-jupiter-engine-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-engine/1.8.1/junit-platform-engine-1.8.1.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="testng">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/testng/testng/7.1.0/testng-7.1.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/com/beust/jcommander/1.72/jcommander-1.72.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/com/google/inject/guice/4.1.0/guice-4.1.0-no_aop.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/javax/inject/javax.inject/1/javax.inject-1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/aopalliance/aopalliance/1.0/aopalliance-1.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/com/google/guava/guava/19.0/guava-19.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/yaml/snakeyaml/1.21/snakeyaml-1.21.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
  </component>
</module>
```

`软工/Submission\Labs\lab6\out\production\lab6\lab6.iml`:

```iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="GENERAL_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="module-library">
      <library name="JUnit4">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/junit/junit/4.13.1/junit-4.13.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="JUnit5.8.1">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter/5.8.1/junit-jupiter-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-api/5.8.1/junit-jupiter-api-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/opentest4j/opentest4j/1.2.0/opentest4j-1.2.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-commons/1.8.1/junit-platform-commons-1.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-params/5.8.1/junit-jupiter-params-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-engine/5.8.1/junit-jupiter-engine-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-engine/1.8.1/junit-platform-engine-1.8.1.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="testng">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/testng/testng/7.1.0/testng-7.1.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/com/beust/jcommander/1.72/jcommander-1.72.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/com/google/inject/guice/4.1.0/guice-4.1.0-no_aop.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/javax/inject/javax.inject/1/javax.inject-1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/aopalliance/aopalliance/1.0/aopalliance-1.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/com/google/guava/guava/19.0/guava-19.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/yaml/snakeyaml/1.21/snakeyaml-1.21.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
  </component>
</module>
```

`软工/Submission\Labs\lab6\src\main\java\DegreeClassifier.java`:

```java
package src.main.java;


/**
 * First Mutation
 */
//public class DegreeClassifier {
//    public String classify(double averageMark) {
//        if (averageMark > 70) { // Turn >= into >
//            return "First-Class";
//        } else if (averageMark >= 60) {
//            return "Upper Second-Class";
//        } else if (averageMark >= 50) {
//            return "Lower Second-Class";
//        } else if (averageMark >= 40) {
//            return "Third-Class";
//        } else {
//            return "Non-Honours";
//        }
//    }
//}

/**
 * Second Mutation Now we run the 2nd mutation test
 */
//public class DegreeClassifier {
//    public String classify(double averageMark) {
//        if (averageMark >= 70) {
//            return "First-Class";
//        } else if (averageMark > 60) { // Turn >= into > this time we change this
//            return "Upper Second-Class";
//        } else if (averageMark >= 50) {
//            return "Lower Second-Class";
//        } else if (averageMark >= 40) {
//            return "Third-Class";
//        } else {
//            return "Non-Honours";
//        }
//    }
//}

/**
 * Third Mutation last mutation test
 */
public class DegreeClassifier {
    public String classify(double averageMark) {
        if (averageMark >= 70) {
            return "First-Class";
        } else if (averageMark >= 60) {
            return "Upper Second-Class";
        } else if (averageMark >= 50) {
            return "Lower Second-Class";
        } else if (averageMark >= 40) {
            return "Second-Class"; // Modify the return value this time we directly change the return value
        } else {
            return "Non-Honours";
        }
    }
}

// That's it, all the mutation tests have been run
```

`软工/Submission\Labs\lab6\src\test\java\DegreeClassifierTest.java`:

```java
package src.test.java;

import org.junit.jupiter.api.Test;
import src.main.java.DegreeClassifier;

import static org.junit.jupiter.api.Assertions.*;

public class DegreeClassifierTest {
    // First Test no problem
    @Test
    public void testFirstClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("First-Class", classifier.classify(85));
    }



    /**
     * First Mutation Test, this test, problem occurred because >= was turned into >
     */
    @Test
    public void testFirstClassBoundary() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("First-Class", classifier.classify(70.0));
    }

    @Test
    public void testUpperSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Upper Second-Class", classifier.classify(65));
    }

    /**
     * Second Mutation Test second mutation test has problem because >= was turned into > aslo
     */
    @Test
    public void testUpperSecondClassBoundary() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Upper Second-Class", classifier.classify(60.0));
    }

    @Test
    public void testLowerSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Lower Second-Class", classifier.classify(55));
    }

    /**
     * Third Mutation Test
     */
    @Test
    public void testThirdClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Third-Class", classifier.classify(45)); // score >= 40 but honor is "Second-class" it should be wrong
    }

    @Test
    public void testNonHonours() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Non-Honours", classifier.classify(35));
    }
}
```

`软工/Submission\Submission(Test & Production)\Production\DegreeClassifierLab5.java`:

```java
package src.main.java;

public class DegreeClassifier {
    /**
     * Classifies a degree based on the average mark.
     *
     * @param averageMark The average mark of the degree.
     * @return The classification of the degree.
     */
    public String classify(double averageMark) {
        if (averageMark >= 70) {
            return "First-Class";
        } else if (averageMark >= 60) {
            return "Upper Second-Class";
        } else if (averageMark >= 50) {
            return "Lower Second-Class";
        } else if (averageMark >= 40) {
            return "Third-Class";
        } else {
            return "Non-Honours";
        }
    }
}
```

`软工/Submission\Submission(Test & Production)\Production\DegreeClassifierLab6.java`:

```java
package src.main.java;


/**
 * First Mutation
 */
//public class DegreeClassifier {
//    public String classify(double averageMark) {
//        if (averageMark > 70) { // Turn >= into >
//            return "First-Class";
//        } else if (averageMark >= 60) {
//            return "Upper Second-Class";
//        } else if (averageMark >= 50) {
//            return "Lower Second-Class";
//        } else if (averageMark >= 40) {
//            return "Third-Class";
//        } else {
//            return "Non-Honours";
//        }
//    }
//}

/**
 * Second Mutation Now we run the 2nd mutation test
 */
//public class DegreeClassifier {
//    public String classify(double averageMark) {
//        if (averageMark >= 70) {
//            return "First-Class";
//        } else if (averageMark > 60) { // Turn >= into > this time we change this
//            return "Upper Second-Class";
//        } else if (averageMark >= 50) {
//            return "Lower Second-Class";
//        } else if (averageMark >= 40) {
//            return "Third-Class";
//        } else {
//            return "Non-Honours";
//        }
//    }
//}

/**
 * Third Mutation last mutation test
 */
public class DegreeClassifier {
    public String classify(double averageMark) {
        if (averageMark >= 70) {
            return "First-Class";
        } else if (averageMark >= 60) {
            return "Upper Second-Class";
        } else if (averageMark >= 50) {
            return "Lower Second-Class";
        } else if (averageMark >= 40) {
            return "Second-Class"; // Modify the return value this time we directly change the return value
        } else {
            return "Non-Honours";
        }
    }
}

// That's it, all the mutation tests have been run
```

`软工/Submission\Submission(Test & Production)\Test\DegreeClassifierTestLab5.java`:

```java
package src.test.java;

import org.junit.jupiter.api.Test;
import src.main.java.DegreeClassifier;

import static org.junit.jupiter.api.Assertions.*;

public class DegreeClassifierTest {
    // We can see that all the test examples ran successfully !
    @Test
    public void testFirstClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("First-Class", classifier.classify(85));
    }

    @Test
    public void testUpperSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Upper Second-Class", classifier.classify(65));
    }

    @Test
    public void testLowerSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Lower Second-Class", classifier.classify(55));
    }

    @Test
    public void testThirdClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Third-Class", classifier.classify(45));
    }

    @Test
    public void testNonHonours() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Non-Honours", classifier.classify(35));
    }
}
```

`软工/Submission\Submission(Test & Production)\Test\DegreeClassifierTestLab6.java`:

```java
package src.test.java;

import org.junit.jupiter.api.Test;
import src.main.java.DegreeClassifier;

import static org.junit.jupiter.api.Assertions.*;

public class DegreeClassifierTest {
    // First Test no problem
    @Test
    public void testFirstClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("First-Class", classifier.classify(85));
    }



    /**
     * First Mutation Test, this test, problem occurred because >= was turned into >
     */
    @Test
    public void testFirstClassBoundary() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("First-Class", classifier.classify(70.0));
    }

    @Test
    public void testUpperSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Upper Second-Class", classifier.classify(65));
    }

    /**
     * Second Mutation Test second mutation test has problem because >= was turned into > aslo
     */
    @Test
    public void testUpperSecondClassBoundary() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Upper Second-Class", classifier.classify(60.0));
    }

    @Test
    public void testLowerSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Lower Second-Class", classifier.classify(55));
    }

    /**
     * Third Mutation Test
     */
    @Test
    public void testThirdClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Third-Class", classifier.classify(45)); // score >= 40 but honor is "Second-class" it should be wrong
    }

    @Test
    public void testNonHonours() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Non-Honours", classifier.classify(35));
    }
}
```

`软工/大代码\MenuUI-post.txt`:

```txt
 package Controller;

 import Constants.ConfigConstants;
 // Remove import DAO.CsvTransactionDao;

 import Service.Impl.TransactionServiceImpl;
 import Service.TransactionService;
 import Utils.CacheManager;
 import model.Transaction;
 import model.User;

 import javax.swing.*;
 import java.awt.*;
 import java.io.IOException;
 import java.util.List;
 import java.util.Vector; // Still used for table row data structure
 import javax.swing.table.DefaultTableModel;

 // Remove static imports related to CSV_PATH

 public class MenuUI {
     private final User currentUser;
     private final TransactionService transactionService;

     // Make tableModel an instance field
     private DefaultTableModel tableModel;
     // Remove the static or instance allData field: private Vector<Vector<String>> allData = new Vector<>();

     // Add instance fields for search input components (for Question 2 & 3)
     private JTextField searchTransactionTimeField;
     private JTextField searchTransactionTypeField;
     private JTextField searchCounterpartyField;
     private JTextField searchCommodityField;
     private JComboBox<String> searchInOutComboBox;
     private JTextField searchPaymentMethodField;
     private JButton searchButton; // Keep reference to the search button

     private JTable table;
     private HistogramPanelContainer histogramPanelContainer;
     private JPanel rightPanel;
     private CardLayout cardLayout;

     // Constructor now accepts the authenticated User and their TransactionService instance
     public MenuUI(User authenticatedUser, TransactionService transactionService){
         this.currentUser = authenticatedUser;
         this.transactionService = transactionService; // Inject the user-specific service

         // Initialize table model (now non-static)
         String[] columnNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注", "Modify", "Delete"};
         this.tableModel = new DefaultTableModel(columnNames, 0);
         this.table = new JTable(this.tableModel);

         this.histogramPanelContainer = new HistogramPanelContainer();
         this.cardLayout = new CardLayout();
         this.rightPanel = new JPanel(this.cardLayout);

         // DEBUG: Print user info
         System.out.println("MenuUI initialized for user: " + currentUser.getUsername());
         System.out.println("Using transaction file: " + currentUser.getTransactionFilePath());

         // Data loading will be called in createMainPanel() after UI setup
     }

     public JPanel createMainPanel() {
         // Main panel, use BorderLayout
         JPanel mainPanel = new JPanel(new BorderLayout());

         // Left panel with Menu and AI buttons
         JPanel leftPanel = createLeftPanel();
         mainPanel.add(leftPanel, BorderLayout.WEST);

         // Right panel for table or AI view
         setupRightPanel();
         mainPanel.add(rightPanel, BorderLayout.CENTER);

         // Load the user's data and display initial view (only income)
         loadCSVDataForCurrentUser("收入"); // Load and display only income initially

         return mainPanel;
     }

     // Method to load CSV data for the current user with optional initial filter
     // This replaces the old loadCSVDataForCurrentUser() method
     public void loadCSVDataForCurrentUser(String initialInOutFilter) {
         this.tableModel.setRowCount(0); // Clear the table model

         try {
             // Get all transactions for the current user using the injected service
             List<Transaction> transactions = transactionService.getAllTransactions();
             System.out.println("Loaded total " + transactions.size() + " transactions from service for user " + currentUser.getUsername());

             // Filter transactions based on the initialInOutFilter
             List<Transaction> filteredTransactions = new java.util.ArrayList<>();
             if (initialInOutFilter == null || initialInOutFilter.trim().isEmpty()) {
                  // If no filter specified, add all transactions
                  filteredTransactions.addAll(transactions);
             } else {
                  // Filter by the specified 收/支 type
                  String filter = initialInOutFilter.trim();
                  filteredTransactions = transactions.stream()
                          .filter(t -> t.getInOut() != null && (t.getInOut().equalsIgnoreCase(filter) ||
                                  (filter.equalsIgnoreCase("收入") && t.getInOut().equalsIgnoreCase("收")) ||
                                  (filter.equalsIgnoreCase("支出") && t.getInOut().equalsIgnoreCase("支")) ))
                          .collect(java.util.stream.Collectors.toList());
             }


             // Add filtered transactions to the table model
             for (Transaction transaction : filteredTransactions) {
                 Vector<String> row = createRowFromTransaction(transaction);
                 this.tableModel.addRow(row);
             }
             System.out.println("Displayed " + filteredTransactions.size() + " transactions in the table.");

         } catch (Exception e) {
             e.printStackTrace();
             JOptionPane.showMessageDialog(null, "加载用户交易数据失败！", "错误", JOptionPane.ERROR_MESSAGE);
         }
     }

     // Method to create the left panel (Menu/AI buttons) - no changes needed here
     private JPanel createLeftPanel() { /* ... existing code ... */ return null; }

     // Method to set up the right panel (Table/Histogram) - no changes needed here
     private void setupRightPanel() { /* ... existing code ... */ }

     // Method to create the table panel - update button editors/renderers to use 'this' MenuUI instance
     private JPanel createTablePanel() {
         JPanel tablePanel = new JPanel(new BorderLayout());

         JPanel inputPanel = createInputPanel(); // This method now initializes search fields
         tablePanel.add(inputPanel, BorderLayout.NORTH);

         JScrollPane tableScrollPane = new JScrollPane(this.table);
         tableScrollPane.setPreferredSize(new Dimension(1000, 250));
         this.table.setRowHeight(30);

         tablePanel.add(tableScrollPane, BorderLayout.CENTER);

         // Set cell renderers and editors - pass 'this' MenuUI instance
         this.table.getColumnModel().getColumn(11).setCellRenderer(new ButtonRenderer());
         this.table.getColumnModel().getColumn(11).setCellEditor(new ButtonEditor(this));

         this.table.getColumnModel().getColumn(12).setCellRenderer(new ButtonRenderer());
         this.table.getColumnModel().getColumn(12).setCellEditor(new ButtonEditor(this));

         // Data loading is now called in createMainPanel()

         return tablePanel;
     }

     // Method to create input panel - Capture references to search fields and button (for Question 2 & 3)
     private JPanel createInputPanel() {
         JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));

         // Create input fields and capture references
         searchTransactionTimeField = new JTextField(10); // 交易时间输入框
         searchTransactionTypeField = new JTextField(10); // 交易类型输入框
         searchCounterpartyField = new JTextField(10);    // 交易对方输入框
         searchCommodityField = new JTextField(10);      // 商品输入框
         searchInOutComboBox = new JComboBox<>(new String[]{"", "收入", "支出"}); // Add empty option for "any"
         searchPaymentMethodField = new JTextField(10);  // 支付方式输入框

         // Add labels and input fields
         inputPanel.add(new JLabel("交易时间:"));
         inputPanel.add(searchTransactionTimeField);
         inputPanel.add(new JLabel("交易类型:"));
         inputPanel.add(searchTransactionTypeField);
         inputPanel.add(new JLabel("交易对方:"));
         inputPanel.add(searchCounterpartyField);
         inputPanel.add(new JLabel("商品:"));
         inputPanel.add(searchCommodityField);
         inputPanel.add(new JLabel("收/支:"));
         inputPanel.add(searchInOutComboBox);
         inputPanel.add(new JLabel("支付方式:"));
         inputPanel.add(searchPaymentMethodField);

         // Create Search and Add buttons and capture reference to search button
         searchButton = new JButton("Search");
         JButton addButton = new JButton("Add");

         // Add buttons
         inputPanel.add(searchButton);
         inputPanel.add(addButton);

         // Add ActionListener for Search button
         searchButton.addActionListener(e -> {
             // Call searchData with current values from the input fields
             searchData(
                     searchTransactionTimeField.getText().trim(),
                     searchTransactionTypeField.getText().trim(),
                     searchCounterpartyField.getText().trim(),
                     searchCommodityField.getText().trim(),
                     (String) searchInOutComboBox.getSelectedItem(),
                     searchPaymentMethodField.getText().trim()
             );
         });

         // Add ActionListener for Add button
         addButton.addActionListener(e -> {
             showAddTransactionDialog();
         });

         return inputPanel;
     }

     // Method to show add transaction dialog - update to use injected service
     private void showAddTransactionDialog() {
         // ... existing code to create dialog and fields ...
         JDialog addDialog = new JDialog();
         addDialog.setTitle("添加交易");
         addDialog.setLayout(new GridLayout(12, 2));

         JTextField transactionTimeField = new JTextField();
         JTextField transactionTypeField = new JTextField();
         JTextField counterpartyField = new JTextField();
         JTextField commodityField = new JTextField();
         JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"}); // Or maybe allow empty for "other"?
         JTextField paymentAmountField = new JTextField();
         JTextField paymentMethodField = new JTextField();
         JTextField currentStatusField = new JTextField();
         JTextField orderNumberField = new JTextField();
         JTextField merchantNumberField = new JTextField();
         JTextField remarksField = new JTextField();

         addDialog.add(new JLabel("交易时间:")); addDialog.add(transactionTimeField);
         addDialog.add(new JLabel("交易类型:")); addDialog.add(transactionTypeField);
         addDialog.add(new JLabel("交易对方:")); addDialog.add(counterpartyField);
         addDialog.add(new JLabel("商品:")); addDialog.add(commodityField);
         addDialog.add(new JLabel("收/支:")); addDialog.add(inOutComboBox);
         addDialog.add(new JLabel("金额(元):")); addDialog.add(paymentAmountField);
         addDialog.add(new JLabel("支付方式:")); addDialog.add(paymentMethodField);
         addDialog.add(new JLabel("当前状态:")); addDialog.add(currentStatusField);
         addDialog.add(new JLabel("交易单号:")); addDialog.add(orderNumberField);
         addDialog.add(new JLabel("商户单号:")); addDialog.add(merchantNumberField);
         addDialog.add(new JLabel("备注:")); addDialog.add(remarksField);


         // Add confirm button
         JButton confirmButton = new JButton("确认");
         confirmButton.addActionListener(e -> {
             String paymentAmountText = paymentAmountField.getText().trim();
             double paymentAmount = 0.0;
             if (!paymentAmountText.isEmpty()) {
                 try {
                      paymentAmount = Double.parseDouble(paymentAmountText);
                 } catch (NumberFormatException ex) {
                      JOptionPane.showMessageDialog(addDialog, "金额格式不正确！请输入数字。", "输入错误", JOptionPane.ERROR_MESSAGE);
                      return;
                 }
             }

             Transaction newTransaction = new Transaction(
                     emptyIfNull(transactionTimeField.getText().trim()),
                     emptyIfNull(transactionTypeField.getText().trim()),
                     emptyIfNull(counterpartyField.getText().trim()),
                     emptyIfNull(commodityField.getText().trim()),
                     (String) inOutComboBox.getSelectedItem(),
                     paymentAmount,
                     emptyIfNull(paymentMethodField.getText().trim()),
                     emptyIfNull(currentStatusField.getText().trim()),
                     emptyIfNull(orderNumberField.getText().trim()), // Ensure order number is provided
                     emptyIfNull(merchantNumberField.getText().trim()),
                     emptyIfNull(remarksField.getText().trim())
             );

             if (newTransaction.getOrderNumber().isEmpty()) {
                  JOptionPane.showMessageDialog(addDialog, "交易单号不能为空！", "输入错误", JOptionPane.ERROR_MESSAGE);
                  return;
             }

             try {
                 transactionService.addTransaction(newTransaction);

                 // After adding, decide what to display.
                 // Option 1: Reload the default (income only) view:
                 // loadCSVDataForCurrentUser("收入");
                 // Option 2: Reload all data:
                 // loadCSVDataForCurrentUser("");
                 // Option 3: Reload the *current* search/filter view (more complex, requires storing current criteria)
                 // Let's choose Option 2 for simplicity - show all data after adding a new transaction.
                 // The user can then filter if needed.
                 loadCSVDataForCurrentUser(""); // Load all data after adding

                 // Also clear search fields after adding
                 clearSearchFields();


                 addDialog.dispose();
                 JOptionPane.showMessageDialog(null, "交易添加成功！", "提示", JOptionPane.INFORMATION_MESSAGE);

             } catch (IOException ex) {
                 ex.printStackTrace();
                 JOptionPane.showMessageDialog(null, "交易添加失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
             }
         });

         addDialog.add(confirmButton);
         addDialog.setSize(400, 300);
         addDialog.setModal(true);
         addDialog.setVisible(true);
     }


     // Method to search data - update to clear tableModel only (remove allData usage)
     public void searchData(String query1, String query2, String query3, String query4, String query6, String query5) { // Renamed query params for clarity
         System.out.println("Searching with criteria: time='" + query1 + "', type='" + query2 + "', counterparty='" + query3 + "', commodity='" + query4 + "', inOut='" + query6 + "', paymentMethod='" + query5 + "'");
         this.tableModel.setRowCount(0); // Clear the table model

         // Create search criteria Transaction object
         Transaction searchCriteria = new Transaction(
                 query1, query2, query3, query4, query6,
                 0, // paymentAmount not used in search criteria from UI
                 query5,
                 "", "", "", ""
         );

         try {
             // Use the injected transactionService instance
             List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);
             System.out.println("Search results count: " + transactions.size());
             for (Transaction transaction : transactions) {
                 Vector<String> row = createRowFromTransaction(transaction);
                 this.tableModel.addRow(row);
             }

         } catch (Exception ex) {
             ex.printStackTrace();
             JOptionPane.showMessageDialog(null, "查询失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
         }
     }

     // Method to create table row from Transaction object - no changes needed here
     private Vector<String> createRowFromTransaction(Transaction transaction) {
         Vector<String> row = new Vector<>();
         row.add(emptyIfNull(transaction.getTransactionTime()));
         row.add(emptyIfNull(transaction.getTransactionType()));
         row.add(emptyIfNull(transaction.getCounterparty()));
         row.add(emptyIfNull(transaction.getCommodity()));
         row.add(emptyIfNull(transaction.getInOut()));
         row.add(String.valueOf(transaction.getPaymentAmount())); // Keep as String for table
         row.add(emptyIfNull(transaction.getPaymentMethod()));
         row.add(emptyIfNull(transaction.getCurrentStatus()));
         row.add(emptyIfNull(transaction.getOrderNumber()));
         row.add(emptyIfNull(transaction.getMerchantNumber()));
         row.add(emptyIfNull(transaction.getRemarks()));
         row.add("Modify"); // Modify button text
         row.add("Delete"); // Delete button text
         return row;
     }


     // Method to delete row - get data from tableModel (remove allData usage)
     public void deleteRow(int rowIndex) {
         System.out.println("尝试删除行: " + rowIndex + " for user " + currentUser.getUsername());
         if (rowIndex >= 0 && rowIndex < this.tableModel.getRowCount()) { // Use tableModel row count

             // Get the order number directly from the displayed table row
             String orderNumber = (String) this.tableModel.getValueAt(rowIndex, 8); // OrderNumber is at index 8
             if (orderNumber == null || orderNumber.trim().isEmpty()) {
                  JOptionPane.showMessageDialog(null, "无法删除：交易单号为空！", "错误", JOptionPane.ERROR_MESSAGE);
                  System.err.println("Attempted to delete row " + rowIndex + " but order number is null or empty.");
                  return; // Cannot delete without an order number
             }
             orderNumber = orderNumber.trim();
             System.out.println("Deleting transaction with order number: " + orderNumber);

             try {
                 // Use the injected transactionService instance
                 boolean deleted = transactionService.deleteTransaction(orderNumber);

                 if (deleted) {
                     // Data is removed from CSV and cache invalidated by service.
                     // Update the UI model directly by removing the row.
                     this.tableModel.removeRow(rowIndex); // Remove the row from the displayed table


                     JOptionPane.showMessageDialog(null, "删除成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                     System.out.println("Deleted row " + rowIndex + " with order number " + orderNumber + " from UI.");

                     // After delete, refresh the view. Let's reload the *current* search/filter view.
                     // Get the current search criteria from the UI fields and re-apply search.
                     triggerCurrentSearch();

                 } else {
                     // This case means the service said it wasn't deleted (likely not found)
                     JOptionPane.showMessageDialog(null, "删除失败：未找到对应的交易单号 " + orderNumber, "错误", JOptionPane.ERROR_MESSAGE);
                     System.err.println("Delete failed: order number " + orderNumber + " not found by service.");
                 }
             } catch (Exception ex) {
                 ex.printStackTrace();
                 JOptionPane.showMessageDialog(null, "删除失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
                 System.err.println("Error during deletion for order number " + orderNumber);
             }
         } else {
              System.err.println("Attempted to delete row with invalid index: " + rowIndex + ". Table row count: " + this.tableModel.getRowCount());
         }
     }

     // Method to edit row - get data from tableModel and update display after edit (remove allData usage)
     public void editRow(int rowIndex) {
         System.out.println("编辑行: " + rowIndex + " for user " + currentUser.getUsername());
         if (rowIndex >= 0 && rowIndex < this.tableModel.getRowCount()) { // Use tableModel row count

             // Get the data for the displayed row directly from the table model
             Vector<String> rowData = new Vector<>();
             // Get data for all columns that correspond to Transaction fields (up to index 10)
             for (int i = 0; i <= 10; i++) { // Columns 0 to 10 are Transaction fields
                 Object value = this.tableModel.getValueAt(rowIndex, i);
                 rowData.add(value != null ? value.toString() : "");
             }
             System.out.println("Retrieved row data from table model for editing: " + rowData);

             // Get the original order number, which is the key for update
             String originalOrderNumber = rowData.get(8).trim(); // Index 8 is OrderNumber
              if (originalOrderNumber.isEmpty()) {
                 JOptionPane.showMessageDialog(null, "无法编辑：交易单号为空！", "错误", JOptionPane.ERROR_MESSAGE);
                 System.err.println("Attempted to edit row " + rowIndex + " but order number is empty.");
                 return; // Cannot edit without an order number
              }


             // Create a panel for edit fields
             JPanel panel = new JPanel(new GridLayout(11, 2)); // 11 Transaction fields

             // Create fields array, populate panel and fields
             JTextField[] fields = new JTextField[11]; // 11 fields for Transaction data
             String[] fieldNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"};

             for (int i = 0; i < fieldNames.length; i++) {
                 panel.add(new JLabel(fieldNames[i] + ":")); // Add label
                 fields[i] = new JTextField(rowData.get(i)); // Set field value from row data
                 panel.add(fields[i]);
             }

             // Disable editing the order number field if it's the primary key and shouldn't be changed
             // If you decide OrderNumber is immutable via edit:
             fields[8].setEditable(false); // Disable editing OrderNumber field


             // Show the dialog
             int result = JOptionPane.showConfirmDialog(null, panel, "修改交易信息 (订单号: " + originalOrderNumber + ")", JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

             if (result == JOptionPane.OK_OPTION) {
                 // User clicked OK, get updated values from fields

                 // Handle paymentAmount parsing carefully
                 double paymentAmount = safeParseDouble(fields[5].getText().trim()); // 金额(元)

                 // Create a Transaction object with updated values
                 // Use the original order number as the key for the update operation
                 Transaction updatedTransaction = new Transaction(
                         fields[0].getText().trim(), // 交易时间
                         fields[1].getText().trim(), // 交易类型
                         fields[2].getText().trim(), // 交易对方
                         fields[3].getText().trim(), // 商品
                         fields[4].getText().trim(), // 收/支
                         paymentAmount,
                         fields[6].getText().trim(), // 支付方式
                         fields[7].getText().trim(), // 当前状态
                         originalOrderNumber, // Use the ORIGINAL order number as the identifier for update
                         fields[9].getText().trim(), // 商户单号
                         fields[10].getText().trim() // 备注
                 );

                 try {
                     // Use the injected transactionService instance to change the transaction
                     transactionService.changeTransaction(updatedTransaction);

                     // *** IMPORTANT CHANGE FOR QUESTION 2 ***
                     // After successful edit, update the search fields and trigger search
                     System.out.println("Edit successful. Preparing to refresh display filtered by InOut: " + updatedTransaction.getInOut());
                     // Clear all search text fields
                     clearSearchFields();
                     // Set the InOut dropdown to the updated value
                     searchInOutComboBox.setSelectedItem(updatedTransaction.getInOut());
                     // Trigger the search based on the updated criteria
                     triggerCurrentSearch();


                     JOptionPane.showMessageDialog(null, "修改成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                     System.out.println("Edited row " + rowIndex + " for order number " + originalOrderNumber + " and refreshed display.");

                 } catch (IllegalArgumentException e) {
                     JOptionPane.showMessageDialog(null, "修改失败！\n" + e.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
                     e.printStackTrace();
                 } catch (Exception ex) {
                     ex.printStackTrace();
                     JOptionPane.showMessageDialog(null, "修改失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
                     System.err.println("Error during editing for order number " + originalOrderNumber);
                 }
             } else {
                  System.out.println("Edit dialog cancelled.");
             }
         } else {
              System.err.println("Attempted to edit row with invalid index: " + rowIndex + ". Table row count: " + this.tableModel.getRowCount());
         }
     }

     // Helper method to safely parse double, return 0.0 on error
     private double safeParseDouble(String value) {
         if (value == null || value.trim().isEmpty()) {
             return 0.0;
         }
         try {
             return Double.parseDouble(value.trim());
         } catch (NumberFormatException e) {
             System.err.println("Failed to parse double from string: '" + value + "'");
             // Consider showing a warning message to the user here
             return 0.0;
         }
     }

      // Helper method to clear all search input fields
     private void clearSearchFields() {
         searchTransactionTimeField.setText("");
         searchTransactionTypeField.setText("");
         searchCounterpartyField.setText("");
         searchCommodityField.setText("");
         searchInOutComboBox.setSelectedItem(""); // Set to the empty option
         searchPaymentMethodField.setText("");
          System.out.println("Cleared search fields.");
     }

      // Helper method to trigger search based on current search field values
      private void triggerCurrentSearch() {
         searchData(
                 searchTransactionTimeField.getText().trim(),
                 searchTransactionTypeField.getText().trim(),
                 searchCounterpartyField.getText().trim(),
                 searchCommodityField.getText().trim(),
                 (String) searchInOutComboBox.getSelectedItem(),
                 searchPaymentMethodField.getText().trim()
         );
          System.out.println("Triggered search with current field values.");
      }


     /**
      * If field is null, return empty string.
      * @param value Field value
      * @return Non-null field value
      */
     private String emptyIfNull(String value) {
         return value == null ? "" : value;
     }

     // Keep getTable() for testing
     public JTable getTable() {
         return table;
     }
 }
```

`软工/大代码\MenuUI-pre.txt`:

```txt
package Controller;

import Constants.ConfigConstants; // [cite: 240]
// Remove import DAO.CsvTransactionDao; // No longer directly initialized here // [cite: 240]

import Service.Impl.TransactionServiceImpl; // [cite: 240]
// Import the specific implementation // [cite: 241]
import Service.TransactionService; // [cite: 241]
// Import the interface as well // [cite: 242]
import Utils.CacheManager; // [cite: 242]
// Might be needed if UI directly invalidates cache (less ideal) // [cite: 243]
import model.Transaction; // [cite: 243]
import model.User; // [cite: 243]
import javax.swing.*; // [cite: 244]
import java.awt.*; // [cite: 244]
import java.io.IOException; // [cite: 244]
import java.util.List; // [cite: 244]
import java.util.Vector; // [cite: 244]
import javax.swing.table.DefaultTableModel; // [cite: 244]
// Remove static imports related to CSV_PATH // [cite: 245]
// import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY; // [cite: 245]
// import static Constants.ConfigConstants.CSV_PATH; // [cite: 245]

public class MenuUI {
    private final User currentUser; // [cite: 246]
    // private final String currentUserTransactionFilePath; // Can get this from currentUser // [cite: 247]

    // Make tableModel and allData instance fields, not static // [cite: 247]
    private DefaultTableModel tableModel; // [cite: 247]
    private Vector<Vector<String>> allData = new Vector<>(); // Non-static data // [cite: 248]

    // Make transactionService an instance field // [cite: 248]
    private final TransactionService transactionService; // [cite: 248]
    private JTable table; // [cite: 249]
    private HistogramPanelContainer histogramPanelContainer; // [cite: 249]
    private JPanel rightPanel; // [cite: 249]
    private CardLayout cardLayout; // [cite: 249]

    // Constructor now accepts the authenticated User and their TransactionService instance // [cite: 250]
    public MenuUI(User authenticatedUser, TransactionService transactionService){
        this.currentUser = authenticatedUser; // [cite: 250]
        this.transactionService = transactionService; // Inject the user-specific service // [cite: 251]

        // Initialize table model (now non-static) // [cite: 251]
        String[] columnNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注", "Modify", "Delete"}; // [cite: 251]
        this.tableModel = new DefaultTableModel(columnNames, 0); // Use 'this' for instance field // [cite: 252]
        this.table = new JTable(this.tableModel); // [cite: 252]
        // Use 'this' // [cite: 253]

        this.histogramPanelContainer = new HistogramPanelContainer(); // [cite: 253]
        // Use 'this' // [cite: 254]
        this.cardLayout = new CardLayout(); // [cite: 254]
        // Use 'this' // [cite: 255]
        this.rightPanel = new JPanel(this.cardLayout); // [cite: 255]
        // Use 'this' // [cite: 256]

        // DEBUG: Print user info // [cite: 256]
        System.out.println("MenuUI initialized for user: " + currentUser.getUsername()); // [cite: 256]
        System.out.println("Using transaction file: " + currentUser.getTransactionFilePath()); // [cite: 257]

        // The rest of the UI setup...
    }

    public JPanel createMainPanel() {
        // Main panel, using BorderLayout // [cite: 257]
        JPanel mainPanel = new JPanel(new BorderLayout()); // [cite: 258]
        // Left panel with Menu and AI buttons // [cite: 258]
        JPanel leftPanel = createLeftPanel(); // [cite: 258]
        mainPanel.add(leftPanel, BorderLayout.WEST); // [cite: 259]

        // Right panel for table or AI view // [cite: 259]
        setupRightPanel(); // [cite: 259]
        mainPanel.add(rightPanel, BorderLayout.CENTER); // [cite: 260]

        // *** IMPORTANT CHANGE *** // [cite: 260]
        // After the UI components are created and the panel is added, // [cite: 260]
        // load the user's data. // [cite: 261]
        // This happens once when the main panel is created/displayed. // [cite: 261]
        loadCSVDataForCurrentUser(); // [cite: 261]
        // Call the loading method here // [cite: 262]

        return mainPanel; // [cite: 262]
    }

    // Method to load CSV data for the current user // [cite: 263]
    // This replaces the old loadCSVData(String caffeineKey) method // [cite: 263]
    public void loadCSVDataForCurrentUser() {
        this.allData.clear(); // [cite: 263]
        // Use 'this' for instance field // [cite: 264]
        this.tableModel.setRowCount(0); // [cite: 264]
        // Use 'this' // [cite: 265]

        try {
            // Get all transactions for the current user using the injected service // [cite: 265]
            // Note: TransactionServiceImpl's getAllTransactionsForCurrentUser is private. // [cite: 266]
            // We need a public method in TransactionService to get all data for the UI. // [cite: 267]
            // Let's add one to TransactionService interface. // [cite: 267]
            // For now, assuming we can get all via search with empty criteria. // [cite: 268]
            // Or, better, add a public getAllTransactions() method to the service interface. // [cite: 268]
            // Let's add `List<Transaction> getAllTransactions()` to TransactionService. // [cite: 269]
            // And implement it in TransactionServiceImpl using `getAllTransactionsForCurrentUser()`. // [cite: 269]

            List<Transaction> transactions = transactionService.getAllTransactions(); // [cite: 269]
            // Call the new public method // [cite: 270]

            for (Transaction transaction : transactions) {
                Vector<String> row = createRowFromTransaction(transaction); // [cite: 270]
                this.allData.add(row); // Use 'this' // [cite: 271]
                this.tableModel.addRow(row); // [cite: 271]
                // Use 'this' // [cite: 272]
            }
            System.out.println("Loaded " + transactions.size() + " transactions into table for user " + currentUser.getUsername()); // [cite: 272]
        } catch (Exception e) {
            e.printStackTrace(); // [cite: 273]
            JOptionPane.showMessageDialog(null, "加载用户交易数据失败！", "错误", JOptionPane.ERROR_MESSAGE); // [cite: 274]
        }
    }

    // Method to create the left panel (Menu/AI buttons) - no changes needed here // [cite: 274]
    private JPanel createLeftPanel() {
        JPanel leftPanel = new JPanel(new GridLayout(2, 1)); // [cite: 384]
        JButton menuButton = new JButton("Menu"); // [cite: 385]
        JButton aiButton = new JButton("AI"); // [cite: 385]

        leftPanel.add(menuButton); // [cite: 385]
        leftPanel.add(aiButton); // [cite: 386]
        // 为 Menu 按钮添加 ActionListener // [cite: 386]
        menuButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Table"); // 切换到表格界面 // [cite: 386]
        });
        // 为 AI 按钮添加 ActionListener // [cite: 387]
        aiButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Histogram"); // 切换到直方图界面 // [cite: 387]
        });
        return leftPanel; // [cite: 388]
    }

    // Method to set up the right panel (Table/Histogram) - no changes needed here // [cite: 275]
    private void setupRightPanel() {
        // 创建搜索和表格的面板 // [cite: 388]
        JPanel tablePanel = createTablePanel(); // [cite: 389]
        // 将表格面板和直方图面板添加到 rightPanel // [cite: 389]
        rightPanel.add(tablePanel, "Table"); // [cite: 389]
        rightPanel.add(histogramPanelContainer, "Histogram"); // [cite: 390]
    }

    // Method to create the table // [cite: 275]
    // panel - update button editors/renderers to use 'this' MenuUI instance // [cite: 275]
    private JPanel createTablePanel() {
        JPanel tablePanel = new JPanel(new BorderLayout()); // [cite: 276]
        JPanel inputPanel = createInputPanel(); // [cite: 276]
        tablePanel.add(inputPanel, BorderLayout.NORTH); // [cite: 277]

        JScrollPane tableScrollPane = new JScrollPane(this.table); // [cite: 277]
        // Use 'this' // [cite: 277]
        tableScrollPane.setPreferredSize(new Dimension(1000, 250)); // [cite: 277]
        this.table.setRowHeight(30); // [cite: 278]
        // Use 'this' // [cite: 278]

        tablePanel.add(tableScrollPane, BorderLayout.CENTER); // [cite: 279]
        // Set cell renderers and editors - pass 'this' MenuUI instance // [cite: 279]
        this.table.getColumnModel().getColumn(11).setCellRenderer(new ButtonRenderer()); // [cite: 279]
        this.table.getColumnModel().getColumn(11).setCellEditor(new ButtonEditor(this)); // Pass 'this' // [cite: 280]

        this.table.getColumnModel().getColumn(12).setCellRenderer(new ButtonRenderer()); // [cite: 280]
        this.table.getColumnModel().getColumn(12).setCellEditor(new ButtonEditor(this)); // Pass 'this' // [cite: 281]

        // Data loading is now called in createMainPanel()

        return tablePanel; // [cite: 282]
    }

    // Method to create input panel - no changes needed here // [cite: 282]
    private JPanel createInputPanel() {
        JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10)); // [cite: 394]
        // 创建输入字段 // [cite: 395]
        JTextField transactionTimeField = new JTextField(10); // [cite: 395]
        // 交易时间输入框 // [cite: 396]
        JTextField transactionTypeField = new JTextField(10); // [cite: 396]
        // 交易类型输入框 // [cite: 397]
        JTextField counterpartyField = new JTextField(10); // [cite: 397]
        // 交易对方输入框 // [cite: 398]
        JTextField commodityField = new JTextField(10); // [cite: 398]
        // 商品输入框 // [cite: 399]
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"}); // [cite: 399]
        // 收/支下拉框 // [cite: 400]
        JTextField paymentMethodField = new JTextField(10); // [cite: 400]
        // 支付方式输入框 // [cite: 401]

        // 添加标签和输入字段到输入面板 // [cite: 401]
        inputPanel.add(new JLabel("交易时间:")); // [cite: 402]
        inputPanel.add(transactionTimeField); // [cite: 402]
        inputPanel.add(new JLabel("交易类型:")); // [cite: 402]
        inputPanel.add(transactionTypeField); // [cite: 402]
        inputPanel.add(new JLabel("交易对方:")); // [cite: 402]
        inputPanel.add(counterpartyField); // [cite: 402]
        inputPanel.add(new JLabel("商品:")); // [cite: 403]
        inputPanel.add(commodityField); // [cite: 403]
        inputPanel.add(new JLabel("收/支:")); // [cite: 403]
        inputPanel.add(inOutComboBox); // [cite: 403]
        inputPanel.add(new JLabel("支付方式:")); // [cite: 403]
        inputPanel.add(paymentMethodField); // [cite: 403]
        // 创建 Search 和 Add 按钮 // [cite: 403]
        JButton searchButton = new JButton("Search"); // [cite: 404]
        JButton addButton = new JButton("Add"); // [cite: 404]

        // 将按钮添加到输入面板 // [cite: 404]
        inputPanel.add(searchButton); // [cite: 404]
        inputPanel.add(addButton); // [cite: 405]
        // 为 Search 按钮添加 ActionListener // [cite: 405]
        searchButton.addActionListener(e -> {
            // 获取输入字段的值 // [cite: 405]
            searchData(
                    transactionTimeField.getText().trim(), // [cite: 406]
                    transactionTypeField.getText().trim(), // [cite: 406]
                    counterpartyField.getText().trim(), // [cite: 406]
                    commodityField.getText().trim(), // [cite: 406]
                    (String) inOutComboBox.getSelectedItem(), // [cite: 406]
                    paymentMethodField.getText().trim() // [cite: 406]
            );
        });
        // 为 Add 按钮添加 ActionListener // [cite: 407]
        addButton.addActionListener(e -> {
            // 弹出对话框，输入交易信息 // [cite: 407]
            showAddTransactionDialog(); // [cite: 407]
        });
        return inputPanel; // [cite: 408]
    }

    // Method to show add transaction dialog - update to use injected service // [cite: 282]
    private void showAddTransactionDialog() {
        JDialog addDialog = new JDialog(); // [cite: 283]
        addDialog.setTitle("添加交易"); // [cite: 283]
        addDialog.setLayout(new GridLayout(12, 2)); // 11 fields + 1 button row // [cite: 283]
        // ... create fields ...
        // Add labels and fields...

        // Create input fields for the dialog
        JTextField transactionTimeField = new JTextField(); // [cite: 409]
        JTextField transactionTypeField = new JTextField(); // [cite: 410]
        JTextField counterpartyField = new JTextField(); // [cite: 410]
        JTextField commodityField = new JTextField(); // [cite: 410]
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"}); // [cite: 411]
        JTextField paymentAmountField = new JTextField(); // [cite: 411]
        JTextField paymentMethodField = new JTextField(); // [cite: 411]
        JTextField currentStatusField = new JTextField(); // [cite: 412]
        JTextField orderNumberField = new JTextField(); // [cite: 412]
        JTextField merchantNumberField = new JTextField(); // [cite: 412]
        JTextField remarksField = new JTextField(); // [cite: 412]

        // Add labels and input fields to the dialog // [cite: 413]
        addDialog.add(new JLabel("交易时间:")); // [cite: 413]
        addDialog.add(transactionTimeField); // [cite: 413]
        addDialog.add(new JLabel("交易类型:")); // [cite: 413]
        addDialog.add(transactionTypeField); // [cite: 413]
        addDialog.add(new JLabel("交易对方:")); // [cite: 413]
        addDialog.add(counterpartyField); // [cite: 413]
        addDialog.add(new JLabel("商品:")); // [cite: 414]
        addDialog.add(commodityField); // [cite: 414]
        addDialog.add(new JLabel("收/支:")); // [cite: 414]
        addDialog.add(inOutComboBox); // [cite: 414]
        addDialog.add(new JLabel("金额(元):")); // [cite: 414]
        addDialog.add(paymentAmountField); // [cite: 414]
        addDialog.add(new JLabel("支付方式:")); // [cite: 414]
        addDialog.add(paymentMethodField); // [cite: 414]
        addDialog.add(new JLabel("当前状态:")); // [cite: 415]
        addDialog.add(currentStatusField); // [cite: 415]
        addDialog.add(new JLabel("交易单号:")); // [cite: 415]
        addDialog.add(orderNumberField); // [cite: 415]
        addDialog.add(new JLabel("商户单号:")); // [cite: 415]
        addDialog.add(merchantNumberField); // [cite: 415]
        addDialog.add(new JLabel("备注:")); // [cite: 415]
        addDialog.add(remarksField); // [cite: 415]

        // Add confirm button // [cite: 284]
        JButton confirmButton = new JButton("确认"); // [cite: 284]
        confirmButton.addActionListener(e -> {
            // ... get field values ...
            String paymentAmountText = paymentAmountField.getText().trim(); // [cite: 284]
            double paymentAmount = 0.0; // Default to 0.0 // [cite: 284]
            if (!paymentAmountText.isEmpty()) { // [cite: 284]
                try { // [cite: 285]
                    paymentAmount = Double.parseDouble(paymentAmountText); // [cite: 285]
                } catch (NumberFormatException ex) {
                    JOptionPane.showMessageDialog(addDialog, "金额格式不正确！请输入数字。", "输入错误", JOptionPane.ERROR_MESSAGE); // [cite: 285]
                    return; // Stop processing if amount is invalid // [cite: 286]
                }
            }

            // Create Transaction object // [cite: 286]
            Transaction newTransaction = new Transaction( // [cite: 287]
                    emptyIfNull(transactionTimeField.getText().trim()), // [cite: 287]
                    emptyIfNull(transactionTypeField.getText().trim()), // [cite: 287]
                    emptyIfNull(counterpartyField.getText().trim()), // [cite: 288]
                    emptyIfNull(commodityField.getText().trim()), // [cite: 288]
                    (String) inOutComboBox.getSelectedItem(), // [cite: 288]
                    paymentAmount, // [cite: 288]
                    emptyIfNull(paymentMethodField.getText().trim()), // [cite: 289]
                    emptyIfNull(currentStatusField.getText().trim()), // [cite: 289]
                    emptyIfNull(orderNumberField.getText().trim()), // Ensure order number is provided if it's the key // [cite: 289]
                    emptyIfNull(merchantNumberField.getText().trim()), // [cite: 289]
                    emptyIfNull(remarksField.getText().trim()) // [cite: 290]
            );
            // Basic validation for order number if it's the primary key // [cite: 290]
            if (newTransaction.getOrderNumber().isEmpty()) { // [cite: 290]
                JOptionPane.showMessageDialog(addDialog, "交易单号不能为空！", "输入错误", JOptionPane.ERROR_MESSAGE); // [cite: 291]
                return; // Stop if order number is missing // [cite: 291]
            }

            try {
                // Use the injected transactionService instance // [cite: 291]
                transactionService.addTransaction(newTransaction); // [cite: 292]
                // Reload CSV data to update the table for the current user // [cite: 292]
                loadCSVDataForCurrentUser(); // [cite: 292]
                // Reload data after add // [cite: 293]

                addDialog.dispose(); // [cite: 293]
                JOptionPane.showMessageDialog(null, "交易添加成功！", "提示", JOptionPane.INFORMATION_MESSAGE); // [cite: 294]
            } catch (IOException ex) {
                ex.printStackTrace(); // [cite: 294]
                JOptionPane.showMessageDialog(null, "交易添加失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE); // [cite: 295]
            }
        });
        // ... add components to dialog ...
        addDialog.add(confirmButton); // [cite: 296]
        // Set dialog size and visibility
        addDialog.setSize(400, 300); // [cite: 426]
        addDialog.setModal(true); // [cite: 426]
        // Set as modal dialog // [cite: 427]
        addDialog.setVisible(true); // [cite: 427]
    }


    // Method to search data - update to use injected service // [cite: 297]
    public void searchData(String query1, String query2, String query3, String query4, String query6, String query5) {
        this.tableModel.setRowCount(0); // [cite: 297]
        // Use 'this' // [cite: 298]
        // Create search criteria Transaction object // [cite: 298]
        Transaction searchCriteria = new Transaction(
                query1, query2, query3, query4, query6, // [cite: 298]
                0, // paymentAmount is not used in search criteria based on MenuUI input fields // [cite: 299]
                query5, // [cite: 299]
                "", "", "", "" // [cite: 299]
        );
        try { // [cite: 300]
            // Use the injected transactionService instance // [cite: 300]
            List<Transaction> transactions = transactionService.searchTransaction(searchCriteria); // [cite: 300]
            for (Transaction transaction : transactions) {
                Vector<String> row = createRowFromTransaction(transaction); // [cite: 301]
                this.tableModel.addRow(row); // Use 'this' // [cite: 302]
            }
            System.out.println("Search completed. Displaying " + transactions.size() + " results."); // [cite: 302]
        } catch (Exception ex) { // searchTransaction can throw Exception from cache loading // [cite: 303]
            ex.printStackTrace(); // [cite: 303]
            JOptionPane.showMessageDialog(null, "查询失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE); // [cite: 304]
        }
    }

    // Method to create table row from Transaction object - no changes needed here // [cite: 304]
    private Vector<String> createRowFromTransaction(Transaction transaction) {
        Vector<String> row = new Vector<>(); // [cite: 436]
        row.add(transaction.getTransactionTime()); // [cite: 437]
        row.add(transaction.getTransactionType()); // [cite: 437]
        row.add(transaction.getCounterparty()); // [cite: 437]
        row.add(transaction.getCommodity()); // [cite: 437]
        row.add(transaction.getInOut()); // [cite: 437]
        row.add(String.valueOf(transaction.getPaymentAmount())); // [cite: 437]
        row.add(transaction.getPaymentMethod()); // [cite: 437]
        row.add(transaction.getCurrentStatus()); // [cite: 438]
        row.add(transaction.getOrderNumber()); // [cite: 438]
        row.add(transaction.getMerchantNumber()); // [cite: 438]
        row.add(transaction.getRemarks()); // [cite: 438]
        row.add("Modify"); // [cite: 438]
        // Modify 按钮 // [cite: 438]
        row.add("Delete"); // [cite: 439]
        // 添加 Delete 按钮 // [cite: 439]
        return row; // [cite: 440]
    }

    // Method to delete row - update to use injected service // [cite: 304]
    public void deleteRow(int rowIndex) {
        if (rowIndex >= 0 && rowIndex < this.allData.size()) { // Use 'this' for allData // [cite: 305]
            String orderNumber = this.allData.get(rowIndex).get(8).trim(); // [cite: 305]
            // Use 'this' // [cite: 306]
            System.out.println("尝试删除的交易单号: " + orderNumber + " for user " + currentUser.getUsername()); // [cite: 306]
            try {
                // Use the injected transactionService instance // [cite: 307]
                boolean deleted = transactionService.deleteTransaction(orderNumber); // [cite: 307]
                if (deleted) { // [cite: 308]
                    // Data is removed from CSV and cache invalidated by service. // [cite: 308]
                    // Now update the UI model. // [cite: 309]
                    // Removing directly from allData and tableModel is acceptable here // [cite: 309]
                    // as loadCSVDataForCurrentUser() reloads from the single source of truth (cache/file). // [cite: 310]
                    // However, if allData is meant to be the in-memory representation used by search, // [cite: 310]
                    // it should be updated consistently. // [cite: 311]
                    // For simplicity and consistency with reloading, let's just reload the UI data. // [cite: 311]
                    loadCSVDataForCurrentUser(); // [cite: 311]
                    // Reload data after delete // [cite: 312]
                    // Alternatively, remove from allData and tableModel directly if allData is kept in sync. // [cite: 312]
                    // this.allData.remove(rowIndex); // If keeping allData perfectly in sync // [cite: 313]
                    // this.tableModel.removeRow(rowIndex); // [cite: 314]
                    // If keeping tableModel perfectly in sync // [cite: 314]


                    JOptionPane.showMessageDialog(null, "删除成功！", "提示", JOptionPane.INFORMATION_MESSAGE); // [cite: 314]
                    System.out.println("Deleted row " + rowIndex + " with order number " + orderNumber); // [cite: 315]
                } else {
                    // This case should be handled by the service throwing an exception or returning false. // [cite: 316]
                    JOptionPane.showMessageDialog(null, "删除失败：未找到对应的交易单号 " + orderNumber, "错误", JOptionPane.ERROR_MESSAGE); // [cite: 317]
                    System.err.println("Delete failed: order number " + orderNumber + " not found."); // [cite: 317]
                }
            } catch (Exception ex) { // deleteTransaction can throw Exception // [cite: 318]
                ex.printStackTrace(); // [cite: 318]
                JOptionPane.showMessageDialog(null, "删除失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE); // [cite: 319]
                System.err.println("Error during deletion for order number " + orderNumber); // [cite: 319]
            }
        } else {
            System.err.println("Attempted to delete row with invalid index: " + rowIndex); // [cite: 320]
        }
    }

    // Method to edit row - update to use injected service // [cite: 321]
    public void editRow(int rowIndex) {
        System.out.println("编辑行: " + rowIndex + " for user " + currentUser.getUsername()); // [cite: 321]
        if (rowIndex >= 0 && rowIndex < this.allData.size()) { // Use 'this' for allData // [cite: 322]
            Vector<String> rowData = new Vector<>(this.allData.get(rowIndex)); // [cite: 322]
            // Use 'this', create a copy // [cite: 323]


            // Create a panel for edit fields // [cite: 323]
            JPanel panel = new JPanel(new GridLayout(rowData.size() - 2, 2)); // [cite: 324]
            // Exclude last two columns ("Modify", "Delete") // [cite: 324]

            // Create fields array // [cite: 324]
            JTextField[] fields = new JTextField[rowData.size() - 2]; // [cite: 325]
            // Populate panel and fields from rowData, skipping last two columns // [cite: 325]
            for (int i = 0; i < rowData.size() - 2; i++) {
                panel.add(new JLabel(this.tableModel.getColumnName(i))); // [cite: 325]
                // Use 'this' // [cite: 326]
                fields[i] = new JTextField(rowData.get(i)); // [cite: 326]
                panel.add(fields[i]); // [cite: 327]
            }

            // Get the original order number, which is the key // [cite: 327]
            String originalOrderNumber = rowData.get(8).trim(); // [cite: 327]
            // Index 8 is OrderNumber // [cite: 328]


            // Show the dialog // [cite: 328]
            int result = JOptionPane.showConfirmDialog(null, panel, "修改交易信息 (订单号: " + originalOrderNumber + ")", JOptionPane.OK_CANCEL_OPTION); // [cite: 329]
            if (result == JOptionPane.OK_OPTION) {
                // User clicked OK, get updated values from fields // [cite: 329]

                // Create a Transaction object with updated values // [cite: 329]
                // Use the original order number as the key for the update operation // [cite: 330]
                Transaction updatedTransaction = new Transaction( // [cite: 330]
                        fields[0].getText().trim(), // 交易时间 // [cite: 330]
                        fields[1].getText().trim(), // 交易类型 // [cite: 331]
                        fields[2].getText().trim(), // 交易对方 // [cite: 331]
                        fields[3].getText().trim(), // 商品 // [cite: 331]
                        fields[4].getText().trim(), // 收/支 // [cite: 332]
                        // Handle paymentAmount parsing carefully // [cite: 332]
                        safeParseDouble(fields[5].getText().trim()), // 金额(元) - Use helper for parsing // [cite: 332]
                        fields[6].getText().trim(), // 支付方式 // [cite: 333]
                        fields[7].getText().trim(), // 当前状态 // [cite: 333]
                        originalOrderNumber, // Use the ORIGINAL order number as the identifier // [cite: 333]
                        fields[9].getText().trim(), // 商户单号 // [cite: 334]
                        fields[10].getText().trim() // 备注 // [cite: 334]
                );
                // Validate key fields if necessary (e.g., ensure OrderNumber wasn't changed in dialog implicitly) // [cite: 335]
                // If OrderNumber was editable, you'd need to handle the change, which is complex. // [cite: 336]
                // Assuming OrderNumber field in dialog is just for display/reference, or its change is handled separately. // [cite: 336]
                // If you want to allow changing OrderNumber, the updateTransaction logic in DAO needs adjustment // [cite: 337]
                // to delete the old and add with the new ON, which is tricky. // [cite: 337]
                // Let's assume OrderNumber is the stable key for updates. // [cite: 338]
                String dialogOrderNumber = fields[8].getText().trim(); // [cite: 338]
                if (!dialogOrderNumber.equals(originalOrderNumber)) { // [cite: 339]
                    System.err.println("Warning: Order number changed in edit dialog from '" + originalOrderNumber + "' to '" + dialogOrderNumber + "'. Using original ON for update."); // [cite: 339]
                    // Or handle this as an error: JOptionPane.showMessageDialog(null, "交易单号不允许修改！", "错误", JOptionPane.ERROR_MESSAGE); return; // [cite: 340]
                }
                // Ensure the updatedTransaction object uses the originalOrderNumber // [cite: 341]
                updatedTransaction.setOrderNumber(originalOrderNumber); // [cite: 341]
                try {
                    // Use the injected transactionService instance // [cite: 342]
                    transactionService.changeTransaction(updatedTransaction); // [cite: 342]
                    // Reload CSV data to update the table for the current user // [cite: 343]
                    loadCSVDataForCurrentUser(); // [cite: 343]
                    // Reload data after edit // [cite: 344]

                    JOptionPane.showMessageDialog(null, "修改成功！", "提示", JOptionPane.INFORMATION_MESSAGE); // [cite: 344]
                    System.out.println("Edited row " + rowIndex + " for order number " + originalOrderNumber); // [cite: 345]
                } catch (IllegalArgumentException e) {
                    // Catch specific exceptions from service, e.g., transaction not found // [cite: 346]
                    JOptionPane.showMessageDialog(null, "修改失败！\n" + e.getMessage(), "错误", JOptionPane.ERROR_MESSAGE); // [cite: 347]
                    e.printStackTrace(); // [cite: 347]
                }
                catch (Exception ex) { // Catch other exceptions from service // [cite: 347]
                    ex.printStackTrace(); // [cite: 348]
                    JOptionPane.showMessageDialog(null, "修改失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE); // [cite: 348]
                    System.err.println("Error during editing for order number " + originalOrderNumber); // [cite: 349]
                }
            }
        } else {
            System.err.println("Attempted to edit row with invalid index: " + rowIndex); // [cite: 350]
        }
    }

    // Helper method to safely parse double, return 0.0 on error // [cite: 350]
    private double safeParseDouble(String value) {
        if (value == null || value.trim().isEmpty()) { // [cite: 351]
            return 0.0; // [cite: 351]
        }
        try {
            return Double.parseDouble(value.trim()); // [cite: 352]
        } catch (NumberFormatException e) {
            System.err.println("Failed to parse double from string: '" + value + "'"); // [cite: 352]
            return 0.0; // Or handle as error // [cite: 353]
        }
    }

    // Keep helper methods like findTextField, findComboBox, emptyIfNull // [cite: 353]
    // Note: findTextField, findComboBox might be less reliable if dialog structure changes. // [cite: 354]
    // Consider making dialogs their own classes that return a Transaction object. // [cite: 354]
    /**
     * If field is null, return empty string. // [cite: 355]
     * @param value Field value // [cite: 356]
     * @return Non-null field value // [cite: 356]
     */
    private String emptyIfNull(String value) {
        return value == null ? "" : value; // [cite: 357]
    }

    // Keep getTable() for testing // [cite: 357]
    public JTable getTable() {
        return table; // [cite: 358]
    }

    // The findTextField and findComboBox methods that were in pre.txt but missing in post.txt
    /**
     * 查找容器中的输入字段
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0; // [cite: 469]
        for (Component component : container.getComponents()) { // [cite: 470]
            if (component instanceof JTextField) { // [cite: 470]
                if (count == index) { // [cite: 470]
                    return (JTextField) component; // [cite: 471]
                }
                count++; // [cite: 472]
            }
        }
        return null; // [cite: 473]
    }

    /**
     * 查找容器中的下拉框
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) { // [cite: 474]
            if (component instanceof JComboBox) { // [cite: 474]
                return (JComboBox<String>) component; // [cite: 475]
            }
        }
        return null; // [cite: 476]
    }
}
```
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\HistogramPanelContainer.java`:

```java
package Controller;
import Service.AIservice.AITransactionService;
import Service.TransactionService;

import javax.swing.*;
import java.awt.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    String userRequest = "分析账单";
    String filePath = "data/transactions.csv";
    String startTime = "2024-01-01";
    String endTime = "2024-12-31";

    private String aiResultText = ""; // 存储 AI 分析结果

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        // 按钮点击监听器
        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> {
            // 调用后台分析并显示结果
            analyzeTransactionsInBackground(userRequest, filePath, startTime, endTime);
        });
        btnShowText2.addActionListener(e -> {
            // 你可以根据需求设置其他的文本显示
            analyzeTransactionsInBackground(userRequest, filePath, startTime, endTime);
        });
    }

    // 切换直方图的显示和隐藏
    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }



    // 显示直方图的函数，模拟数据
    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }

    // 设置 AI 结果文本（供 AI 结果处理后调用）
    public void setAiResultText(String result) {
        this.aiResultText = result;
    }

    // 从后台线程调用，获取 AI 分析结果并更新界面
    public void analyzeTransactionsInBackground(String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            System.out.println("分析任务开始...");  // 调试输出
            String result = new AITransactionService().analyzeTransactions(userRequest, filePath, startTimeStr, endTimeStr);

            // 输出结果查看是否有返回
            System.out.println("AI分析结果: " + result);

            if (result != null && !result.isEmpty()) {
                SwingUtilities.invokeLater(() -> {
                    setAiResultText(result);  // 更新 AI 结果文本
                    toggleText(result);       // 显示 AI 结果
                });
            } else {
                System.out.println("AI分析没有返回结果!");
            }
        });
        executor.shutdown();
    }

    public void toggleText(String text) {
        System.out.println("切换文本显示...");  // 调试输出
        if (isTextVisible) {
            textArea.setText("");  // 清空文本区域
            textArea.setVisible(false);
        } else {
            aiResultText = text;
            textArea.setText(text);
            textArea.setVisible(true);
        }
        isTextVisible = !isTextVisible;
        SwingUtilities.invokeLater(() -> {
            System.out.println("更新分割条位置...");  // 调试输出
            splitPane.setDividerLocation(isTextVisible ? 0.5 : 0.0);
        });
    }

}


```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\Individual Contribution.txt`:

```txt

DAO

关熙辰：


负责模块: 数据访问层 (DAO) 的实现、核心数据模型设计、部分基础设施、 AI API 访问基础。

Individual Contribution:

CSV 数据访问实现: 完成并维护所有 DAO.Impl 包下的类 (CsvTransactionDao.java, CsvUserDao.java, CsvSummaryStatisticDao.java)，确保其能正确地读写 CSV 文件，并实现 DAO.TransactionDao, DAO.UserDao, DAO.SummaryStatisticDao 接口中定义的所有方法。

核心数据模型设计: 负责设计并维护 model 包下的类 (Transaction.java, User.java, SummaryStatistic.java, MonthlySummary.java)，确保其字段和结构满足业务需求。

AI API Key 获取: 负责获取和配置 AI 服务的 API Key，并在 AITransactionService 中安全地使用它（从环境变量）。

用户使用场景设计: 参与项目需求和用户故事的讨论，设计不同角色的使用场景和流程（与 backlog 相关，代码实现内容较少，但有助于理解数据模型和 DAO 需求）。

设置和维护项目的构建工具（Maven），管理所有外部依赖（如 Apache Commons CSV, Caffeine, XChart, VolcEngine SDK）

Service
陈鸿帆：

负责模块: AI 相关的业务逻辑实现、用户认证逻辑、跨用户统计计算逻辑、部分实用工具。
Individual Contribution:

AI 服务逻辑实现: 完成并维护 Service.AIservice 包下的类 (AITransactionService.java, CollegeStudentNeeds.java)，实现个人财务分析、预算建议、储蓄目标建议、个性化节约建议、交易类型识别等核心 AI 业务逻辑。确保这些服务能够利用 TransactionService 提供的结构化数据（如月度摘要）。

跨用户统计计算: 完成并维护 Service.Impl.SummaryStatisticService.java，实现读取所有用户数据、聚合计算每周汇总统计数据（包括总收支、最高支出类别、参与用户数）并将结果通过 SummaryStatisticDao 保存的功能。

日期/时间解析工具: 负责编写和维护日期/时间解析相关的工具方法或类（例如，确保在 TransactionServiceImpl, SummaryStatisticService, CollegeStudentNeeds 中使用的日期解析逻辑一致且健壮，考虑将其提取到 Utils 包下）。

AI 分类建议 UI 交互（UI层）: 在 showAddTransactionDialog() 和 editRow() 方法中，实现“AI分类建议”按钮的 ActionListener 逻辑，包括调用 CollegeStudentNeeds.RecognizeTransaction、显示/隐藏等待对话框、在 AI 返回后更新交易类型文本框。



唐梓茗

负责模块: 项目总体设计与集成、核心交易业务逻辑、缓存管理、常量定义、构建与配置管理、主程序入口。
Individual Contribution:

核心交易服务逻辑: 完成并维护 Service.TransactionService.java 接口和 Service.Impl.TransactionServiceImpl.java 实现类，实现基于单个用户数据的 CRUD (创建、读取、更新、删除)、搜索、获取月度摘要、从 CSV 导入等核心业务操作。依赖 TransactionDao。

缓存管理: 完成并维护 Utils.CacheManager.java，利用 Caffeine 实现用户交易数据的缓存管理逻辑，并集成到 TransactionServiceImpl 和 AITransactionService 中。负责废弃或移除 CacheUtil.java。

配置文件和常量定义: 负责 Constants.ConfigConstants.java 的实现和维护，确保能正确加载配置文件中的各项路径（CSV 文件路径、用户文件路径、统计文件路径）。负责编写常量类（Constants.CaffeineKeys.java, Constants.ConfigConstants.java, Constants.StandardCategories.java 等），定义项目使用的各种常量和配置键。

登录校验功能设计 (存储): 完成并维护 Service.User.UserService.java，实现用户登录校验逻辑，依赖 UserDao 获取用户数据。设计用户校验信息的数据存储格式（users.csv）和其与 User 模型的对应关系。与组别一人负责的 CsvUserDao 协作实现存取。

多用户数据处理设计: 设计不同用户交易数据文件的命名规则和存储位置，确保 User 模型的 transactionFilePath 字段能够正确关联用户与其数据文件。协调 Service 层和 DAO 层使用正确的用户文件路径。

CSV 数据导入 UI: 在 createInputPanel() 中添加“导入 CSV”按钮（与人员 1 协作布局），并实现其 ActionListener 逻辑 (showImportDialog())，包括弹出 JFileChooser 文件选择器，获取用户选择的文件路径，并调用 TransactionService.importTransactionsFromCsv() 进行导入（在后台线程中运行）。


UI

陈冠儒

负责模块: 核心 UI 框架、交易列表界面布局与基础元素、 Service 层与 UI 的基础联调。
Individual Contribution:

整体 UI 框架: 设计并维护 Controller.MenuUI.java 的主结构，包括继承 JPanel，设置主布局管理器 (BorderLayout)，创建左侧导航面板和右侧内容切换面板 (CardLayout)。

左侧导航面板: 创建并布局左侧导航面板 (createLeftPanel()) 中的所有按钮（“交易列表”, “AI分析”, “管理员统计” (管理员可见), “可视化”），设置其基础样式和布局，和其点击事件的 Service 层调用逻辑。

交易列表界面: 设计并实现交易列表面板 (createTablePanel()) 的布局，包括搜索输入面板 (createInputPanel() 的布局和基础组件创建，包含 action listeners) 和表格显示区域 (JTable 和 JScrollPane 的设置)。

表格行操作按钮: 实现 Controller.ButtonRenderer.java 和 Controller.ButtonEditor.java 类，为表格的“Modify”和“Delete”列提供按钮的显示和点击事件处理。

表格行操作逻辑: 在 MenuUI.java 中，实现由 ButtonEditor 调用的 deleteRow() 和 editRow() 方法中的业务逻辑，包括从表格模型获取数据、调用 TransactionService 进行删除和修改、更新 UI（刷新表格显示）。也包括 createInputPanel() 中“Add”按钮调用的 showAddTransactionDialog() 的逻辑实现（与人员 2 协作 AI 部分）。

基础 Service 联调: 负责将 MenuUI 实例（作为 Controller）与 Service 层对象（transactionService, summaryStatisticService, aiTransactionService, collegeStudentNeeds）通过构造函数注入进行关联，确保 UI 能够持有 Service 层的引用。

表格基础设置: 完成 JTable 的基本设置，如列名、行高、自动调整模式等。


李昊洋


负责模块: AI 相关 UI 界面、个人可视化界面（数据准备部分）、 AI 与 UI 的业务逻辑联调。
Individual Contribution:

AI 分析界面: 设计并实现 AI 分析面板 (createAIPanel()) 的详细布局，包括文本输入框、时间范围输入框、文本显示区域 (JTextArea) 以及所有 AI 功能按钮（“通用分析”, “个人消费总结”, “储蓄目标建议”, “个性化节约建议”, “预算建议”, “省钱技巧”）。

AI 按钮行为: 实现 AI 分析面板中所有按钮的 ActionListener 逻辑，包括从输入字段获取参数、调用 Service.AIservice 包下的相应方法（AITransactionService, CollegeStudentNeeds），在后台线程中运行 AI 调用，并在 AI 返回结果后通过 SwingUtilities.invokeLater 更新 aiResultArea。

可视化界面（数据准备）: 设计并实现可视化面板 (VisualizationPanel.java) 的布局，包括图表类型选择器 (chartTypeSelector)、月份选择器 (monthSelector)、“生成图表”按钮 (generateChartButton) 以及图表显示区域 (chartDisplayPanel)。实现根据用户选择从 transactionService.getMonthlyTransactionSummary() 获取数据的逻辑。

可视化控件行为: 实现可视化面板中选择器和“生成图表”按钮的 ActionListener 逻辑，包括根据选择器的值判断需要的数据和图表类型，调用 Service 获取数据，但不包含实际的图表绘制代码。实现 populateMonthSelector() 和 refreshPanelData() 方法。



林海天

负责模块: 管理员统计界面、数据导入 UI、表格行操作按钮、整体界面美化。
Individual Contribution:

管理员统计界面: 设计并实现管理员统计面板 (createAdminStatsPanel()) 的布局，包括按钮（“生成/更新统计数据”, “刷新显示”）和统计结果文本区域 (adminStatsArea)。

管理员按钮行为: 实现管理员统计面板中按钮的 ActionListener 逻辑，包括调用 SummaryStatisticService 的相应方法（generateAndSaveWeeklyStatistics, getAllSummaryStatistics）并在后台线程中运行，更新 adminStatsArea 显示统计结果。

整体界面美化: 负责统一应用程序的视觉风格，包括字体、颜色、组件间距、边框等，确保界面整洁、专业、用户友好。这贯穿所有 UI 模块。

图表绘制实现: 在 VisualizationPanel.generateAndDisplayChart() 方法中，使用 XChart 库根据数据绘制实际的饼图和柱状图，并将 XChartPanel 添加到 chartDisplayPanel 中。（将图表绘制这个相对独立的任务分配给美化人员，增加其代码工作量）



```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\README.md`:

```md
## Project Overview
This module is a transaction record management 
system in the Service layer of the project that connects 
with the Dao layer that provides CRUD (Create, Read, Update
, Delete) functionality and data processing for
transaction data. Core features include transaction 
creation, modification, deletion, and flexible querying,
all accessible through standardized interfaces.

## Structure and Function
Swing GUI (Controller) <- Service <- DAO <-data(CSV/JSON)<-model

##  Model 

### Overview

This Java class, located in the `model` package, serves 
as a Plain Old Java Object (POJO) or data model to 
represent a single financial transaction record. It 
encapsulates all the standard details associated with 
a transaction, such as its time, type, amount, parties 
involved, status, and unique identifiers.

This class is typically used in conjunction with Data 
Access Objects (DAOs) like `TransactionDao` and
`CsvTransactionDao` to load, save, and manipulate 
transaction data from a persistent store (e.g., a CSV 
file or database).

### Package

`model`

### Fields

The `Transaction` class contains the following fields:

* `transactionTime` (String): The date and time when the transaction occurred (e.g., "2023-10-27 15:30:00").
* `transactionType` (String): The category or type of the transaction (e.g., "在线支付" - Online Payment, "转账" - Transfer, "退款" - Refund).
* `counterparty` (String): The name or identifier of the other party involved in the transaction.
* `commodity` (String): A description of the goods, service, or reason for the transaction (e.g., "Coffee", "Salary", "Online Course Fee").
* `inOut` (String): Indicates the direction of the money flow relative to the account holder. Typically:
* `paymentAmount` (double): The monetary value of the transaction. The currency unit (e.g., Yuan) is implied by the context where this class is used (often indicated by header names like "金额(元)" in associated CSV files).
* `paymentMethod` (String): The method used for the payment (e.g., "支付宝" - Alipay, "微信支付" - WeChat Pay, "银行卡" - Bank Card, "现金" - Cash).
* `currentStatus` (String): The current processing status of the transaction (e.g., "交易成功" - Transaction Successful, "等待付款" - Awaiting Payment, "已关闭" - Closed, "退款成功" - Refund Successful).
* `orderNumber` (String): A unique identifier assigned to this specific transaction instance by the payment system or application. Often used as a primary key.
* `merchantNumber` (String): An order number or identifier associated with the merchant's system, often provided for reconciliation purposes. May be empty or null if not applicable.
* `remarks` (String): An optional field for any additional notes, comments, or user-provided descriptions about the transaction.

### Constructors

* **`public Transaction()`**
    * Default no-argument constructor. Creates an empty `Transaction` object with all fields initialized to their default values (null for String, 0.0 for double).

* **`public Transaction(String transactionTime, String transactionType, ..., String remarks)`**
    * Parameterized constructor that accepts values for all fields. Allows for quick instantiation of a fully populated `Transaction` object.

### Methods

The class provides standard public **getter** (`get...()`) and **setter** (`set...()`) methods for all its private fields. These methods allow controlled access and modification of the transaction's attributes from other parts of the application.

* `getTransactionTime()` / `setTransactionTime(String time)`
* `getTransactionType()` / `setTransactionType(String type)`
* `getCounterparty()` / `setCounterparty(String counterparty)`
* `getCommodity()` / `setCommodity(String commodity)`
* `getInOut()` / `setInOut(String inOut)`
* `getPaymentAmount()` / `setPaymentAmount(double amount)`
* `getPaymentMethod()` / `setPaymentMethod(String method)`
* `getCurrentStatus()` / `setCurrentStatus(String status)`
* `getOrderNumber()` / `setOrderNumber(String orderNumber)`
* `getMerchantNumber()` / `setMerchantNumber(String merchantNumber)`
* `getRemarks()` / `setRemarks(String remarks)`

 
### Service (Business logic)
- Responsibilities:
Transaction CRUD operations, calling the DAO layer to read and write local files,
User-defined classification logic (e.g. modifying transaction categories)
  (3) Operations:

Add Transaction:

Transaction t = new Transaction();
// Set field values
service.addTransaction(t);

Modify Transaction:

Transaction update = new Transaction();
update.setOrderNumber("ORD123");
// Set fields to update
service.changeTransaction(update);

Query Transactions:

Transaction criteria = new Transaction();
criteria.setCounterparty("Alipay");
List<Transaction> results = service.searchTransaction(criteria);
Code structure
   Directory Layout:
   src/main/java/
   └── Service/
   ├── Impl/
   │   └── TransactionServiceImpl.java  # Service implementation
   └── TransactionService.java          # Service interface
   TransactionService.java:
   Defines the service interface with business-agnostic method signatures, enforcing decoupling 
   between business logic and implementation details.
   TransactionServiceImpl.java:
   Implements the concrete business logic while depending only on the interface-defined contract, maintaining loose coupling with the data access layer through dependency injection.


- AIService (Intelligent Analytics) Responsibilities: Generate budget recommendations based
on historical data, and detect cost-cutting recommendations for seasonal spending in China
(e.g. Spring Festival) (e.g. marking high-frequency small spending)


- **`AITransactionService`**

The central class that performs the full AI-driven transaction analysis. It:

- Loads transaction data from a CSV file via `CsvTransactionDao`.
- Filters transactions by user-specified time range (`startTimeStr`, `endTimeStr`).
- Aggregates data by counterparty (income/spending, transaction counts).
- Formats the result into concise summaries sent to the AI.
- Sends user questions and formatted data to the Volcengine Ark AI API.
- Returns a response within **400 characters** for efficient display.

Key methods:
- `analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr)`
  → Returns an AI-generated analysis result string.
- `runAiInThread(...)`
  → Runs the AI logic in a background thread (single-threaded executor).
- `formatTransactions(...)`
  → Groups transactions and summarizes them by counterparty and time range.
- `parseDateTime(...)`
  → Supports flexible input formats like `yyyy/MM/dd`, `yyyy/MM/dd HH:mm`, and more. - **`AIAnalyzerThread`** A `Runnable` implementation for threading scenarios (especially GUI usage). It calls `AITransactionService.analyzeTransactions(...)` and prints the result. UI developers can replace the console output with GUI updates using `SwingUtilities.invokeLater()`. --- ### Tests (`test/java/Service/AIservice/`) - **`AIserviceTest`** Unit tests for `AITransactionService`, verifying: - Correct loading and filtering of transactions. - Accurate AI response generation and formatting. - Graceful handling of edge cases (e.g., no transactions in range, invalid time formats). - **`AIAnalyzerThreadTest`** Validates threading logic: - Ensures `AIAnalyzerThread` executes `Runnable` correctly. - Demonstrates clean and concurrent AI analysis flow. - Simulates integration with a GUI environment. - **`AiFunctionTest`** Utility-level tests: - Ensures proper CSV parsing and data transformation. - Verifies output formatting before sending to the AI. - Tests various time formats and edge case behaviors

## DAO (File Storage)
- Responsibilities: Save transaction data in CSV or JSON format and provide interfaces for adding,
  deleting, and modifying in-memory data
### CsvTransactionDao Class

#### Package

`DAO`

#### Dependencies

* **`model.Transaction`**: The data model class representing a single transaction.
* **`DAO.TransactionDao`**: The interface this class is intended to implement (though the implementation is incomplete).
* **Apache Commons CSV (`org.apache.commons.csv.*`)**: Used for robust parsing and writing of CSV data.
* **Apache Commons IO (`org.apache.commons.io.input.BOMInputStream`)**: Used specifically to handle potential Byte Order Marks (BOM) often found in UTF-8 encoded files, particularly those edited in Windows.
* **Java Standard Libraries**: `java.io.*`, `java.nio.*`.

#### Key Features & Implementation Details

* **CSV Loading (`loadFromCSV`)**:
  * Reads data from a specified CSV file path.
  * Expects UTF-8 encoding.
  * Handles potential Byte Order Mark (BOM) at the beginning of the file.
  * Uses the first row of the CSV as the header to map columns to `Transaction` fields. Assumes specific header names (e.g., "交易时间", "交易类型", "金额(元)").
  * Parses transaction records into a `List<Transaction>`.
  * Includes basic caching using an internal `transactions` list and an `isLoad` flag to avoid redundant file reads within the same instance lifecycle (unless forced by methods like `deleteTransaction` or `changeInformation`).
* **Record Parsing (`parseRecord`)**:
  * Converts a `CSVRecord` object (from Apache Commons CSV) into a `Transaction` object.
  * Specifically handles the "金额(元)" (Amount) field by removing the leading "¥" symbol before parsing it as a `double`.
* **Adding Transactions (`addTransaction(String filePath, Transaction newTransaction)`)**:
  * **Appends** a new transaction record to the *end* of the specified CSV file.
  * Creates the file if it doesn't exist.
  * Writes the header row only if the file is new or was empty.
  * Formats the payment amount by prepending "¥".
* **Deleting Transactions (`deleteTransaction(String filePath, String orderNumber)`)**:
  * Loads data from the file if not already cached.
  * Filters the cached list to remove the transaction matching the given `orderNumber`.
  * **Overwrites** the *entire* original CSV file with the filtered list using `writeTransactionsToCSV`.
  * Returns `true` if a transaction was removed, `false` otherwise.
* **Updating Transactions (`changeInformation`)**:
  * Loads data if not already cached.
  * Finds the transaction by `orderNumber`.
  * Modifies the specified field (`head`) of the found transaction object in memory.
  * **Crucially, it attempts the update by first *deleting* the original record (using `deleteTransaction`, which overwrites the file) and then *adding* the modified record (using `addTransaction`, which appends to the file).** This logic is inefficient and potentially problematic due to the conflicting file write strategies (overwrite vs. append).
  * Error handling for invalid `head` parameters prints to `System.err`. The method often returns `true` even if the underlying delete/add fails.
* **CSV Writing (`writeTransactionsToCSV`)**:
  * Helper method used by `deleteTransaction`.
  * Writes a given `List<Transaction>` to the specified file path, **overwriting** any existing content.
  * Writes a standard header row.
  * Formats the payment amount by prepending "¥".

#### Important Issues & Considerations

1.  **Incomplete `TransactionDao` Implementation**: The methods declared in the `TransactionDao` interface (`getAllTransactions`, `addTransaction(Transaction)`, `deleteTransaction(String)`, `updateTransaction`, `getTransactionByOrderNumber`) are present but contain only placeholder/stub code. The actual working logic uses separate methods that require the `filePath` to be passed explicitly each time. **This class, in its current state, does not correctly function as a `TransactionDao` implementation.**
2.  **Inconsistent File Writing Strategy**: `addTransaction` *appends* to the file, while `deleteTransaction` and `writeTransactionsToCSV` (used by `deleteTransaction` and `changeInformation`) *overwrite* the entire file. This inconsistency can lead to unexpected behavior, especially within the `changeInformation` method.
3.  **Inefficient Updates/Deletes**: Rewriting the entire CSV file for every single deletion or modification (`changeInformation`) is highly inefficient, especially for large transaction files.
4.  **Flawed Update Logic (`changeInformation`)**: The delete-then-add approach for updates is problematic due to the inconsistent write strategies and potential race conditions or partial failures. The modified record will likely appear at the *end* of the file, not its original position.
5.  **Basic Caching**: The caching mechanism (`isLoad` flag) is simple and does not account for external modifications to the CSV file during the application's runtime.
6.  **Hardcoded Dependencies**: The code relies on specific header names (in Chinese) and the "¥" currency symbol format within the CSV data. Changes to the CSV format would require code modifications.

#### Usage Example (Using Functional Methods)

```java
import DAO.Impl.CsvTransactionDao; // Assuming TransactionDao interface exists but is not used directly here due to stub methods
import model.Transaction;
import java.io.IOException;
import java.util.List;

public class CsvDataManager {

    public static void main(String[] args) {
        // NOTE: Using the class directly, not via the TransactionDao interface
        // because the interface methods are not fully implemented.
        CsvTransactionDao csvDao = new CsvTransactionDao();
        String csvFilePath = "path/to/your/transactions.csv"; // <--- Specify your file path

        try {
            // --- Load Data ---
            System.out.println("Loading transactions...");
            List<Transaction> transactions = csvDao.loadFromCSV(csvFilePath);
            System.out.println("Loaded " + transactions.size() + " transactions.");
            // Display first transaction if available
            if (!transactions.isEmpty()) {
                 System.out.println("First transaction order number: " + transactions.get(0).getOrderNumber());
            }

            // --- Add a New Transaction (Appends) ---
            Transaction newTx = new Transaction(
                 "2025-04-20 08:14:00", "Test Add", "Counterparty", "Item", "支",
                 10.0, "支付宝", "交易成功", "NEW_ORDER_123", "MERCH_456", "Test via DAO add"
            );
            System.out.println("\nAdding new transaction (append): " + newTx.getOrderNumber());
            // csvDao.addTransaction(csvFilePath, newTx); // Uncomment to actually add
            System.out.println("Transaction potentially added.");

            // --- Delete a Transaction (Overwrites File) ---
            String orderToDelete = "SOME_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number from your file
            System.out.println("\nAttempting to delete transaction: " + orderToDelete);
            // boolean deleted = csvDao.deleteTransaction(csvFilePath, orderToDelete); // Uncomment to actually delete
            // if (deleted) {
            //     System.out.println("Transaction deleted successfully (File rewritten).");
            // } else {
            //     System.out.println("Transaction not found for deletion.");
            // }

            // --- Change Information (Overwrites then Appends - Use with Caution) ---
             String orderToChange = "ANOTHER_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number
             String fieldToChange = "remarks";
             String newValue = "Updated remark via changeInformation";
             System.out.println("\nAttempting to change info for: " + orderToChange);
             // boolean changed = csvDao.changeInformation(orderToChange, fieldToChange, newValue, csvFilePath); // Uncomment with caution
             // System.out.println("Change operation attempted (File rewritten and appended). Result: " + changed);


        } catch (IOException e) {
            System.err.println("Error interacting with CSV file: " + e.getMessage());
            e.printStackTrace();
        } catch (NumberFormatException e) {
            System.err.println("Error parsing amount in CSV: " + e.getMessage());
        }
    }
}
```

## Controller (Swing GUI)

Responsibilities: Manage user interface components (buttons, tables, text boxes) to listen for 
events (clicks, inputs) and call service layer methods to update the interface data display

## attention
encoding with UTF-8

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\README.txt`:

```txt
## Project Overview

This module is a transaction record management 
system in the Service layer of the project that connects 
with the Dao layer that provides CRUD (Create, Read, Update
, Delete) functionality and data processing for
transaction data. Core features include transaction 
creation, modification, deletion, and flexible querying,
all accessible through standardized interfaces.

## Structure and Function

Swing GUI (Controller) <- Service <- DAO <-data(CSV/JSON)<-model

##  Model 

### Overview

This Java class, located in the `model` package, serves 
as a Plain Old Java Object (POJO) or data model to 
represent a single financial transaction record. It 
encapsulates all the standard details associated with 
a transaction, such as its time, type, amount, parties 
involved, status, and unique identifiers.

This class is typically used in conjunction with Data 
Access Objects (DAOs) like `TransactionDao` and
`CsvTransactionDao` to load, save, and manipulate 
transaction data from a persistent store (e.g., a CSV 
file or database).

### Package

`model`

### Fields

The `Transaction` class contains the following fields:

* `transactionTime` (String): The date and time when the transaction occurred (e.g., "2023-10-27 15:30:00").
* `transactionType` (String): The category or type of the transaction (e.g., "在线支付" - Online Payment, "转账" - Transfer, "退款" - Refund).
* `counterparty` (String): The name or identifier of the other party involved in the transaction.
* `commodity` (String): A description of the goods, service, or reason for the transaction (e.g., "Coffee", "Salary", "Online Course Fee").
* `inOut` (String): Indicates the direction of the money flow relative to the account holder. Typically:
* `paymentAmount` (double): The monetary value of the transaction. The currency unit (e.g., Yuan) is implied by the context where this class is used (often indicated by header names like "金额(元)" in associated CSV files).
* `paymentMethod` (String): The method used for the payment (e.g., "支付宝" - Alipay, "微信支付" - WeChat Pay, "银行卡" - Bank Card, "现金" - Cash).
* `currentStatus` (String): The current processing status of the transaction (e.g., "交易成功" - Transaction Successful, "等待付款" - Awaiting Payment, "已关闭" - Closed, "退款成功" - Refund Successful).
* `orderNumber` (String): A unique identifier assigned to this specific transaction instance by the payment system or application. Often used as a primary key.
* `merchantNumber` (String): An order number or identifier associated with the merchant's system, often provided for reconciliation purposes. May be empty or null if not applicable.
* `remarks` (String): An optional field for any additional notes, comments, or user-provided descriptions about the transaction.

### Constructors

* **`public Transaction()`**
  * Default no-argument constructor. Creates an empty `Transaction` object with all fields initialized to their default values (null for String, 0.0 for double).

* **`public Transaction(String transactionTime, String transactionType, ..., String remarks)`**
  * Parameterized constructor that accepts values for all fields. Allows for quick instantiation of a fully populated `Transaction` object.

### Methods

The class provides standard public **getter** (`get...()`) and **setter** (`set...()`) methods for all its private fields. These methods allow controlled access and modification of the transaction's attributes from other parts of the application.

* `getTransactionTime()` / `setTransactionTime(String time)`
* `getTransactionType()` / `setTransactionType(String type)`
* `getCounterparty()` / `setCounterparty(String counterparty)`
* `getCommodity()` / `setCommodity(String commodity)`
* `getInOut()` / `setInOut(String inOut)`
* `getPaymentAmount()` / `setPaymentAmount(double amount)`
* `getPaymentMethod()` / `setPaymentMethod(String method)`
* `getCurrentStatus()` / `setCurrentStatus(String status)`
* `getOrderNumber()` / `setOrderNumber(String orderNumber)`
* `getMerchantNumber()` / `setMerchantNumber(String merchantNumber)`
* `getRemarks()` / `setRemarks(String remarks)`


### Service (Business logic)

- Responsibilities:
  Transaction CRUD operations, calling the DAO layer to read and write local files,
  User-defined classification logic (e.g. modifying transaction categories)
  (3) Operations:

Add Transaction:

Transaction t = new Transaction();
// Set field values
service.addTransaction(t);

Modify Transaction:

Transaction update = new Transaction();
update.setOrderNumber("ORD123");
// Set fields to update
service.changeTransaction(update);

Query Transactions:

Transaction criteria = new Transaction();
criteria.setCounterparty("Alipay");
List<Transaction> results = service.searchTransaction(criteria);
Code structure
   Directory Layout:
   src/main/java/
   └── Service/
   ├── Impl/
   │   └── TransactionServiceImpl.java  # Service implementation
   └── TransactionService.java          # Service interface
   TransactionService.java:
   Defines the service interface with business-agnostic method signatures, enforcing decoupling 
   between business logic and implementation details.
   TransactionServiceImpl.java:
   Implements the concrete business logic while depending only on the interface-defined contract, maintaining loose coupling with the data access layer through dependency injection.


- AIService (Intelligent Analytics) Responsibilities: Generate budget recommendations based
  on historical data, and detect cost-cutting recommendations for seasonal spending in China
  (e.g. Spring Festival) (e.g. marking high-frequency small spending)


- **`AITransactionService`**

The central class that performs the full AI-driven transaction analysis. It:

- Loads transaction data from a CSV file via `CsvTransactionDao`.
- Filters transactions by user-specified time range (`startTimeStr`, `endTimeStr`).
- Aggregates data by counterparty (income/spending, transaction counts).
- Formats the result into concise summaries sent to the AI.
- Sends user questions and formatted data to the Volcengine Ark AI API.
- Returns a response within **400 characters** for efficient display.

Key methods:

- `analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr)`
  → Returns an AI-generated analysis result string.
- `runAiInThread(...)`
  → Runs the AI logic in a background thread (single-threaded executor).
- `formatTransactions(...)`
  → Groups transactions and summarizes them by counterparty and time range.
- `parseDateTime(...)`
  → Supports flexible input formats like `yyyy/MM/dd`, `yyyy/MM/dd HH:mm`, and more. - **`AIAnalyzerThread`** A `Runnable` implementation for threading scenarios (especially GUI usage). It calls `AITransactionService.analyzeTransactions(...)` and prints the result. UI developers can replace the console output with GUI updates using `SwingUtilities.invokeLater()`. --- ### Tests (`test/java/Service/AIservice/`) - **`AIserviceTest`** Unit tests for `AITransactionService`, verifying: - Correct loading and filtering of transactions. - Accurate AI response generation and formatting. - Graceful handling of edge cases (e.g., no transactions in range, invalid time formats). - **`AIAnalyzerThreadTest`** Validates threading logic: - Ensures `AIAnalyzerThread` executes `Runnable` correctly. - Demonstrates clean and concurrent AI analysis flow. - Simulates integration with a GUI environment. - **`AiFunctionTest`** Utility-level tests: - Ensures proper CSV parsing and data transformation. - Verifies output formatting before sending to the AI. - Tests various time formats and edge case behaviors

## DAO (File Storage)

- Responsibilities: Save transaction data in CSV or JSON format and provide interfaces for adding,
  deleting, and modifying in-memory data

### CsvTransactionDao Class

#### Package

`DAO`

#### Dependencies

* **`model.Transaction`**: The data model class representing a single transaction.
* **`DAO.TransactionDao`**: The interface this class is intended to implement (though the implementation is incomplete).
* **Apache Commons CSV (`org.apache.commons.csv.*`)**: Used for robust parsing and writing of CSV data.
* **Apache Commons IO (`org.apache.commons.io.input.BOMInputStream`)**: Used specifically to handle potential Byte Order Marks (BOM) often found in UTF-8 encoded files, particularly those edited in Windows.
* **Java Standard Libraries**: `java.io.*`, `java.nio.*`.

#### Key Features & Implementation Details

* **CSV Loading (`loadFromCSV`)**:
  * Reads data from a specified CSV file path.
  * Expects UTF-8 encoding.
  * Handles potential Byte Order Mark (BOM) at the beginning of the file.
  * Uses the first row of the CSV as the header to map columns to `Transaction` fields. Assumes specific header names (e.g., "交易时间", "交易类型", "金额(元)").
  * Parses transaction records into a `List<Transaction>`.
  * Includes basic caching using an internal `transactions` list and an `isLoad` flag to avoid redundant file reads within the same instance lifecycle (unless forced by methods like `deleteTransaction` or `changeInformation`).
* **Record Parsing (`parseRecord`)**:
  * Converts a `CSVRecord` object (from Apache Commons CSV) into a `Transaction` object.
  * Specifically handles the "金额(元)" (Amount) field by removing the leading "¥" symbol before parsing it as a `double`.
* **Adding Transactions (`addTransaction(String filePath, Transaction newTransaction)`)**:
  * **Appends** a new transaction record to the *end* of the specified CSV file.
  * Creates the file if it doesn't exist.
  * Writes the header row only if the file is new or was empty.
  * Formats the payment amount by prepending "¥".
* **Deleting Transactions (`deleteTransaction(String filePath, String orderNumber)`)**:
  * Loads data from the file if not already cached.
  * Filters the cached list to remove the transaction matching the given `orderNumber`.
  * **Overwrites** the *entire* original CSV file with the filtered list using `writeTransactionsToCSV`.
  * Returns `true` if a transaction was removed, `false` otherwise.
* **Updating Transactions (`changeInformation`)**:
  * Loads data if not already cached.
  * Finds the transaction by `orderNumber`.
  * Modifies the specified field (`head`) of the found transaction object in memory.
  * **Crucially, it attempts the update by first *deleting* the original record (using `deleteTransaction`, which overwrites the file) and then *adding* the modified record (using `addTransaction`, which appends to the file).** This logic is inefficient and potentially problematic due to the conflicting file write strategies (overwrite vs. append).
  * Error handling for invalid `head` parameters prints to `System.err`. The method often returns `true` even if the underlying delete/add fails.
* **CSV Writing (`writeTransactionsToCSV`)**:
  * Helper method used by `deleteTransaction`.
  * Writes a given `List<Transaction>` to the specified file path, **overwriting** any existing content.
  * Writes a standard header row.
  * Formats the payment amount by prepending "¥".

#### Important Issues & Considerations

1.  **Incomplete `TransactionDao` Implementation**: The methods declared in the `TransactionDao` interface (`getAllTransactions`, `addTransaction(Transaction)`, `deleteTransaction(String)`, `updateTransaction`, `getTransactionByOrderNumber`) are present but contain only placeholder/stub code. The actual working logic uses separate methods that require the `filePath` to be passed explicitly each time. **This class, in its current state, does not correctly function as a `TransactionDao` implementation.**
2.  **Inconsistent File Writing Strategy**: `addTransaction` *appends* to the file, while `deleteTransaction` and `writeTransactionsToCSV` (used by `deleteTransaction` and `changeInformation`) *overwrite* the entire file. This inconsistency can lead to unexpected behavior, especially within the `changeInformation` method.
3.  **Inefficient Updates/Deletes**: Rewriting the entire CSV file for every single deletion or modification (`changeInformation`) is highly inefficient, especially for large transaction files.
4.  **Flawed Update Logic (`changeInformation`)**: The delete-then-add approach for updates is problematic due to the inconsistent write strategies and potential race conditions or partial failures. The modified record will likely appear at the *end* of the file, not its original position.
5.  **Basic Caching**: The caching mechanism (`isLoad` flag) is simple and does not account for external modifications to the CSV file during the application's runtime.
6.  **Hardcoded Dependencies**: The code relies on specific header names (in Chinese) and the "¥" currency symbol format within the CSV data. Changes to the CSV format would require code modifications.

#### Usage Example (Using Functional Methods)

```java
import DAO.Impl.CsvTransactionDao; // Assuming TransactionDao interface exists but is not used directly here due to stub methods
import model.Transaction;
import java.io.IOException;
import java.util.List;

public class CsvDataManager {

    public static void main(String[] args) {
        // NOTE: Using the class directly, not via the TransactionDao interface
        // because the interface methods are not fully implemented.
        CsvTransactionDao csvDao = new CsvTransactionDao();
        String csvFilePath = "path/to/your/transactions.csv"; // <--- Specify your file path

        try {
            // --- Load Data ---
            System.out.println("Loading transactions...");
            List<Transaction> transactions = csvDao.loadFromCSV(csvFilePath);
            System.out.println("Loaded " + transactions.size() + " transactions.");
            // Display first transaction if available
            if (!transactions.isEmpty()) {
                 System.out.println("First transaction order number: " + transactions.get(0).getOrderNumber());
            }

            // --- Add a New Transaction (Appends) ---
            Transaction newTx = new Transaction(
                 "2025-04-20 08:14:00", "Test Add", "Counterparty", "Item", "支",
                 10.0, "支付宝", "交易成功", "NEW_ORDER_123", "MERCH_456", "Test via DAO add"
            );
            System.out.println("\nAdding new transaction (append): " + newTx.getOrderNumber());
            // csvDao.addTransaction(csvFilePath, newTx); // Uncomment to actually add
            System.out.println("Transaction potentially added.");

            // --- Delete a Transaction (Overwrites File) ---
            String orderToDelete = "SOME_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number from your file
            System.out.println("\nAttempting to delete transaction: " + orderToDelete);
            // boolean deleted = csvDao.deleteTransaction(csvFilePath, orderToDelete); // Uncomment to actually delete
            // if (deleted) {
            //     System.out.println("Transaction deleted successfully (File rewritten).");
            // } else {
            //     System.out.println("Transaction not found for deletion.");
            // }

            // --- Change Information (Overwrites then Appends - Use with Caution) ---
             String orderToChange = "ANOTHER_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number
             String fieldToChange = "remarks";
             String newValue = "Updated remark via changeInformation";
             System.out.println("\nAttempting to change info for: " + orderToChange);
             // boolean changed = csvDao.changeInformation(orderToChange, fieldToChange, newValue, csvFilePath); // Uncomment with caution
             // System.out.println("Change operation attempted (File rewritten and appended). Result: " + changed);


        } catch (IOException e) {
            System.err.println("Error interacting with CSV file: " + e.getMessage());
            e.printStackTrace();
        } catch (NumberFormatException e) {
            System.err.println("Error parsing amount in CSV: " + e.getMessage());
        }
    }
}
```

## Controller (Swing GUI)

Responsibilities: Manage user interface components (buttons, tables, text boxes) to listen for 
events (clicks, inputs) and call service layer methods to update the interface data display

## attention

encoding with UTF-8
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211 - 副本\项目要求.txt`:

```txt
1. General Information 
In the next few weeks, your team will be required to develop a software application that 
will serve as a smart personal finance manager that helps users track expenses, set 
savings goals, and analyses spending habits using AI. Agile methods should be applied 
in all activities, from requirements through analysis/design, implementation, and testing. 
Iterations should be planned, and outcomes should be submitted. 
There are no restrictions on what you can include in the final product, and the given 
specification contains only high-level abstract requirements. It should be noted that 
determining the software requirements is one of the most important and complex phases 
in any development project. You should apply requirement-finding techniques and Agile 
methods to identify the actual requirements at an appropriate level. Most importantly, you 
need to prioritize the features that are implemented in accordance with both ease of 
implementation and meeting requirements. As in real software, you should define the 
project scope properly. Keep your design SIMPLE. Bear in mind that there is no absolute 
right answer – your solution may be perfectly appropriate.

2. Project Specification 
2.1 Basic Requirements 
Managing personal finances effectively is crucial in today’s digital economy, where 
transactions occur across multiple platforms like WeChat Pay, Alipay, and traditional 
banking. Many individuals struggle with tracking expenses, categorizing spending, and 
setting realistic budgets. An AI-powered personal finance tracker simplifies financial 
management by automatically classifying transactions, detecting spending patterns, and 
offering personalized savings recommendations. However, AI is not perfect – users must 
manually review to ensure accuracy. By integrating AI with manual validation, this 
software helps users make informed financial decisions while adapting to regional 
spending habits and economic conditions, improving financial literacy and budgeting 
skills. Here are some suggested functions to assist you in getting started. Suggested 
features can include the following, but not limited to: 
• Manual & Automated Data Entry: End users may input transactions manually or 
import structured CSV files from banking/financial apps. 
• Expense Categorisation (AI + Manual Correction): AI classifies transactions into 
categories (e.g., groceries, rent, entertainment), but end users can verify & correct 
misclassifications. 
• Spending Insights & Predictions: AI suggests monthly budgets, savings goals, and 
cost-cutting recommendations based on spending behaviour. 
• Local Financial Context: Customisable to China-specific budgeting habits, for 
example detects seasonal spending habits, such as higher expenses during Chinese 
New Year. 
A full prototype of the application should be produced. It is not required to implement the 
full working code for all functions in the prototype, however your team should implement 
core functions of your choice. 

2.2 Other Requirements 
• The software must be developed using Java as a stand-alone application running 
on computers. A simple graphic user interface (GUI) should be used. The recent 
Java Edition should be used. Do NOT build a Web-based application or Phone 
App. 
• All input and output data should be in simple text file format. You may use plain 
text (txt), CSV, JSON, or XML. Do NOT use a database. 
• Basic restrictions and error checking must be considered. 
• Your design must be flexible and extensible to adapt to future changes, e.g. 
modify existing features and add new features. When doing so, you should be 
able to reuse the existing components and make the least impact on the existing 
code. 
Page 2 of 8 
Your tasks are to define detailed requirements, design, develop and test the above software 
using Agile methods. Feel free to design the software as long as it satisfies the basic 
requirements, define the SCOPE properly.  

2.3 AI-Assisted Development 
To prevent over-reliance on AI, 
the following constraints apply: 
• Live Data Collection: AI cannot generate user-specific data patterns – you must 
gather real data. 请给出相应的数据搜集渠道（但是我们已经设计好了csv表，相应字段也设计了）
• Manual Data Cleaning and Validation: AI assistance is allowed, but the team must 
need to manually check for missing information, inconsistency, and inappropriate 
categorisation, etc. 
• Context-Specific Constraints: AI may struggle with domain-specific rules – you 
must implement real-world constraints (e.g. AI may count a WeChat Red Packet as a 
personal income where it is in fact a gift money and not a regular income.) 
• Oral Spot-Check: During the vivas, you will need to answer questions like “Why did 
AI make this recommendation?”, “How did you modify AI’s solution?”, etc, to 
demonstrate your understanding.
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\AITestt.java`:

```java
package ControllerTest;

import Controller.HistogramPanelContainer;

import javax.swing.*;

public class AITestt {
    public static void main(String[] args) {
        // 设置外观为系统默认
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (Exception e) {
            e.printStackTrace();
        }

        // 创建窗口
        JFrame frame = new JFrame("Histogram Panel 测试");
        HistogramPanelContainer container = new HistogramPanelContainer();

        // 使用 SwingUtilities.invokeAndWait 来确保 UI 线程安全
        SwingUtilities.invokeLater(() -> {
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(1000, 600);
            frame.setContentPane(container);
            frame.setVisible(true);

            // 模拟调用 AI 结果（这里你可以改成真实的文件路径和参数）
            container.analyzeTransactionsInBackground(
                    "请分析交易中的异常模式",
                    "data/transactions.csv",  // 确保路径存在或替换为你实际的测试路径
                    "2022-01-01",
                    "2023-01-01"
            );
        });

        // 你可以适当的加入等待时间来保证后台线程有足够的时间完成
        try {
            Thread.sleep(3000);  // 等待 3 秒钟，以确保后台任务执行完毕（根据实际情况调整时间）
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>Ai-bill</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>com.formdev</groupId>
            <artifactId>flatlaf</artifactId>
            <version>3.6</version>
        </dependency>
        <dependency>
            <groupId>org.knowm.xchart</groupId>
            <artifactId>xchart</artifactId>
            <version>3.8.4</version> <!-- Use the latest version -->
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.2</version>
            <scope>test</scope>
        </dependency>

        <!-- CSV 解析核心库 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-csv</artifactId>
            <version>1.10.0</version>
        </dependency>

        <!-- 文件操作工具 -->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>2.15.1</version>
        </dependency>

        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>5.10.0</version>
            <scope>test</scope>
        </dependency>

        <!-- 断言增强库 -->
        <dependency>
            <groupId>org.assertj</groupId>
            <artifactId>assertj-core</artifactId>
            <version>3.24.2</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.volcengine</groupId>
            <artifactId>volcengine-java-sdk-ark-runtime</artifactId>
            <version>LATEST</version>
        </dependency>
        <dependency>
            <groupId>javax.annotation</groupId>
            <artifactId>javax.annotation-api</artifactId>
            <version>1.3.2</version>
        </dependency>
        <!-- pom.xml -->



        <!-- JSON 处理 -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.15.2</version>
        </dependency>

        <!--        caffeine缓存中间件-->
        <dependency>
            <groupId>com.github.ben-manes.caffeine</groupId>
            <artifactId>caffeine</artifactId>
            <version>3.1.8</version> <!-- 使用最新版本 -->
        </dependency>

    </dependencies>

</project>
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Constants\CaffeineKeys.java`:

```java
package Constants;

public class CaffeineKeys {
    public static final String TRANSACTION_CAFFEINE_KEY = "transactions";

}

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Constants\ConfigConstants.java`:

```java
package Constants;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

/**
 * Configuration Constants Class (Thread-safe initialization)
 */
public final class ConfigConstants {
    private ConfigConstants() {} // Private constructor to prevent instantiation

    // CSV Path Constants
    public static final String CSV_PATH; // Original, may still be referenced in old code
    public static final String USERS_CSV_PATH; // User CSV path
    public static final String SUMMARY_CSV_PATH; // Added summary statistics CSV path


    // Static initialization block (executes when the class is loaded)
    static {
        Properties prop = new Properties();
        try (InputStream input = ConfigConstants.class.getClassLoader()
                .getResourceAsStream("config.properties")) {

            if (input == null) {
                throw new RuntimeException("Configuration file config.properties not found in classpath");
            }

            prop.load(input);

            CSV_PATH = prop.getProperty("csv.path");
            USERS_CSV_PATH = prop.getProperty("csv.users_path");
            SUMMARY_CSV_PATH = prop.getProperty("csv.summary_path"); // Read summary statistics CSV path


            // Basic validation
            if (USERS_CSV_PATH == null || USERS_CSV_PATH.trim().isEmpty()) {
                throw new RuntimeException("'csv.users_path' not found or is empty in config.properties.");
            }
            if (SUMMARY_CSV_PATH == null || SUMMARY_CSV_PATH.trim().isEmpty()) {
                throw new RuntimeException("'csv.summary_path' not found or is empty in config.properties.");
            }

        } catch (IOException e) {
            throw new RuntimeException("Failed to load configuration file", e); // Convert to runtime exception
        }
        System.out.println("Loaded USERS_CSV_PATH: " + USERS_CSV_PATH);
        System.out.println("Loaded SUMMARY_CSV_PATH: " + SUMMARY_CSV_PATH);
        if (CSV_PATH != null) System.out.println("Loaded CSV_PATH: " + CSV_PATH); // Optional print
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Constants\StandardCategories.java`:

```java
package Constants;

import java.util.List;
import java.util.ArrayList;
import java.util.Collections; // For immutable lists
import java.util.stream.Collectors;

public final class StandardCategories {
    private StandardCategories() {} // Prevent instantiation

    // Standard Expense Categories for analysis and filtering
    public static final List<String> EXPENSE_CATEGORIES = Collections.unmodifiableList(List.of(
            "Dining",
            "Groceries",
            "Clothing",
            "Daily Necessities",
            "Transportation",
            "Entertainment",
            "Housing",
            "Communication",
            "Education",
            "Medical",
            "Financial Services",
            "Other Expenses"      //  General catch-all for expenses
    ));

    // Standard Income Categories
    public static final List<String> INCOME_CATEGORIES = Collections.unmodifiableList(List.of(
            "Salary",
            "Part-time Income",
            "Investment Income",
            "Other Income"        //  General catch-all for income
    ));

    // Special Transaction Types (may not be strictly 'expense' or 'income' in analysis)
    public static final List<String> SPECIAL_TYPES = Collections.unmodifiableList(List.of(
            "Transfer",           //  Transfers between accounts or people
            "Red Packet"          //  WeChat/Alipay Red Packets - often social, not regular income/expense
            // Add other special types as needed, e.g., Refund, Credit Card Repayment
    ));

    /**
     * Generates a comma-separated string of all standard categories for AI prompts.
     * @return String like "Dining,Groceries,Clothing,..."
     */
    public static String getAllCategoriesString() {
        return ALL_KNOWN_TYPES.stream()
                .collect(Collectors.joining(","));
    }

    // All Known Transaction Types (combination of all the above + potentially user-defined ones initially)
    // This list might be used for dropdowns in UI, etc.
    public static final List<String> ALL_KNOWN_TYPES;

    static {
        List<String> allTypesMutable = new ArrayList<>();
        allTypesMutable.addAll(EXPENSE_CATEGORIES);
        allTypesMutable.addAll(INCOME_CATEGORIES);
        allTypesMutable.addAll(SPECIAL_TYPES);
        ALL_KNOWN_TYPES = Collections.unmodifiableList(allTypesMutable);
    }


    /**
     * Helper method to check if a transaction type is a standard expense category.
     * Handles potential variations like "支" vs "支出".
     */
    public static boolean isStandardExpenseCategory(String type) {
        if (type == null) return false;
        String trimmedType = type.trim();
        // First, check if it's directly in the list
        if (EXPENSE_CATEGORIES.contains(trimmedType)) {
            return true;
        }
        // Handle common aliases/variations if necessary, e.g., "交通费" -> "交通"
        // This might require a mapping logic if aliases are common and not handled by AI mapping.
        return false; // For now, strict check
    }

    /**
     * Helper method to get the standardized category for a given transaction type string.
     * This is where mapping from potentially messy user input or AI output to standard categories happens.
     * For now, a simple direct match is used. In the future, this could use AI recognition results
     * or manual mapping rules.
     * @param rawType The transaction type string from data.
     * @return The matched standard category, or the original rawType if no standard match, or "Unknown" for null/empty.
     */
    public static String getStandardCategory(String rawType) {
        if (rawType == null || rawType.trim().isEmpty()) {
            return "Unknown"; // Unknown category
        }
        String trimmedType = rawType.trim();
        // Check if it matches any standard category (case-insensitive might be better)
        // Let's do a simple case-sensitive check for now against the predefined lists.
        if (ALL_KNOWN_TYPES.contains(trimmedType)) {
            return trimmedType; // Direct match
        }

        // Future Improvement: Implement smarter mapping here, potentially using AI suggestions
        // or a configuration file for mapping common user inputs to standard categories.


        return trimmedType; // If no standard match, return the original type.
        // We might want a dedicated "Other" if it doesn't fit any *known* type.
    }

    /**
     * Helper method to check if a transaction type is a standard income category.
     */
    public static boolean isStandardIncomeCategory(String type) {
        if (type == null) return false;
        return INCOME_CATEGORIES.contains(type.trim());
    }

    /**
     * Helper method to check if a transaction type is a special type.
     */
    public static boolean isSpecialType(String type) {
        if (type == null) return false;
        return SPECIAL_TYPES.contains(type.trim());
    }


}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Controller\ButtonEditor.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.TableCellEditor;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

class ButtonEditor extends AbstractCellEditor implements TableCellEditor {
    private final JPanel panel = new JPanel(new BorderLayout()); // Use BorderLayout
    private final JButton button = new JButton();
    private int rowIndex;
    private final MenuUI menuUI;

    public ButtonEditor(MenuUI menuUI) {
        this.menuUI = menuUI;

        // Set button style
        button.setFocusPainted(false); // Remove focus border from button
        button.setPreferredSize(new Dimension(80, 30)); // Set fixed size for the button

        // Add button to panel
        panel.add(button, BorderLayout.CENTER);

        // Add action listener to the button
        button.addActionListener(e -> {
            System.out.println("Button click event triggered: " + button.getText()); // "按钮点击事件触发: "
            fireEditingStopped(); // Stop editing
            String buttonText = button.getText();
            if ("Modify".equals(buttonText)) {
                menuUI.editRow(rowIndex); // Call MenuUI's editRow method
            } else if ("Delete".equals(buttonText)) {
                int confirm = JOptionPane.showConfirmDialog(panel, "Are you sure you want to delete this row?", "Confirm Delete", JOptionPane.YES_NO_OPTION); // "Are you sure you want to delete this row?", "Confirm deletion"
                if (confirm == JOptionPane.YES_OPTION) {
                    menuUI.deleteRow(rowIndex); // Call MenuUI's deleteRow method
                }
            }
        });
    }

    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
        this.rowIndex = row; // Update current row index
        button.setText(value != null ? value.toString() : ""); // Set button text based on cell value
        return panel;
    }

    @Override
    public Object getCellEditorValue() {
        return button.getText(); // Return the current text of the button
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Controller\ButtonRenderer.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import java.awt.*;

class ButtonRenderer extends DefaultTableCellRenderer {
    private final JPanel panel = new JPanel(new BorderLayout()); // Use BorderLayout
    private final JButton button = new JButton();

    public ButtonRenderer() {
        button.setFocusPainted(false); // Remove focus border from button
        button.setPreferredSize(new Dimension(80, 30)); // Set fixed size for the button
        panel.add(button, BorderLayout.CENTER); // Add button to the panel center
    }

    @Override
    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
        // Set button text based on cell value
        button.setText(value != null ? value.toString() : "");
        return panel;
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Controller\HistogramExample.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;
import java.util.HashMap;
import java.util.Random;

// Data Generation Class
class DataGenerator {
    public static int[] generateData(int numberOfDataPoints, int maxValue) {
        Random random = new Random();
        int[] data = new int[numberOfDataPoints];
        for (int i = 0; i < numberOfDataPoints; i++) {
            data[i] = random.nextInt(maxValue);
        }
        return data;
    }
}

// Histogram Calculation Class
class Histogram {
    private int binSize;
    private int[] data;

    public Histogram(int[] data, int binSize) {
        this.data = data;
        this.binSize = binSize;
    }

    public HashMap<Integer, Integer> computeFrequency() {
        HashMap<Integer, Integer> frequencyMap = new HashMap<>();
        for (int number : data) {
            int bin = number / binSize;
            frequencyMap.put(bin, frequencyMap.getOrDefault(bin, 0) + 1);
        }
        return frequencyMap;
    }
}

// Histogram GUI Drawing Class
class HistogramPanel extends JPanel {
    HashMap<Integer, Integer> frequencyMap;

    public HistogramPanel() {
        this.frequencyMap = new HashMap<>();
    }

    public void updateData(HashMap<Integer, Integer> frequencyMap) {
        this.frequencyMap = frequencyMap;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        int barWidth = 40;
        int gap = 10;
        int maxFrequency = frequencyMap.values().stream().mapToInt(v -> v).max().orElse(1);

        int index = 0;
        for (Integer key : frequencyMap.keySet()) {
            int height = (int) ((frequencyMap.get(key) / (double) maxFrequency) * getHeight());
            g.setColor(Color.BLUE);
            g.fillRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.setColor(Color.BLACK);
            g.drawRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.drawString("Bin " + key, index * (barWidth + gap) + 5, getHeight() - 5);
            index++;
        }
    }
}


// Main Window Class
public class HistogramExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("Data Analysis Interface"); // "数据分析界面"
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            // Assuming HistogramPanelContainer is defined elsewhere or if it's a typo and should be HistogramPanel
            // If HistogramPanelContainer is a separate class, its content is not provided for translation.
            // For now, I'll assume it might be a placeholder for HistogramPanel or a similar container.
            // If HistogramPanel itself is to be added:
            // HistogramPanel histogramPanel = new HistogramPanel();
            // // Example data for histogram (if not loaded through a container)
            // int[] data = DataGenerator.generateData(100, 100);
            // Histogram histogram = new Histogram(data, 10);
            // histogramPanel.updateData(histogram.computeFrequency());
            // frame.add(histogramPanel);
            // If HistogramPanelContainer is a real class, its name implies it contains HistogramPanel.
            // The user will need to provide that class if its internal strings/comments need translation.
            frame.add(new HistogramPanelContainer()); // This line remains, assuming HistogramPanelContainer exists
            frame.setVisible(true);
        });
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Controller\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// Histogram Panel Container
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("Show Histogram");
        JButton btnShowText1 = new JButton("Show Text 1");
        JButton btnShowText2 = new JButton("Show Text 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("Microsoft YaHei", Font.PLAIN, 18)); // "微软雅黑" (Microsoft YaHei is a common font name)
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("This is a very long text..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Controller\MenuUI.java`:

```java
package Controller;

import Constants.StandardCategories; // Import StandardCategories if needed in UI
import Service.AIservice.AITransactionService; // Import AI services
import Service.AIservice.CollegeStudentNeeds;
import Service.Impl.SummaryStatisticService; // Import SummaryStatisticService
import Service.TransactionService;
import model.SummaryStatistic; // Import SummaryStatistic
import model.Transaction;
import model.User;
// import Constants.StandardCategories; // Already imported above

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.io.IOException;
import java.util.List;
import java.util.Vector;
import java.util.Comparator; // For sorting stats display
import java.util.stream.Collectors; // Added for loadCSVDataForCurrentUser

public class MenuUI extends JPanel { // Extend JPanel for easier use in Main (optional but common)

    private final User currentUser;
    private final TransactionService transactionService;
    private final SummaryStatisticService summaryStatisticService;
    private final AITransactionService aiTransactionService;
    private final CollegeStudentNeeds collegeStudentNeeds;

    private DefaultTableModel tableModel;

    // Fields for search input components
    private JTextField searchTransactionTimeField;
    private JTextField searchTransactionTypeField;
    private JTextField searchCounterpartyField;
    private JTextField searchCommodityField;
    private JComboBox<String> searchInOutComboBox;
    private JTextField searchPaymentMethodField;
    private JButton searchButton;

    private JTable table;
    // REMOVED: private HistogramPanelContainer histogramPanelContainer; // No longer needed

    private JPanel rightPanel;
    private CardLayout cardLayout;

    // UI components for AI panel (existing)
    private JTextArea aiResultArea;
    private JTextField aiStartTimeField;
    private JTextField aiEndTimeField;
    private JButton aiAnalyzeButton;
    private JButton aiBudgetButton;
    private JButton aiTipsButton;
    private JButton aiPersonalSummaryButton;
    private JButton aiSavingsGoalsButton;
    private JButton aiPersonalSavingTipsButton;


    // UI components for Admin Stats panel (existing)
    private JTextArea adminStatsArea;
    private JButton generateStatsButton;
    private JButton refreshDisplayButton;

    // New panel for Visualization
    private VisualizationPanel visualizationPanel; // Add instance field


    // Constructor now accepts all necessary service instances (same as before)
    public MenuUI(User authenticatedUser, TransactionService transactionService,
                  SummaryStatisticService summaryStatisticService,
                  AITransactionService aiTransactionService,
                  CollegeStudentNeeds collegeStudentNeeds) {

        this.currentUser = authenticatedUser;
        this.transactionService = transactionService;
        this.summaryStatisticService = summaryStatisticService;
        this.aiTransactionService = aiTransactionService;
        this.collegeStudentNeeds = collegeStudentNeeds;

        // Initialize table model (same as before)
        String[] columnNames = {"Transaction Time", "Transaction Type", "Counterparty", "Commodity", "In/Out", "Amount(CNY)", "Payment Method", "Current Status", "Order Number", "Merchant Number", "Remarks", "Modify", "Delete"};
        this.tableModel = new DefaultTableModel(columnNames, 0);
        this.table = new JTable(this.tableModel);

        // Initialize the main panel layout (same as before)
        setLayout(new BorderLayout());

        // Add the left panel (will be modified)
        add(createLeftPanel(), BorderLayout.WEST);

        // Add the right panel (will be modified)
        setupRightPanel();
        add(rightPanel, BorderLayout.CENTER);

        // Initial data load is done in createMainPanel (same as before)
        // loadCSVDataForCurrentUser("Income");

        System.out.println("MenuUI initialized for user: " + currentUser.getUsername() + " (" + currentUser.getRole() + ")");
    }

    public JPanel createMainPanel() {
        // MenuUI itself is the main panel, just add the initial data
        loadCSVDataForCurrentUser(""); // Load and display all data initially, or a default like "Income"
        return this; // Return itself
    }


    // Method to load CSV data for the current user with optional initial filter
    // Same logic as before
    public void loadCSVDataForCurrentUser(String initialInOutFilter) {
        this.tableModel.setRowCount(0); // Clear the table model

        try {
            List<Transaction> transactions = transactionService.getAllTransactions();
            System.out.println("Loaded total " + transactions.size() + " transactions from service for user " + currentUser.getUsername());

            List<Transaction> filteredTransactions = new java.util.ArrayList<>();
            if (initialInOutFilter == null || initialInOutFilter.trim().isEmpty()) {
                filteredTransactions.addAll(transactions);
            } else {
                String filter = initialInOutFilter.trim();
                // Assuming "Income" maps to "收" and "Expense" maps to "支" or their English equivalents if data uses that.
                // The UI might use "Income"/"Expense", while data might use "收"/"支" or "In"/"Out".
                // This filter needs to be robust to these variations.
                filteredTransactions = transactions.stream()
                        .filter(t -> t.getInOut() != null && (t.getInOut().equalsIgnoreCase(filter) ||
                                (filter.equalsIgnoreCase("Income") && (t.getInOut().equalsIgnoreCase("收") || t.getInOut().equalsIgnoreCase("In"))) ||
                                (filter.equalsIgnoreCase("Expense") && (t.getInOut().equalsIgnoreCase("支") || t.getInOut().equalsIgnoreCase("Out"))) ))
                        .collect(Collectors.toList());
            }

            for (Transaction transaction : filteredTransactions) {
                Vector<String> row = createRowFromTransaction(transaction);
                this.tableModel.addRow(row);
            }
            System.out.println("Displayed " + filteredTransactions.size() + " transactions in the table.");

        } catch (Exception e) {
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, "Failed to load user transaction data!", "Error", JOptionPane.ERROR_MESSAGE);
        }
    }

    // Method to create the left panel (Menu/AI/Admin/Visualization buttons) - MODIFIED
    private JPanel createLeftPanel() {
        JPanel leftPanel = new JPanel();
        leftPanel.setLayout(new BoxLayout(leftPanel, BoxLayout.Y_AXIS));
        leftPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        JButton menuButton = new JButton("Transaction List"); // "交易列表"
        JButton aiButton = new JButton("AI Analysis");       // "AI分析"
        JButton adminButton = new JButton("Admin Stats");     // "管理员统计"
        JButton visualizationButton = new JButton("Visualization"); // "可视化"

        // Set consistent size for buttons
        Dimension buttonSize = new Dimension(150, 40);
        menuButton.setMaximumSize(buttonSize);
        aiButton.setMaximumSize(buttonSize);
        adminButton.setMaximumSize(buttonSize);
        visualizationButton.setMaximumSize(buttonSize);


        menuButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        aiButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        adminButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        visualizationButton.setAlignmentX(Component.CENTER_ALIGNMENT);


        leftPanel.add(menuButton);
        leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        leftPanel.add(aiButton);
        leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));

        // Add Admin button only if the user is admin (same as before)
        if ("admin".equalsIgnoreCase(currentUser.getRole())) {
            leftPanel.add(adminButton);
            leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        }

        // Add Visualization button (visible for all users)
        leftPanel.add(visualizationButton);
        leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));


        // Add action listeners (existing for Menu, AI, Admin)
        menuButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Table");
            loadCSVDataForCurrentUser("Income"); // Load "Income" by default or "" for all
        });

        aiButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "AI");
        });

        if ("admin".equalsIgnoreCase(currentUser.getRole())) {
            adminButton.addActionListener(e -> {
                cardLayout.show(rightPanel, "AdminStats");
                displaySummaryStatistics(); // Refresh stats display when switching
            });
        }

        // Add action listener for Visualization button - NEW
        visualizationButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Visualization"); // Switch to visualization view
            if (visualizationPanel != null) { // Ensure panel is initialized
                visualizationPanel.refreshPanelData(); // Call refresh method
            }
        });


        leftPanel.add(Box.createVerticalGlue());

        return leftPanel;
    }

    // Method to set up the right panel, adding different views - MODIFIED
    private void setupRightPanel() {
        this.cardLayout = new CardLayout();
        this.rightPanel = new JPanel(this.cardLayout);

        // Create and add different panels (views)
        JPanel tablePanel = createTablePanel(); // Table view
        JPanel aiPanel = createAIPanel(); // AI view
        JPanel adminStatsPanel = createAdminStatsPanel(); // Admin stats view
        this.visualizationPanel = new VisualizationPanel(this.transactionService);


        rightPanel.add(tablePanel, "Table");
        rightPanel.add(aiPanel, "AI");
        if ("admin".equalsIgnoreCase(currentUser.getRole())) {
            rightPanel.add(adminStatsPanel, "AdminStats");
        }
        rightPanel.add(visualizationPanel, "Visualization");


        // Set the initially visible card (Table view)
        cardLayout.show(rightPanel, "Table");
    }

    // Method to create the table panel - same as before
    private JPanel createTablePanel() {
        JPanel tablePanel = new JPanel(new BorderLayout());

        JPanel inputPanel = createInputPanel();
        tablePanel.add(inputPanel, BorderLayout.NORTH);

        JScrollPane tableScrollPane = new JScrollPane(this.table);
        tableScrollPane.setPreferredSize(new Dimension(1000, 250));
        this.table.setFillsViewportHeight(true);
        this.table.setRowHeight(30);

        tablePanel.add(tableScrollPane, BorderLayout.CENTER);

        // Set cell renderers and editors
        this.table.getColumnModel().getColumn(11).setCellRenderer(new ButtonRenderer());
        this.table.getColumnModel().getColumn(11).setCellEditor(new ButtonEditor(this));

        this.table.getColumnModel().getColumn(12).setCellRenderer(new ButtonRenderer());
        this.table.getColumnModel().getColumn(12).setCellEditor(new ButtonEditor(this));

        return tablePanel;
    }

    // Inside MenuUI class
    private JPanel createInputPanel() {
        JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));

        searchTransactionTimeField = new JTextField(10);
        searchTransactionTypeField = new JTextField(10);
        searchCounterpartyField = new JTextField(10);
        searchCommodityField = new JTextField(10);
        searchInOutComboBox = new JComboBox<>(new String[]{"", "Income", "Expense"}); // "Income", "Expense"
        searchPaymentMethodField = new JTextField(10);

        inputPanel.add(new JLabel("Transaction Time:")); inputPanel.add(searchTransactionTimeField);
        inputPanel.add(new JLabel("Transaction Type:")); inputPanel.add(searchTransactionTypeField);
        inputPanel.add(new JLabel("Counterparty:")); inputPanel.add(searchCounterpartyField);
        inputPanel.add(new JLabel("Commodity:")); inputPanel.add(searchCommodityField);
        inputPanel.add(new JLabel("In/Out:")); inputPanel.add(searchInOutComboBox);
        inputPanel.add(new JLabel("Payment Method:")); inputPanel.add(searchPaymentMethodField);

        searchButton = new JButton("Search");
        JButton addButton = new JButton("Add");
        JButton importButton = new JButton("Import CSV"); // "Import CSV"

        inputPanel.add(searchButton);
        inputPanel.add(addButton);
        inputPanel.add(importButton);

        searchButton.addActionListener(e -> triggerCurrentSearch());
        addButton.addActionListener(e -> showAddTransactionDialog());

        importButton.addActionListener(e -> {
            showImportDialog();
        });

        return inputPanel;
    }

    // Inside MenuUI class
    private void showImportDialog() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Select CSV file to import");
        fileChooser.setFileFilter(new javax.swing.filechooser.FileNameExtensionFilter("CSV Files (*.csv)", "csv"));

        int userSelection = fileChooser.showOpenDialog(this);

        if (userSelection == JFileChooser.APPROVE_OPTION) {
            java.io.File fileToImport = fileChooser.getSelectedFile();
            String filePath = fileToImport.getAbsolutePath();
            System.out.println("User selected file for import: " + filePath);

            new Thread(() -> {
                String message;
                try {
                    int importedCount = transactionService.importTransactionsFromCsv(currentUser.getTransactionFilePath(), filePath);
                    message = "Successfully imported " + importedCount + " transaction records.";
                    System.out.println(message);

                    String finalMessage = message;
                    SwingUtilities.invokeLater(() -> {
                        loadCSVDataForCurrentUser("");
                        clearSearchFields();
                        JOptionPane.showMessageDialog(this, finalMessage, "Import Successful", JOptionPane.INFORMATION_MESSAGE);
                    });

                } catch (Exception ex) {
                    message = "Import failed!\n" + ex.getMessage();
                    System.err.println("CSV Import failed: " + ex.getMessage());
                    ex.printStackTrace();
                    String finalMessage1 = message;
                    SwingUtilities.invokeLater(() -> {
                        JOptionPane.showMessageDialog(this, finalMessage1, "Import Error", JOptionPane.ERROR_MESSAGE);
                    });
                }
            }).start();
        } else {
            System.out.println("User cancelled file selection.");
        }
    }

    // Inside MenuUI class, showAddTransactionDialog method
    private void showAddTransactionDialog() {
        JDialog addDialog = new JDialog();
        addDialog.setTitle("Add Transaction"); // "Add Transaction"
        JPanel dialogPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.insets = new Insets(5, 5, 5, 5);

        JTextField transactionTimeField = new JTextField(15);
        JTextField transactionTypeField = new JTextField(15);
        JButton aiSuggestButton = new JButton("AI Category Suggestion"); // "AI Category Suggestion"

        JTextField counterpartyField = new JTextField(15);
        JTextField commodityField = new JTextField(15);
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"Income", "Expense"}); // "Income", "Expense"
        JTextField paymentAmountField = new JTextField(15);
        JTextField paymentMethodField = new JTextField(15);
        JTextField currentStatusField = new JTextField(15);
        JTextField orderNumberField = new JTextField(15);
        JTextField merchantNumberField = new JTextField(15);
        JTextField remarksField = new JTextField(15);


        gbc.gridx = 0; gbc.gridy = 0; dialogPanel.add(new JLabel("Transaction Time:"), gbc);
        gbc.gridx = 1; gbc.gridy = 0; gbc.gridwidth = 2; dialogPanel.add(transactionTimeField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 1; dialogPanel.add(new JLabel("Transaction Type:"), gbc);
        gbc.gridx = 1; gbc.gridy = 1; gbc.weightx = 1.0; dialogPanel.add(transactionTypeField, gbc);
        gbc.gridx = 2; gbc.gridy = 1; gbc.weightx = 0.0; dialogPanel.add(aiSuggestButton, gbc);

        gbc.gridx = 0; gbc.gridy = 2; gbc.gridwidth = 1; dialogPanel.add(new JLabel("Counterparty:"), gbc);
        gbc.gridx = 1; gbc.gridy = 2; gbc.gridwidth = 2; dialogPanel.add(counterpartyField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 3; gbc.gridwidth = 1; dialogPanel.add(new JLabel("Commodity:"), gbc);
        gbc.gridx = 1; gbc.gridy = 3; gbc.gridwidth = 2; dialogPanel.add(commodityField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 4; gbc.gridwidth = 1; dialogPanel.add(new JLabel("In/Out:"), gbc);
        gbc.gridx = 1; gbc.gridy = 4; gbc.gridwidth = 2; dialogPanel.add(inOutComboBox, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 5; gbc.gridwidth = 1; dialogPanel.add(new JLabel("Amount(CNY):"), gbc);
        gbc.gridx = 1; gbc.gridy = 5; gbc.gridwidth = 2; dialogPanel.add(paymentAmountField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 6; gbc.gridwidth = 1; dialogPanel.add(new JLabel("Payment Method:"), gbc);
        gbc.gridx = 1; gbc.gridy = 6; gbc.gridwidth = 2; dialogPanel.add(paymentMethodField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 7; gbc.gridwidth = 1; dialogPanel.add(new JLabel("Current Status:"), gbc);
        gbc.gridx = 1; gbc.gridy = 7; gbc.gridwidth = 2; dialogPanel.add(currentStatusField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 8; gbc.gridwidth = 1; dialogPanel.add(new JLabel("Order Number:"));
        gbc.gridx = 1; gbc.gridy = 8; gbc.gridwidth = 2; dialogPanel.add(orderNumberField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 9; gbc.gridwidth = 1; dialogPanel.add(new JLabel("Merchant Number:"));
        gbc.gridx = 1; gbc.gridy = 9; gbc.gridwidth = 2; dialogPanel.add(merchantNumberField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 10; gbc.gridwidth = 1; dialogPanel.add(new JLabel("Remarks:"));
        gbc.gridx = 1; gbc.gridy = 10; gbc.gridwidth = 2; dialogPanel.add(remarksField, gbc); gbc.gridwidth = 1;

        JDialog waitingDialog = new JDialog(addDialog, "Please wait", true); // "Please wait"
        waitingDialog.setLayout(new FlowLayout());
        waitingDialog.add(new JLabel("Getting AI category suggestion...")); // "Getting AI category suggestion..."
        waitingDialog.setSize(250, 100);
        waitingDialog.setResizable(false);

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        JButton confirmButton = new JButton("Confirm"); // "Confirm"
        JButton cancelButton = new JButton("Cancel");   // "Cancel"
        buttonPanel.add(confirmButton);
        buttonPanel.add(cancelButton);

        gbc.gridx = 0; gbc.gridy = 11; gbc.gridwidth = 3; gbc.anchor = GridBagConstraints.CENTER; gbc.fill = GridBagConstraints.NONE;
        dialogPanel.add(buttonPanel, gbc);

        addDialog.add(dialogPanel, BorderLayout.CENTER);

        aiSuggestButton.addActionListener(e -> {
            System.out.println("AI Suggest button clicked (EDT).");
            aiSuggestButton.setEnabled(false);
            Transaction tempTransaction = new Transaction(
                    emptyIfNull(transactionTimeField.getText().trim()),
                    emptyIfNull(transactionTypeField.getText().trim()),
                    emptyIfNull(counterpartyField.getText().trim()),
                    emptyIfNull(commodityField.getText().trim()),
                    (String) inOutComboBox.getSelectedItem(),
                    safeParseDouble(paymentAmountField.getText().trim()),
                    emptyIfNull(paymentMethodField.getText().trim()),
                    emptyIfNull(currentStatusField.getText().trim()),
                    emptyIfNull(orderNumberField.getText().trim()),
                    emptyIfNull(merchantNumberField.getText().trim()),
                    emptyIfNull(remarksField.getText().trim())
            );
            new Thread(() -> {
                System.out.println("Background thread started for AI classification...");
                String aiSuggestion = null;
                try {
                    aiSuggestion = collegeStudentNeeds.RecognizeTransaction(tempTransaction);
                    System.out.println("AI Classification returned in background thread: " + aiSuggestion);
                } catch (Exception ex) {
                    System.err.println("Error in background AI thread: " + ex.getMessage());
                    ex.printStackTrace();
                    aiSuggestion = "Error: " + ex.getMessage();
                }
                String finalSuggestion = aiSuggestion;
                SwingUtilities.invokeLater(() -> {
                    System.out.println("Updating UI on EDT from background thread.");
                    waitingDialog.setVisible(false);
                    if (finalSuggestion != null && !finalSuggestion.isEmpty() && !finalSuggestion.startsWith("Error:")) {
                        if (StandardCategories.ALL_KNOWN_TYPES.contains(finalSuggestion.trim())) {
                            transactionTypeField.setText(finalSuggestion.trim());
                        } else {
                            System.err.println("AI returned non-standard category despite prompt: " + finalSuggestion);
                            JOptionPane.showMessageDialog(addDialog, "AI returned an unexpected category format:\n" + finalSuggestion + "\nPlease enter manually.", "AI Result Anomaly", JOptionPane.WARNING_MESSAGE);
                            transactionTypeField.setText("");
                        }
                    } else if (finalSuggestion != null && finalSuggestion.startsWith("Error:")) {
                        JOptionPane.showMessageDialog(addDialog, "Failed to get AI category suggestion!\n" + finalSuggestion.substring(6), "AI Error", JOptionPane.ERROR_MESSAGE);
                        transactionTypeField.setText("");
                    }
                    else {
                        JOptionPane.showMessageDialog(addDialog, "AI could not provide a category suggestion.", "AI Tip", JOptionPane.INFORMATION_MESSAGE);
                        transactionTypeField.setText("");
                    }
                    aiSuggestButton.setEnabled(true);
                    System.out.println("UI update complete, buttons re-enabled.");
                });
            }).start();
            System.out.println("Showing waiting dialog (EDT block continues here).");
            waitingDialog.setLocationRelativeTo(addDialog);
            waitingDialog.setVisible(true);
            System.out.println("waiting dialog is now hidden (EDT unblocked).");
        });

        confirmButton.addActionListener(e -> {
            String transactionTime = emptyIfNull(transactionTimeField.getText().trim());
            String finalTransactionType = emptyIfNull(transactionTypeField.getText().trim());
            String counterparty = emptyIfNull(counterpartyField.getText().trim());
            String commodity = emptyIfNull(commodityField.getText().trim());
            String inOut = (String) inOutComboBox.getSelectedItem();
            String paymentAmountText = paymentAmountField.getText().trim();
            String paymentMethod = emptyIfNull(paymentMethodField.getText().trim());
            String currentStatus = emptyIfNull(currentStatusField.getText().trim());
            String orderNumber = emptyIfNull(orderNumberField.getText().trim());
            String merchantNumber = emptyIfNull(merchantNumberField.getText().trim());
            String remarks = emptyIfNull(remarksField.getText().trim());

            if (orderNumber.isEmpty()) {
                JOptionPane.showMessageDialog(addDialog, "Order Number cannot be empty!", "Input Error", JOptionPane.ERROR_MESSAGE);
                return;
            }
            if (finalTransactionType.isEmpty()) {
                JOptionPane.showMessageDialog(addDialog, "Transaction Type cannot be empty!", "Input Error", JOptionPane.ERROR_MESSAGE);
                return;
            }
            if (!StandardCategories.ALL_KNOWN_TYPES.contains(finalTransactionType)) {
                JOptionPane.showMessageDialog(addDialog, "Transaction type must be one of the standard categories!\nAllowed categories:\n" + StandardCategories.getAllCategoriesString(), "Input Error", JOptionPane.ERROR_MESSAGE);
                return;
            }
            double paymentAmount = 0.0;
            if (!paymentAmountText.isEmpty()) {
                try {
                    paymentAmount = Double.parseDouble(paymentAmountText);
                    if (paymentAmount < 0) {
                        JOptionPane.showMessageDialog(addDialog, "Amount cannot be negative!", "Input Error", JOptionPane.ERROR_MESSAGE);
                        return;
                    }
                } catch (NumberFormatException ex) {
                    JOptionPane.showMessageDialog(addDialog, "Amount format is incorrect! Please enter a number.", "Input Error", JOptionPane.ERROR_MESSAGE);
                    return;
                }
            }
            Transaction newTransaction = new Transaction(
                    transactionTime, finalTransactionType, counterparty, commodity, inOut,
                    paymentAmount, paymentMethod, currentStatus, orderNumber, merchantNumber, remarks
            );
            try {
                transactionService.addTransaction(newTransaction);
                loadCSVDataForCurrentUser("");
                clearSearchFields();
                addDialog.dispose();
                JOptionPane.showMessageDialog(null, "Transaction added successfully!", "Information", JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(null, "Failed to add transaction!\n" + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
            } catch (Exception ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(null, "Failed to add transaction!\n" + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
            }
        });
        cancelButton.addActionListener(e -> addDialog.dispose());
        addDialog.pack();
        addDialog.setLocationRelativeTo(this);
        addDialog.setVisible(true);
    }

    public void editRow(int rowIndex) {
        System.out.println("Editing row: " + rowIndex + " for user " + currentUser.getUsername());
        JDialog editDialog = new JDialog();
        JPanel dialogPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();

        if (rowIndex >= 0 && rowIndex < this.tableModel.getRowCount()) {
            Vector<String> rowData = new Vector<>();
            for (int i = 0; i <= 10; i++) {
                Object value = this.tableModel.getValueAt(rowIndex, i);
                rowData.add(value != null ? value.toString() : "");
            }
            System.out.println("Retrieved row data from table model for editing: " + rowData);
            String originalOrderNumber = rowData.get(8).trim();
            if (originalOrderNumber.isEmpty()) {
                JOptionPane.showMessageDialog(null, "Cannot edit: Order Number is empty!", "Error", JOptionPane.ERROR_MESSAGE);
                System.err.println("Attempted to edit row " + rowIndex + " but order number is empty.");
                return;
            }
            editDialog.setTitle("Edit Transaction (Order No: " + originalOrderNumber + ")"); // "Edit Transaction (Order No: "
            editDialog.setModal(true);
            gbc.fill = GridBagConstraints.HORIZONTAL;
            gbc.insets = new Insets(5, 5, 5, 5);
            JTextField[] fields = new JTextField[11];
            String[] fieldNames = {"Transaction Time", "Transaction Type", "Counterparty", "Commodity", "In/Out", "Amount(CNY)", "Payment Method", "Current Status", "Order Number", "Merchant Number", "Remarks"};
            JButton aiSuggestButton = new JButton("AI Category Suggestion"); // "AI Category Suggestion"

            for (int i = 0; i < fieldNames.length; i++) {
                gbc.gridx = 0; gbc.gridy = i; gbc.gridwidth = 1; gbc.weightx = 0.0; dialogPanel.add(new JLabel(fieldNames[i] + ":"), gbc);
                fields[i] = new JTextField(rowData.get(i));
                if (i == 1) {
                    gbc.gridx = 1; gbc.gridy = i; gbc.weightx = 1.0; dialogPanel.add(fields[i], gbc);
                    gbc.gridx = 2; gbc.gridy = i; gbc.weightx = 0.0; dialogPanel.add(aiSuggestButton, gbc);
                    gbc.gridwidth = 1;
                } else {
                    gbc.gridx = 1; gbc.gridy = i; gbc.gridwidth = 2; gbc.weightx = 1.0; dialogPanel.add(fields[i], gbc);
                    gbc.gridwidth = 1;
                }
            }
            fields[8].setEditable(false);

            JDialog waitingDialog = new JDialog(editDialog, "Please wait", true); // "Please wait"
            waitingDialog.setLayout(new FlowLayout());
            waitingDialog.add(new JLabel("Getting AI category suggestion...")); // "Getting AI category suggestion..."
            waitingDialog.setSize(250, 100);
            waitingDialog.setResizable(false);

            JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
            JButton confirmButton = new JButton("Confirm"); // "Confirm"
            JButton cancelButton = new JButton("Cancel");   // "Cancel"
            buttonPanel.add(confirmButton);
            buttonPanel.add(cancelButton);
            gbc.gridx = 0; gbc.gridy = fieldNames.length; gbc.gridwidth = 3; gbc.anchor = GridBagConstraints.CENTER; gbc.fill = GridBagConstraints.NONE; dialogPanel.add(buttonPanel, gbc);
            editDialog.add(dialogPanel, BorderLayout.CENTER);

            aiSuggestButton.addActionListener(e -> {
                System.out.println("AI Suggest button clicked (EDT) in edit dialog.");
                aiSuggestButton.setEnabled(false);
                Transaction tempTransaction = new Transaction(
                        fields[0].getText().trim(), fields[1].getText().trim(), fields[2].getText().trim(),
                        fields[3].getText().trim(), fields[4].getText().trim(), safeParseDouble(fields[5].getText().trim()),
                        fields[6].getText().trim(), fields[7].getText().trim(), fields[8].getText().trim(),
                        fields[9].getText().trim(), fields[10].getText().trim()
                );
                new Thread(() -> {
                    System.out.println("Background thread started for AI classification (edit dialog)...");
                    String aiSuggestion = null;
                    try {
                        aiSuggestion = collegeStudentNeeds.RecognizeTransaction(tempTransaction);
                        System.out.println("AI Classification returned in background thread (edit dialog): " + aiSuggestion);
                    } catch (Exception ex) {
                        System.err.println("Error in background AI thread (edit dialog): " + ex.getMessage());
                        ex.printStackTrace();
                        aiSuggestion = "Error: " + ex.getMessage();
                    }
                    String finalSuggestion = aiSuggestion;
                    SwingUtilities.invokeLater(() -> {
                        System.out.println("Updating UI on EDT from background thread (edit dialog).");
                        waitingDialog.setVisible(false);
                        if (finalSuggestion != null && !finalSuggestion.isEmpty() && !finalSuggestion.startsWith("Error:")) {
                            if (StandardCategories.ALL_KNOWN_TYPES.contains(finalSuggestion.trim())) {
                                fields[1].setText(finalSuggestion.trim());
                            } else {
                                System.err.println("AI returned non-standard category despite prompt: " + finalSuggestion);
                                JOptionPane.showMessageDialog(editDialog, "AI returned an unexpected category format:\n" + finalSuggestion + "\nPlease enter manually.", "AI Result Anomaly", JOptionPane.WARNING_MESSAGE);
                                fields[1].setText("");
                            }
                        } else if (finalSuggestion != null && finalSuggestion.startsWith("Error:")) {
                            JOptionPane.showMessageDialog(editDialog, "Failed to get AI category suggestion!\n" + finalSuggestion.substring(6), "AI Error", JOptionPane.ERROR_MESSAGE);
                            fields[1].setText("");
                        }
                        else {
                            JOptionPane.showMessageDialog(editDialog, "AI could not provide a category suggestion.", "AI Tip", JOptionPane.INFORMATION_MESSAGE);
                            fields[1].setText("");
                        }
                        aiSuggestButton.setEnabled(true);
                        System.out.println("UI update complete, buttons re-enabled (edit dialog).");
                    });
                }).start();
                System.out.println("Showing waiting dialog (EDT block continues here in edit dialog).");
                waitingDialog.setLocationRelativeTo(editDialog);
                waitingDialog.setVisible(true);
                System.out.println("waiting dialog is now hidden (EDT unblocked in edit dialog).");
            });

            confirmButton.addActionListener(e -> {
                String transactionTime = fields[0].getText().trim();
                String finalTransactionType = fields[1].getText().trim();
                String counterparty = fields[2].getText().trim();
                String commodity = fields[3].getText().trim();
                String inOut = fields[4].getText().trim();
                String paymentAmountText = fields[5].getText().trim();
                String paymentMethod = fields[6].getText().trim();
                String currentStatus = fields[7].getText().trim();
                String merchantNumber = fields[9].getText().trim();
                String remarks = fields[10].getText().trim();

                if (finalTransactionType.isEmpty()) {
                    JOptionPane.showMessageDialog(editDialog, "Transaction Type cannot be empty!", "Input Error", JOptionPane.ERROR_MESSAGE);
                    return;
                }
                if (!StandardCategories.ALL_KNOWN_TYPES.contains(finalTransactionType)) {
                    JOptionPane.showMessageDialog(editDialog, "Transaction type must be one of the standard categories!\nAllowed categories:\n" + StandardCategories.getAllCategoriesString(), "Input Error", JOptionPane.ERROR_MESSAGE);
                    return;
                }
                if (!inOut.equalsIgnoreCase("Income") && !inOut.equalsIgnoreCase("Expense") &&
                        !inOut.equalsIgnoreCase("In") && !inOut.equalsIgnoreCase("Out")) {
                    JOptionPane.showMessageDialog(editDialog, "In/Out field must be 'Income' or 'Expense'.", "Input Error", JOptionPane.ERROR_MESSAGE);
                    return;
                }
                double paymentAmount = 0.0;
                if (!paymentAmountText.isEmpty()) {
                    try {
                        paymentAmount = Double.parseDouble(paymentAmountText);
                        if (paymentAmount < 0) {
                            JOptionPane.showMessageDialog(editDialog, "Amount cannot be negative!", "Input Error", JOptionPane.ERROR_MESSAGE);
                            return;
                        }
                    } catch (NumberFormatException ex) {
                        JOptionPane.showMessageDialog(editDialog, "Amount format is incorrect! Please enter a number.", "Input Error", JOptionPane.ERROR_MESSAGE);
                        return;
                    }
                }
                Transaction updatedTransaction = new Transaction(
                        transactionTime, finalTransactionType, counterparty, commodity, inOut,
                        paymentAmount, paymentMethod, currentStatus, originalOrderNumber,
                        merchantNumber, remarks
                );
                try {
                    transactionService.changeTransaction(updatedTransaction);
                    System.out.println("Edit successful. Preparing to refresh display filtered by InOut: " + updatedTransaction.getInOut());
                    clearSearchFields();
                    String updatedInOut = updatedTransaction.getInOut();
                    boolean foundInOut = false;
                    for(int i=0; i < searchInOutComboBox.getItemCount(); i++) {
                        if (updatedInOut != null && updatedInOut.equals(searchInOutComboBox.getItemAt(i))) {
                            searchInOutComboBox.setSelectedItem(updatedInOut);
                            foundInOut = true;
                            break;
                        }
                    }
                    if (!foundInOut) { searchInOutComboBox.setSelectedItem(""); }
                    triggerCurrentSearch();
                    editDialog.dispose();
                    JOptionPane.showMessageDialog(null, "Update successful!", "Information", JOptionPane.INFORMATION_MESSAGE);
                    System.out.println("Edited row " + rowIndex + " for order number " + originalOrderNumber + " and refreshed display.");
                } catch (IllegalArgumentException ex) {
                    JOptionPane.showMessageDialog(editDialog, "Update failed!\n" + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
                    ex.printStackTrace();
                } catch (Exception ex) {
                    ex.printStackTrace();
                    JOptionPane.showMessageDialog(editDialog, "Update failed!\n" + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
                }
            });
            cancelButton.addActionListener(e -> editDialog.dispose());
            editDialog.pack();
            editDialog.setLocationRelativeTo(this);
            editDialog.setVisible(true);
        } else {
            System.err.println("Attempted to edit row with invalid index: " + rowIndex + ". Table row count: " + this.tableModel.getRowCount());
        }
    }

    private JPanel createAIPanel() {
        JPanel panel = new JPanel(new BorderLayout(10, 10));
        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        JPanel generalAnalysisPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));
        JTextField userRequestField = new JTextField(40);
        aiStartTimeField = new JTextField(10);
        aiEndTimeField = new JTextField(10);
        aiAnalyzeButton = new JButton("General Analysis (Raw Data)"); // "General Analysis (Raw Data)"

        generalAnalysisPanel.add(new JLabel("General Analysis Request:")); // "General Analysis Request:"
        generalAnalysisPanel.add(userRequestField);
        generalAnalysisPanel.add(new JLabel("Time Range (yyyy/MM/dd HH:mm): From:")); // "Time Range (yyyy/MM/dd HH:mm): From:"
        generalAnalysisPanel.add(aiStartTimeField);
        generalAnalysisPanel.add(new JLabel("To:")); // "To:"
        generalAnalysisPanel.add(aiAnalyzeButton);

        JPanel summaryAnalysisPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));
        aiPersonalSummaryButton = new JButton("Personal Spending Summary"); // "Personal Spending Summary"
        aiSavingsGoalsButton = new JButton("Savings Goal Suggestions");   // "Savings Goal Suggestions"
        aiPersonalSavingTipsButton = new JButton("Personalized Saving Tips"); // "Personalized Saving Tips"

        summaryAnalysisPanel.add(new JLabel("Based on Monthly Summary Analysis:")); // "Based on Monthly Summary Analysis:"
        summaryAnalysisPanel.add(aiPersonalSummaryButton);
        summaryAnalysisPanel.add(aiSavingsGoalsButton);
        summaryAnalysisPanel.add(aiPersonalSavingTipsButton);

        JPanel csButtonsPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));
        aiBudgetButton = new JButton("Budget Suggestion (Student)"); // "Budget Suggestion (Student)"
        aiTipsButton = new JButton("Saving Tips (Student)");       // "Saving Tips (Student)"
        csButtonsPanel.add(new JLabel("Student-Specific Features:")); // "Student-Specific Features:"
        csButtonsPanel.add(aiBudgetButton);
        csButtonsPanel.add(aiTipsButton);

        JPanel topControlPanel = new JPanel();
        topControlPanel.setLayout(new BoxLayout(topControlPanel, BoxLayout.Y_AXIS));
        topControlPanel.add(generalAnalysisPanel);
        topControlPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        topControlPanel.add(summaryAnalysisPanel);
        topControlPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        topControlPanel.add(csButtonsPanel);
        topControlPanel.add(Box.createRigidArea(new Dimension(0, 10)));

        panel.add(topControlPanel, BorderLayout.NORTH);
        aiResultArea = new JTextArea();
        aiResultArea.setFont(new Font("Microsoft YaHei", Font.PLAIN, 14)); // "Microsoft YaHei" is a common font name for Chinese
        aiResultArea.setLineWrap(true);
        aiResultArea.setWrapStyleWord(true);
        aiResultArea.setEditable(false);
        aiResultArea.setText("Welcome to the AI Personal Finance Analysis feature.\n\n" +
                "You can try the following operations:\n" +
                "1. Enter a general analysis request in the input field above (based on raw data, time range can be specified), then click \"General Analysis\".\n" +
                "2. Click \"Personal Spending Summary\" to get a detailed summary based on your monthly income and expenses.\n" +
                "3. Click \"Savings Goal Suggestions\" to get savings advice based on your income and expenditure situation.\n" +
                "4. Click \"Personalized Saving Tips\" to get saving advice based on your spending categories.\n" +
                "5. Student users can click \"Budget Suggestion\" and \"Saving Tips\" for exclusive advice.\n");

        JScrollPane resultScrollPane = new JScrollPane(aiResultArea);
        panel.add(resultScrollPane, BorderLayout.CENTER);

        aiPersonalSummaryButton.addActionListener(e -> {
            aiResultArea.setText("--- Generating Personal Spending Summary ---\n\nGenerating summary based on your monthly spending data, please wait...\n");
            setAIButtonsEnabled(false);
            new Thread(() -> {
                String result = aiTransactionService.generatePersonalSummary(currentUser.getTransactionFilePath());
                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- Personal Spending Summary ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        aiSavingsGoalsButton.addActionListener(e -> {
            aiResultArea.setText("--- Generating Savings Goal Suggestions ---\n\nGenerating savings goal suggestions based on your income and expenses, please wait...\n");
            setAIButtonsEnabled(false);
            new Thread(() -> {
                String result = aiTransactionService.suggestSavingsGoals(currentUser.getTransactionFilePath());
                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- Savings Goal Suggestions ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        aiPersonalSavingTipsButton.addActionListener(e -> {
            aiResultArea.setText("--- Generating Personalized Saving Tips ---\n\nGenerating saving tips based on your spending categories, please wait...\n");
            setAIButtonsEnabled(false);
            new Thread(() -> {
                String result = aiTransactionService.givePersonalSavingTips(currentUser.getTransactionFilePath());
                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- Personalized Saving Tips ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        aiAnalyzeButton.addActionListener(e -> {
            String userRequest = userRequestField.getText().trim();
            String startTimeStr = aiStartTimeField.getText().trim();
            String endTimeStr = aiEndTimeField.getText().trim();
            if (userRequest.isEmpty()) {
                JOptionPane.showMessageDialog(this, "Please enter the AI general analysis request.", "Input Tip", JOptionPane.INFORMATION_MESSAGE);
                return;
            }
            if (startTimeStr.isEmpty() && !endTimeStr.isEmpty()) {
                JOptionPane.showMessageDialog(this, "Please enter at least the start time for the analysis.", "Input Tip", JOptionPane.INFORMATION_MESSAGE);
                return;
            }
            aiResultArea.setText("--- Generating General Analysis ---\n\n" + "Performing AI general analysis, please wait...\n");
            setAIButtonsEnabled(false);
            new Thread(() -> {
                String result = aiTransactionService.analyzeTransactions(userRequest, currentUser.getTransactionFilePath(), startTimeStr, endTimeStr);
                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- General Analysis Result ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        aiBudgetButton.addActionListener(e -> {
            aiResultArea.setText("--- Generating Student Budget Suggestion ---\n\nGenerating budget suggestion based on your historical spending, please wait...\n");
            setAIButtonsEnabled(false);
            new Thread(() -> {
                String resultMessage;
                try {
                    double[] budgetRange = collegeStudentNeeds.generateBudget(currentUser.getTransactionFilePath());
                    if (budgetRange != null && budgetRange.length == 2 && budgetRange[0] != -1) {
                        resultMessage = String.format("Based on your spending records, the recommended budget range for next week is: [%.2f CNY, %.2f CNY]", budgetRange[0], budgetRange[1]);
                    } else if (budgetRange != null && budgetRange.length == 2 && budgetRange[0] == -1) {
                        resultMessage = "Not enough spending records to calculate weekly budget suggestions.";
                    }
                    else {
                        resultMessage = "Failed to generate budget suggestion, AI did not return a valid range.";
                        System.err.println("AI Budget generation failed, invalid response format.");
                    }
                } catch (Exception ex) {
                    resultMessage = "Failed to generate budget suggestion!\n" + ex.getMessage();
                    System.err.println("Error generating AI budget:");
                    ex.printStackTrace();
                }
                String finalResultMessage = resultMessage;
                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- Student Budget Suggestion ---\n\n" + finalResultMessage);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        aiTipsButton.addActionListener(e -> {
            aiResultArea.setText("--- Generating Student Saving Tips ---\n\nGenerating saving tips, please wait...\n");
            setAIButtonsEnabled(false);
            new Thread(() -> {
                String resultMessage;
                try {
                    resultMessage = collegeStudentNeeds.generateTipsForSaving(currentUser.getTransactionFilePath());
                } catch (Exception ex) {
                    resultMessage = "Failed to generate saving tips!\n" + ex.getMessage();
                    System.err.println("Error generating AI tips:");
                    ex.printStackTrace();
                }
                String finalResultMessage = resultMessage;
                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- Student Saving Tips ---\n\n" + finalResultMessage);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });
        return panel;
    }

    private void setAIButtonsEnabled(boolean enabled) {
        if (aiAnalyzeButton != null) aiAnalyzeButton.setEnabled(enabled);
        if (aiBudgetButton != null) aiBudgetButton.setEnabled(enabled);
        if (aiTipsButton != null) aiTipsButton.setEnabled(enabled);
        if (aiPersonalSummaryButton != null) aiPersonalSummaryButton.setEnabled(enabled);
        if (aiSavingsGoalsButton != null) aiSavingsGoalsButton.setEnabled(enabled);
        if (aiPersonalSavingTipsButton != null) aiPersonalSavingTipsButton.setEnabled(enabled);
    }

    private JPanel createAdminStatsPanel() {
        JPanel panel = new JPanel(new BorderLayout(10, 10));
        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        generateStatsButton = new JButton("Generate/Update Statistics"); // "Generate/Update Statistics"
        refreshDisplayButton = new JButton("Refresh Display");        // "Refresh Display"
        controlPanel.add(generateStatsButton);
        controlPanel.add(refreshDisplayButton);
        panel.add(controlPanel, BorderLayout.NORTH);
        adminStatsArea = new JTextArea();
        adminStatsArea.setFont(new Font("Microsoft YaHei", Font.PLAIN, 14)); // "Microsoft YaHei"
        adminStatsArea.setEditable(false);
        adminStatsArea.setLineWrap(true);
        adminStatsArea.setWrapStyleWord(true);
        JScrollPane scrollPane = new JScrollPane(adminStatsArea);
        panel.add(scrollPane, BorderLayout.CENTER);

        generateStatsButton.addActionListener(e -> {
            adminStatsArea.setText("Generating/Updating summary statistics, please wait...\n"); // "Generating/Updating summary statistics, please wait...\n"
            generateStatsButton.setEnabled(false);
            refreshDisplayButton.setEnabled(false);
            new Thread(() -> {
                String message;
                try {
                    summaryStatisticService.generateAndSaveWeeklyStatistics();
                    message = "Summary statistics generated/updated successfully!\nPlease click 'Refresh Display' to view the latest data."; // "Summary statistics generated/updated successfully!\nPlease click 'Refresh Display' to view the latest data."
                    System.out.println(message);
                } catch (Exception ex) {
                    message = "Failed to generate/update summary statistics!\n" + ex.getMessage(); // "Failed to generate/update summary statistics!\n"
                    System.err.println(message);
                    ex.printStackTrace();
                }
                String finalMessage = message;
                SwingUtilities.invokeLater(() -> {
                    adminStatsArea.setText(finalMessage);
                    generateStatsButton.setEnabled(true);
                    refreshDisplayButton.setEnabled(true);
                });
            }).start();
        });

        refreshDisplayButton.addActionListener(e -> {
            displaySummaryStatistics();
        });

        new Thread(() -> {
            SwingUtilities.invokeLater(() -> adminStatsArea.setText("Loading existing statistics...\n")); // "Loading existing statistics...\n"
            try {
                List<SummaryStatistic> initialStats = summaryStatisticService.getAllSummaryStatistics();
                if (!initialStats.isEmpty()) {
                    SwingUtilities.invokeLater(this::displaySummaryStatistics);
                } else {
                    SwingUtilities.invokeLater(() -> adminStatsArea.setText("No existing summary statistics found.\nPlease click the 'Generate/Update Statistics' button to generate them.")); // "No existing summary statistics found.\nPlease click the 'Generate/Update Statistics' button to generate them."
                }
            } catch (IOException ex) {
                SwingUtilities.invokeLater(() -> adminStatsArea.setText("Failed to load existing statistics!\n" + ex.getMessage())); // "Failed to load existing statistics!\n"
                ex.printStackTrace();
            }
        }).start();
        return panel;
    }

    private void displaySummaryStatistics() {
        adminStatsArea.setText("Loading summary statistics...\n"); // "Loading summary statistics...\n"
        if(generateStatsButton != null) generateStatsButton.setEnabled(false);
        if(refreshDisplayButton != null) refreshDisplayButton.setEnabled(false);

        new Thread(() -> {
            String displayContent;
            try {
                List<SummaryStatistic> stats = summaryStatisticService.getAllSummaryStatistics();
                if (stats.isEmpty()) {
                    displayContent = "No summary statistics currently available.\nPlease click the 'Generate/Update Statistics' button first."; // "No summary statistics currently available.\nPlease click the 'Generate/Update Statistics' button first."
                } else {
                    StringBuilder sb = new StringBuilder("===== Summary Statistics =====\n\n"); // "===== Summary Statistics =====\n\n"
                    stats.sort(Comparator.comparing(SummaryStatistic::getWeekIdentifier));
                    for (int i = stats.size() - 1; i >= 0; i--) {
                        SummaryStatistic stat = stats.get(i);
                        sb.append("Week Identifier: ").append(stat.getWeekIdentifier()).append("\n"); // "Week Identifier: "
                        sb.append("  Total Income: ").append(String.format("%.2f", stat.getTotalIncomeAllUsers())).append(" CNY\n"); // "  Total Income: " ... " CNY\n"
                        sb.append("  Total Expense: ").append(String.format("%.2f", stat.getTotalExpenseAllUsers())).append(" CNY\n"); // "  Total Expense: " ... " CNY\n"
                        if (stat.getTopExpenseCategoryAmount() > 0) {
                            sb.append("  Top Expense Category: ").append(stat.getTopExpenseCategory()).append(" (").append(String.format("%.2f", stat.getTopExpenseCategoryAmount())).append(" CNY)\n"); // "  Top Expense Category: " ... " CNY)\n"
                        } else {
                            sb.append("  Top Expense Category: No significant expense category\n"); // "  Top Expense Category: No significant expense category\n"
                        }
                        sb.append("  Number of Participating Users: ").append(stat.getNumberOfUsersWithTransactions()).append("\n"); // "  Number of Participating Users: "
                        sb.append("  Generated Time: ").append(stat.getTimestampGenerated()).append("\n"); // "  Generated Time: "
                        sb.append("--------------------\n");
                    }
                    displayContent = sb.toString();
                }
            } catch (IOException ex) {
                displayContent = "Failed to load summary statistics!\n" + ex.getMessage(); // "Failed to load summary statistics!\n"
                ex.printStackTrace();
            }
            String finalDisplayContent = displayContent;
            SwingUtilities.invokeLater(() -> {
                adminStatsArea.setText(finalDisplayContent);
                if(generateStatsButton != null) generateStatsButton.setEnabled(true);
                if(refreshDisplayButton != null) refreshDisplayButton.setEnabled(true);
            });
        }).start();
    }

    public void deleteRow(int rowIndex) {
        System.out.println("Attempting to delete row: " + rowIndex + " for user " + currentUser.getUsername());
        if (rowIndex >= 0 && rowIndex < this.tableModel.getRowCount()) {
            String orderNumber = (String) this.tableModel.getValueAt(rowIndex, 8);
            if (orderNumber == null || orderNumber.trim().isEmpty()) {
                JOptionPane.showMessageDialog(null, "Cannot delete: Order Number is empty!", "Error", JOptionPane.ERROR_MESSAGE);
                System.err.println("Attempted to delete row " + rowIndex + " but order number is null or empty.");
                return;
            }
            orderNumber = orderNumber.trim();
            System.out.println("Deleting transaction with order number: " + orderNumber);
            int confirm = JOptionPane.showConfirmDialog(
                    this,
                    "Are you sure you want to delete the transaction with order number '" + orderNumber + "'?", // "Are you sure you want to delete the transaction with order number '" ... "'?"
                    "Confirm Delete", // "Confirm Delete"
                    JOptionPane.YES_NO_OPTION,
                    JOptionPane.QUESTION_MESSAGE
            );
            if (confirm == JOptionPane.YES_OPTION) {
                try {
                    boolean deleted = transactionService.deleteTransaction(orderNumber);
                    if (deleted) {
                        this.tableModel.removeRow(rowIndex);
                        JOptionPane.showMessageDialog(null, "Delete successful!", "Information", JOptionPane.INFORMATION_MESSAGE); // "Delete successful!"
                        System.out.println("Deleted row " + rowIndex + " with order number " + orderNumber + " from UI.");
                        triggerCurrentSearch();
                    } else {
                        JOptionPane.showMessageDialog(null, "Delete failed: Corresponding order number " + orderNumber + " not found", "Error", JOptionPane.ERROR_MESSAGE); // "Delete failed: Corresponding order number " ... " not found"
                        System.err.println("Delete failed: order number " + orderNumber + " not found by service.");
                    }
                } catch (Exception ex) {
                    ex.printStackTrace();
                    JOptionPane.showMessageDialog(null, "Delete failed!\n" + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE); // "Delete failed!\n"
                    System.err.println("Error during deletion for order number " + orderNumber);
                }
            } else {
                System.out.println("Deletion cancelled by user for order number: " + orderNumber);
            }
        } else {
            System.err.println("Attempted to delete row with invalid index: " + rowIndex + ". Table row count: " + this.tableModel.getRowCount());
        }
    }

    private Vector<String> createRowFromTransaction(Transaction transaction) {
        Vector<String> row = new Vector<>();
        row.add(emptyIfNull(transaction.getTransactionTime()));
        row.add(emptyIfNull(transaction.getTransactionType()));
        row.add(emptyIfNull(transaction.getCounterparty()));
        row.add(emptyIfNull(transaction.getCommodity()));
        row.add(emptyIfNull(transaction.getInOut()));
        row.add(String.valueOf(transaction.getPaymentAmount()));
        row.add(emptyIfNull(transaction.getPaymentMethod()));
        row.add(emptyIfNull(transaction.getCurrentStatus()));
        row.add(emptyIfNull(transaction.getOrderNumber()));
        row.add(emptyIfNull(transaction.getMerchantNumber()));
        row.add(emptyIfNull(transaction.getRemarks()));
        row.add("Modify");
        row.add("Delete");
        return row;
    }

    public void searchData(String query1, String query2, String query3, String query4, String query6, String query5) {
        System.out.println("Searching with criteria: time='" + query1 + "', type='" + query2 + "', counterparty='" + query3 + "', commodity='" + query4 + "', inOut='" + query6 + "', paymentMethod='" + query5 + "'");
        this.tableModel.setRowCount(0);
        Transaction searchCriteria = new Transaction(
                query1, query2, query3, query4, query6,
                0,
                query5,
                "", "", "", ""
        );
        try {
            List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);
            System.out.println("Search results count: " + transactions.size());
            for (Transaction transaction : transactions) {
                Vector<String> row = createRowFromTransaction(transaction);
                this.tableModel.addRow(row);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(null, "Search failed!\n" + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE); // "Search failed!\n"
        }
    }

    private double safeParseDouble(String value) {
        if (value == null || value.trim().isEmpty()) return 0.0;
        try { return Double.parseDouble(value.trim()); }
        catch (NumberFormatException e) { System.err.println("Failed to parse double from string: '" + value + "'"); return 0.0; }
    }
    private void clearSearchFields() {
        searchTransactionTimeField.setText("");
        searchTransactionTypeField.setText("");
        searchCounterpartyField.setText("");
        searchCommodityField.setText("");
        searchInOutComboBox.setSelectedItem("");
        searchPaymentMethodField.setText("");
        System.out.println("Cleared search fields.");
    }
    private void triggerCurrentSearch() {
        searchData(
                searchTransactionTimeField.getText().trim(),
                searchTransactionTypeField.getText().trim(),
                searchCounterpartyField.getText().trim(),
                searchCommodityField.getText().trim(),
                (String) searchInOutComboBox.getSelectedItem(),
                searchPaymentMethodField.getText().trim()
        );
        System.out.println("Triggered search with current field values.");
    }
    private String emptyIfNull(String value) {
        return value == null ? "" : value;
    }
    public JTable getTable() {
        return table;
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Controller\VisualizationPanel.java`:

```java
package Controller;

import Service.TransactionService;
import model.MonthlySummary;

import java.awt.*;
import java.util.Map;
import java.util.List; // Import List
import java.util.ArrayList; // Import ArrayList
import java.util.HashMap; // Import HashMap
import java.util.Collections; // Import Collections for sorting
import java.util.Comparator; // Import Comparator

import javax.swing.*;

// Import XChart classes
import org.knowm.xchart.CategoryChart;
import org.knowm.xchart.CategoryChartBuilder;
import org.knowm.xchart.PieChart;
import org.knowm.xchart.PieChartBuilder;
import org.knowm.xchart.SwingWrapper; // Might be needed for Swing components
import org.knowm.xchart.XChartPanel; // Use XChartPanel for Swing display
import org.knowm.xchart.style.Styler.LegendPosition; // For chart styling


/**
 * Panel to display transaction data visualizations using XChart.
 */
public class VisualizationPanel extends JPanel {

    private final TransactionService transactionService;

    private JComboBox<String> monthSelector;
    private JComboBox<String> chartTypeSelector;
    private JButton generateChartButton;
    private JPanel chartDisplayPanel;

    // Define string constants for chart types to avoid magic strings in comparisons
    private static final String SELECT_CHART_TYPE_PROMPT = "Select Chart Type";
    private static final String MONTHLY_EXPENSE_PIE_CHART = "Monthly Expense Category Pie Chart";
    private static final String MONTHLY_TREND_BAR_CHART = "Monthly Income/Expense Trend Bar Chart";
    private static final String SELECT_MONTH_PROMPT = "Select Month";


    /**
     * Constructor to inject the TransactionService.
     * @param transactionService The service to retrieve user transaction data.
     */
    public VisualizationPanel(TransactionService transactionService) {
        this.transactionService = transactionService;
        setLayout(new BorderLayout(10, 10));
        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // --- Control Panel (Top) ---
        JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 5));

        chartTypeSelector = new JComboBox<>(new String[]{SELECT_CHART_TYPE_PROMPT, MONTHLY_EXPENSE_PIE_CHART, MONTHLY_TREND_BAR_CHART});
        controlPanel.add(new JLabel("Chart Type:"));
        controlPanel.add(chartTypeSelector);

        monthSelector = new JComboBox<>();
        monthSelector.setEnabled(false);
        controlPanel.add(new JLabel("Select Month:"));
        controlPanel.add(monthSelector);


        generateChartButton = new JButton("Generate Chart");
        controlPanel.add(generateChartButton);

        add(controlPanel, BorderLayout.NORTH);


        // --- Chart Display Panel (Center) ---
        chartDisplayPanel = new JPanel(new BorderLayout());
        chartDisplayPanel.setBackground(Color.WHITE);
        add(chartDisplayPanel, BorderLayout.CENTER);


        // --- Action Listeners ---
        chartTypeSelector.addActionListener(e -> {
            String selectedType = (String) chartTypeSelector.getSelectedItem();
            boolean needsMonth = MONTHLY_EXPENSE_PIE_CHART.equals(selectedType);
            monthSelector.setEnabled(needsMonth);
            // Populate months only when Pie Chart is selected
            if (needsMonth) {
                populateMonthSelector();
            } else {
                monthSelector.removeAllItems(); // Clear months if not needed
                monthSelector.addItem(SELECT_MONTH_PROMPT); // Add default item back
            }
        });

        generateChartButton.addActionListener(e -> {
            generateAndDisplayChart();
        });

        // Initial state display
        displayPlaceholderChart("Please select a chart type and necessary parameters to generate the chart.");

    }

    /**
     * Populates the month selector combo box with months from available data.
     */
    private void populateMonthSelector() {
        monthSelector.removeAllItems();
        monthSelector.addItem(SELECT_MONTH_PROMPT);

        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            if (summaries != null && !summaries.isEmpty()) {
                // Sort month identifiers chronologically
                summaries.keySet().stream().sorted().forEach(monthSelector::addItem);
            } else {
                JOptionPane.showMessageDialog(this, "No monthly transaction data found to generate charts.", "Insufficient Data", JOptionPane.INFORMATION_MESSAGE);
            }
        } catch (Exception e) {
            System.err.println("Error loading monthly summaries for month selector: " + e.getMessage());
            JOptionPane.showMessageDialog(this, "Failed to load month data!\n" + e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
        }
    }


    /**
     * Generates and displays the selected chart based on user selection using XChart.
     */
    private void generateAndDisplayChart() {
        String selectedChartType = (String) chartTypeSelector.getSelectedItem();
        String selectedMonth = (String) monthSelector.getSelectedItem();

        // Clear previous chart
        chartDisplayPanel.removeAll();
        chartDisplayPanel.revalidate();
        chartDisplayPanel.repaint();

        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            if (summaries == null || summaries.isEmpty()) {
                displayPlaceholderChart("No monthly transaction data found to generate charts.");
                return;
            }

            if (MONTHLY_EXPENSE_PIE_CHART.equals(selectedChartType)) {
                if (selectedMonth == null || selectedMonth.equals(SELECT_MONTH_PROMPT) || selectedMonth.trim().isEmpty()) {
                    JOptionPane.showMessageDialog(this, "Please select a month to view.", "Information", JOptionPane.INFORMATION_MESSAGE);
                    displayPlaceholderChart("Please select a valid month to generate the pie chart.");
                    return;
                }
                // --- Generate Pie Chart ---
                MonthlySummary selectedMonthSummary = summaries.get(selectedMonth);
                if (selectedMonthSummary == null || selectedMonthSummary.getExpenseByCategory().isEmpty()) {
                    displayPlaceholderChart(selectedMonth + " has no expense category data.");
                    return;
                }

                System.out.println("Generating Pie Chart for " + selectedMonth + "...");
                PieChart chart = new PieChartBuilder()
                        .width(chartDisplayPanel.getWidth() > 0 ? chartDisplayPanel.getWidth() : 600) // Ensure width > 0
                        .height(chartDisplayPanel.getHeight() > 0 ? chartDisplayPanel.getHeight() : 400) // Ensure height > 0
                        .title(selectedMonth + " Expense Categories")
                        .build();

                selectedMonthSummary.getExpenseByCategory().entrySet().stream()
                        .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                        .forEach(entry -> chart.addSeries(entry.getKey(), entry.getValue()));

                // Customize chart style
                chart.getStyler().setLegendPosition(LegendPosition.OutsideE);


                // Add the chart to the display panel
                XChartPanel<PieChart> chartPanel = new XChartPanel<>(chart);
                chartDisplayPanel.add(chartPanel, BorderLayout.CENTER);
                System.out.println("Pie Chart generated and displayed.");


            } else if (MONTHLY_TREND_BAR_CHART.equals(selectedChartType)) {
                // --- Generate Bar Chart (Category Chart) ---
                System.out.println("Generating Monthly Income/Expense Trend Bar Chart...");

                List<String> months = new ArrayList<>();
                List<Double> totalIncomes = new ArrayList<>();
                List<Double> totalExpenses = new ArrayList<>();

                List<String> sortedMonths = new ArrayList<>(summaries.keySet());
                Collections.sort(sortedMonths);

                for (String month : sortedMonths) {
                    MonthlySummary ms = summaries.get(month);
                    months.add(month);
                    totalIncomes.add(ms.getTotalIncome());
                    totalExpenses.add(ms.getTotalExpense());
                }

                CategoryChart chart = new CategoryChartBuilder()
                        .width(chartDisplayPanel.getWidth() > 0 ? chartDisplayPanel.getWidth() : 800) // Ensure width > 0
                        .height(chartDisplayPanel.getHeight() > 0 ? chartDisplayPanel.getHeight() : 500) // Ensure height > 0
                        .title("Monthly Income/Expense Trend")
                        .xAxisTitle("Month")
                        .yAxisTitle("Amount (CNY)")
                        .build();

                chart.addSeries("Total Income", months, totalIncomes);
                chart.addSeries("Total Expense", months, totalExpenses);

                // Customize chart style
                chart.getStyler().setLegendPosition(LegendPosition.OutsideS);
                chart.getStyler().setStacked(false);

                // Add the chart to the display panel
                XChartPanel<CategoryChart> chartPanel = new XChartPanel<>(chart);
                chartDisplayPanel.add(chartPanel, BorderLayout.CENTER);
                System.out.println("Bar Chart generated and displayed.");


            } else {
                displayPlaceholderChart("Please select a chart type and necessary parameters to generate the chart.");
            }

        } catch (Exception e) {
            System.err.println("Error generating chart: " + selectedChartType);
            e.printStackTrace();
            displayPlaceholderChart("Failed to generate chart!\n" + e.getMessage());
            JOptionPane.showMessageDialog(this, "Failed to generate chart!\n" + e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
        } finally {
            chartDisplayPanel.revalidate();
            chartDisplayPanel.repaint();
        }
    }

    /**
     * Helper method to display a placeholder message.
     */
    private void displayPlaceholderChart(String message) {
        // Clear previous content first
        chartDisplayPanel.removeAll();

        JLabel placeholderLabel = new JLabel(message, SwingConstants.CENTER);
        placeholderLabel.setFont(new Font("Microsoft YaHei", Font.PLAIN, 16)); // Using a common font name
        chartDisplayPanel.add(placeholderLabel, BorderLayout.CENTER);

        chartDisplayPanel.revalidate();
        chartDisplayPanel.repaint();
    }

    // Optional: Method to trigger initial setup when panel is displayed
    // Call this from MenuUI's ActionListener for the Visualization button
    public void refreshPanelData() {
        System.out.println("VisualizationPanel refreshPanelData called.");
        // Reset chart type selector to default on refresh
        chartTypeSelector.setSelectedItem(SELECT_CHART_TYPE_PROMPT);
        // Display initial instruction message
        displayPlaceholderChart("Please select a chart type and necessary parameters to generate the chart.");
    }

}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\DAO\Impl\CsvSummaryStatisticDao.java`:

```java
package DAO.Impl;

import DAO.SummaryStatisticDao;
import model.SummaryStatistic;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class CsvSummaryStatisticDao implements SummaryStatisticDao {

    // Define the header for the summary statistics CSV
    private static final String[] HEADERS = {
            "week_identifier", "total_income_all_users", "total_expense_all_users",
            "top_expense_category", "top_expense_category_amount",
            "number_of_users_with_transactions", "timestamp_generated"
    };

    @Override
    public List<SummaryStatistic> loadAllStatistics(String filePath) throws IOException {
        List<SummaryStatistic> statistics = new ArrayList<>();
        Path path = Paths.get(filePath);

        if (!Files.exists(path) || Files.size(path) == 0) {
            System.out.println("Summary statistics CSV file not found or is empty: " + filePath);
            return statistics;
        }

        try (Reader reader = new InputStreamReader(
                new BOMInputStream(Files.newInputStream(path)),
                StandardCharsets.UTF_8)) {

            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()
                    .withIgnoreHeaderCase(true)
                    .withTrim(true);

            try (CSVParser csvParser = new CSVParser(reader, format)) {
                Map<String, Integer> headerMap = csvParser.getHeaderMap();
                // Basic header validation
                List<String> requiredHeaders = List.of(HEADERS);
                if (headerMap == null || !headerMap.keySet().containsAll(requiredHeaders)) {
                    throw new IOException("Missing required headers in summary statistics CSV file: " + requiredHeaders +
                            " Found: " + (headerMap == null ? "null" : headerMap.keySet()));
                }

                for (CSVRecord record : csvParser) {
                    try {
                        SummaryStatistic stat = parseRecord(record);
                        if (stat != null) { // parseRecord might return null on error
                            statistics.add(stat);
                        }
                    } catch (Exception e) {
                        System.err.println("Skipping malformed summary statistic record at line " + record.getRecordNumber() + ": " + record.toString());
                        e.printStackTrace();
                    }
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading summary statistics from CSV: " + filePath);
            e.printStackTrace();
            throw e;
        }
        System.out.println("Successfully loaded " + statistics.size() + " summary statistics from " + filePath);
        return statistics;
    }

    // Helper to parse a single CSV record into a SummaryStatistic object
    private SummaryStatistic parseRecord(CSVRecord record) {
        // Defensive getting of values to prevent exceptions on missing columns
        String weekIdentifier = record.get("week_identifier");
        String totalIncomeStr = record.get("total_income_all_users");
        String totalExpenseStr = record.get("total_expense_all_users");
        String topExpenseCategory = record.get("top_expense_category");
        String topExpenseAmountStr = record.get("top_expense_category_amount");
        String numUsersStr = record.get("number_of_users_with_transactions");
        String timestampGenerated = record.get("timestamp_generated");

        // Basic validation for essential fields
        if (weekIdentifier == null || weekIdentifier.trim().isEmpty() ||
                totalIncomeStr == null || totalIncomeStr.trim().isEmpty() ||
                totalExpenseStr == null || totalExpenseStr.trim().isEmpty() ||
                numUsersStr == null || numUsersStr.trim().isEmpty() ||
                timestampGenerated == null || timestampGenerated.trim().isEmpty()) {
            System.err.println("Skipping summary record due to missing essential fields: " + record.toMap());
            return null; // Indicate parsing failed for this record
        }

        try {
            double totalIncome = Double.parseDouble(totalIncomeStr.trim());
            double totalExpense = Double.parseDouble(totalExpenseStr.trim());
            double topExpenseAmount = (topExpenseAmountStr != null && !topExpenseAmountStr.trim().isEmpty()) ? Double.parseDouble(topExpenseAmountStr.trim()) : 0.0;
            int numUsers = Integer.parseInt(numUsersStr.trim());

            return new SummaryStatistic(
                    weekIdentifier.trim(),
                    totalIncome,
                    totalExpense,
                    topExpenseCategory != null ? topExpenseCategory.trim() : "N/A", // Top category might be empty if no expenses
                    topExpenseAmount,
                    numUsers,
                    timestampGenerated.trim()
            );
        } catch (NumberFormatException e) {
            System.err.println("Skipping summary record due to number format error: " + record.toMap());
            e.printStackTrace();
            return null; // Indicate parsing failed
        }
    }


    @Override
    public void writeAllStatistics(String filePath, List<SummaryStatistic> statistics) throws IOException {
        Path path = Paths.get(filePath);
        // Ensure the directory exists
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }

        // Use a temporary file for atomic write
        File targetFile = path.toFile();
        File tempFile = File.createTempFile("summary_temp", ".csv", targetFile.getParentFile());

        try (BufferedWriter writer = Files.newBufferedWriter(tempFile.toPath(), StandardCharsets.UTF_8);
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(HEADERS).withTrim())) { // Always write header for overwrite

            for (SummaryStatistic stat : statistics) {
                csvPrinter.printRecord(
                        stat.getWeekIdentifier(),
                        stat.getTotalIncomeAllUsers(),
                        stat.getTotalExpenseAllUsers(),
                        stat.getTopExpenseCategory(),
                        stat.getTopExpenseCategoryAmount(),
                        stat.getNumberOfUsersWithTransactions(),
                        stat.getTimestampGenerated()
                );
            }
            // csvPrinter.flush(); // Auto-flushed on close
        } catch (IOException e) {
            tempFile.delete(); // Clean up temp file on failure
            System.err.println("Error writing summary statistics to temporary CSV file: " + tempFile.toPath());
            e.printStackTrace();
            throw e; // Re-throw
        }

        // Atomic replacement
        try {
            Files.move(tempFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
            System.out.println("Atomically replaced " + filePath + " with updated summary statistics.");
        } catch (IOException e) {
            System.err.println("Failed to atomically replace original summary file: " + targetFile.toPath());
            tempFile.delete(); // Clean up temp file
            e.printStackTrace();
            throw e; // Re-throw
        }
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\DAO\Impl\CsvTransactionDao.java`:

```java
package DAO.Impl; // Changed package

import Constants.ConfigConstants;
import DAO.TransactionDao; // Implement the interface
import model.Transaction;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional; // Using Optional for getTransactionByOrderNumber
import java.util.stream.Collectors;


public class CsvTransactionDao implements TransactionDao { // Implement TransactionDao interface

    @Override
    public List<Transaction> loadFromCSV(String filePath) throws IOException {
        List<Transaction> transactions = new ArrayList<>();
        Path path = Paths.get(filePath);

        if (!Files.exists(path) || Files.size(path) == 0) {
            System.out.println("CSV file not found or is empty: " + filePath);
            return transactions;
        }

        try (Reader reader = new InputStreamReader(
                new BOMInputStream(Files.newInputStream(path)),
                StandardCharsets.UTF_8)) {

            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()
                    .withIgnoreHeaderCase(true)
                    .withTrim(true);

            try (CSVParser csvParser = new CSVParser(reader, format)) {
                // Define expected English headers
                List<String> requiredHeaders = List.of(
                        "Transaction Time", "Transaction Type", "Counterparty", "Commodity", "In/Out", "Amount(CNY)",
                        "Payment Method", "Current Status", "Order Number", "Merchant Number", "Remarks"
                );

                Map<String, Integer> headerMap = csvParser.getHeaderMap();
                if (headerMap == null || !headerMap.keySet().containsAll(requiredHeaders)) {
                    throw new IOException("Missing required headers in CSV file. Expected: " + requiredHeaders +
                            " Found: " + (headerMap == null ? "No headers found by parser" : headerMap.keySet()));
                }
                System.out.println("Successfully identified headers: " + headerMap.keySet() + " in file: " + filePath);

                for (CSVRecord record : csvParser) {
                    try {
                        transactions.add(parseRecord(record));
                    } catch (Exception e) {
                        System.err.println("Skipping malformed record at line " + record.getRecordNumber() + ": " + record.toString());
                        e.printStackTrace();
                    }
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading CSV file: " + filePath);
            e.printStackTrace();
            throw e;
        }
        System.out.println("Successfully loaded " + transactions.size() + " records from " + filePath);
        return transactions;
    }

    private Transaction parseRecord(CSVRecord record) {
        // Now using English header names to get values from the record
        String amountStr = record.get("Amount(CNY)").trim();
        double paymentAmount = 0.0;
        try {
            if (amountStr.startsWith("¥") || amountStr.startsWith("$")) { // Allow for currency symbols
                amountStr = amountStr.substring(1);
            }
            paymentAmount = Double.parseDouble(amountStr);
        } catch (NumberFormatException e) {
            System.err.println("Warning: Could not parse payment amount '" + record.get("Amount(CNY)") + "' at line " + record.getRecordNumber());
        } catch (IllegalArgumentException e) {
            System.err.println("Warning: Missing 'Amount(CNY)' column or empty value at line " + record.getRecordNumber());
        }

        // Expect English values for "In/Out" from CSV or standardize them here if necessary
        // For now, assuming the CSV provides "Income" or "Expense" directly for "In/Out"
        String inOut = record.get("In/Out").trim();
        // Example standardization if CSV might still have Chinese:
        // if (inOut.equals("收入") || inOut.equals("收")) {
        //     inOut = "Income";
        // } else if (inOut.equals("支出") || inOut.equals("支")) {
        //     inOut = "Expense";
        // }

        return new Transaction(
                record.get("Transaction Time").trim(),
                record.get("Transaction Type").trim(),
                record.get("Counterparty").trim(),
                record.get("Commodity").trim(),
                inOut, // Use the processed/standardized inOut
                paymentAmount,
                record.get("Payment Method").trim(),
                record.get("Current Status").trim(),
                record.get("Order Number").trim(),
                record.get("Merchant Number").trim(),
                record.get("Remarks").trim()
        );
    }

    @Override
    public List<Transaction> getAllTransactions(String filePath) throws IOException {
        return loadFromCSV(filePath);
    }

    @Override
    public void addTransaction(String filePath, Transaction newTransaction) throws IOException {
        Path path = Paths.get(filePath);
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }
        boolean fileExists = Files.exists(path) && Files.size(path) > 0;

        // Use English headers for writing
        String[] headers = {"Transaction Time", "Transaction Type", "Counterparty", "Commodity", "In/Out", "Amount(CNY)", "Payment Method", "Current Status", "Order Number", "Merchant Number", "Remarks"};

        try (BufferedWriter writer = Files.newBufferedWriter(path, StandardCharsets.UTF_8, StandardOpenOption.CREATE, StandardOpenOption.APPEND)) {
            CSVFormat format;
            if (!fileExists) { // If file did not exist or was empty before this operation
                format = CSVFormat.DEFAULT.withHeader(headers).withTrim();
            } else {
                format = CSVFormat.DEFAULT.withTrim();
            }

            try (CSVPrinter csvPrinter = new CSVPrinter(writer, format)) {
                csvPrinter.printRecord(
                        newTransaction.getTransactionTime(),
                        newTransaction.getTransactionType(),
                        newTransaction.getCounterparty(),
                        newTransaction.getCommodity(),
                        newTransaction.getInOut(), // Expecting this to be "Income" or "Expense"
                        String.format("¥%.2f", newTransaction.getPaymentAmount()), // Or use "CNY" prefix if preferred
                        newTransaction.getPaymentMethod(),
                        newTransaction.getCurrentStatus(),
                        newTransaction.getOrderNumber(),
                        newTransaction.getMerchantNumber(),
                        newTransaction.getRemarks()
                );
            }
            System.out.println("Added transaction to " + filePath);
        } catch (IOException e) {
            System.err.println("Error adding transaction to CSV: " + filePath);
            e.printStackTrace();
            throw e;
        }
    }

    @Override
    public boolean deleteTransaction(String filePath, String orderNumber) throws IOException {
        List<Transaction> allTransactions = loadFromCSV(filePath);
        List<Transaction> updatedTransactions = allTransactions.stream()
                .filter(t -> !t.getOrderNumber().trim().equals(orderNumber.trim()))
                .collect(Collectors.toList());

        boolean deleted = allTransactions.size() > updatedTransactions.size();
        if (deleted) {
            writeTransactionsToCSV(filePath, updatedTransactions);
            System.out.println("Deleted transaction with order number " + orderNumber + " from " + filePath);
        } else {
            System.out.println("Transaction with order number " + orderNumber + " not found in " + filePath);
        }
        return deleted;
    }

    @Override
    public boolean updateTransaction(String filePath, String orderNumber, String fieldName, String newValue) throws IOException {
        List<Transaction> allTransactions = loadFromCSV(filePath);
        Optional<Transaction> transactionToUpdateOpt = allTransactions.stream()
                .filter(t -> t.getOrderNumber().trim().equals(orderNumber.trim()))
                .findFirst();

        if (!transactionToUpdateOpt.isPresent()) {
            System.out.println("Transaction with order number " + orderNumber + " not found for update in " + filePath);
            return false;
        }

        Transaction transactionToUpdate = transactionToUpdateOpt.get();
        boolean updated = false;

        // Assuming fieldName matches the English property names of Transaction class
        switch (fieldName) {
            case "transactionTime":
                transactionToUpdate.setTransactionTime(newValue);
                updated = true;
                break;
            case "transactionType":
                transactionToUpdate.setTransactionType(newValue);
                updated = true;
                break;
            case "counterparty":
                transactionToUpdate.setCounterparty(newValue);
                updated = true;
                break;
            case "commodity":
                transactionToUpdate.setCommodity(newValue);
                updated = true;
                break;
            case "inOut": // Ensure newValue is "Income" or "Expense"
                if ("Income".equalsIgnoreCase(newValue) || "Expense".equalsIgnoreCase(newValue)) {
                    transactionToUpdate.setInOut(newValue);
                    updated = true;
                } else {
                    System.err.println("Invalid value for In/Out update: " + newValue + ". Must be 'Income' or 'Expense'.");
                }
                break;
            case "paymentAmount":
                try {
                    if (newValue.startsWith("¥") || newValue.startsWith("$")) {
                        newValue = newValue.substring(1);
                    }
                    transactionToUpdate.setPaymentAmount(Double.parseDouble(newValue));
                    updated = true;
                } catch (NumberFormatException e) {
                    System.err.println("Invalid number format for paymentAmount update: " + newValue);
                    throw new NumberFormatException("Invalid number format for paymentAmount: " + newValue);
                }
                break;
            case "paymentMethod":
                transactionToUpdate.setPaymentMethod(newValue);
                updated = true;
                break;
            case "currentStatus":
                transactionToUpdate.setCurrentStatus(newValue);
                updated = true;
                break;
            case "orderNumber":
                transactionToUpdate.setOrderNumber(newValue);
                updated = true;
                break;
            case "merchantNumber":
                transactionToUpdate.setMerchantNumber(newValue);
                updated = true;
                break;
            case "remarks":
                transactionToUpdate.setRemarks(newValue);
                updated = true;
                break;
            default:
                System.err.println("Invalid field name for update: " + fieldName);
                throw new IllegalArgumentException("Invalid field name: " + fieldName);
        }

        if (updated) {
            writeTransactionsToCSV(filePath, allTransactions);
            System.out.println("Updated transaction with order number " + orderNumber + " in " + filePath + " field: " + fieldName);
        }
        return updated;
    }

    @Override
    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
        Path path = Paths.get(filePath);
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }
        File targetFile = path.toFile();
        File tempFile = File.createTempFile("transaction_temp_", ".csv", targetFile.getParentFile());

        // Use English headers for writing
        String[] headers = {"Transaction Time", "Transaction Type", "Counterparty", "Commodity", "In/Out", "Amount(CNY)", "Payment Method", "Current Status", "Order Number", "Merchant Number", "Remarks"};

        try (BufferedWriter writer = Files.newBufferedWriter(tempFile.toPath(), StandardCharsets.UTF_8);
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(headers).withTrim())) {
            for (Transaction t : transactions) {
                csvPrinter.printRecord(
                        t.getTransactionTime(),
                        t.getTransactionType(),
                        t.getCounterparty(),
                        t.getCommodity(),
                        t.getInOut(), // Expecting "Income" or "Expense"
                        String.format("¥%.2f", t.getPaymentAmount()), // Or "CNY" prefix
                        t.getPaymentMethod(),
                        t.getCurrentStatus(),
                        t.getOrderNumber(),
                        t.getMerchantNumber(),
                        t.getRemarks()
                );
            }
        } catch (IOException e) {
            if (tempFile.exists()) tempFile.delete();
            System.err.println("Error writing transactions to temporary CSV file: " + tempFile.toPath());
            e.printStackTrace();
            throw e;
        }

        try {
            Files.move(tempFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
            System.out.println("Atomically replaced " + filePath + " with updated data.");
        } catch (IOException e) {
            System.err.println("Failed to atomically replace original file: " + targetFile.toPath() + " with " + tempFile.toPath());
            if (tempFile.exists()) tempFile.delete();
            e.printStackTrace();
            throw e;
        }
    }

    @Override
    public Transaction getTransactionByOrderNumber(String filePath, String orderNumber) throws IOException {
        List<Transaction> allTransactions = loadFromCSV(filePath);
        Optional<Transaction> transactionOpt = allTransactions.stream()
                .filter(t -> t.getOrderNumber().trim().equals(orderNumber.trim()))
                .findFirst();
        return transactionOpt.orElse(null);
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\DAO\Impl\CsvUserDao.java`:

```java
package DAO.Impl;

import Constants.ConfigConstants;
import DAO.UserDao;
import model.User;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

public class CsvUserDao implements UserDao {

    private final String filePath;

    public CsvUserDao(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public List<User> getAllUsers() throws IOException {
        List<User> users = new ArrayList<>();
        // Use BOMInputStream to handle potential Byte Order Mark issues
        try (Reader reader = new InputStreamReader(
                new BOMInputStream(Files.newInputStream(Paths.get(filePath))),
                StandardCharsets.UTF_8)) {

            // Configure CSVFormat to handle headers
            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()
                    .withIgnoreHeaderCase(true) // Ignore header case for robustness
                    .withTrim(true); // Trim leading/trailing whitespace

            try (CSVParser csvParser = new CSVParser(reader, format)) {
                // Check if the required headers are present
                List<String> requiredHeaders = List.of("username", "password", "role", "transaction_csv_path");
                if (!csvParser.getHeaderMap().keySet().containsAll(requiredHeaders)) {
                    throw new IOException("Missing required headers in users CSV file: " + requiredHeaders);
                }

                for (CSVRecord record : csvParser) {
                    // Basic error handling for potentially missing fields in a row
                    String username = record.get("username");
                    String password = record.get("password");
                    String role = record.get("role");
                    String transactionFilePath = record.get("transaction_csv_path");

                    if (username == null || username.trim().isEmpty() || password == null || password.trim().isEmpty() || role == null || role.trim().isEmpty() || transactionFilePath == null || transactionFilePath.trim().isEmpty()) {
                        System.err.println("Skipping malformed user record: " + record.toMap());
                        continue; // Skip this row
                    }

                    User user = new User(username.trim(), password.trim(), role.trim(), transactionFilePath.trim());
                    users.add(user);
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading users from CSV file: " + filePath);
            e.printStackTrace();
            throw e; // Re-throw the exception after logging
        }
        return users;
    }

    // Helper method to parse a single record (optional, can be in getAllUsers)
    // private User parseRecord(CSVRecord record) { ... }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\DAO\SummaryStatisticDao.java`:

```java
package DAO;

import model.SummaryStatistic;

import java.io.IOException;
import java.util.List;

public interface SummaryStatisticDao {

    /**
     * Loads all summary statistics from the configured data source.
     * @param filePath The path to the summary statistics CSV file.
     * @return A list of all summary statistics.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<SummaryStatistic> loadAllStatistics(String filePath) throws IOException;

    /**
     * Writes a list of summary statistics to the configured data source, overwriting existing data.
     * @param filePath The path to the summary statistics CSV file.
     * @param statistics The list of statistics to write.
     * @throws IOException If an I/O error occurs during saving.
     */
    void writeAllStatistics(String filePath, List<SummaryStatistic> statistics) throws IOException;

    // Optional: Add method to get statistic by week identifier if needed
    // SummaryStatistic getStatisticByWeek(String filePath, String weekIdentifier) throws IOException;
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\DAO\TransactionDao.java`:

```java
package DAO;

import model.Transaction;

import java.io.IOException;
import java.util.List;

/**
 * Interface for Data Access Object (DAO) operations related to Transactions.
 * Defines the contract for loading, adding, deleting, and updating transaction data.
 */
public interface TransactionDao {

    // Keep loadFromCSV - used by cache loader
    List<Transaction> loadFromCSV(String filePath) throws IOException;

    /**
     * Loads all transactions from the specified data source file.
     * @param filePath The path to the user's CSV file.
     * @return A list of all transactions.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<Transaction> getAllTransactions(String filePath) throws IOException;


    /**
     * Adds a new transaction to the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param transaction The new transaction to add.
     * @throws IOException If an I/O error occurs during saving.
     */
    void addTransaction(String filePath, Transaction transaction) throws IOException;

    /**
     * Deletes a transaction identified by its order number from the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param orderNumber The unique order number of the transaction to delete.
     * @return true if a transaction was found and deleted, false otherwise.
     * @throws IOException If an I/O error occurs during loading or saving.
     */
    boolean deleteTransaction(String filePath, String orderNumber) throws IOException;

    /**
     * Updates a specific field of an existing transaction identified by its order number
     * in the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param orderNumber The unique order number of the transaction to update.
     * @param fieldName   The name of the field to update (e.g., "transactionType", "paymentAmount").
     * @param newValue    The new value for the specified field.
     * @return true if the transaction was found and updated, false otherwise.
     * @throws IOException             If an I/O error occurs during loading or saving.
     * @throws NumberFormatException   If updating 'paymentAmount' and newValue is not a valid double.
     * @throws IllegalArgumentException If the fieldName is invalid.
     */
    boolean updateTransaction(String filePath, String orderNumber, String fieldName, String newValue) throws IOException;

    /**
     * Retrieves a transaction by its unique order number from the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param orderNumber The unique order number.
     * @return The Transaction object if found, null otherwise.
     * @throws IOException If an I/O error occurs during loading.
     */
    Transaction getTransactionByOrderNumber(String filePath, String orderNumber) throws IOException;

    void writeTransactionsToCSV(String currentUserTransactionFilePath, List<Transaction> updatedList) throws IOException;

    // Remove the old methods without filePath parameter from the interface
    // List<Transaction> getAllTransactions() throws IOException; // Removed
    // void addTransaction(Transaction transaction) throws IOException; // Removed
    // boolean deleteTransaction(String orderNumber) throws IOException; // Removed
    // boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException; // Removed
    // Transaction getTransactionByOrderNumber(String orderNumber) throws IOException; // Removed
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\DAO\UserDao.java`:

```java
package DAO;

import model.User;

import java.io.IOException;
import java.util.List;

/**
 * Interface for Data Access Object (DAO) operations related to Users.
 */
public interface UserDao {

    /**
     * Loads all users from the configured data source.
     *
     * @return A list of all users.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<User> getAllUsers() throws IOException;

    // Add other user-related methods if needed later (e.g., addUser, deleteUser)
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Interceptor\Login\LoginDialog.java`:

```java
package Interceptor.Login;

import Service.User.UserService; // Import the new UserService
import model.User;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class LoginDialog extends JDialog {
    private User authenticatedUser = null; // Change from boolean flag to User object
    private JTextField usernameField;
    private JPasswordField passwordField;
    // UserService should ideally be injected, but for simplicity in LoginDialog,
    // we might initialize it here or pass it from Main. Let's pass it from Main.
    private final UserService userService;

    // Constructor now accepts UserService
    public LoginDialog(UserService userService) {
        this.userService = userService; // Inject UserService

        setTitle("User Login"); // "用户登录"
        setLayout(new GridLayout(3, 2));
        setModal(true);
        setSize(300, 150);
        setResizable(false); // Prevent resizing

        // Input components
        usernameField = new JTextField();
        passwordField = new JPasswordField();
        JButton loginButton = new JButton("Login");
        JButton cancelButton = new JButton("Cancel");

        // Add components
        add(new JLabel("Username:"));
        add(usernameField);
        add(new JLabel("Password:"));
        add(passwordField);
        add(loginButton);
        add(cancelButton);

        // Login button logic
        loginButton.addActionListener(e -> {
            String username = usernameField.getText().trim();
            String password = new String(passwordField.getPassword()).trim();

            authenticatedUser = userService.authenticate(username, password); // Use new authenticate method

            if (authenticatedUser != null) { // Check if a User object was returned
                dispose(); // Close dialog
            } else {
                JOptionPane.showMessageDialog(
                        this,
                        "Incorrect username or password!", // "Wrong username or password!"
                        "Login Failed",                    // "Login Failed"
                        JOptionPane.ERROR_MESSAGE
                );
                clearFields(); // Clear fields on failure
            }
        });

        // Cancel button logic
        cancelButton.addActionListener(e -> {
            authenticatedUser = null; // Ensure no user is set on cancel
            dispose();
            System.exit(0); // Exit application on cancel
        });

        setLocationRelativeTo(null); // Center dialog
    }

    // Method to clear input fields
    private void clearFields() {
        usernameField.setText("");
        passwordField.setText("");
        usernameField.requestFocusInWindow(); // Focus back to username field
    }

    /**
     * Shows the login dialog and returns the authenticated user upon successful login.
     * Blocking call.
     * @return The authenticated User object, or null if login failed or was cancelled.
     */
    public User showDialogAndGetResult() {
        setVisible(true); // Show the dialog (this call is blocking because modal is true)
        return authenticatedUser; // Return the result after dialog is closed
    }

    // Remove isLoginSuccessful() as we now return the User object
    // public boolean isLoginSuccessful() { return loginSuccessful; }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Main.java`:

```java
import javax.swing.*;

import Controller.MenuUI;
import DAO.Impl.CsvTransactionDao;
import DAO.Impl.CsvUserDao;
import DAO.Impl.CsvSummaryStatisticDao;
import DAO.UserDao;
import DAO.TransactionDao;
import DAO.SummaryStatisticDao;
import Interceptor.Login.LoginDialog;
import Service.Impl.TransactionServiceImpl;
import Service.Impl.SummaryStatisticService;
import Service.AIservice.AITransactionService; // Import AI Service classes
import Service.AIservice.CollegeStudentNeeds;
import Service.TransactionService;
import Service.User.UserService;
import com.formdev.flatlaf.FlatIntelliJLaf;
import model.User;
import Constants.ConfigConstants;

public class Main {
    public static void main(String[] args) {
        // Ensure ConfigConstants is loaded first
        String usersCsvPath = ConfigConstants.USERS_CSV_PATH;
        String summaryCsvPath = ConfigConstants.SUMMARY_CSV_PATH;
        System.out.println("Attempting to load users from: " + usersCsvPath);
        System.out.println("Summary statistics will be saved to: " + summaryCsvPath);


        // Initialize DAOs
        UserDao userDao = new CsvUserDao(usersCsvPath);
        TransactionDao transactionDao = new CsvTransactionDao();
        SummaryStatisticDao summaryStatisticDao = new CsvSummaryStatisticDao();


        // Initialize Services
        UserService userService = new UserService(userDao);
        // TransactionServiceImpl is initialized per user in MenuUI -> NO, initialize it here and pass it!
        // The TransactionServiceImpl instance *is* user-specific, so it's better to create it *after* login.
        // But AI Services need it *before* MenuUI is fully constructed and shows the panel.
        // Option 1: Pass TransactionService to MenuUI constructor and AI/CS services are initialized in MenuUI. (Current approach)
        // Option 2: Create AI/CS services here in Main and pass them to MenuUI. They would need the user-specific TS instance.
        // Let's stick with Option 1 for now, initializing AI/CS in MenuUI after getting TS.

        SummaryStatisticService summaryStatisticService = new SummaryStatisticService(userDao, transactionDao, summaryStatisticDao);

        try {
            UIManager.setLookAndFeel( new FlatIntelliJLaf() );
        } catch( Exception ex ) {
            System.err.println( "Failed to initialize LaF" );
        }
        // In the event dispatch thread (EDT) start GUI
        SwingUtilities.invokeLater(() -> {
            LoginDialog loginDialog = new LoginDialog(userService);
            User authenticatedUser = loginDialog.showDialogAndGetResult();

            if (authenticatedUser != null) {
                System.out.println("Logged in as: " + authenticatedUser.getUsername() + " (" + authenticatedUser.getRole() + ")");
                System.out.println("User's transaction file: " + authenticatedUser.getTransactionFilePath());

                // Initialize TransactionServiceImpl *for the logged-in user*
                TransactionService transactionServiceForCurrentUser = new TransactionServiceImpl(authenticatedUser.getTransactionFilePath());

                // Initialize AI Services *with* the user-specific TransactionService
                // This is where AI/CS services are created with their dependency injected
                AITransactionService aiTransactionService = new AITransactionService(transactionServiceForCurrentUser);
                CollegeStudentNeeds collegeStudentNeeds = new CollegeStudentNeeds(transactionServiceForCurrentUser);


                // Pass the authenticated user, their transaction service, summary statistic service, AND AI services to MenuUI
                MenuUI menuUI = new MenuUI(authenticatedUser, transactionServiceForCurrentUser, summaryStatisticService, aiTransactionService, collegeStudentNeeds); // Modify MenuUI constructor


                JFrame frame = new JFrame("Transaction Management System - " + authenticatedUser.getUsername());
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.setSize(2000, 1500);
                frame.setLocationRelativeTo(null);
                frame.add(menuUI.createMainPanel());
                frame.setVisible(true);
            } else {
                System.out.println("Login failed or cancelled. Exiting.");
                System.exit(0);
            }
        });
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Service\AIservice\AIAnalyzerThread.java`:

```java
package Service.AIservice;

// Add required imports
import Service.TransactionService; // Import if analyzeTransactions throws Exception


public class AIAnalyzerThread implements Runnable {
    private final String userRequest;
    private final String filePath; // Still needed for analyzeTransactions method signature
    private final String startTimeStr;
    private final String endTimeStr;

    // Field to hold the injected AITransactionService service instance
    private final AITransactionService aiTransactionService;


    /**
     * Constructor now accepts the AITransactionService service instance
     * and the parameters for the analysis request.
     *
     * @param aiTransactionService The AITransactionService service instance to use.
     * @param userRequest The user's natural language request.
     * @param filePath The path to the user's transaction data file.
     * @param startTimeStr The start time string for filtering.
     * @param endTimeStr The end time string for filtering.
     */
    public AIAnalyzerThread(AITransactionService aiTransactionService, String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        this.aiTransactionService = aiTransactionService; // Inject the service
        this.userRequest = userRequest;
        this.filePath = filePath; // Still needed for analyzeTransactions call
        this.startTimeStr = startTimeStr;
        this.endTimeStr = endTimeStr;
        System.out.println("AIAnalyzerThread initialized for file: " + filePath);
    }

    @Override
    public void run() {
        System.out.println("AIAnalyzerThread started for analysis request: '" + userRequest + "' on file: " + filePath);
        try {
            // Call the analyzeTransactions method on the injected service instance
            String result = aiTransactionService.analyzeTransactions(userRequest, filePath, startTimeStr, endTimeStr);

            // Print the result or handle it as needed by the test/caller that starts this thread
            System.out.println("AI analysis result from thread: " + result);

            // TODO: If this thread is used by a UI program, use SwingUtilities.invokeLater() to update a UI component with 'result'
            // This indicates this class might be intended for background tasks separate from the main UI refresh cycle handled in MenuUI.
        } catch (Exception e) { // Catch Exception as analyzeTransactions throws Exception
            System.err.println("Error during AI analysis in thread for file " + filePath + ": " + e.getMessage());
            e.printStackTrace();
            // You might want to pass this error back to the caller if it's a UI context.
        }
        System.out.println("AIAnalyzerThread finished for file: " + filePath);
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Service\AIservice\AITransactionService.java`:

```java
package Service.AIservice;

import DAO.TransactionDao;
import DAO.Impl.CsvTransactionDao;
import Service.TransactionService;
import Utils.CacheManager;
import model.MonthlySummary;
import model.Transaction;

import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;

import java.io.IOException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;
import java.util.concurrent.*;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;

public class AITransactionService {
    // Keep static ArkService as it's typically thread-safe and stateless
    private static final String API_KEY = System.getenv("ARK_API_KEY"); // Or load from config.properties
    private static final ArkService service = ArkService.builder()
            .timeout(Duration.ofSeconds(1800))
            .connectTimeout(Duration.ofSeconds(20))
            .baseUrl("https://ark.cn-beijing.volces.com/api/v3")
            .apiKey(API_KEY) // Ensure API_KEY is loaded
            .build();

    // Need access to TransactionService to get monthly summaries
    private final TransactionService transactionService; // Inject TransactionService


    /**
     * Constructor now accepts TransactionService instance.
     */
    public AITransactionService(TransactionService transactionService) {
        this.transactionService = transactionService; // Inject the service
        System.out.println("AITransactionService initialized with TransactionService.");
    }

    /**
     * Analyzes transactions from a specific user's file based on user request and time range.
     *
     * @param userRequest The user's natural language request.
     * @param filePath The path to the user's transaction CSV file.
     * @param startTimeStr The start time string for filtering.
     * @param endTimeStr The end time string for filtering.
     * @return AI analysis result as a String.
     */
    public String analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        try {
            // Get transactions for the specified file path using CacheManager
            // Need to pass a DAO instance for the CacheManager's loader if it needs to load from file.
            TransactionDao transactionDaoForLoading = new CsvTransactionDao(); // Create a DAO instance for loading
            List<Transaction> transactions = CacheManager.getTransactions(filePath, transactionDaoForLoading);
            System.out.println("AI Service: Retrieved " + transactions.size() + " transactions for file: " + filePath);


            // Format filtered transactions for the AI prompt
            List<String> transactionDetails = formatTransactions(transactions, startTimeStr, endTimeStr);
            System.out.println("AI Service: Formatted " + transactionDetails.size() + " transactions for AI.");


            // Check if any transactions were found after filtering
            if (transactionDetails.isEmpty() || (transactionDetails.size() == 1 && transactionDetails.get(0).startsWith("No transactions found within this time period"))) {
                return "No transaction records found matching the criteria within this time period, analysis cannot be performed. Please check the time and transaction data.";
            }

            String aiPrompt = userRequest + "\n" + "Here is my billing information:\n" + String.join("\n", transactionDetails);
            System.out.println("AI Service: Sending prompt to AI. Prompt length: " + aiPrompt.length());
            return askAi(aiPrompt);
        } catch (IllegalArgumentException e) {
            System.err.println("AI analysis failed due to invalid time format: " + e.getMessage());
            return "AI analysis failed: Incorrect time format. " + e.getMessage();
        }
        catch (Exception e) {
            System.err.println("AI analysis failed during data retrieval or AI call for file: " + filePath);
            e.printStackTrace();
            return "AI analysis failed: An error occurred while fetching data or calling the AI service. " + e.getMessage();
        }
    }


    // Keep formatTransactions, parseDateTime, askAi methods. Ensure parseDateTime is robust.
    // The formatTransactions method relies on parseDateTime, ensure consistency with TransactionServiceImpl's parser.

    public List<String> formatTransactions(List<Transaction> transactions, String startTimeStr, String endTimeStr) {
        LocalDateTime startTime = parseDateTime(startTimeStr);
        // If end time is empty, use current time
        LocalDateTime endTime = (endTimeStr == null || endTimeStr.trim().isEmpty())
                ? LocalDateTime.now()
                : parseDateTime(endTimeStr);

        if (startTime == null) {
            // Handle the case where start time is invalid.
            // Depending on requirements, you might throw an exception or return an error message list.
            // Throwing IllegalArgumentException is better for analyzeTransactions to catch.
            throw new IllegalArgumentException("Incorrect start time format: " + startTimeStr);
        }
        // If endTime parsing fails, treat it as current time as per original logic if endTimeStr was not empty
        if ((endTimeStr != null && !endTimeStr.trim().isEmpty()) && endTime == null) {
            throw new IllegalArgumentException("Incorrect end time format: " + endTimeStr);
        }
        // If endTimeStr was empty, endTime is already LocalDateTime.now() which is not null.

        System.out.println("Filtering transactions from " + startTime + " to " + endTime);


        List<Transaction> filtered = transactions.stream()
                .filter(t -> {
                    LocalDateTime tTime = parseDateTime(t.getTransactionTime());
                    // Include transactions exactly at startTime, exclude transactions exactly at endTime (standard range behavior [start, end))
                    // If endTime should be inclusive, change isBefore(startTime) to !isAfter(startTime) and isAfter(endTime) to !isBefore(endTime)
                    // Or use isBefore(startTime) || isAfter(endTime) and negate.
                    // Let's use !isBefore(startTime) && !isAfter(endTime) as it seems more intuitive for a date range, inclusive.
                    return tTime != null && !tTime.isBefore(startTime) && !tTime.isAfter(endTime); // Range [startTime, endTime]
                })
                .collect(Collectors.toList());
        System.out.println("Filtered down to " + filtered.size() + " transactions within range.");


        // Group by Counterparty and summarize net amount and count
        Map<String, double[]> grouped = new HashMap<>(); // double[0] = net amount, double[1] = count
        for (Transaction t : filtered) {
            String counterparty = t.getCounterparty();
            double amount = t.getPaymentAmount();
            // Assuming t.getInOut() returns "Income"/"Expense" or "In"/"Out"
            if (t.getInOut().equalsIgnoreCase("Expense") || t.getInOut().equalsIgnoreCase("Out")) {
                amount = -amount;
            } else if (!t.getInOut().equalsIgnoreCase("Income") && !t.getInOut().equalsIgnoreCase("In")) {
                System.err.println("Warning: Unknown In/Out type for transaction: " + t.getOrderNumber() + " - " + t.getInOut());
                // Decide how to handle unknown types - ignore from analysis? Treat as 0?
                continue; // Skip unknown types for aggregation
            }

            grouped.putIfAbsent(counterparty, new double[]{0.0, 0});
            grouped.get(counterparty)[0] += amount;
            grouped.get(counterparty)[1] += 1;
        }
        System.out.println("Grouped transactions by counterparty. Found " + grouped.size() + " counterparties.");


        List<String> results = grouped.entrySet().stream()
                .map(e -> {
                    String cp = e.getKey();
                    double net = e.getValue()[0];
                    int count = (int) e.getValue()[1];
                    String inOutLabel = net >= 0 ? "Total Income" : "Total Expense";
                    if (Math.abs(net) < 0.01 && count > 0) { // If net is near zero but there were transactions
                        inOutLabel = "Net Zero"; // Or specify "Income equals Expense"
                    }
                    return String.format("Counterparty: %s, Net %s: %.2f CNY, Transaction Count: %d",
                            cp, inOutLabel, Math.abs(net), count);
                })
                .collect(Collectors.toList());
        System.out.println("Formatted grouped results.");


        // Add time range information to the results list
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm");
        String rangeInfo = String.format("Analysis Time Range: %s - %s",
                formatter.format(startTime), formatter.format(endTime));
        results.add(0, rangeInfo); // Add range info at the beginning

        if (filtered.isEmpty()) { // Check if the filtered list was empty before grouping
            return List.of(rangeInfo, "No transactions found within this time period.");
        }
        return results;
    }


    // Keep parseDateTime method - ensure it matches the one in TransactionServiceImpl
    private LocalDateTime parseDateTime(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // Clean whitespace
        timeStr = timeStr.trim().replaceAll("\\s+", " ");

        // Append time if only date
        if (timeStr.matches("\\d{4}/\\d{1,2}/\\d{1,2}")) {
            timeStr += " 00:00"; // Assuming minutes format
        } else if (timeStr.matches("\\d{4}-\\d{1,2}-\\d{1,2}")) {
            timeStr += " 00:00:00"; // Assuming seconds format
        }


        // Try parsing with multiple formats
        List<String> patterns = List.of(
                "yyyy/M/d H:mm", "yyyy/M/d HH:mm",
                "yyyy/MM/d H:mm", "yyyy/MM/d HH:mm",
                "yyyy/M/dd H:mm", "yyyy/M/dd HH:mm",
                "yyyy/MM/dd H:mm", "yyyy/MM/dd HH:mm",
                "yyyy/MM/dd HH:mm:ss", // Added seconds format
                "yyyy-MM-dd HH:mm:ss", // Added dash format
                "yyyy/MM/dd" // Date only (handled above)
                // Add more patterns if needed based on your CSV data
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDateTime.parse(timeStr, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern and try the next
            }
        }
        System.err.println("AI Service: Failed to parse date string: " + timeStr);
        return null; // Return null if no pattern matches
    }


    // Keep askAi method
    public String askAi(String prompt) {
        try {
            if (API_KEY == null || API_KEY.trim().isEmpty()) {
                System.err.println("ARK_API_KEY environment variable is not set.");
                return "AI service configuration error: ARK_API_KEY not set.";
            }
            // Ensure the static service instance is properly built with the key
            // This might be better done once at application startup if API_KEY is loaded from config.
            // For now, relying on the static final initialization is acceptable if the env var is set before class loading.


            List<ChatMessage> messages = List.of(
                    ChatMessage.builder().role(ChatMessageRole.USER).content(prompt).build()
            );

            ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
                    .model("ep-20250308174053-7pbkq") // Use your model name
                    .messages(messages)
                    .build();

            System.out.println("AI Service: Sending request to VolcEngine Ark...");
            // Use the static service instance
            String responseContent = (String) service.createChatCompletion(chatCompletionRequest)
                    .getChoices().get(0).getMessage().getContent();
            System.out.println("AI Service: Received response from AI.");
            return responseContent;

        } catch (Exception e) {
            System.err.println("AI Service: AI request failed.");
            e.printStackTrace();
            return "AI request failed: " + e.getMessage();
        }
    }

    // Keep runAiInThread method, ensure it uses the correct analyzeTransactions method
    public void runAiInThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        // ExecutorService should ideally be managed at a higher level in a larger app,
        // but a simple single thread executor per request is acceptable for this scale.
        // However, this creates a new thread and executor every time.
        // A fixed thread pool managed statically or by a dedicated AI Service Manager would be more efficient.
        // For now, let's keep it simple as in the original code.

        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            // Call the instance method analyzeTransactions
            String result = this.analyzeTransactions(userRequest, filePath,startTimeStr, endTimeStr);
            System.out.println("AI analysis thread finished. Result: " + result);
            // TODO: How to pass the result back to the UI?
            // This thread doesn't have access to the UI components directly.
            // Need a mechanism like a callback or SwingUtilities.invokeLater.
            // This will be addressed when integrating AI output into the UI (Step 10).
        });
        // Consider shutting down the executor more gracefully, e.g., when the app exits.
        // executor.shutdown(); // Shutting down immediately might cancel the task
        // A better approach is `executor.shutdown()` after submitting, but manage the executor lifecycle elsewhere.
    }

    /**
     * Generates a personal consumption summary based on monthly data.
     * @param userFilePath The path to the user's transaction CSV file. (Might not be strictly needed if service handles context)
     * @return AI analysis result as a String.
     */
    public String generatePersonalSummary(String userFilePath) {
        try {
            // Get monthly summary data from TransactionService
            // Note: TransactionService already operates on the current user's data implicitly if passed correctly.
            // We might not need userFilePath explicitly in this method signature if the service instance is user-specific.
            // Let's assume the injected transactionService is already scoped to the current user.
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("AI Service: Retrieved " + summaries.size() + " months of summary data.");

            if (summaries.isEmpty()) {
                return "Not enough transaction data found to generate a personal spending summary.";
            }

            // Format the summary data for the AI prompt
            StringBuilder summaryPromptBuilder = new StringBuilder();
            summaryPromptBuilder.append("Please generate a personal spending habits summary based on the following monthly data. Analyze main expense categories, monthly trends, and assess my spending health:\n\n");

            // Sort months chronologically for better trend analysis by AI
            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                summaryPromptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                summaryPromptBuilder.append("  Total Income: ").append(String.format("%.2f", ms.getTotalIncome())).append(" CNY\n");
                summaryPromptBuilder.append("  Total Expense: ").append(String.format("%.2f", ms.getTotalExpense())).append(" CNY\n");
                summaryPromptBuilder.append("  Expense Breakdown:\n");
                if (ms.getExpenseByCategory().isEmpty()) {
                    summaryPromptBuilder.append("    (No expenses)\n");
                } else {
                    // Sort categories by amount descending for AI to easily see major categories
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    summaryPromptBuilder.append(String.format("    %s: %.2f CNY\n", entry.getKey(), entry.getValue()))
                            );
                }
                summaryPromptBuilder.append("\n"); // Add space between months
            }

            String aiPrompt = summaryPromptBuilder.toString();
            System.out.println("AI Service: Sending personal summary prompt to AI. Prompt length: " + aiPrompt.length());

            return askAi(aiPrompt); // Call the generic AI method
        } catch (Exception e) {
            System.err.println("AI Service: Failed to generate personal summary.");
            e.printStackTrace();
            return "Failed to generate personal spending summary: " + e.getMessage();
        }
    }

    /**
     * Generates suggestions for savings goals based on monthly data.
     * @param userFilePath The path to the user's transaction CSV file. (Might not be strictly needed)
     * @return AI suggestions as a String.
     */
    public String suggestSavingsGoals(String userFilePath) {
        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("AI Service: Retrieved " + summaries.size() + " months of summary data for savings goal suggestion.");

            if (summaries.isEmpty()) {
                return "Not enough transaction data found to suggest savings goals.";
            }

            StringBuilder promptBuilder = new StringBuilder();
            promptBuilder.append("Please provide some reasonable savings goal suggestions for my spending habits based on the following monthly income and expense summary data:\n\n");

            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  Total Income: ").append(String.format("%.2f", ms.getTotalIncome())).append(" CNY\n");
                promptBuilder.append("  Total Expense: ").append(String.format("%.2f", ms.getTotalExpense())).append(" CNY\n");
                double net = ms.getTotalIncome() - ms.getTotalExpense();
                promptBuilder.append("  Monthly Net Income/Expense: ").append(String.format("%.2f", net)).append(" CNY\n");
                promptBuilder.append("\n");
            }

            String aiPrompt = promptBuilder.toString();
            System.out.println("AI Service: Sending savings goals prompt to AI. Prompt length: " + aiPrompt.length());

            return askAi(aiPrompt);
        } catch (Exception e) {
            System.err.println("AI Service: Failed to suggest savings goals.");
            e.printStackTrace();
            return "Failed to suggest savings goals: " + e.getMessage();
        }
    }

    /**
     * Generates personalized cost-cutting recommendations based on monthly data.
     * @param userFilePath The path to the user's transaction CSV file. (Might not be strictly needed)
     * @return AI recommendations as a String.
     */
    public String givePersonalSavingTips(String userFilePath) {
        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("AI Service: Retrieved " + summaries.size() + " months of summary data for saving tips.");

            if (summaries.isEmpty()) {
                return "Not enough transaction data found to provide personalized saving tips.";
            }

            StringBuilder promptBuilder = new StringBuilder();
            promptBuilder.append("Please provide some targeted cost-saving suggestions for me based on the following monthly spending summary data:\n\n");

            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  Total Expense: ").append(String.format("%.2f", ms.getTotalExpense())).append(" CNY\n");
                promptBuilder.append("  Expense Breakdown:\n");
                if (ms.getExpenseByCategory().isEmpty()) {
                    promptBuilder.append("    (No expenses)\n");
                } else {
                    // Sort categories by amount descending
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    promptBuilder.append(String.format("    %s: %.2f CNY\n", entry.getKey(), entry.getValue()))
                            );
                }
                promptBuilder.append("\n");
            }

            String aiPrompt = promptBuilder.toString();
            System.out.println("AI Service: Sending personal saving tips prompt to AI. Prompt length: " + aiPrompt.length());

            return askAi(aiPrompt);
        } catch (Exception e) {
            System.err.println("AI Service: Failed to give personal saving tips.");
            e.printStackTrace();
            return "Failed to generate personalized saving tips: " + e.getMessage();
        }
    }


    // ... Keep other methods like analyzeTransactions, formatTransactions, parseDateTime, askAi ...

    // The existing CollegeStudentNeeds class also has budget and tips methods.
    // We need to decide: should AITransactionService offer general AI for anyone,
    // and CollegeStudentNeeds offer student-specific prompts/logic?
    // Or should AITransactionService be the main AI interaction point,
    // and CollegeStudentNeeds just holds student-specific logic/prompts used by AITransactionService?
    // Given the project structure, it might be better to keep student logic in CollegeStudentNeeds
    // and call it from MenuUI or a wrapper service.
    // Let's adjust: generatePersonalSummary, suggestSavingsGoals, givePersonalSavingTips will use monthly summary.
    // CollegeStudentNeeds.generateBudget and generateTipsForSaving can remain using their current logic
    // (budget uses weekly expenses, tips is generic for now).
    // The prompt for CollegeStudentNeeds.generateBudget might need to be updated to use the monthly summary data too for better context.
    // Let's refine CollegeStudentNeeds methods in the next step.

    // For now, the three new methods above will use the monthly summary.
    // The existing analyzeTransactions method in AITransactionService and the methods in CollegeStudentNeeds remain as is for now,
    // but their usage in UI might change slightly.

}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Service\AIservice\ColledgeStudentThread.java`:

```java
package Service.AIservice;

// Add required imports
import Service.TransactionService; // Keep import if generateBudget throws Exception
// import java.io.IOException; // Removed specific IOException import if using general Exception


public class ColledgeStudentThread implements Runnable{
    // Remove the old budgetRange field, it's not used here
    // public String budgetRange;

    // Field to hold the injected CollegeStudentNeeds service instance
    private final CollegeStudentNeeds collegeStudentNeeds;
    // The file path is still needed to pass to the generateBudget method
    private final String filePath;


    /**
     * Constructor now accepts the CollegeStudentNeeds service instance and the file path.
     * The injected service instance already contains the necessary TransactionService.
     *
     * @param collegeStudentNeeds The CollegeStudentNeeds service instance to use for generating the budget.
     * @param filePath The path to the user's transaction data file.
     */
    public ColledgeStudentThread(CollegeStudentNeeds collegeStudentNeeds, String filePath) {
        this.collegeStudentNeeds = collegeStudentNeeds;
        this.filePath = filePath;
        System.out.println("ColledgeStudentThread initialized for file: " + filePath);
    }

    @Override
    public void run(){
        System.out.println("ColledgeStudentThread started for file: " + filePath);
        try {
            // Call the generateBudget method on the injected service instance
            double[] budget = collegeStudentNeeds.generateBudget(filePath);

            // Print the result or handle it as needed by the test/caller that starts this thread
            if (budget != null && budget.length == 2 && budget[0] != -1) {
                System.out.println("Budget generated in thread for file " + filePath + ": [" + budget[0] + ", " + budget[1] + "]");
            } else {
                // handle the case where budget generation failed or returned -1
                System.out.println("Budget generation in thread finished, but no valid budget was returned for file " + filePath + ".");
                // You might want to distinguish between "no data" (-1,-1) and other exceptions here.
            }
        } catch (Exception e) { // Catch Exception as generateBudget throws Exception
            System.err.println("Error generating budget in thread for file " + filePath + ": " + e.getMessage());
            e.printStackTrace();
        }
        System.out.println("ColledgeStudentThread finished for file: " + filePath);
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Service\AIservice\CollegeStudentNeeds.java`:

```java
package Service.AIservice;

import Constants.StandardCategories;
import DAO.TransactionDao;
import DAO.Impl.CsvTransactionDao;
// Removed: import Service.Impl.TransactionServiceImpl; // Not directly used here
import Utils.CacheManager;
import model.Transaction;
import model.MonthlySummary;
import Service.TransactionService;

import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Collections;
import java.util.Optional;
import java.util.stream.Collectors;

public class CollegeStudentNeeds {
    // Prompts for AI interaction
    private final String requestBudge = "I am a college student with a limited budget. Based on my historical weekly spending and monthly income/expense summary provided below, please help me set a budget range for next week. You must provide the answer in the format [minimum_budget, maximum_budget], with no additional text.";
    private final String requestTips = "I am a college student with a limited budget. Based on my monthly spending summary data provided below, please recommend some targeted ways for me to save money.";
    private final String requestRecognition =
            "Please infer the most appropriate transaction type based on the following billing information. The returned type must exactly match one of the entries in the following list:\n" +
                    StandardCategories.getAllCategoriesString() + "\n" + // Include the list of valid categories
                    "If it cannot be determined, please return 'Other Expenses' or 'Other Income' (depending on the income/expense direction). Return only the type string, do not include additional text or explanations. Billing information:";

    // TransactionService is injected to access transaction data and summaries.
    private final TransactionService transactionService;

    /**
     * Constructor that accepts a TransactionService instance.
     * @param transactionService The service to interact with transaction data.
     */
    public CollegeStudentNeeds(TransactionService transactionService) {
        this.transactionService = transactionService;
        System.out.println("CollegeStudentNeeds initialized with TransactionService.");
    }

    /**
     * Recognizes the spending category of a single transaction using AI.
     * This method uses the raw transaction details for recognition.
     *
     * @param transaction The transaction to recognize.
     * @return The AI's suggested category.
     */
    public String RecognizeTransaction(Transaction transaction) {
        if (transaction == null) {
            return "Cannot recognize empty transaction information";
        }
        StringBuilder sb = new StringBuilder();
        // Build the string with transaction details for the AI prompt.
        // Assuming In/Out and other fields are in English or will be handled by AI.
        sb.append("Transaction Type:").append(transaction.getTransactionType()).append(",")
                .append("Counterparty:").append(transaction.getCounterparty()).append(",")
                .append("Commodity:").append(transaction.getCommodity()).append(",")
                .append("In/Out:").append(transaction.getInOut()).append(",")
                .append("Amount(CNY):").append(String.format("%.2f", transaction.getPaymentAmount())).append(",")
                .append("Payment Method:").append(transaction.getPaymentMethod()).append(",")
                .append("Remarks:").append(transaction.getRemarks());

        System.out.println("CollegeStudentNeeds: Sending recognition request to AI: " + sb.toString());
        // Create a local AITransactionService instance for askAi calls, as it doesn't need an injected TransactionService for this specific task.
        AITransactionService localAiService = new AITransactionService(null);
        return localAiService.askAi(requestRecognition + sb.toString());
    }

    /**
     * Generates saving tips for college students using AI, based on their monthly summary.
     * @param userFilePath The path to the user's transaction CSV file. This parameter might be
     *                     refactored if TransactionService is inherently user-scoped.
     * @return AI's suggested saving tips.
     */
    public String generateTipsForSaving(String userFilePath) {
        try {
            // Get monthly summary data using the injected TransactionService.
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("CollegeStudentNeeds: Retrieved " + summaries.size() + " months of summary data for tips.");

            if (summaries.isEmpty()) {
                return "Not enough transaction data found to provide personalized saving tips.";
            }

            StringBuilder promptBuilder = new StringBuilder();
            promptBuilder.append(requestTips).append("\n\nHere is my monthly spending summary data:\n\n");

            // Sort months chronologically to present data in order to the AI.
            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  Total Expense: ").append(String.format("%.2f", ms.getTotalExpense())).append(" CNY\n");
                promptBuilder.append("  Expense Breakdown:\n");
                if (ms.getExpenseByCategory().isEmpty()) {
                    promptBuilder.append("    (No expenses)\n");
                } else {
                    // Sort categories by amount in descending order for clarity.
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    promptBuilder.append(String.format("    %s: %.2f CNY\n", entry.getKey(), entry.getValue()))
                            );
                }
                promptBuilder.append("\n");
            }

            String aiPrompt = promptBuilder.toString();
            System.out.println("CollegeStudentNeeds: Sending saving tips prompt to AI. Prompt length: " + aiPrompt.length());

            AITransactionService localAiService = new AITransactionService(null);
            return localAiService.askAi(aiPrompt);

        } catch (Exception e) {
            System.err.println("CollegeStudentNeeds: Failed to generate saving tips.");
            e.printStackTrace();
            return "Failed to generate personalized saving tips: " + e.getMessage();
        }
    }

    /**
     * Analyzes weekly spending and monthly summaries to ask AI for a budget range.
     * @param filePath The path to the user's transaction CSV file.
     * @return A double array [minBudget, maxBudget] parsed from AI response, or [-1, -1] on failure.
     * @throws Exception If there's an error accessing transaction data or summaries.
     */
    public double[] generateBudget(String filePath) throws Exception {
        List<Transaction> transactions;
        Map<String, MonthlySummary> summaries;

        try {
            // Get transactions using CacheManager.
            TransactionDao transactionDaoForLoading = new CsvTransactionDao();
            transactions = CacheManager.getTransactions(filePath, transactionDaoForLoading);
            System.out.println("CollegeStudentNeeds: Retrieved " + transactions.size() + " transactions for budget analysis from: " + filePath);

            // Get monthly summary data for additional context.
            summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("CollegeStudentNeeds: Retrieved " + summaries.size() + " months of summary data for budget context.");

        } catch (Exception e) {
            System.err.println("CollegeStudentNeeds: Error retrieving transactions or summary for budget analysis: " + filePath);
            e.printStackTrace();
            throw e;
        }

        // Handle case with no transactions.
        if (transactions.isEmpty()) {
            System.out.println("CollegeStudentNeeds: No transactions found for budget analysis.");
            if (!summaries.isEmpty()) {
                // If monthly summaries exist, use them for the AI prompt.
                StringBuilder promptBuilder = new StringBuilder();
                promptBuilder.append("Here is my monthly income and expense summary data:\n\n");
                List<String> sortedMonths = new ArrayList<>(summaries.keySet());
                Collections.sort(sortedMonths);
                for (String month : sortedMonths) {
                    MonthlySummary ms = summaries.get(month);
                    promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                    promptBuilder.append("  Total Income: ").append(String.format("%.2f", ms.getTotalIncome())).append(" CNY\n");
                    promptBuilder.append("  Total Expense: ").append(String.format("%.2f", ms.getTotalExpense())).append(" CNY\n");
                    double net = ms.getTotalIncome() - ms.getTotalExpense();
                    promptBuilder.append("  Monthly Net Income/Expense: ").append(String.format("%.2f", net)).append(" CNY\n");
                    promptBuilder.append("  Main Expense Categories:\n");
                    if (ms.getExpenseByCategory().isEmpty()) {
                        promptBuilder.append("    (No expenses)\n");
                    } else {
                        ms.getExpenseByCategory().entrySet().stream()
                                .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                                .forEach(entry ->
                                        promptBuilder.append(String.format("    %s: %.2f CNY\n", entry.getKey(), entry.getValue()))
                                );
                    }
                    promptBuilder.append("\n");
                }
                String answer = new AITransactionService(null).askAi(requestBudge + "\n\nNo weekly spending data found.\n" + promptBuilder.toString());
                return parseDoubleArrayFromString(answer);
            }
            return new double[]{-1, -1}; // No data at all.
        }

        // Filter for 'Expense' transactions and sort them by date (newest first).
        // Assumes In/Out field uses "Expense" or "Out" for expense transactions.
        List<Transaction> expenseTransactions = transactions.stream()
                .filter(t -> t.getInOut() != null && (t.getInOut().equalsIgnoreCase("Expense") || t.getInOut().equalsIgnoreCase("Out")))
                .sorted((t1, t2) -> {
                    LocalDate date1 = parseDateSafe(t1.getTransactionTime());
                    LocalDate date2 = parseDateSafe(t2.getTransactionTime());
                    if (date1 != null && date2 != null) { return date2.compareTo(date1); }
                    else if (date1 == null && date2 == null) { return 0; }
                    else if (date1 == null) { return 1; } // Treat null dates as later for sorting purposes if needed.
                    else { return -1; }
                })
                .collect(Collectors.toList());
        System.out.println("CollegeStudentNeeds: Filtered " + expenseTransactions.size() + " expense transactions for budget analysis.");

        // Handle case with no expense transactions.
        if (expenseTransactions.isEmpty()) {
            System.out.println("CollegeStudentNeeds: No expense transactions found for budget analysis.");
            if (!summaries.isEmpty()) {
                // If monthly summaries exist, use them for the AI prompt.
                StringBuilder promptBuilder = new StringBuilder();
                promptBuilder.append("Here is my monthly income and expense summary data:\n\n");
                List<String> sortedMonths = new ArrayList<>(summaries.keySet());
                Collections.sort(sortedMonths);
                for (String month : sortedMonths) {
                    MonthlySummary ms = summaries.get(month);
                    promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                    promptBuilder.append("  Total Income: ").append(String.format("%.2f", ms.getTotalIncome())).append(" CNY\n");
                    promptBuilder.append("  Total Expense: ").append(String.format("%.2f", ms.getTotalExpense())).append(" CNY\n");
                    double net = ms.getTotalIncome() - ms.getTotalExpense();
                    promptBuilder.append("  Monthly Net Income/Expense: ").append(String.format("%.2f", net)).append(" CNY\n");
                    promptBuilder.append("  Main Expense Categories:\n");
                    if (ms.getExpenseByCategory().isEmpty()) {
                        promptBuilder.append("    (No expenses)\n");
                    } else {
                        ms.getExpenseByCategory().entrySet().stream()
                                .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                                .forEach(entry ->
                                        promptBuilder.append(String.format("    %s: %.2f CNY\n", entry.getKey(), entry.getValue()))
                                );
                    }
                    promptBuilder.append("\n");
                }
                String answer = new AITransactionService(null).askAi(requestBudge + "\n\nNo weekly spending data found.\n" + promptBuilder.toString());
                return parseDoubleArrayFromString(answer);
            }
            return new double[]{-1, -1}; // No expense data and no summary data.
        }

        // Calculate weekly expenses from the filtered expense transactions.
        List<Double> weeklyExpenses = new ArrayList<>();
        LocalDate currentWeekStart = null;
        double currentWeekTotal = 0;

        for (Transaction expense : expenseTransactions) {
            LocalDate transactionDate = parseDateSafe(expense.getTransactionTime());
            if (transactionDate == null) continue;

            if (currentWeekStart == null) {
                currentWeekStart = transactionDate;
            }

            long daysDifference = ChronoUnit.DAYS.between(transactionDate, currentWeekStart);

            if (daysDifference >= 0 && daysDifference < 7) {
                currentWeekTotal += expense.getPaymentAmount();
            } else if (daysDifference >= 7) {
                weeklyExpenses.add(currentWeekTotal);
                currentWeekStart = transactionDate;
                currentWeekTotal = expense.getPaymentAmount();
            }
        }
        if (currentWeekTotal > 0 || currentWeekStart != null) { // Add the last week's total.
            weeklyExpenses.add(currentWeekTotal);
        }
        System.out.println("CollegeStudentNeeds: Calculated weekly expenses for " + weeklyExpenses.size() + " weeks: " + weeklyExpenses);

        // Format the prompt including both weekly expenses and monthly summary.
        StringBuilder promptBuilder = new StringBuilder();
        promptBuilder.append(requestBudge).append("\n\n");

        promptBuilder.append("Here is my recent weekly spending data:\n");
        if (weeklyExpenses.isEmpty()) {
            promptBuilder.append("(Not enough periodic expense data found)\n");
        } else {
            for (int i = 0; i < weeklyExpenses.size(); i++) {
                promptBuilder.append("Week ");
                promptBuilder.append(weeklyExpenses.size() - i); // Week numbers count down (e.g., Week 3, Week 2, Week 1 (most recent))
                promptBuilder.append(": Spent ");
                promptBuilder.append(String.format("%.2f", weeklyExpenses.get(i)));
                promptBuilder.append(" CNY; ");
            }
            promptBuilder.append("\n");
        }

        promptBuilder.append("\nAdditionally, here is my monthly income and expense summary data:\n\n");
        if (summaries.isEmpty()) {
            promptBuilder.append("(No monthly summary data found)\n");
        } else {
            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);
            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  Total Income: ").append(String.format("%.2f", ms.getTotalIncome())).append(" CNY\n");
                promptBuilder.append("  Total Expense: ").append(String.format("%.2f", ms.getTotalExpense())).append(" CNY\n");
                double net = ms.getTotalIncome() - ms.getTotalExpense();
                promptBuilder.append("  Monthly Net Income/Expense: ").append(String.format("%.2f", net)).append(" CNY\n");
                promptBuilder.append("  Main Expense Categories:\n");
                if (ms.getExpenseByCategory().isEmpty()) {
                    promptBuilder.append("    (No expenses)\n");
                } else {
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    promptBuilder.append(String.format("    %s: %.2f CNY\n", entry.getKey(), entry.getValue()))
                            );
                }
                promptBuilder.append("\n");
            }
        }

        String aiPrompt = promptBuilder.toString();
        System.out.println("CollegeStudentNeeds: Sending budget request to AI. Prompt length: " + aiPrompt.length());

        String answer = new AITransactionService(null).askAi(aiPrompt);
        System.out.println("CollegeStudentNeeds: Received budget response from AI: " + answer);

        double[] ret = parseDoubleArrayFromString(answer);
        if (ret == null || ret.length != 2) {
            System.err.println("CollegeStudentNeeds: Failed to parse budget array from AI response: " + answer + ". Full AI Response: " + answer);
            return new double[]{-1, -1};
        }
        return ret;
    }

    /**
     * Helper method to safely parse a date string from a transaction's time field.
     * This method attempts to parse the date part of various common timestamp formats.
     * @param timeStr The transaction time string.
     * @return A LocalDate object, or null if parsing fails.
     */
    private LocalDate parseDateSafe(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        String datePart = timeStr.split(" ")[0]; // Get the date part (before space).
        datePart = datePart.trim().replace('-', '/'); // Normalize hyphens to slashes.

        List<String> patterns = List.of(
                "yyyy/M/d", "yyyy/MM/d", "yyyy/M/dd", "yyyy/MM/dd"
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDate.parse(datePart, formatter);
            } catch (DateTimeParseException ignored) {
                // Ignore parsing errors for this pattern and try the next.
            }
        }
        System.err.println("CollegeStudentNeeds: Failed to parse date part '" + datePart + "' from transaction time: " + timeStr);
        return null;
    }

    /**
     * Parses a string representation of a budget range (e.g., "[100.0, 200.0]") into a double array.
     * @param input The string to parse.
     * @return A double array containing [minBudget, maxBudget], or null if parsing fails.
     */
    public double[] parseDoubleArrayFromString(String input) {
        if (input == null) { return null; }
        String trimmedInput = input.trim();
        System.out.println("CollegeStudentNeeds: Attempting to parse budget string: '" + trimmedInput + "'");
        int startIndex = trimmedInput.indexOf('[');
        int endIndex = trimmedInput.lastIndexOf(']');
        if (startIndex == -1 || endIndex == -1 || endIndex < startIndex) {
            System.err.println("CollegeStudentNeeds: Budget string does not contain valid []. Input: " + trimmedInput);
            return null;
        }
        String content = trimmedInput.substring(startIndex + 1, endIndex).trim();
        // Split by comma, allowing for optional spaces around the comma.
        String[] numberStrings = content.split("\\s*,\\s*");
        if (numberStrings.length != 2) {
            System.err.println("CollegeStudentNeeds: Budget string content does not contain exactly two numbers separated by comma. Content: " + content);
            return null;
        }
        double[] result = new double[2];
        try {
            result[0] = Double.parseDouble(numberStrings[0].trim());
            result[1] = Double.parseDouble(numberStrings[1].trim());
            System.out.println("CollegeStudentNeeds: Successfully parsed budget: [" + result[0] + ", " + result[1] + "]");
            return result;
        } catch (NumberFormatException e) {
            System.err.println("CollegeStudentNeeds: Error parsing numbers from budget string: " + content);
            e.printStackTrace();
            return null;
        }
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Service\Impl\SummaryStatisticService.java`:

```java
package Service.Impl;

import Constants.StandardCategories; // Import StandardCategories
import DAO.TransactionDao; // Import TransactionDao interface
import DAO.UserDao; // Import UserDao interface
import DAO.SummaryStatisticDao; // Import SummaryStatisticDao interface
import model.SummaryStatistic;
import model.Transaction;
import model.User;
import Utils.CacheManager; // Import CacheManager
import Constants.ConfigConstants; // Import ConfigConstants for summary file path

import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.temporal.WeekFields; // For getting week of year
import java.util.*;
import java.util.stream.Collectors;
import java.time.format.DateTimeFormatter; // For generating timestamp

public class SummaryStatisticService {

    private final UserDao userDao;
    private final TransactionDao transactionDao; // Need a DAO instance for CacheManager loading
    private final SummaryStatisticDao summaryStatisticDao;
    private final String summaryFilePath;

    /**
     * Constructor to inject dependencies.
     * @param userDao DAO for user data.
     * @param transactionDao DAO for transaction data (used by CacheManager loader).
     * @param summaryStatisticDao DAO for summary statistics data.
     */
    public SummaryStatisticService(UserDao userDao, TransactionDao transactionDao, SummaryStatisticDao summaryStatisticDao) {
        this.userDao = userDao;
        this.transactionDao = transactionDao; // Injected for use in CacheManager loader
        this.summaryStatisticDao = summaryStatisticDao;
        this.summaryFilePath = ConfigConstants.SUMMARY_CSV_PATH; // Get summary file path from config
        System.out.println("SummaryStatisticService initialized. Summary file: " + summaryFilePath);
    }

    /**
     * Helper method to load all transactions from all user files.
     * Uses CacheManager to benefit from caching.
     * @param users List of all users.
     * @return A single list containing all transactions from all users.
     * @throws Exception If loading from any user file fails.
     */
    private List<Transaction> loadAllTransactionsFromAllUsers(List<User> users) throws Exception {
        List<Transaction> allTransactions = new ArrayList<>();
        for (User user : users) {
            String userFilePath = user.getTransactionFilePath();
            if (userFilePath != null && !userFilePath.trim().isEmpty()) {
                try {
                    // Use CacheManager to get transactions for this user's file
                    // Pass the transactionDao instance for the loader
                    List<Transaction> userTransactions = CacheManager.getTransactions(userFilePath, transactionDao);
                    allTransactions.addAll(userTransactions);
                    System.out.println("Loaded " + userTransactions.size() + " transactions for user: " + user.getUsername() + " from " + userFilePath);
                } catch (Exception e) {
                    System.err.println("Error loading transactions for user " + user.getUsername() + " from " + userFilePath + ". Skipping this user.");
                    e.printStackTrace();
                    // Decide whether to stop or continue if one user's file fails.
                    // Continuing is more robust for aggregate statistics.
                    // throw e; // Uncomment to stop processing if any user file fails
                }
            } else {
                System.out.println("User " + user.getUsername() + " has no transaction file path configured. Skipping.");
            }
        }
        return allTransactions;
    }


    /**
     * Helper method to group transactions by week identifier (YYYY-Www).
     * @param transactions The list of transactions.
     * @return A map where keys are week identifiers and values are lists of transactions in that week.
     */
    private Map<String, List<Transaction>> groupTransactionsByWeek(List<Transaction> transactions) {
        WeekFields weekFields = WeekFields.ISO; // ISO 8601 week numbering (Monday is the first day of the week)
        DateTimeFormatter weekFormatter = DateTimeFormatter.ofPattern("yyyy-'W'ww"); // Format as "YYYY-Www"

        return transactions.stream()
                .filter(t -> t.getTransactionTime() != null && !t.getTransactionTime().trim().isEmpty()) // Filter out transactions with no time
                .collect(Collectors.groupingBy(t -> {
                    try {
                        // Safely parse the transaction date (only date part is needed for week)
                        // Need to ensure the parser is consistent with the one in TransactionServiceImpl/AITransactionService
                        // Let's re-use the safe parsing logic or ensure consistency.
                        // Simplest: Use a helper method for date parsing just for this service, matching expected formats.
                        LocalDate date = parseDateFromTransactionTime(t.getTransactionTime());
                        if (date != null) {
                            return date.format(weekFormatter); // Format date to week identifier
                        }
                    } catch (Exception e) {
                        System.err.println("Failed to parse date for week grouping: " + t.getTransactionTime() + ". Skipping transaction.");
                        // Transaction with unparseable date will be grouped under 'null' or skipped by filter
                    }
                    return "未知周"; // Group unparseable dates under an 'unknown' key
                }));
    }

    // Helper method to parse date from transaction time string (should match other parsers)
    private LocalDate parseDateFromTransactionTime(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // Clean whitespace and potential hyphens if the expected format is slash-separated
        // Assume the format used in CSV/Transaction model is one of the parsers in other services
        // Let's use a robust set of date patterns matching parseDateTimeSafe in TransactionServiceImpl
        String datePart = timeStr.split(" ")[0]; // Get the date part

        datePart = datePart.trim().replace('-', '/').replaceAll("\\s+", "");


        // Try parsing with multiple slash formats
        List<String> patterns = List.of(
                "yyyy/M/d", "yyyy/MM/d", "yyyy/M/dd", "yyyy/MM/dd",
                "yyyy-MM-dd" // Add dash format just in case
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDate.parse(datePart, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern
            }
        }
        System.err.println("SummaryStatisticService: Failed to parse date part '" + datePart + "' from transaction time: " + timeStr);
        return null; // Return null if no pattern matches
    }


    /**
     * Retrieves all summary statistics from the data source.
     * @return List of summary statistics.
     * @throws IOException If loading fails.
     */
    public List<SummaryStatistic> getAllSummaryStatistics() throws IOException {
        // Simply delegate to the DAO
        return summaryStatisticDao.loadAllStatistics(summaryFilePath);
    }


    // --- Revised Plan for generateAndSaveWeeklyStatistics ---
    // The previous approach of loading all transactions and then grouping by week
    // doesn't easily allow counting unique users per week unless we augment the Transaction object
    // or wrap it with User info during loading.
    // A better approach for unique user count is to process user by user.

    public void generateAndSaveWeeklyStatistics() throws Exception {
        System.out.println("Generating weekly summary statistics (Revised approach)...");
        List<User> allUsers = userDao.getAllUsers();
        System.out.println("Loaded " + allUsers.size() + " users.");

        // Map to hold weekly stats per user (WeekId -> Map<UserId, UserWeeklyStats>)
        // This intermediate structure is complex.

        // Map to hold aggregated stats for each week (WeekId -> AggregatedWeeklyStats)
        Map<String, Double> totalIncomeByWeek = new HashMap<>();
        Map<String, Double> totalExpenseByWeek = new HashMap<>();
        Map<String, Map<String, Double>> expenseByCategoryByWeek = new HashMap<>(); // WeekId -> (Category -> Amount)
        Map<String, Set<String>> usersByWeek = new HashMap<>(); // WeekId -> Set<Username>

        WeekFields weekFields = WeekFields.ISO;
        DateTimeFormatter weekFormatter = DateTimeFormatter.ofPattern("yyyy-'W'ww");


        // Iterate through each user
        for (User user : allUsers) {
            String userFilePath = user.getTransactionFilePath();
            String username = user.getUsername();

            if (userFilePath != null && !userFilePath.trim().isEmpty()) {
                try {
                    // Load transactions for this user
                    List<Transaction> userTransactions = CacheManager.getTransactions(userFilePath, transactionDao);
                    System.out.println("Processing " + userTransactions.size() + " transactions for user: " + username);

                    // Iterate through transactions for this user
                    for (Transaction t : userTransactions) {
                        if (t.getTransactionTime() == null || t.getTransactionTime().trim().isEmpty()) {
                            System.err.println("Skipping transaction with no time for user " + username + ": " + t.getOrderNumber());
                            continue; // Skip transactions with no time
                        }

                        LocalDate date = parseDateFromTransactionTime(t.getTransactionTime());
                        if (date == null) {
                            System.err.println("Skipping transaction with unparseable date for user " + username + ": " + t.getTransactionTime());
                            continue; // Skip transactions with invalid date
                        }

                        String weekIdentifier = date.format(weekFormatter);

                        // Add user to the set for this week
                        usersByWeek.computeIfAbsent(weekIdentifier, k -> new HashSet<>()).add(username);

                        // Aggregate income/expense
                        if (t.getInOut() != null) {
                            String inOut = t.getInOut().trim();
                            if (inOut.equals("收入") || inOut.equals("收")) {
                                totalIncomeByWeek.put(weekIdentifier, totalIncomeByWeek.getOrDefault(weekIdentifier, 0.0) + t.getPaymentAmount());
                            } else if (inOut.equals("支出") || inOut.equals("支")) {
                                totalExpenseByWeek.put(weekIdentifier, totalExpenseByWeek.getOrDefault(weekIdentifier, 0.0) + t.getPaymentAmount());

                                // Aggregate expense by standard category
                                String rawType = t.getTransactionType();
                                String standardCategory = StandardCategories.getStandardCategory(rawType);
                                // Only aggregate standard expense categories for the top category calculation
                                if (StandardCategories.isStandardExpenseCategory(standardCategory) || !StandardCategories.ALL_KNOWN_TYPES.contains(standardCategory)) {
                                    String effectiveExpenseCategoryForTop = StandardCategories.isStandardExpenseCategory(standardCategory) ? standardCategory : "其他支出";
                                    expenseByCategoryByWeek.computeIfAbsent(weekIdentifier, k -> new HashMap<>())
                                            .put(effectiveExpenseCategoryForTop, expenseByCategoryByWeek.get(weekIdentifier).getOrDefault(effectiveExpenseCategoryForTop, 0.0) + t.getPaymentAmount());
                                }
                            }
                        }
                    }
                } catch (Exception e) {
                    System.err.println("Error loading transactions for user " + user.getUsername() + " from " + userFilePath + ". Skipping this user's data for statistics.");
                    e.printStackTrace();
                    // Continue processing other users
                }
            } else {
                System.out.println("User " + user.getUsername() + " has no transaction file path configured. Skipping for statistics.");
            }
        }
        System.out.println("Completed aggregation across all users by week.");


        // 5. Consolidate aggregated data into SummaryStatistic objects
        List<SummaryStatistic> calculatedStatistics = new ArrayList<>();
        DateTimeFormatter timestampFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String timestamp = LocalDateTime.now().format(timestampFormatter);

        // Iterate through all week identifiers found
        Set<String> allWeeks = new HashSet<>();
        allWeeks.addAll(totalIncomeByWeek.keySet());
        allWeeks.addAll(totalExpenseByWeek.keySet());
        allWeeks.addAll(usersByWeek.keySet());
        allWeeks.addAll(expenseByCategoryByWeek.keySet());

        List<String> sortedWeekIdentifiers = allWeeks.stream().sorted().collect(Collectors.toList());

        for (String weekIdentifier : sortedWeekIdentifiers) {
            double totalIncome = totalIncomeByWeek.getOrDefault(weekIdentifier, 0.0);
            double totalExpense = totalExpenseByWeek.getOrDefault(weekIdentifier, 0.0);
            int numberOfUsers = usersByWeek.getOrDefault(weekIdentifier, Collections.emptySet()).size();

            // Find top expense category for this week
            Map<String, Double> weeklyExpenseByCategory = expenseByCategoryByWeek.getOrDefault(weekIdentifier, Collections.emptyMap());
            String topExpenseCategory = "无支出";
            double topExpenseCategoryAmount = 0.0;

            Optional<Map.Entry<String, Double>> maxEntry = weeklyExpenseByCategory.entrySet().stream()
                    .max(Map.Entry.comparingByValue());

            if (maxEntry.isPresent()) {
                topExpenseCategory = maxEntry.get().getKey();
                topExpenseCategoryAmount = maxEntry.get().getValue();
            }

            calculatedStatistics.add(new SummaryStatistic(
                    weekIdentifier,
                    totalIncome,
                    totalExpense,
                    topExpenseCategory,
                    topExpenseCategoryAmount,
                    numberOfUsers,
                    timestamp // Timestamp is when the stats were generated, not per week
            ));
        }
        System.out.println("Created " + calculatedStatistics.size() + " SummaryStatistic objects.");


        // 6. Load existing statistics
        List<SummaryStatistic> existingStatistics = getAllSummaryStatistics();
        System.out.println("Loaded " + existingStatistics.size() + " existing summary statistics.");

        // 7. Merge existing and newly calculated statistics (overwrite new weeks, keep old)
        Map<String, SummaryStatistic> finalStatisticsMap = new HashMap<>();
        for(SummaryStatistic stat : existingStatistics) {
            finalStatisticsMap.put(stat.getWeekIdentifier(), stat);
        }
        for(SummaryStatistic stat : calculatedStatistics) {
            finalStatisticsMap.put(stat.getWeekIdentifier(), stat); // New calculation replaces old for the week
        }

        // 8. Sort merged statistics by week identifier (chronologically)
        List<SummaryStatistic> finalStatistics = finalStatisticsMap.values().stream()
                .sorted(Comparator.comparing(SummaryStatistic::getWeekIdentifier))
                .collect(Collectors.toList());

        // 9. Save the final list
        summaryStatisticDao.writeAllStatistics(summaryFilePath, finalStatistics);
        System.out.println("Weekly summary statistics generated and saved successfully to " + summaryFilePath);
    }


}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Service\Impl\TransactionServiceImpl.java`:

```java
package Service.Impl;

import Constants.StandardCategories;
import DAO.TransactionDao; // Import the interface
import DAO.Impl.CsvTransactionDao; // Import the implementation
import Service.TransactionService;
import Utils.CacheManager; // Import the new CacheManager
import model.MonthlySummary;
import model.Transaction;

import javax.swing.*;
import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.YearMonth;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException; // Added for clarity in catch blocks if specific parsing errors are handled
import java.util.*;
import java.util.stream.Collectors; // Needed for search

public class TransactionServiceImpl implements TransactionService {

    private final String currentUserTransactionFilePath; // Store the user's file path
    // TransactionDao instance needed to load data if cache misses
    private final TransactionDao transactionDao;

    /**
     * Constructor now accepts the user's transaction file path.
     *
     * @param currentUserTransactionFilePath The file path for the current user's transactions.
     */
    public TransactionServiceImpl(String currentUserTransactionFilePath) {
        this.currentUserTransactionFilePath = currentUserTransactionFilePath;
        // Create a DAO instance for this service instance.
        this.transactionDao = new CsvTransactionDao(); // One DAO instance per service instance
        System.out.println("TransactionServiceImpl initialized for file: " + currentUserTransactionFilePath);
        // Cache is managed by CacheManager, not directly by this instance.
    }

    @Override // Implement the new interface method
    public List<Transaction> getAllTransactions() throws Exception {
        // Simply call the internal method that uses the cache
        return getAllTransactionsForCurrentUser();
    }

    /**
     * Imports transactions from a given CSV file path into the current user's transactions.
     * Reads the import file, merges with existing data, and saves back.
     *
     * @param userFilePath The file path for the current user's transactions (target).
     * @param importFilePath The file path of the CSV to import from (source).
     * @return The number of transactions successfully imported.
     * @throws Exception If an error occurs during reading, parsing, or saving.
     */
    @Override // Implement the new interface method
    public int importTransactionsFromCsv(String userFilePath, String importFilePath) throws Exception {
        System.out.println("Starting import from " + importFilePath + " to user file " + userFilePath);
        List<Transaction> existingTransactions;
        List<Transaction> transactionsToImport;

        try {
            // 1. Load existing transactions for the current user (from cache/file)
            // Use the method that uses the CacheManager
            existingTransactions = getAllTransactions(); // Already uses CacheManager

            // 2. Read and parse transactions from the import file
            // Use the DAO's loadFromCSV method with the import file path
            // Need a *separate* DAO instance or method call that targets the import file
            TransactionDao importDao = new CsvTransactionDao(); // Create a temporary DAO for reading the import file
            transactionsToImport = importDao.loadFromCSV(importFilePath); // Load from the selected file
            System.out.println("Read " + transactionsToImport.size() + " transactions from import file.");

        } catch (IOException e) {
            System.err.println("Error loading files during import process.");
            e.printStackTrace();
            throw new Exception("Failed to read transaction data!", e); // Wrap and re-throw
        }

        // 3. Merge imported transactions with existing ones
        // Simple merge: add all imported transactions.
        // Handle potential duplicates: check if order number exists.
        // If order numbers are not guaranteed unique in imported file or against existing,
        // consider generating new unique IDs for imported items if their ON is empty or conflicts.
        List<Transaction> mergedTransactions = new ArrayList<>(existingTransactions);
        int importedCount = 0;

        for (Transaction importedTx : transactionsToImport) {
            // Basic Check: Ensure imported transaction has an order number or generate one
            if (importedTx.getOrderNumber() == null || importedTx.getOrderNumber().trim().isEmpty()) {
                // Generate a unique ID for transactions without one
                String uniqueId = "IMPORT_" + UUID.randomUUID().toString();
                importedTx.setOrderNumber(uniqueId);
                System.out.println("Generated unique order number for imported transaction: " + uniqueId);
            } else {
                // Check for potential duplicate order number against existing transactions
                boolean duplicate = existingTransactions.stream()
                        .anyMatch(t -> t.getOrderNumber().trim().equals(importedTx.getOrderNumber().trim()));
                if (duplicate) {
                    System.err.println("Skipping imported transaction due to duplicate order number: " + importedTx.getOrderNumber());
                    // Decide: skip, overwrite, or generate new ID. Skipping for now.
                    JOptionPane.showMessageDialog(null, "Duplicate transaction order number found: " + importedTx.getOrderNumber() + ", skipped.", "Import Warning", JOptionPane.WARNING_MESSAGE);
                    continue; // Skip this duplicate transaction
                }
            }

            // Add the transaction to the merged list
            mergedTransactions.add(importedTx);
            importedCount++;
        }
        System.out.println("Merged transactions. Total after merge: " + mergedTransactions.size() + ". Successfully imported count: " + importedCount);


        // 4. Save the merged list back to the current user's file
        try {
            // Use the DAO instance associated with this service
            transactionDao.writeTransactionsToCSV(userFilePath, mergedTransactions);
            System.out.println("Saved merged transactions to user file: " + userFilePath);

            // 5. Invalidate or update the cache for the current user's file
            // Invalidation is simpler: forces CacheManager to reload from the updated file next time.
            CacheManager.invalidateTransactionCache(userFilePath);
            System.out.println("Cache invalidated for user file: " + userFilePath);


        } catch (IOException e) {
            System.err.println("Error saving merged transactions after import.");
            e.printStackTrace();
            // Consider leaving the original file untouched on save failure
            throw new Exception("Failed to save imported transaction data!", e); // Wrap and re-throw
        }

        System.out.println("Import process finished.");
        return importedCount; // Return the count of transactions actually added
    }

    /**
     * Gets all transactions for the current user from the cache (loading if necessary).
     * @return List of transactions.
     * @throws Exception If an error occurs during loading.
     */
    private List<Transaction> getAllTransactionsForCurrentUser() throws Exception {
        // Get transactions using the CacheManager for the current user's file
        return CacheManager.getTransactions(currentUserTransactionFilePath, transactionDao);
    }

    /**
     * Add transaction for the current user.
     *
     * @param transaction The new transaction to add.
     */
    @Override
    public void addTransaction(Transaction transaction) throws IOException {
        // Set transaction time to current time if not already set
        if (transaction.getTransactionTime() == null || transaction.getTransactionTime().isEmpty()) {
            LocalDateTime now = LocalDateTime.now();
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
            String currentTime = now.format(formatter);
            transaction.setTransactionTime(currentTime);
        }

        try {
            // Call DAO layer to add transaction to the user's specific file
            transactionDao.addTransaction(currentUserTransactionFilePath, transaction);

            // After adding, invalidate the cache for this user's file
            CacheManager.invalidateTransactionCache(currentUserTransactionFilePath);
            System.out.println("Transaction added and cache invalidated for " + currentUserTransactionFilePath);

        } catch (IOException e) {
            System.err.println("Error adding transaction for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e; // Re-throw
        }
    }

    /**
     * Change transaction information for the current user.
     *
     * @param updatedTransaction The transaction object with updated information.
     */
    @Override
    public void changeTransaction(Transaction updatedTransaction) throws Exception {
        try {
            // Load existing transactions (from cache/file)
            List<Transaction> allTransactions = getAllTransactionsForCurrentUser();

            // Find and update the target transaction in the list
            boolean foundAndUpdatedInMemory = false;
            List<Transaction> updatedList = new ArrayList<>(allTransactions.size());
            for (Transaction t : allTransactions) {
                if (t.getOrderNumber().trim().equals(updatedTransaction.getOrderNumber().trim())) {
                    // Found the transaction, apply updates
                    updateTransactionFields(t, updatedTransaction); // Helper method to apply updates
                    updatedList.add(t); // Add the modified transaction
                    foundAndUpdatedInMemory = true;
                    System.out.println("Transaction with order number " + updatedTransaction.getOrderNumber() + " found and updated in memory.");
                } else {
                    updatedList.add(t); // Add unchanged transactions
                }
            }

            if (!foundAndUpdatedInMemory) {
                throw new IllegalArgumentException("Transaction order number not found: " + updatedTransaction.getOrderNumber() + " in file " + currentUserTransactionFilePath);
            }

            // Write the entire updated list back to the CSV file
            transactionDao.writeTransactionsToCSV(currentUserTransactionFilePath, updatedList);
            System.out.println("Updated transaction with order number " + updatedTransaction.getOrderNumber() + " and wrote back to file.");

            // Update the cache with the modified list
            CacheManager.putTransactions(currentUserTransactionFilePath, updatedList, transactionDao);
            System.out.println("Cache updated with the modified transaction list for " + currentUserTransactionFilePath);

        } catch (IOException e) {
            System.err.println("Error changing transaction for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e;
        } catch (Exception e) { // Catch exception from getAllTransactionsForCurrentUser
            System.err.println("Error loading transactions for change operation: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e;
        }
    }

    /**
     * Helper method: Updates non-empty fields from source to target.
     */
    private void updateTransactionFields(Transaction target, Transaction source) {
        // OrderNumber is the key and should generally not be updated this way.
        if (source.getTransactionTime() != null && !source.getTransactionTime().trim().isEmpty()) {
            target.setTransactionTime(source.getTransactionTime().trim());
        }
        if (source.getTransactionType() != null && !source.getTransactionType().trim().isEmpty()) {
            target.setTransactionType(source.getTransactionType().trim());
        }
        if (source.getCounterparty() != null && !source.getCounterparty().trim().isEmpty()) {
            target.setCounterparty(source.getCounterparty().trim());
        }
        if (source.getCommodity() != null && !source.getCommodity().trim().isEmpty()) {
            target.setCommodity(source.getCommodity().trim());
        }
        if (source.getInOut() != null && !source.getInOut().trim().isEmpty()) {
            String inOut = source.getInOut().trim();
            // Assuming inOut values from UI are already validated or are "Income"/"Expense" or "In"/"Out"
            if (inOut.equalsIgnoreCase("Income") || inOut.equalsIgnoreCase("In") ||
                    inOut.equalsIgnoreCase("Expense") || inOut.equalsIgnoreCase("Out")) {
                target.setInOut(inOut);
            } else {
                System.err.println("Warning: Invalid value for In/Out: " + source.getInOut() + ". Keeping original.");
            }
        }
        // For paymentAmount, assume the value from the source (e.g., UI dialog) is the intended new value.
        target.setPaymentAmount(source.getPaymentAmount());

        if (source.getPaymentMethod() != null && !source.getPaymentMethod().trim().isEmpty()) {
            target.setPaymentMethod(source.getPaymentMethod().trim());
        }
        if (source.getCurrentStatus() != null && !source.getCurrentStatus().trim().isEmpty()) {
            target.setCurrentStatus(source.getCurrentStatus().trim());
        }
        if (source.getMerchantNumber() != null && !source.getMerchantNumber().trim().isEmpty()) {
            target.setMerchantNumber(source.getMerchantNumber().trim());
        }
        if (source.getRemarks() != null && !source.getRemarks().trim().isEmpty()) { // Remarks can be empty, so allow empty string.
            target.setRemarks(source.getRemarks().trim());
        }
        System.out.println("Applied updates to transaction: " + target.getOrderNumber());
    }


    /**
     * Delete transaction for the current user by order number.
     *
     * @param orderNumber The unique order number of the transaction to delete.
     * @return true if deletion was successful.
     * @throws Exception If an error occurs or transaction is not found.
     */
    @Override
    public boolean deleteTransaction(String orderNumber) throws Exception {
        try {
            // Call DAO layer to delete transaction from the user's specific file
            boolean deleted = transactionDao.deleteTransaction(currentUserTransactionFilePath, orderNumber);

            if (deleted) {
                // After deleting, invalidate the cache for this user's file
                CacheManager.invalidateTransactionCache(currentUserTransactionFilePath);
                System.out.println("Transaction with order number " + orderNumber + " deleted and cache invalidated for " + currentUserTransactionFilePath);
            } else {
                System.out.println("Transaction with order number " + orderNumber + " not found for deletion in " + currentUserTransactionFilePath);
            }
            return deleted;

        } catch (IOException e) {
            System.err.println("Error deleting transaction for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e;
        }
    }

    /**
     * Search transactions for the current user based on criteria.
     *
     * @param searchCriteria The Transaction object containing search criteria.
     * @return List of matched transactions.
     */
    @Override
    public List<Transaction> searchTransaction(Transaction searchCriteria) {
        try {
            List<Transaction> allTransactions = getAllTransactionsForCurrentUser();
            System.out.println("Searching through " + allTransactions.size() + " transactions for user " + currentUserTransactionFilePath);

            List<Transaction> matched = allTransactions.stream()
                    .filter(t -> matchesCriteria(t, searchCriteria))
                    .collect(Collectors.toList());
            System.out.println("Found " + matched.size() + " matching transactions.");

            matched.sort((t1, t2) -> {
                LocalDateTime time1 = parseDateTimeSafe(t1.getTransactionTime());
                LocalDateTime time2 = parseDateTimeSafe(t2.getTransactionTime());
                if (time1 != null && time2 != null) {
                    return time2.compareTo(time1); // Newest first
                } else if (time1 == null && time2 == null) return 0;
                else if (time1 == null) return 1;
                else return -1;
            });
            System.out.println("Matched transactions sorted.");
            return matched;
        } catch (Exception e) {
            System.err.println("Error during search operation for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            return List.of();
        }
    }

    /**
     * Helper method: Checks if a single transaction matches the search criteria.
     */
    private boolean matchesCriteria(Transaction transaction, Transaction criteria) {
        return containsIgnoreCase(transaction.getTransactionTime(), criteria.getTransactionTime())
                && containsIgnoreCase(transaction.getTransactionType(), criteria.getTransactionType())
                && containsIgnoreCase(transaction.getCounterparty(), criteria.getCounterparty())
                && containsIgnoreCase(transaction.getCommodity(), criteria.getCommodity())
                && matchesInOutCriteria(transaction.getInOut(), criteria.getInOut())
                && containsIgnoreCase(transaction.getPaymentMethod(), criteria.getPaymentMethod());
    }

    /**
     * Helper method: Fuzzy match string, ignoring case and trimming whitespace.
     * An empty/null target criteria matches everything.
     */
    private boolean containsIgnoreCase(String source, String target) {
        if (target == null || target.trim().isEmpty()) {
            return true;
        }
        if (source == null) {
            return false;
        }
        return source.trim().toLowerCase().contains(target.trim().toLowerCase());
    }

    /**
     * Helper method: Matches In/Out criteria. Handles "Income" vs "In", "Expense" vs "Out".
     * An empty/null target criteria matches everything.
     */
    private boolean matchesInOutCriteria(String source, String target) {
        if (target == null || target.trim().isEmpty()) {
            return true;
        }
        if (source == null) {
            return false;
        }
        String sourceTrimmed = source.trim();
        String targetTrimmed = target.trim();

        if (targetTrimmed.equalsIgnoreCase("Income") || targetTrimmed.equalsIgnoreCase("In")) {
            return sourceTrimmed.equalsIgnoreCase("Income") || sourceTrimmed.equalsIgnoreCase("In");
        }
        if (targetTrimmed.equalsIgnoreCase("Expense") || targetTrimmed.equalsIgnoreCase("Out")) {
            return sourceTrimmed.equalsIgnoreCase("Expense") || sourceTrimmed.equalsIgnoreCase("Out");
        }
        return sourceTrimmed.toLowerCase().contains(targetTrimmed.toLowerCase());
    }

    /**
     * Helper method: Safely parses a time string into LocalDateTime.
     * Returns null if parsing fails.
     */
    private LocalDateTime parseDateTimeSafe(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;
        timeStr = timeStr.trim().replaceAll("\\s+", " ");

        if (timeStr.matches("\\d{4}/\\d{1,2}/\\d{1,2}")) {
            timeStr += " 00:00";
        } else if (timeStr.matches("\\d{4}-\\d{1,2}-\\d{1,2}")) {
            timeStr += " 00:00:00";
        }

        List<String> patterns = List.of(
                "yyyy/M/d H:mm", "yyyy/M/d HH:mm",
                "yyyy/MM/d H:mm", "yyyy/MM/d HH:mm",
                "yyyy/M/dd H:mm", "yyyy/M/dd HH:mm",
                "yyyy/MM/dd H:mm", "yyyy/MM/dd HH:mm",
                "yyyy/MM/dd HH:mm:ss",
                "yyyy-MM-dd HH:mm:ss"
        );
        for (String pattern : patterns) {
            try {
                return LocalDateTime.parse(timeStr, DateTimeFormatter.ofPattern(pattern));
            } catch (DateTimeParseException ignored) {}
        }
        System.err.println("Failed to parse date string: " + timeStr);
        return null;
    }

    /**
     * Aggregates transactions for the current user by month and standard category.
     *
     * @return A map where keys are month identifiers (e.g., "YYYY-MM") and values are MonthlySummary objects.
     * @throws Exception If an error occurs during data retrieval.
     */
    @Override
    public Map<String, MonthlySummary> getMonthlyTransactionSummary() throws Exception {
        System.out.println("Generating monthly transaction summary for user file: " + currentUserTransactionFilePath);
        List<Transaction> allTransactions;
        try {
            allTransactions = getAllTransactions();
            System.out.println("Retrieved " + allTransactions.size() + " transactions for summary.");
        } catch (Exception e) {
            System.err.println("Error retrieving transactions for summary generation.");
            e.printStackTrace();
            throw new Exception("Failed to get transaction data!", e);
        }

        Map<String, MonthlySummary> monthlySummaries = new HashMap<>();
        DateTimeFormatter monthFormatter = DateTimeFormatter.ofPattern("yyyy-MM");

        for (Transaction t : allTransactions) {
            if (t.getTransactionTime() == null || t.getTransactionTime().trim().isEmpty()) {
                System.err.println("Skipping transaction with no time for summary aggregation: " + t.getOrderNumber());
                continue;
            }
            LocalDate date = parseDateFromTransactionTimeSafe(t.getTransactionTime());
            if (date == null) {
                System.err.println("Skipping transaction with unparseable date for summary aggregation: " + t.getTransactionTime() + " - " + t.getOrderNumber());
                continue;
            }
            String monthIdentifier = YearMonth.from(date).format(monthFormatter);
            monthlySummaries.putIfAbsent(monthIdentifier, new MonthlySummary(monthIdentifier));
            MonthlySummary currentMonthSummary = monthlySummaries.get(monthIdentifier);

            if (t.getInOut() != null) {
                String inOut = t.getInOut().trim();
                if (inOut.equalsIgnoreCase("Income") || inOut.equalsIgnoreCase("In")) { // Use English here
                    currentMonthSummary.addIncome(t.getPaymentAmount());
                } else if (inOut.equalsIgnoreCase("Expense") || inOut.equalsIgnoreCase("Out")) { // Use English here
                    String rawType = t.getTransactionType();
                    String standardCategory = StandardCategories.getStandardCategory(rawType);
                    String effectiveExpenseCategoryForSummary = StandardCategories.isStandardExpenseCategory(standardCategory) ? standardCategory : StandardCategories.EXPENSE_CATEGORIES.get(StandardCategories.EXPENSE_CATEGORIES.size() - 1); // Default to "Other Expenses"
                    currentMonthSummary.addExpense(t.getPaymentAmount(), effectiveExpenseCategoryForSummary);
                }
            }
        }
        System.out.println("Generated summary for " + monthlySummaries.size() + " months.");
        return monthlySummaries;
    }

    /**
     * Helper method to parse date from transaction time string safely.
     */
    private LocalDate parseDateFromTransactionTimeSafe(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;
        String datePart = timeStr.split(" ")[0];
        datePart = datePart.trim().replace('-', '/');

        List<String> patterns = List.of(
                "yyyy/M/d", "yyyy/MM/d", "yyyy/M/dd", "yyyy/MM/dd"
        );
        for (String pattern : patterns) {
            try {
                return LocalDate.parse(datePart, DateTimeFormatter.ofPattern(pattern));
            } catch (DateTimeParseException ignored) {}
        }
        System.err.println("TransactionServiceImpl: Failed to parse date part '" + datePart + "' from transaction time: " + timeStr);
        return null;
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Service\TransactionService.java`:

```java
package Service;

import model.MonthlySummary;
import model.Transaction;

import java.io.IOException;
import java.util.List;
import java.util.Map;

public interface TransactionService {

    /**
     * Gets all transactions for the current user.
     * @return List of all transactions.
     * @throws Exception If data retrieval fails (e.g., IO error, cache issue).
     */
    List<Transaction> getAllTransactions() throws Exception; // Added this method


    /**
     * 新增交易
     * @param transaction
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * 修改交易
     * @param transaction
     * @throws Exception If modification fails.
     */
    void changeTransaction(Transaction transaction) throws Exception;

    /**
     * 根据订单号删除交易
     * @param orderNumber
     * @return true if deletion was successful, false if transaction not found.
     * @throws Exception If deletion fails (e.g., IO error).
     */
    boolean deleteTransaction(String orderNumber) throws Exception; // Changed return type to boolean

    /**
     * 根据用户输入信息查询交易
     * @param transaction Search criteria.
     * @return List of matched transactions.
     */
    List<Transaction> searchTransaction(Transaction transaction);

    /**
     * Imports transactions from a given CSV file path into the current user's transactions.
     *
     * @param userFilePath The file path for the current user's transactions (target).
     * @param importFilePath The file path of the CSV to import from (source).
     * @return The number of transactions successfully imported.
     * @throws Exception If an error occurs during reading, parsing, or saving.
     */
    int importTransactionsFromCsv(String userFilePath, String importFilePath) throws Exception; // Added this method


    /**
     * Aggregates transactions for the current user by month and standard category.
     *
     * @return A map where keys are month identifiers (e.g., "YYYY-MM") and values are MonthlySummary objects.
     * @throws Exception If an error occurs during data retrieval.
     */
    Map<String, MonthlySummary> getMonthlyTransactionSummary() throws Exception; // Added this method
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Service\User\UserService.java`:

```java
package Service.User; // Changed package

import DAO.UserDao;
import model.User;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class UserService {
    private final UserDao userDao;
    private final Map<String, User> userCache = new HashMap<>(); // Cache users in memory

    public UserService(UserDao userDao) {
        this.userDao = userDao;
        loadUsers(); // Load users when the service is initialized
    }

    private void loadUsers() {
        try {
            List<User> users = userDao.getAllUsers();
            userCache.clear(); // Clear previous cache
            for (User user : users) {
                userCache.put(user.getUsername(), user);
            }
            System.out.println("Loaded " + userCache.size() + " users into cache.");
        } catch (IOException e) {
            System.err.println("Failed to load users from data source.");
            e.printStackTrace();
            // Depending on requirements, you might want to exit or handle this more gracefully
            // For now, we'll allow the app to run with an empty user list, though login will fail.
        }
    }

    /**
     * Authenticates a user.
     *
     * @param username The username.
     * @param password The password.
     * @return The authenticated User object if successful, null otherwise.
     */
    public User authenticate(String username, String password) {
        if (username == null || username.trim().isEmpty() || password == null || password.trim().isEmpty()) {
            return null;
        }

        User user = userCache.get(username.trim());
        if (user != null && user.getPassword().equals(password.trim())) { // Simple password check
            System.out.println("Authentication successful for user: " + username);
            return user; // Authentication successful, return the User object
        }
        System.out.println("Authentication failed for username: " + username);
        return null; // Authentication failed
    }

    /**
     * Retrieves a user by username from the cache.
     * @param username The username.
     * @return The User object or null if not found.
     */
    public User getUserByUsername(String username) {
        if (username == null || username.trim().isEmpty()) {
            return null;
        }
        return userCache.get(username.trim());
    }


    // Add other user management methods if needed (e.g., registerUser, deleteUser)
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Service\deepseek\ChatCompletionsExample.java`:

```java
package Service.deepseek;

import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;
import okhttp3.ConnectionPool;
import okhttp3.Dispatcher;
import org.apache.commons.lang.StringUtils;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
public class ChatCompletionsExample {
    static String apiKey = System.getenv("ARK_API_KEY");
    static ConnectionPool connectionPool = new ConnectionPool(5, 1, TimeUnit.SECONDS);
    static Dispatcher dispatcher = new Dispatcher();
    // The output time of the reasoning model is relatively long. Please increase the timeout period.//
    static ArkService service = ArkService.builder().timeout(Duration.ofSeconds(1800)).connectTimeout(Duration.ofSeconds(20)).dispatcher(dispatcher).connectionPool(connectionPool).baseUrl("https://ark.cn-beijing.volces.com/api/v3").apiKey(apiKey).build();

//    public static void main(String[] args) {
//        System.out.println(" [Recommended]----- streaming request -----");
//        final List<ChatMessage> streamMessages = new ArrayList<>();
//        final ChatMessage streamUserMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("请回答15.11和15.9哪个大？").build();
//        streamMessages.add(streamUserMessage);
//        ChatCompletionRequest streamChatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(streamMessages)
//                .build();
//        service.streamChatCompletion(streamChatCompletionRequest)
//                .doOnError(Throwable::printStackTrace)
//                .blockingForEach(
//                        delta -> {
//                            if (!delta.getChoices().isEmpty()) {
//                                if (StringUtils.isNotEmpty(delta.getChoices().get(0).getMessage().getReasoningContent())) {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getReasoningContent());
//                                } else {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getContent());
//                                }
//                            }
//                        }
//                );
//        System.out.println(" ----- standard request -----");
//        final List<ChatMessage> messages = new ArrayList<>();
//        final ChatMessage userMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("常见的十字花科植物有哪些？").build();
//        messages.add(userMessage);
//        ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(messages)
//                .build();
//        service.createChatCompletion(chatCompletionRequest).getChoices().forEach(
//                choice -> {
//                    System.out.println(choice.getMessage().getReasoningContent());
//                    System.out.println(choice.getMessage().getContent());
//                }
//        );
//        // shutdown service after all requests is finished
//        service.shutdownExecutor();
//    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Utils\CacheManager.java`:

```java
package Utils;

import Constants.CaffeineKeys;
import DAO.Impl.CsvTransactionDao; // Assuming CsvTransactionDao is in DAO.Impl
import DAO.TransactionDao; // Assuming TransactionDao interface is in DAO
import model.Transaction;
import com.github.benmanes.caffeine.cache.Cache; // Use general Cache interface
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.LoadingCache;

import java.io.IOException;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

/**
 * Manages Caffeine caches for different transaction data files (per user).
 * Uses the file path as the cache key.
 */
public class CacheManager {

    // Use a map to hold caches, keyed by file path
    // The value is the Caffeine LoadingCache for that specific file path
    private static final ConcurrentHashMap<String, LoadingCache<String, List<Transaction>>> fileCaches = new ConcurrentHashMap<>();

    // Define default cache parameters
    private static final int DEFAULT_MAX_SIZE = 1; // Only cache one instance (the list of transactions) per file
    private static final long DEFAULT_EXPIRE_AFTER_WRITE_MINUTES = 10; // Cache entry expires after 10 minutes
    private static final long DEFAULT_REFRESH_AFTER_WRITE_MINUTES = 1; // Refresh entry after 1 minute

    // Private constructor to prevent instantiation
    private CacheManager() {}

    /**
     * Gets or creates a LoadingCache for the specified transaction file path.
     * The cache loads List<Transaction> from the file using TransactionDao.
     *
     * @param filePath The path to the user's transaction CSV file.
     * @param transactionDao The TransactionDao instance to use for loading.
     * @return The LoadingCache instance for the given file path.
     */
    public static LoadingCache<String, List<Transaction>> getTransactionCache(String filePath, TransactionDao transactionDao) {
        // Use computeIfAbsent to get or create the cache atomically
        return fileCaches.computeIfAbsent(filePath, key -> {
            System.out.println("CacheManager: Creating new cache for file: " + filePath);
            // Create a new LoadingCache for this specific file path
            return Caffeine.newBuilder()
                    .maximumSize(DEFAULT_MAX_SIZE)
                    .expireAfterWrite(DEFAULT_EXPIRE_AFTER_WRITE_MINUTES, TimeUnit.MINUTES)
                    .refreshAfterWrite(DEFAULT_REFRESH_AFTER_WRITE_MINUTES, TimeUnit.MINUTES)
                    // Define the loader function: how to load data when cache is missed or refreshed
                    .build(cacheKey -> {
                        System.out.println("CacheManager: Loading transactions from file: " + filePath + " (Cache Miss/Refresh)");
                        try {
                            // The cacheKey here will likely be a constant like "transactions"
                            // We use the outer filePath variable to load from the correct file
                            return transactionDao.loadFromCSV(filePath);
                        } catch (IOException e) {
                            System.err.println("CacheManager: Error loading data for file " + filePath);
                            e.printStackTrace();
                            throw new RuntimeException("Error loading transactions from " + filePath, e); // Wrap IOException in RuntimeException for Caffeine loader
                        }
                    });
        });
    }

    /**
     * Invalidates the cache for a specific transaction file path.
     * @param filePath The path to the user's transaction CSV file.
     */
    public static void invalidateTransactionCache(String filePath) {
        LoadingCache<String, List<Transaction>> cache = fileCaches.get(filePath);
        if (cache != null) {
            System.out.println("CacheManager: Invalidating cache for file: " + filePath);
            // The cache key for List<Transaction> is likely a constant like "transactions"
            cache.invalidate(CaffeineKeys.TRANSACTION_CAFFEINE_KEY); // Invalidate the entry storing the transaction list
        }

    }

    /**
     * Gets the transaction list from the cache for the specified file path.
     * Loads data if not present or expired. Handles exceptions thrown by the loader.
     *
     * @param filePath The path to the user's transaction CSV file.
     * @param transactionDao The TransactionDao instance to use for loading if cache misses.
     * @return The list of transactions.
     * @throws Exception If an error occurs during loading (e.g., IOException).
     */
    public static List<Transaction> getTransactions(String filePath, TransactionDao transactionDao) throws Exception {
        LoadingCache<String, List<Transaction>> cache = getTransactionCache(filePath, transactionDao);
        // The cache key for the list of transactions from a specific file is a constant.
        // This constant key maps to the *entire list* of transactions for that file.
        return cache.get(CaffeineKeys.TRANSACTION_CAFFEINE_KEY);
    }

    /**
     * Manually puts a list of transactions into the cache for a specific file path.
     * This is useful after a write operation (add, delete, update) to refresh the cache.
     *
     * @param filePath The path to the user's transaction CSV file.
     * @param transactions The updated list of transactions.
     * @param transactionDao The TransactionDao instance (needed to get/create cache if not exists).
     */
    public static void putTransactions(String filePath, List<Transaction> transactions, TransactionDao transactionDao) {
        LoadingCache<String, List<Transaction>> cache = getTransactionCache(filePath, transactionDao);
        cache.put(CaffeineKeys.TRANSACTION_CAFFEINE_KEY, transactions);
        System.out.println("CacheManager: Manually updated cache for file: " + filePath);
    }

    /**
     * Shutdown any resources if necessary (though Caffeine typically manages its threads).
     */
    public static void shutdown() {
        // Caffeine cache doesn't require explicit shutdown in most cases
        // If using custom executors, they might need shutdown.
        System.out.println("CacheManager: Shutdown completed.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\Utils\CacheUtil.java`:

```java
package Utils;

import com.github.benmanes.caffeine.cache.*;

import java.util.concurrent.TimeUnit;
import java.util.function.Function;

import com.github.benmanes.caffeine.cache.Caffeine;

/**
 * Generic Cache Utility Class (Supports generics and exception propagation through the loader)
 * @param <K> Key type
 * @param <V> Value type
 * @param <E> Exception type (e.g., IOException, which the loader function might throw)
 */
public class CacheUtil<K, V, E extends Exception> {
    private final LoadingCache<K, V> cache;

    public CacheUtil(Function<K, V> loader,
                     int maxSize,
                     long expireAfterWrite,
                     long refreshAfterWrite) {

        this.cache = Caffeine.newBuilder()
                .maximumSize(maxSize)
                .expireAfterWrite(expireAfterWrite, TimeUnit.MINUTES)
                .refreshAfterWrite(refreshAfterWrite, TimeUnit.MINUTES)
                .build(loader::apply); // 关键修改：使用build(loader)创建LoadingCache
    }

    /**
     * Gets the cached value.
     * If the key is not in the cache, the loader function will be called to compute it.
     * @param key The key whose associated value is to be returned.
     * @return The value associated with the key.
     */
    public V get(K key) {
        return cache.get(key);
    }

    /**
     * Manually updates the cache with a new value for a given key.
     * @param key The key with which the specified value is to be associated.
     * @param value The value to be associated with the specified key.
     */
    public void put(K key, V value) {
        cache.put(key, value);
    }

    /**
     * Manually removes the entry for a key from the cache.
     * @param key The key whose mapping is to be removed from the cache.
     */
    public void invalidate(K key) {
        cache.invalidate(key);
    }
}



```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\model\MonthlySummary.java`:

```java
package model;

import java.util.HashMap;
import java.util.Map;

// Represents a summary of transactions for a specific month
public class MonthlySummary {
    private String monthIdentifier; // e.g., "2025-03"
    private double totalIncome;
    private double totalExpense;
    // Map from standard expense category to total amount spent in that category
    private Map<String, Double> expenseByCategory;

    public MonthlySummary(String monthIdentifier) {
        this.monthIdentifier = monthIdentifier;
        this.totalIncome = 0.0;
        this.totalExpense = 0.0;
        this.expenseByCategory = new HashMap<>();
    }

    // Getters
    public String getMonthIdentifier() {
        return monthIdentifier;
    }

    public double getTotalIncome() {
        return totalIncome;
    }

    public double getTotalExpense() {
        return totalExpense;
    }

    public Map<String, Double> getExpenseByCategory() {
        return expenseByCategory;
    }

    // Methods to add transaction amounts
    public void addIncome(double amount) {
        this.totalIncome += amount;
    }

    public void addExpense(double amount, String standardCategory) {
        this.totalExpense += amount;
        // Aggregate by standard category
        expenseByCategory.put(standardCategory, expenseByCategory.getOrDefault(standardCategory, 0.0) + amount);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Month: ").append(monthIdentifier).append("\n");
        sb.append("  Total Income: ").append(String.format("%.2f", totalIncome)).append("元\n");
        sb.append("  Total Expense: ").append(String.format("%.2f", totalExpense)).append("元\n");
        sb.append("  Expenses by Category:\n");
        if (expenseByCategory.isEmpty()) {
            sb.append("    (None)\n");
        } else {
            // Sort categories alphabetically for consistent output
            expenseByCategory.entrySet().stream()
                    .sorted(Map.Entry.comparingByKey())
                    .forEach(entry ->
                            sb.append(String.format("    %s: %.2fCNY\n", entry.getKey(), entry.getValue()))
                    );
        }
        return sb.toString();
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\model\SummaryStatistic.java`:

```java
package model;

// Represents a summary statistic for a specific week across all users
public class SummaryStatistic {
    private String weekIdentifier; // e.g., "2025-W14"
    private double totalIncomeAllUsers;
    private double totalExpenseAllUsers;
    private String topExpenseCategory; // e.g., "FOOD"
    private double topExpenseCategoryAmount; // Amount spent in the top category
    private int numberOfUsersWithTransactions; // Number of users who had any transaction this week
    private String timestampGenerated; // When this statistic record was created

    // Constructors
    public SummaryStatistic() {
    }

    public SummaryStatistic(String weekIdentifier, double totalIncomeAllUsers, double totalExpenseAllUsers, String topExpenseCategory, double topExpenseCategoryAmount, int numberOfUsersWithTransactions, String timestampGenerated) {
        this.weekIdentifier = weekIdentifier;
        this.totalIncomeAllUsers = totalIncomeAllUsers;
        this.totalExpenseAllUsers = totalExpenseAllUsers;
        this.topExpenseCategory = topExpenseCategory;
        this.topExpenseCategoryAmount = topExpenseCategoryAmount;
        this.numberOfUsersWithTransactions = numberOfUsersWithTransactions;
        this.timestampGenerated = timestampGenerated;
    }

    // Getters
    public String getWeekIdentifier() {
        return weekIdentifier;
    }

    public double getTotalIncomeAllUsers() {
        return totalIncomeAllUsers;
    }

    public double getTotalExpenseAllUsers() {
        return totalExpenseAllUsers;
    }

    public String getTopExpenseCategory() {
        return topExpenseCategory;
    }

    public double getTopExpenseCategoryAmount() {
        return topExpenseCategoryAmount;
    }

    public int getNumberOfUsersWithTransactions() {
        return numberOfUsersWithTransactions;
    }

    public String getTimestampGenerated() {
        return timestampGenerated;
    }

    // Setters (if needed for creation/population)
    public void setWeekIdentifier(String weekIdentifier) {
        this.weekIdentifier = weekIdentifier;
    }

    public void setTotalIncomeAllUsers(double totalIncomeAllUsers) {
        this.totalIncomeAllUsers = totalIncomeAllUsers;
    }

    public void setTotalExpenseAllUsers(double totalExpenseAllUsers) {
        this.totalExpenseAllUsers = totalExpenseAllUsers;
    }

    public void setTopExpenseCategory(String topExpenseCategory) {
        this.topExpenseCategory = topExpenseCategory;
    }

    public void setTopExpenseCategoryAmount(double topExpenseCategoryAmount) {
        this.topExpenseCategoryAmount = topExpenseCategoryAmount;
    }

    public void setNumberOfUsersWithTransactions(int numberOfUsersWithTransactions) {
        this.numberOfUsersWithTransactions = numberOfUsersWithTransactions;
    }

    public void setTimestampGenerated(String timestampGenerated) {
        this.timestampGenerated = timestampGenerated;
    }

    @Override
    public String toString() {
        return "SummaryStatistic{" +
                "weekIdentifier='" + weekIdentifier + '\'' +
                ", totalIncomeAllUsers=" + totalIncomeAllUsers +
                ", totalExpenseAllUsers=" + totalExpenseAllUsers +
                ", topExpenseCategory='" + topExpenseCategory + '\'' +
                ", topExpenseCategoryAmount=" + topExpenseCategoryAmount +
                ", numberOfUsersWithTransactions=" + numberOfUsersWithTransactions +
                ", timestampGenerated='" + timestampGenerated + '\'' +
                '}';
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\model\Transaction.java`:

```java
package model;
//Transaction time, transaction type, transaction counterparty,
// commodity receipt/payment amount (yuan), payment method, current status,
// transaction order number, merchant order number, remarks
public class Transaction {
    private String transactionTime;
    private String transactionType;
    private String counterparty;
    private String commodity;
    private String inOut;
    private double paymentAmount;
    private String paymentMethod;
    private String currentStatus;
    private String orderNumber;
    private String merchantNumber;
    private String remarks;

    public Transaction() {
    }

    public Transaction(String transactionTime, String transactionType, String counterparty, String commodity, String inOut, double paymentAmount, String paymentMethod, String currentStatus, String orderNumber, String merchantNumber, String remarks) {
        this.transactionTime = transactionTime;
        this.transactionType = transactionType;
        this.counterparty = counterparty;
        this.commodity = commodity;
        this.inOut = inOut;
        this.paymentAmount = paymentAmount;
        this.paymentMethod = paymentMethod;
        this.currentStatus = currentStatus;
        this.orderNumber = orderNumber;
        this.merchantNumber = merchantNumber;
        this.remarks = remarks;
    }

    public String getInOut() {
        return inOut;
    }

    public void setInOut(String inOut) {
        this.inOut = inOut;
    }

    public void setTransactionTime(String transactionTime) {
        this.transactionTime = transactionTime;
    }

    public void setTransactionType(String transactionType) {
        this.transactionType = transactionType;
    }

    public void setCounterparty(String counterparty) {
        this.counterparty = counterparty;
    }

    public void setCommodity(String commodity) {
        this.commodity = commodity;
    }

    public void setPaymentAmount(double paymentAmount) {
        this.paymentAmount = paymentAmount;
    }

    public void setPaymentMethod(String paymentMethod) {
        this.paymentMethod = paymentMethod;
    }

    public void setCurrentStatus(String currentStatus) {
        this.currentStatus = currentStatus;
    }

    public void setOrderNumber(String orderNumbe) {
        this.orderNumber = orderNumbe;
    }

    public void setMerchantNumber(String merchantNumber) {
        this.merchantNumber = merchantNumber;
    }

    public void setRemarks(String remarks) {
        this.remarks = remarks;
    }

    public String getTransactionTime() {
        return transactionTime;
    }

    public String getTransactionType() {
        return transactionType;
    }

    public String getCounterparty() {
        return counterparty;
    }

    public String getCommodity() {
        return commodity;
    }

    public double getPaymentAmount() {
        return paymentAmount;
    }

    public String getPaymentMethod() {
        return paymentMethod;
    }

    public String getCurrentStatus() {
        return currentStatus;
    }

    public String getOrderNumber() {
        return orderNumber;
    }

    public String getMerchantNumber() {
        return merchantNumber;
    }

    public String getRemarks() {
        return remarks;
    }
}

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\java\model\User.java`:

```java
package model;

// User model class
public class User {
    private String username;
    private String password;
    private String role; // e.g., "user", "admin"
    private String transactionFilePath; // Path to the user's transaction CSV file

    // Constructors
    public User() {
    }

    public User(String username, String password, String role, String transactionFilePath) {
        this.username = username;
        this.password = password;
        this.role = role;
        this.transactionFilePath = transactionFilePath;
    }

    // Getters and Setters
    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }

    public String getTransactionFilePath() {
        return transactionFilePath;
    }

    public void setTransactionFilePath(String transactionFilePath) {
        this.transactionFilePath = transactionFilePath;
    }

    @Override
    public String toString() {
        return "User{" +
                "username='" + username + '\'' +
                ", role='" + role + '\'' +
                ", transactionFilePath='" + transactionFilePath + '\'' +
                '}';
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\resources\CSVForm\stats\summary_statistics.csv`:

```csv
week_identifier,total_income_all_users,total_expense_all_users,top_expense_category,top_expense_category_amount,number_of_users_with_transactions,timestamp_generated
2022-W37,0.0,0.0,无支出,0.0,1,2025-05-24 14:14:04
2025-W09,0.0,0.0,无支出,0.0,3,2025-05-24 14:14:04
2025-W10,0.0,0.0,无支出,0.0,3,2025-05-24 14:14:04
2025-W11,0.0,0.0,无支出,0.0,3,2025-05-24 14:14:04
2025-W12,0.0,0.0,无支出,0.0,3,2025-05-24 14:14:04

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\resources\CSVForm\transactions\admin_transactions.csv`:

```csv
Transaction Time,Transaction Type,Counterparty,Commodity,In/Out,Amount(CNY),Payment Method,Current Status,Order Number,Merchant Number,Remarks
2025/03/01 09:00:00,Salary,Company A,March Salary,Income,¥10000.00,Bank Card,Credited,SALARY_MAR_A,PAYROLL_A_001,This month's base salary
2025/03/05 14:30:00,Groceries,Supermarket B,Groceries,Expense,¥250.50,Alipay,Completed,SHOP_B_001,ALIPAY_12345,Weekend shopping
2025/03/15 11:00:00,Dining,Restaurant C,Lunch Takeaway,Expense,¥35.75,Meituan Pay,Completed,MEAL_C_001,MEITUAN_11223,Workday lunch
2025/03/20 16:00:00,Financial Services,Stock Account,Stock Purchase,Expense,¥5000.00,Meituan Pay,Completed,INVEST_STOCK_001,BANK_99887,Long-term investment
2022/09/10 16:00:00,Investment,Stock Account,Stock Purchase,Expense,¥5000.00,TongHuaShun,Pending,INVEST_STOCK_002,BANK_99887,Short-term investment
2025/03/10 10:00:00,Transfer,User 1,Lunch Reimbursement,Expense,¥50.00,WeChat Pay,Completed,TRANSFER_U1_001,WECHAT_56789,Returning lunch money
2025/03/10 10:00:00,Transfer,BUPT,ASS,Income,¥2000.00,AliPay,Completed,1,1,Wow!

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\resources\CSVForm\transactions\user1_transactions.csv`:

```csv
Transaction Time,Transaction Type,Counterparty,Commodity,In/Out,Amount(CNY),Payment Method,Current Status,Order Number,Merchant Number,Remarks
2025/03/01 09:00:00,Salary,Company A,March Salary,Expense,¥10000.00,Bank Card,Credited,SALARY_MAR_A,PAYROLL_A_001,This month's base salary
2025/03/05 14:30:00,Groceries,Supermarket B,Groceries,Expense,¥250.50,Alipay,Completed,SHOP_B_001,ALIPAY_12345,Weekend shopping
2025/03/10 10:00:00,Transfer,User 1,Lunch Reimbursement,Expense,¥50.00,WeChat Pay,Completed,TRANSFER_U1_001,WECHAT_56789,Returning lunch money
2025/03/15 11:00:00,Dining,Restaurant C,Lunch Takeaway,Expense,¥35.75,Meituan Pay,Completed,MEAL_C_001,MEITUAN_11223,Workday lunch
2025/03/20 16:00:00,Investment,Stock Account,Stock Purchase,Expense,¥5000.00,Bank Transfer,Completed,INVEST_STOCK_001,BANK_99887,Long-term investment
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\resources\CSVForm\transactions\user2_transactions.csv`:

```csv
Transaction Time,Transaction Type,Counterparty,Commodity,In/Out,Amount(CNY),Payment Method,Current Status,Order Number,Merchant Number,Remarks
2025/03/01 09:00:00,Salary,Company A,March Salary,Expense,¥10000.00,Bank Card,Credited,SALARY_MAR_A,PAYROLL_A_001,This month's base salary
2025/03/05 14:30:00,Groceries,Supermarket B,Groceries,Expense,¥250.50,Alipay,Completed,SHOP_B_001,ALIPAY_12345,Weekend shopping
2025/03/10 10:00:00,Transfer,User 1,Lunch Reimbursement,Expense,¥50.00,WeChat Pay,Completed,TRANSFER_U1_001,WECHAT_56789,Returning lunch money
2025/03/15 11:00:00,Dining,Restaurant C,Lunch Takeaway,Expense,¥35.75,Meituan Pay,Completed,MEAL_C_001,MEITUAN_11223,Workday lunch
2025/03/20 16:00:00,Investment,Stock Account,Stock Purchase,Expense,¥5000.00,Bank Transfer,Completed,INVEST_STOCK_001,BANK_99887,Long-term investment
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\resources\CSVForm\users\users.csv`:

```csv
username,password,role,transaction_csv_path
admin,admin123,admin,Ai Bill Application/src/main/resources/CSVForm/transactions/admin_transactions.csv
user1,pass123,user,Ai Bill Application/src/main/resources/CSVForm/transactions/user1_transactions.csv
user2,securepwd,user,Ai Bill Application/src/main/resources/CSVForm/transactions/user2_transactions.csv

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\main\resources\config.properties`:

```properties
# config.properties
#csv.path=Ai Bill Application/src/main/resources/CSVForm/0001.csv
csv.path=Ai Bill Application/src/main/resources/CSVForm/transactions/admin_transactions.csv
csv.users_path=Ai Bill Application/src/main/resources/CSVForm/users/users.csv
csv.summary_path=Ai Bill Application/src/main/resources/CSVForm/stats/summary_statistics.csv
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Controller\ButtonEditorTest.java`:

```java
package Controller;

import Controller.ButtonEditor;
import Controller.MenuUI;
import DAO.Impl.CsvSummaryStatisticDao;
import DAO.Impl.CsvTransactionDao;
import DAO.Impl.CsvUserDao;
import DAO.SummaryStatisticDao;
import DAO.TransactionDao;
import DAO.UserDao;
import Service.AIservice.AITransactionService;
import Service.AIservice.CollegeStudentNeeds;
import Service.Impl.SummaryStatisticService;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Service.User.UserService;
import model.User;
import Constants.ConfigConstants;

import org.junit.jupiter.api.Test;
import javax.swing.*;
import java.awt.*;

public class ButtonEditorTest {

    @Test
    void testButtonEditorInstantiationAndUsage() {
        // Full setup for MenuUI is required because ButtonEditor depends on it.
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        UserService userService = new UserService(userDao);
        User testUser = userService.authenticate("user1", "pass123");

        if (testUser == null) {
            System.err.println("ButtonEditorTest: Failed to authenticate test user 'user1'. Test cannot proceed.");
            return;
        }

        TransactionDao transactionDao = new CsvTransactionDao();
        TransactionService transactionService = new TransactionServiceImpl(testUser.getTransactionFilePath());
        SummaryStatisticDao summaryStatisticDao = new CsvSummaryStatisticDao();
        SummaryStatisticService summaryStatisticService = new SummaryStatisticService(userDao, transactionDao, summaryStatisticDao);
        AITransactionService aiTransactionService = new AITransactionService(transactionService);
        CollegeStudentNeeds collegeStudentNeeds = new CollegeStudentNeeds(transactionService);

        // MenuUI needs to be created on EDT if it does heavy UI work in constructor,
        // but its constructor seems okay for direct call here.
        // For safety, let's ensure any UI part of MenuUI setup is on EDT if it were an issue.
        // However, the constructor itself doesn't build the final panel yet.
        MenuUI menuUI = new MenuUI(testUser, transactionService, summaryStatisticService, aiTransactionService, collegeStudentNeeds);
        // We don't need to display MenuUI itself for this ButtonEditor test.

        try {
            ButtonEditor editor = new ButtonEditor(menuUI); // Pass the MenuUI instance
            // Simulate a call from JTable
            Component component = editor.getTableCellEditorComponent(
                    null,           // JTable (can be null for basic test)
                    "Edit Button",  // value
                    false,          // isSelected
                    0,              // row
                    0               // column
            );
            System.out.println("ButtonEditorTest: ButtonEditor instantiated and getTableCellEditorComponent called.");
            Object editorValue = editor.getCellEditorValue();
            System.out.println("ButtonEditorTest: getCellEditorValue returned: " + editorValue);

            if (component instanceof JPanel) {
                System.out.println("ButtonEditorTest: Editor component is a JPanel as expected.");
            } else {
                System.err.println("ButtonEditorTest: Editor component is NOT a JPanel.");
            }

        } catch (Exception e) {
            System.err.println("ButtonEditorTest: Error during test.");
            e.printStackTrace();
            throw e; // Re-throw to make JUnit mark it as failed
        }
        System.out.println("ButtonEditorTest: testButtonEditorInstantiationAndUsage finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Controller\ButtonRendererTest.java`:

```java
package Controller;

import Controller.ButtonRenderer;
import org.junit.jupiter.api.Test;
import javax.swing.*;
import java.awt.*;

public class ButtonRendererTest {

    @Test
    void testButtonRendererInstantiationAndUsage() {
        try {
            ButtonRenderer renderer = new ButtonRenderer();
            // Simulate a call from JTable
            Component component = renderer.getTableCellRendererComponent(
                    null, // JTable (can be null for basic test)
                    "Test Button",  // value
                    false,          // isSelected
                    false,          // hasFocus
                    0,              // row
                    0               // column
            );
            System.out.println("ButtonRendererTest: ButtonRenderer instantiated and getTableCellRendererComponent called.");
            // To visually test, you'd need to add this component to a visible frame,
            // but for a "can it run" test, just calling the method is sufficient.
            if (component instanceof JPanel) {
                System.out.println("ButtonRendererTest: Component is a JPanel as expected.");
            } else {
                System.err.println("ButtonRendererTest: Component is NOT a JPanel.");
            }
        } catch (Exception e) {
            System.err.println("ButtonRendererTest: Error during test.");
            e.printStackTrace();
            // If we reach here, the test effectively fails for "can it run"
            throw e; // Re-throw to make JUnit mark it as failed
        }
        System.out.println("ButtonRendererTest: testButtonRendererInstantiationAndUsage finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Controller\HistogramPanelContainerTest.java`:

```java
package Controller;

import Controller.HistogramPanelContainer;
import org.junit.jupiter.api.Test;
import javax.swing.*;
import java.awt.*;

public class HistogramPanelContainerTest {

    @Test
    void testDisplayHistogramPanelContainer() {
        SwingUtilities.invokeLater(() -> {
            try {
                JFrame frame = new JFrame("HistogramPanelContainer Test Display");
                frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
                frame.setSize(800, 600);
                frame.add(new HistogramPanelContainer());
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
                System.out.println("HistogramPanelContainerTest: HistogramPanelContainer displayed.");
            } catch (Exception e) {
                System.err.println("HistogramPanelContainerTest: Error creating or displaying HistogramPanelContainer.");
                e.printStackTrace();
            }
        });

        try {
            Thread.sleep(5000); // Keep frame visible for 5 seconds
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("HistogramPanelContainerTest: testDisplayHistogramPanelContainer finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Controller\MenuUITest.java`:

```java
package Controller;

import Controller.MenuUI;
import DAO.Impl.CsvSummaryStatisticDao;
import DAO.Impl.CsvTransactionDao;
import DAO.Impl.CsvUserDao;
import DAO.SummaryStatisticDao;
import DAO.TransactionDao;
import DAO.UserDao;
import Interceptor.Login.LoginDialog; // Not used directly for MenuUI test, but part of typical flow
import Service.AIservice.AITransactionService;
import Service.AIservice.CollegeStudentNeeds;
import Service.Impl.SummaryStatisticService;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Service.User.UserService;
import model.User;
import Constants.ConfigConstants; // For paths

import org.junit.jupiter.api.Test;
import javax.swing.*;
import java.awt.*;

public class MenuUITest {

    @Test
    void testDisplayMenuUI() {
        // Setup services and user
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        UserService userService = new UserService(userDao);
        // Authenticate a test user (e.g., user1)
        User testUser = userService.authenticate("user1", "pass123");
        if (testUser == null) {
            System.err.println("MenuUITest: Failed to authenticate test user 'user1'. Check credentials and users.csv.");
            // Attempt with admin if user1 fails, for robustness in test setup
            testUser = userService.authenticate("admin", "admin123");
            if (testUser == null) {
                System.err.println("MenuUITest: Failed to authenticate test user 'admin' as well. Test cannot proceed.");
                return;
            }
        }
        final User currentUser = testUser; // Effectively final for lambda

        TransactionDao transactionDao = new CsvTransactionDao();
        TransactionService transactionService = new TransactionServiceImpl(currentUser.getTransactionFilePath());

        SummaryStatisticDao summaryStatisticDao = new CsvSummaryStatisticDao();
        SummaryStatisticService summaryStatisticService = new SummaryStatisticService(userDao, transactionDao, summaryStatisticDao);

        AITransactionService aiTransactionService = new AITransactionService(transactionService);
        CollegeStudentNeeds collegeStudentNeeds = new CollegeStudentNeeds(transactionService);

        SwingUtilities.invokeLater(() -> {
            try {
                MenuUI menuUI = new MenuUI(currentUser, transactionService, summaryStatisticService, aiTransactionService, collegeStudentNeeds);
                JPanel mainPanel = menuUI.createMainPanel();

                JFrame frame = new JFrame("MenuUI Test Display");
                frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
                frame.setSize(1200, 700);
                frame.add(mainPanel);
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
                System.out.println("MenuUITest: MenuUI panel for user '" + currentUser.getUsername() + "' displayed.");
            } catch (Exception e) {
                System.err.println("MenuUITest: Error creating or displaying MenuUI.");
                e.printStackTrace();
            }
        });

        try {
            Thread.sleep(5000); // Keep frame visible for 5 seconds
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("MenuUITest: testDisplayMenuUI finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Controller\VisualizationPanelTest.java`:

```java
package Controller;

import Controller.VisualizationPanel;
import DAO.Impl.CsvUserDao;
import DAO.UserDao;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Service.User.UserService;
import model.User;
import Constants.ConfigConstants;

import org.junit.jupiter.api.Test;
import javax.swing.*;
import java.awt.*;

public class VisualizationPanelTest {

    @Test
    void testDisplayVisualizationPanel() {
        // Setup a TransactionService instance
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        UserService userService = new UserService(userDao);
        User testUser = userService.authenticate("user1", "pass123"); // Using user1 for transaction data

        if (testUser == null) {
            System.err.println("VisualizationPanelTest: Failed to authenticate test user 'user1'. Check credentials and users.csv.");
            return;
        }

        TransactionService transactionService = new TransactionServiceImpl(testUser.getTransactionFilePath());

        SwingUtilities.invokeLater(() -> {
            try {
                VisualizationPanel visualizationPanel = new VisualizationPanel(transactionService);
                // Optionally call a method to load initial data/charts if available
                // visualizationPanel.refreshPanelData(); // As per VisualizationPanel's own method

                JFrame frame = new JFrame("VisualizationPanel Test Display");
                frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
                frame.setSize(800, 600);
                frame.add(visualizationPanel);
                frame.setLocationRelativeTo(null);
                frame.setVisible(true);
                System.out.println("VisualizationPanelTest: VisualizationPanel displayed.");

                // Call refreshPanelData after the panel is visible and has a size
                SwingUtilities.invokeLater(visualizationPanel::refreshPanelData);

            } catch (Exception e) {
                System.err.println("VisualizationPanelTest: Error creating or displaying VisualizationPanel.");
                e.printStackTrace();
            }
        });

        try {
            Thread.sleep(5000); // Keep frame visible for 5 seconds
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("VisualizationPanelTest: testDisplayVisualizationPanel finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\DAOTest\CsvTransactionDaoTest.java`:

```java
package DAOTest;

import DAO.Impl.CsvTransactionDao;
import model.Transaction;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static Constants.ConfigConstants.CSV_PATH;
import static org.junit.Assert.*; // Using JUnit 4 Assert for assertEquals, assertNotNull etc.

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List; // Keep this import as it's used.
import java.util.ArrayList; // Added this import as List.of() is used in createTestCsvFile and its usage might imply ArrayList for modifications later.


class CsvTransactionDaoTest {
    private static final String TEST_ADMIN_CSV_PATH = "Ai Bill Application/src/test/resources/CSVForm/transactions/admin_transactions.csv"; // Path to admin CSV for testing

    // Test file path (adjust according to actual structure)
    private static final String TEST_CSV_PATH = CSV_PATH; // General test CSV path from constants
    private static CsvTransactionDao dao;

    @Test
    void testLoadFromCSV_ValidFile_ReturnsTransactions() throws Exception {
        // Given
        CsvTransactionDao dao = new CsvTransactionDao();

        // When
        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);

        // Verify fields of the first record (or all records)
        for (int i = 0; i < transactions.size(); i++) {
            System.out.println(transactions.get(i).getRemarks());
            System.out.println(transactions.get(i).getCommodity());
        }
    }

    @Test
    void testAddTransaction() throws IOException {
        dao = new CsvTransactionDao();
        Transaction newTx = new Transaction(
                "2025-03-09 10:00",
                "Transfer",           // "Transfer"
                "Xiao Ming",          // "Xiao Ming"
                "Books",              // "Books"
                "Out",                // "Out" (Assuming "支" means "Out" or "Expense")
                99.99,
                "WeChat",             // "WeChat"
                "Completed",          // "Completed"
                "TX123456",
                "M789012",
                "");

        dao.addTransaction("src/test/resources/001.csv", newTx); // Path to a specific test file for adding

        List<Transaction> transactions = dao.loadFromCSV(TEST_CSV_PATH); // Load from the general test path to verify
    }

    @BeforeEach
        // This runs before each test method
    void setUp() {
        // Initialize DAO before each test
        dao = new CsvTransactionDao();
        // Ensure the test file exists - maybe create it programmatically here for reliable testing
        // or rely on it being present in src/test/resources and copied to classpath
    }

    @Test
    void testLoadAdminCSV() throws IOException {
        System.out.println("Attempting to load test CSV: " + TEST_ADMIN_CSV_PATH);
        Path csvPath = Paths.get(TEST_ADMIN_CSV_PATH);
        assertTrue("Test CSV file should exist at " + TEST_ADMIN_CSV_PATH, Files.exists(csvPath));
        assertTrue("Test CSV file should not be empty.", Files.size(csvPath) > 0);

        // When loading the specific admin CSV
        List<Transaction> transactions = dao.loadFromCSV(TEST_ADMIN_CSV_PATH);

        // Then assert that loading was successful and data is present
        assertNotNull(transactions.toString(), "Loaded transactions list should not be null");
        assertFalse("Loaded transactions list should not be empty", transactions.isEmpty());
        // Assuming the DAO returns 5 data rows. Adjust if header affects count.
        assertEquals("Should load 5 transaction records", 5, transactions.size());

        // Optional: Verify content of a specific row
        Transaction firstTx = transactions.get(0);
        // Assuming the Transaction object field names are English, and CSV values map to them.
        // If CSV values are Chinese and DAO maps them:
        assertEquals("CompanyA", firstTx.getCounterparty()); // Example: "公司A" maps to CompanyA
        assertEquals("March Salary", firstTx.getCommodity());   // Example: "三月工资" maps to March Salary
        assertEquals(10000.00, firstTx.getPaymentAmount(), 0.01); // Use delta for double comparison
    }

    // Add other tests like testAddTransaction, testDeleteTransaction, testChangeInformation etc.
    // Ensure these tests also use the correct file paths and verify file content changes.
    // For modification/deletion tests, you might need to create a temporary CSV file
    // or use a file specifically for testing that can be modified without affecting other tests.

    // Example of a helper method to create a test CSV file programmatically
    // This is more reliable than relying on manual copying/pasting for tests.
    private void createTestCsvFile(String filePath, List<Transaction> transactions) throws IOException {
        Path path = Paths.get(filePath);
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }
        // Delete old file if it exists
        if (Files.exists(path)) {
            Files.delete(path);
        }

        // Assuming English headers for consistency with most CSV libraries' defaults
        // If your DAO strictly expects Chinese headers, use the Chinese header array.
        String[] headers = {"Transaction Time", "Transaction Type", "Counterparty", "Commodity", "In/Out", "Amount(CNY)", "Payment Method", "Current Status", "Order Number", "Merchant Number", "Remarks"};
        // Chinese version for reference:
        // String[] headers = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"};
        try (BufferedWriter writer = Files.newBufferedWriter(path, StandardCharsets.UTF_8); // Use UTF-8 for potential Chinese characters in data
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(headers).withTrim())) {

            for (Transaction t : transactions) {
                csvPrinter.printRecord(
                        t.getTransactionTime(),
                        t.getTransactionType(),
                        t.getCounterparty(),
                        t.getCommodity(),
                        t.getInOut(), // Expecting English like "Income", "Expense"
                        String.format("¥%.2f", t.getPaymentAmount()), // Or your DAO might handle currency symbol differently
                        t.getPaymentMethod(),
                        t.getCurrentStatus(),
                        t.getOrderNumber(),
                        t.getMerchantNumber(),
                        t.getRemarks()
                );
            }
        }
    }

    @Test
    void testAddTransactionToFile() throws IOException {
        // Create a temporary test file path or use a dedicated test file name
        String tempFilePath = "Ai Bill Application/src/main/resources/CSVForm/transactions/test_add.csv"; // Path might need adjustment for test resources
        // Create an empty or initial test file
        createTestCsvFile(tempFilePath, new ArrayList<>()); // Start with an empty file

        CsvTransactionDao testDao = new CsvTransactionDao(); // Or reuse the instance from BeforeEach if path is managed

        Transaction newTx = new Transaction(
                "2025/04/11 08:00:00",
                "TestType",        // "Test Type"
                "TestCounterparty",// "Test Counterparty"
                "TestCommodity",   // "Test Commodity"
                "Income",          // "Income"
                123.45,
                "TestMethod",      // "Test Method"
                "TestStatus",      // "Test Status"
                "TEST001",
                "MERCHANT001",
                "TestRemark"       // "Test Remark"
        );

        // Add the transaction
        testDao.addTransaction(tempFilePath, newTx);

        // Load the file back and verify
        List<Transaction> transactions = testDao.loadFromCSV(tempFilePath);

        assertNotNull(transactions);
        assertEquals(1, transactions.size());
        Transaction addedTx = transactions.get(0);
        assertEquals("TEST001", addedTx.getOrderNumber());
        assertEquals(123.45, addedTx.getPaymentAmount(), 0.01);

        // Clean up the test file (optional but good practice)
        Files.deleteIfExists(Paths.get(tempFilePath));
    }

    @Test
    void testDeleteTransaction() throws IOException {
        dao = new CsvTransactionDao(); // Assuming dao is class member initialized in @BeforeEach

        // Path "CSV_RELATIVE_PATH" is a placeholder. For a real test, set up a file.
        // Using the temp file from setUp as an example, assuming it was copied from admin_transactions.csv
        // String testFileForDelete = testCsvPathForWrites.toString(); // If using @TempDir or similar setup

        // For this example, let's assume TEST_CSV_PATH is a valid, modifiable test file.
        // To make this test robust, you'd first ensure the transaction to delete exists.
        // For now, this is just a call demonstration.
        String orderToDelete = "4200057899202502250932735481"; // An example order number
        // dao.deleteTransaction(testFileForDelete, orderToDelete);
        // List<Transaction> transactions = dao.loadFromCSV(testFileForDelete);
        // Then assert that the transaction is no longer in the list.

        // The original lines:
        dao.deleteTransaction("CSV_RELATIVE_PATH", orderToDelete); // This path needs to be valid.
        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH); // This path also needs to be valid and reflect the deletion.
        // Add assertions here.
    }

//    @Test
//    void testChangeInfo() throws IOException{
//        dao=new CsvTransactionDao();
//        // dao.changeInformation("TX123456","remarks","Test modify information",TEST_CSV_PATH); // "Test modify information"
//        // dao.changeInformation("TX123456","paymentAmount","116156",TEST_CSV_PATH);
//        // The changeInformation method is not standard in TransactionDao interface. Prefer using updateTransaction.
//        // If testing updateTransaction, it would look like:
//        // dao.updateTransaction(TEST_CSV_PATH, "TX123456", "remarks", "Test modify information");
//        // dao.updateTransaction(TEST_CSV_PATH, "TX123456", "paymentAmount", "116156.00"); // Ensure amount is a valid double string
//    }

}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\DAO\Impl\CsvSummaryStatisticDaoTest.java`:

```java
package DAO.Impl;


import DAO.Impl.CsvSummaryStatisticDao;
import DAO.SummaryStatisticDao;
import model.SummaryStatistic;
import Constants.ConfigConstants; // For SUMMARY_CSV_PATH

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.List;

public class CsvSummaryStatisticDaoTest {

    private SummaryStatisticDao summaryDao;
    private final String sampleSummaryFilePath = ConfigConstants.SUMMARY_CSV_PATH;
    private Path tempSummaryFilePath;

    @BeforeEach
    void setUp() throws IOException {
        summaryDao = new CsvSummaryStatisticDao();
        Path originalPath = Paths.get(sampleSummaryFilePath);
        if (!Files.exists(originalPath)) {
            // Create a dummy original file if it doesn't exist, so copy works
            Files.createFile(originalPath);
            // Optionally write a header or a dummy record
            Files.writeString(originalPath, "week_identifier,total_income_all_users,total_expense_all_users,top_expense_category,top_expense_category_amount,number_of_users_with_transactions,timestamp_generated\n");
            System.out.println("CsvSummaryStatisticDaoTest: Created dummy summary file at " + sampleSummaryFilePath + " because it was missing.");
        }
        tempSummaryFilePath = Files.createTempFile("test_summary_stats_", ".csv");
        Files.copy(originalPath, tempSummaryFilePath, StandardCopyOption.REPLACE_EXISTING);
        System.out.println("CsvSummaryStatisticDaoTest: Copied " + sampleSummaryFilePath + " to temporary file " + tempSummaryFilePath.toString() + " for testing.");
    }

    @AfterEach
    void tearDown() throws IOException {
        if (tempSummaryFilePath != null && Files.exists(tempSummaryFilePath)) {
            Files.delete(tempSummaryFilePath);
            System.out.println("CsvSummaryStatisticDaoTest: Deleted temporary summary file " + tempSummaryFilePath.toString());
        }
    }

    @Test
    void testLoadAllStatistics() {
        try {
            // Test loading from the original sample file
            List<SummaryStatistic> stats = summaryDao.loadAllStatistics(sampleSummaryFilePath);
            System.out.println("CsvSummaryStatisticDaoTest (loadAll): Loaded " + stats.size() + " summary statistics from " + sampleSummaryFilePath);
            if (!stats.isEmpty()) {
                System.out.println("CsvSummaryStatisticDaoTest (loadAll): First statistic: " + stats.get(0).getWeekIdentifier());
            }
        } catch (Exception e) {
            System.err.println("CsvSummaryStatisticDaoTest (loadAll): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("CsvSummaryStatisticDaoTest (loadAll): testLoadAllStatistics finished.");
    }

    @Test
    void testWriteAllStatistics() {
        try {
            List<SummaryStatistic> newStats = new ArrayList<>();
            newStats.add(new SummaryStatistic("2024-W01", 1000, 500, "Food", 200, 10, "2024-01-08 10:00:00"));
            newStats.add(new SummaryStatistic("2024-W02", 1200, 600, "Transport", 150, 12, "2024-01-15 10:00:00"));

            System.out.println("CsvSummaryStatisticDaoTest (writeAll): Attempting to write " + newStats.size() + " new statistics to " + tempSummaryFilePath.toString());
            summaryDao.writeAllStatistics(tempSummaryFilePath.toString(), newStats);
            System.out.println("CsvSummaryStatisticDaoTest (writeAll): Statistics written.");

            List<SummaryStatistic> reReadStats = summaryDao.loadAllStatistics(tempSummaryFilePath.toString());
            System.out.println("CsvSummaryStatisticDaoTest (writeAll): Re-read " + reReadStats.size() + " statistics.");
            if (reReadStats.size() == newStats.size()) {
                System.out.println("CsvSummaryStatisticDaoTest (writeAll): Count matches.");
                if(!reReadStats.isEmpty()){
                    System.out.println("CsvSummaryStatisticDaoTest (writeAll): First re-read stat week: " + reReadStats.get(0).getWeekIdentifier());
                }
            } else {
                System.err.println("CsvSummaryStatisticDaoTest (writeAll): Count MISMATCH after write/read.");
            }

        } catch (Exception e) {
            System.err.println("CsvSummaryStatisticDaoTest (writeAll): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("CsvSummaryStatisticDaoTest (writeAll): testWriteAllStatistics finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\DAO\Impl\CsvTransactionDaoTest.java`:

```java
package DAO.Impl;

// No specific imports needed for TransactionDao interface itself in JUnit test usually
// import DAO.TransactionDao;
import model.Transaction;
// import Constants.ConfigConstants; // Not directly used in this test logic

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
// It's good practice to import static assertions if used, e.g., import static org.junit.jupiter.api.Assertions.*;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

// Test class for CsvTransactionDao
public class CsvTransactionDaoTest {

    private CsvTransactionDao transactionDao; // Use concrete class for testing its specific implementation
    // Path to a sample CSV file used for read tests and as a base for write tests.
    // Ensure this file exists in the specified location relative to the project root.
    private final String sampleTransactionFilePath = "src/test/resources/CSVForm/transactions/admin_transactions.csv";
    private Path tempTransactionFilePath; // Temporary file path for tests that modify data.

    @BeforeEach
    void setUp() throws IOException {
        transactionDao = new CsvTransactionDao();
        // Create a temporary copy of the sample file before each test that might modify data.
        // This ensures test isolation.
        Path originalPath = Paths.get(sampleTransactionFilePath);
        if (!Files.exists(originalPath)) {
            throw new IOException("Sample transaction file not found at: " + sampleTransactionFilePath);
        }
        tempTransactionFilePath = Files.createTempFile("test_transactions_", ".csv");
        Files.copy(originalPath, tempTransactionFilePath, StandardCopyOption.REPLACE_EXISTING);
        System.out.println("CsvTransactionDaoTest: Copied " + sampleTransactionFilePath + " to temporary file " + tempTransactionFilePath.toString() + " for testing.");
    }

    @AfterEach
    void tearDown() throws IOException {
        // Delete the temporary file after each test to clean up.
        if (tempTransactionFilePath != null && Files.exists(tempTransactionFilePath)) {
            Files.delete(tempTransactionFilePath);
            System.out.println("CsvTransactionDaoTest: Deleted temporary file " + tempTransactionFilePath.toString());
        }
    }

    @Test
    void testLoadFromCSV() {
        // Test loading transactions from a CSV file.
        try {
            List<Transaction> transactions = transactionDao.loadFromCSV(sampleTransactionFilePath);
            System.out.println("CsvTransactionDaoTest (loadFromCSV): Loaded " + transactions.size() + " transactions from " + sampleTransactionFilePath);
            // Basic check: if transactions were loaded, print info about the first one.
            if (!transactions.isEmpty()) {
                System.out.println("CsvTransactionDaoTest (loadFromCSV): First transaction order number: " + transactions.get(0).getOrderNumber());
            }
            // Add assertions here, e.g., assertTrue(!transactions.isEmpty()); assertEquals(expectedSize, transactions.size());
        } catch (Exception e) {
            System.err.println("CsvTransactionDaoTest (loadFromCSV): Error during test.");
            e.printStackTrace();
            // Fail the test if an exception occurs.
            throw new RuntimeException("testLoadFromCSV failed", e);
        }
        System.out.println("CsvTransactionDaoTest (loadFromCSV): testLoadFromCSV finished.");
    }

    @Test
    void testGetAllTransactions() {
        // Test the getAllTransactions method (which typically calls loadFromCSV).
        try {
            List<Transaction> transactions = transactionDao.getAllTransactions(sampleTransactionFilePath);
            System.out.println("CsvTransactionDaoTest (getAllTransactions): Loaded " + transactions.size() + " transactions from " + sampleTransactionFilePath);
            if (!transactions.isEmpty()) {
                System.out.println("CsvTransactionDaoTest (getAllTransactions): First transaction order number: " + transactions.get(0).getOrderNumber());
            }
            // Add assertions.
        } catch (Exception e) {
            System.err.println("CsvTransactionDaoTest (getAllTransactions): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testGetAllTransactions failed", e);
        }
        System.out.println("CsvTransactionDaoTest (getAllTransactions): testGetAllTransactions finished.");
    }

    @Test
    void testAddTransaction() {
        // Test adding a new transaction to the CSV file.
        try {
            String uniqueOrderNumber = "TEST_ADD_" + UUID.randomUUID().toString();
            Transaction newTx = new Transaction("2024/01/01 10:00", "TestType", "TestCounterparty", "TestCommodity", "Expense", 10.0, "TestPay", "Completed", uniqueOrderNumber, "M001", "Add test");

            System.out.println("CsvTransactionDaoTest (addTransaction): Attempting to add transaction with ON: " + uniqueOrderNumber + " to " + tempTransactionFilePath.toString());
            transactionDao.addTransaction(tempTransactionFilePath.toString(), newTx);
            System.out.println("CsvTransactionDaoTest (addTransaction): Transaction added.");

            // Verify by reloading and checking.
            List<Transaction> transactions = transactionDao.loadFromCSV(tempTransactionFilePath.toString());
            boolean found = transactions.stream().anyMatch(t -> t.getOrderNumber().equals(uniqueOrderNumber));
            System.out.println("CsvTransactionDaoTest (addTransaction): Transaction found after add: " + found);
            if (!found) {
                System.err.println("CsvTransactionDaoTest (addTransaction): Added transaction NOT FOUND in file.");
                // Assert.fail("Added transaction was not found after reload.");
            }
            // Assert.assertTrue(found, "Transaction should be found after adding.");
        } catch (Exception e) {
            System.err.println("CsvTransactionDaoTest (addTransaction): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testAddTransaction failed", e);
        }
        System.out.println("CsvTransactionDaoTest (addTransaction): testAddTransaction finished.");
    }

    @Test
    void testDeleteTransaction() {
        // Test deleting an existing transaction.
        try {
            // First, add a transaction to ensure it exists, then delete it.
            String uniqueOrderNumber = "TEST_DELETE_" + UUID.randomUUID().toString();
            Transaction txToDelete = new Transaction("2024/01/02 11:00", "ToDelete", "DelCounter", "DelItem", "Expense", 20.0, "DelPay", "Done", uniqueOrderNumber, "M002", "Delete test");
            transactionDao.addTransaction(tempTransactionFilePath.toString(), txToDelete);
            System.out.println("CsvTransactionDaoTest (deleteTransaction): Added transaction for deletion: " + uniqueOrderNumber);

            boolean deleted = transactionDao.deleteTransaction(tempTransactionFilePath.toString(), uniqueOrderNumber);
            System.out.println("CsvTransactionDaoTest (deleteTransaction): Deletion result for ON " + uniqueOrderNumber + ": " + deleted);
            // Assert.assertTrue(deleted, "Deletion should return true for an existing transaction.");

            // Verify by reloading.
            List<Transaction> transactions = transactionDao.loadFromCSV(tempTransactionFilePath.toString());
            boolean stillExists = transactions.stream().anyMatch(t -> t.getOrderNumber().equals(uniqueOrderNumber));
            System.out.println("CsvTransactionDaoTest (deleteTransaction): Transaction still exists after delete: " + stillExists);
            if (stillExists) {
                System.err.println("CsvTransactionDaoTest (deleteTransaction): Deleted transaction STILL FOUND in file.");
                // Assert.fail("Transaction was found after it should have been deleted.");
            }
            // Assert.assertFalse(stillExists, "Transaction should not exist after deletion.");
        } catch (Exception e) {
            System.err.println("CsvTransactionDaoTest (deleteTransaction): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testDeleteTransaction failed", e);
        }
        System.out.println("CsvTransactionDaoTest (deleteTransaction): testDeleteTransaction finished.");
    }

    @Test
    void testUpdateTransaction() {
        // Test updating a field of an existing transaction.
        try {
            String uniqueOrderNumber = "TEST_UPDATE_" + UUID.randomUUID().toString();
            Transaction txToUpdate = new Transaction("2024/01/03 12:00", "ToUpdate", "UpdCounter", "UpdItem", "Income", 30.0, "UpdPay", "Pending", uniqueOrderNumber, "M003", "Update test original");
            transactionDao.addTransaction(tempTransactionFilePath.toString(), txToUpdate);
            System.out.println("CsvTransactionDaoTest (updateTransaction): Added transaction for update: " + uniqueOrderNumber);

            String newRemark = "Remark updated successfully!";
            boolean updated = transactionDao.updateTransaction(tempTransactionFilePath.toString(), uniqueOrderNumber, "remarks", newRemark);
            System.out.println("CsvTransactionDaoTest (updateTransaction): Update result for ON " + uniqueOrderNumber + ": " + updated);
            // Assert.assertTrue(updated, "Update should return true for an existing transaction and valid field.");

            // Verify by fetching the transaction.
            Transaction fetched = transactionDao.getTransactionByOrderNumber(tempTransactionFilePath.toString(), uniqueOrderNumber);
            if (fetched != null) {
                System.out.println("CsvTransactionDaoTest (updateTransaction): Fetched remark: " + fetched.getRemarks() + ". Expected: " + newRemark);
                if (!newRemark.equals(fetched.getRemarks())) {
                    System.err.println("CsvTransactionDaoTest (updateTransaction): Remark NOT updated correctly.");
                    // Assert.fail("Remark was not updated as expected.");
                }
                // Assert.assertEquals(newRemark, fetched.getRemarks(), "Remark should be updated.");
            } else {
                System.err.println("CsvTransactionDaoTest (updateTransaction): Transaction NOT FOUND after update attempt.");
                // Assert.fail("Transaction not found after update attempt.");
            }
        } catch (Exception e) {
            System.err.println("CsvTransactionDaoTest (updateTransaction): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testUpdateTransaction failed", e);
        }
        System.out.println("CsvTransactionDaoTest (updateTransaction): testUpdateTransaction finished.");
    }

    @Test
    void testGetTransactionByOrderNumber() {
        // Test fetching a specific transaction by its order number.
        try {
            // Assuming 'SALARY_MAR_A' exists in the sample admin_transactions.csv.
            // This order number should be present in the temp file after copy.
            String existingOrderNumber = "SALARY_MAR_A"; // Make sure this ON exists in your sample CSV.
            Transaction transaction = transactionDao.getTransactionByOrderNumber(tempTransactionFilePath.toString(), existingOrderNumber);
            if (transaction != null) {
                System.out.println("CsvTransactionDaoTest (getByON): Found transaction commodity: " + transaction.getCommodity() + " for ON " + existingOrderNumber);
                // Assert.assertEquals(existingOrderNumber, transaction.getOrderNumber());
            } else {
                System.err.println("CsvTransactionDaoTest (getByON): Transaction with ON " + existingOrderNumber + " NOT FOUND in " + tempTransactionFilePath.toString());
                // Assert.fail("Expected transaction not found: " + existingOrderNumber);
            }

            // Test with a non-existing order number.
            String nonExistingOrderNumber = "NON_EXISTENT_ON_123";
            Transaction nonExistingTx = transactionDao.getTransactionByOrderNumber(tempTransactionFilePath.toString(), nonExistingOrderNumber);
            System.out.println("CsvTransactionDaoTest (getByON): Result for non-existing ON " + nonExistingOrderNumber + ": " + (nonExistingTx == null ? "null (Correct)" : "Found (Incorrect)"));
            // Assert.assertNull(nonExistingTx, "Should return null for a non-existing order number.");
        } catch (Exception e) {
            System.err.println("CsvTransactionDaoTest (getByON): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testGetTransactionByOrderNumber failed", e);
        }
        System.out.println("CsvTransactionDaoTest (getByON): testGetTransactionByOrderNumber finished.");
    }

    @Test
    void testWriteTransactionsToCSV() {
        // Test writing a list of transactions to a new CSV file (overwrite).
        Path newTempFile = null;
        try {
            newTempFile = Files.createTempFile("test_write_all_", ".csv");
            List<Transaction> transactionsToWrite = new ArrayList<>();
            transactionsToWrite.add(new Transaction("2024/02/01", "Write1", "W_Counter1", "W_Item1", "Expense", 1.0, "Cash", "OK", "W_ON001", "WM001", "Note1"));
            transactionsToWrite.add(new Transaction("2024/02/02", "Write2", "W_Counter2", "W_Item2", "Income", 2.0, "Card", "OK", "W_ON002", "WM002", "Note2"));

            System.out.println("CsvTransactionDaoTest (writeAll): Attempting to write " + transactionsToWrite.size() + " transactions to " + newTempFile.toString());
            transactionDao.writeTransactionsToCSV(newTempFile.toString(), transactionsToWrite);
            System.out.println("CsvTransactionDaoTest (writeAll): Wrote transactions.");

            // Verify by reloading from the new file.
            List<Transaction> reReadTransactions = transactionDao.loadFromCSV(newTempFile.toString());
            System.out.println("CsvTransactionDaoTest (writeAll): Re-read " + reReadTransactions.size() + " transactions.");
            if (reReadTransactions.size() == transactionsToWrite.size()) {
                System.out.println("CsvTransactionDaoTest (writeAll): Count matches.");
                // Assert.assertEquals(transactionsToWrite.size(), reReadTransactions.size(), "Number of transactions should match after writing and rereading.");
            } else {
                System.err.println("CsvTransactionDaoTest (writeAll): Count MISMATCH after write/read.");
                // Assert.fail("Transaction count mismatch after write and read.");
            }
        } catch (Exception e) {
            System.err.println("CsvTransactionDaoTest (writeAll): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testWriteTransactionsToCSV failed", e);
        } finally {
            // Clean up the newly created temporary file for this test.
            if (newTempFile != null) {
                try {
                    Files.deleteIfExists(newTempFile);
                    System.out.println("CsvTransactionDaoTest (writeAll): Deleted temp write file " + newTempFile.toString());
                } catch (IOException e) {
                    System.err.println("CsvTransactionDaoTest (writeAll): Error deleting temp file " + newTempFile.toString());
                    e.printStackTrace();
                }
            }
        }
        System.out.println("CsvTransactionDaoTest (writeAll): testWriteTransactionsToCSV finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\DAO\Impl\CsvUserDaoTest.java`:

```java
package DAO.Impl;

import DAO.Impl.CsvUserDao;
import DAO.UserDao;
import model.User;
import Constants.ConfigConstants; // For USERS_CSV_PATH

import org.junit.jupiter.api.Test;
import java.util.List;

public class CsvUserDaoTest {

    @Test
    void testGetAllUsers() {
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        try {
            List<User> users = userDao.getAllUsers();
            System.out.println("CsvUserDaoTest: Loaded " + users.size() + " users.");
            if (!users.isEmpty()) {
                System.out.println("CsvUserDaoTest: First user: " + users.get(0));
            }
            // No assertions, just checking if it runs
        } catch (Exception e) {
            System.err.println("CsvUserDaoTest: Error in testGetAllUsers.");
            e.printStackTrace();
            // To make JUnit fail the test if an exception occurs
            throw new RuntimeException("Test failed due to exception in getAllUsers", e);
        }
        System.out.println("CsvUserDaoTest: testGetAllUsers finished successfully.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Service\AIAnalyzerThreadTest.java`:

```java
package Service;



import Service.AIservice.AIAnalyzerThread;
import org.junit.jupiter.api.Test;

public class AIAnalyzerThreadTest {

//    @Test
//    public void testRunAIAnalyzerThread() throws InterruptedException {
//        String userRequest = "Please help me analyze the recent transaction income and expenditure";
//        String filePath = "src/test/resources/sample_transactions.csv";
//        String startTimeStr = "2025/03/20";
//        String endTimeStr = "";
//
//        // Starting a Thread
//        Thread thread = new Thread(new AIAnalyzerThread(userRequest, filePath, startTimeStr, endTimeStr));
//        thread.start();
//
//        // Waiting for thread execution to complete
//        thread.join();
//    }
}

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Service\AIserviceTest.java`:

```java
package Service;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

public class AIserviceTest {

    @Test
    public void testAnalyzeTransactions() {
//        AITransactionService service = new AITransactionService();
//
//        String userRequest = "Please help me analyze this month's income and expenditure";
//        String filePath = "src/test/resources/sample_transactions.csv";
//
//        String result = service.analyzeTransactions(userRequest, filePath,"2025/03/20","");
//
//        assertNotNull(result, "AI analysis results cannot be empty");
//        System.out.println("AI analysis results: " + result);
    }


}

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Service\AIservice\AIAnalyzerThreadTest.java`:

```java
package Service.AIservice;

import DAO.Impl.CsvUserDao;
import DAO.UserDao;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Service.User.UserService;
import model.User;
import Constants.ConfigConstants;

import org.junit.jupiter.api.Test;

public class AIAnalyzerThreadTest {

    @Test
    void testRunAIAnalyzerThread() {
        System.out.println("AIAnalyzerThreadTest: Running testRunAIAnalyzerThread...");
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        UserService userService = new UserService(userDao);
        User testUser = userService.authenticate("admin", "admin123");

        if (testUser == null) {
            System.err.println("AIAnalyzerThreadTest: Failed to authenticate test user 'admin'. Test cannot proceed.");
            return;
        }

        TransactionService transactionService = new TransactionServiceImpl(testUser.getTransactionFilePath());
        AITransactionService aiService = new AITransactionService(transactionService);

        AIAnalyzerThread analyzerThread = new AIAnalyzerThread(
                aiService,
                "Analyze my spending",
                testUser.getTransactionFilePath(),
                "2025/03/01",
                ""
        );
        Thread thread = new Thread(analyzerThread);
        thread.start();
        try {
            thread.join(10000); // Wait for up to 10 seconds
            System.out.println("AIAnalyzerThreadTest: Thread finished or timed out.");
        } catch (InterruptedException e) {
            System.err.println("AIAnalyzerThreadTest: Thread interrupted.");
            e.printStackTrace();
            Thread.currentThread().interrupt();
        }
        System.out.println("AIAnalyzerThreadTest: testRunAIAnalyzerThread finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Service\AIservice\AITransactionServiceTest.java`:

```java
package Service.AIservice;


import DAO.Impl.CsvUserDao;
import DAO.UserDao;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Service.User.UserService;
import model.User;
import Constants.ConfigConstants;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

public class AITransactionServiceTest {

    private AITransactionService aiTransactionService;
    private TransactionService transactionService; // For AITransactionService dependency
    private User testUser;

    @BeforeEach
    void setUp() {
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        UserService userService = new UserService(userDao);
        testUser = userService.authenticate("user1", "pass123"); // Use a common test user

        if (testUser == null) {
            System.err.println("AITransactionServiceTest: Failed to authenticate test user 'user1'. Using admin.");
            testUser = userService.authenticate("admin", "admin123");
        }
        if (testUser == null) {
            throw new IllegalStateException("AITransactionServiceTest: Cannot authenticate any test user. Aborting setup.");
        }

        transactionService = new TransactionServiceImpl(testUser.getTransactionFilePath());
        aiTransactionService = new AITransactionService(transactionService); // Inject dependency
    }

    @Test
    void testAnalyzeTransactions() {
        System.out.println("AITransactionServiceTest: Running testAnalyzeTransactions...");
        try {
            String result = aiTransactionService.analyzeTransactions(
                    "Help me analyze my recent spending",
                    testUser.getTransactionFilePath(),
                    "2025/03/01",
                    "2025/03/31"
            );
            System.out.println("AITransactionServiceTest (analyzeTransactions) Result: " + result);
        } catch (Exception e) {
            System.err.println("AITransactionServiceTest (analyzeTransactions): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("AITransactionServiceTest: testAnalyzeTransactions finished.");
    }

    @Test
    void testGeneratePersonalSummary() {
        System.out.println("AITransactionServiceTest: Running testGeneratePersonalSummary...");
        try {
            String result = aiTransactionService.generatePersonalSummary(testUser.getTransactionFilePath());
            System.out.println("AITransactionServiceTest (generatePersonalSummary) Result: " + result);
        } catch (Exception e) {
            System.err.println("AITransactionServiceTest (generatePersonalSummary): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("AITransactionServiceTest: testGeneratePersonalSummary finished.");
    }

    @Test
    void testSuggestSavingsGoals() {
        System.out.println("AITransactionServiceTest: Running testSuggestSavingsGoals...");
        try {
            String result = aiTransactionService.suggestSavingsGoals(testUser.getTransactionFilePath());
            System.out.println("AITransactionServiceTest (suggestSavingsGoals) Result: " + result);
        } catch (Exception e) {
            System.err.println("AITransactionServiceTest (suggestSavingsGoals): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("AITransactionServiceTest: testSuggestSavingsGoals finished.");
    }

    @Test
    void testGivePersonalSavingTips() {
        System.out.println("AITransactionServiceTest: Running testGivePersonalSavingTips...");
        try {
            String result = aiTransactionService.givePersonalSavingTips(testUser.getTransactionFilePath());
            System.out.println("AITransactionServiceTest (givePersonalSavingTips) Result: " + result);
        } catch (Exception e) {
            System.err.println("AITransactionServiceTest (givePersonalSavingTips): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("AITransactionServiceTest: testGivePersonalSavingTips finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Service\AIservice\ColledgeStudentThreadTest.java`:

```java
package Service.AIservice;

import DAO.Impl.CsvUserDao;
import DAO.UserDao;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Service.User.UserService;
import model.User;
import Constants.ConfigConstants;

import org.junit.jupiter.api.Test;

public class ColledgeStudentThreadTest { // Corrected class name

    @Test
    void testRunCollegeStudentThread() {
        System.out.println("CollegeStudentThreadTest: Running testRunCollegeStudentThread...");
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        UserService userService = new UserService(userDao);
        User testUser = userService.authenticate("user1", "pass123"); // Student user

        if (testUser == null) {
            System.err.println("CollegeStudentThreadTest: Failed to authenticate test user 'user1'. Test cannot proceed.");
            return;
        }

        TransactionService transactionService = new TransactionServiceImpl(testUser.getTransactionFilePath());
        CollegeStudentNeeds collegeStudentNeeds = new CollegeStudentNeeds(transactionService);

        // Corrected instantiation of ColledgeStudentThread (as per original file name)
        // If the class name was intended to be CollegeStudentThread, adjust accordingly.
        ColledgeStudentThread studentThread = new ColledgeStudentThread(
                collegeStudentNeeds,
                testUser.getTransactionFilePath()
        );
        Thread thread = new Thread(studentThread);
        thread.start();
        try {
            thread.join(10000); // Wait for up to 10 seconds
            System.out.println("CollegeStudentThreadTest: Thread finished or timed out.");
        } catch (InterruptedException e) {
            System.err.println("CollegeStudentThreadTest: Thread interrupted.");
            e.printStackTrace();
            Thread.currentThread().interrupt();
        }
        System.out.println("CollegeStudentThreadTest: testRunCollegeStudentThread finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Service\AIservice\CollegeStudentNeedsTest.java`:

```java
package Service.AIservice;

import DAO.Impl.CsvUserDao;
import DAO.UserDao;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Service.User.UserService;
import model.Transaction;
import model.User;
import Constants.ConfigConstants;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

public class CollegeStudentNeedsTest {

    private CollegeStudentNeeds collegeStudentNeeds;
    private User testUser;
    private TransactionService transactionService; // For CollegeStudentNeeds dependency

    @BeforeEach
    void setUp() {
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        UserService userService = new UserService(userDao);
        testUser = userService.authenticate("user1", "pass123"); // Assuming user1 might be a student

        if (testUser == null) {
            System.err.println("CollegeStudentNeedsTest: Failed to authenticate test user 'user1'. Using admin.");
            testUser = userService.authenticate("admin", "admin123");
        }
        if (testUser == null) {
            throw new IllegalStateException("CollegeStudentNeedsTest: Cannot authenticate any test user. Aborting setup.");
        }

        transactionService = new TransactionServiceImpl(testUser.getTransactionFilePath());
        collegeStudentNeeds = new CollegeStudentNeeds(transactionService); // Inject dependency
    }

    @Test
    void testRecognizeTransaction() {
        System.out.println("CollegeStudentNeedsTest: Running testRecognizeTransaction...");
        try {
            Transaction sampleTransaction = new Transaction(
                    "2025/03/15 12:00", "lunch", "school cafeteria", "braised pork set meal", "expenditure",
                    15.0, "Campus Card", "Completed", "STU001", "SCH001", "Regular Lunch"
            );
            String category = collegeStudentNeeds.RecognizeTransaction(sampleTransaction);
            System.out.println("CollegeStudentNeedsTest (RecognizeTransaction) Suggested Category: " + category);
        } catch (Exception e) {
            System.err.println("CollegeStudentNeedsTest (RecognizeTransaction): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("CollegeStudentNeedsTest: testRecognizeTransaction finished.");
    }

    @Test
    void testGenerateTipsForSaving() {
        System.out.println("CollegeStudentNeedsTest: Running testGenerateTipsForSaving...");
        try {
            String tips = collegeStudentNeeds.generateTipsForSaving(testUser.getTransactionFilePath());
            System.out.println("CollegeStudentNeedsTest (generateTipsForSaving) Tips: " + tips);
        } catch (Exception e) {
            System.err.println("CollegeStudentNeedsTest (generateTipsForSaving): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("CollegeStudentNeedsTest: testGenerateTipsForSaving finished.");
    }

    @Test
    void testGenerateBudget() {
        System.out.println("CollegeStudentNeedsTest: Running testGenerateBudget...");
        try {
            double[] budget = collegeStudentNeeds.generateBudget(testUser.getTransactionFilePath());
            if (budget != null && budget.length == 2) {
                System.out.println("CollegeStudentNeedsTest (generateBudget) Budget: [" + budget[0] + ", " + budget[1] + "]");
            } else {
                System.out.println("CollegeStudentNeedsTest (generateBudget) Budget: Could not be generated or invalid format.");
            }
        } catch (Exception e) {
            System.err.println("CollegeStudentNeedsTest (generateBudget): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("CollegeStudentNeedsTest: testGenerateBudget finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Service\AiFunctionTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.Test;
import Service.AIservice.AITransactionService;

import java.io.IOException;
import java.util.List;

public class AiFunctionTest {

    @Test
    public void testAnalyzeTransactions() throws IOException {

//        String filePath = "src/test/resources/sample_transactions.csv";
//        CsvTransactionDao transactionDao = new CsvTransactionDao();
//
//        List<Transaction> transactions = transactionDao.loadFromCSV(filePath);
//
//        // Instantiate the service class
//        AITransactionService service = new AITransactionService();
//
//        // Call the merge formatting function
//        List<String> result = service.formatTransactions(transactions,"2025/03/29","2025/04/10");
//
//        // Output
//        result.forEach(System.out::println);
    }




}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Service\CacheTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import model.Transaction;
import org.junit.jupiter.api.Test;

import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;

public class CacheTest {

//    TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());
//
//    @Test
//    void DeleteCache(){
//        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;
//        cache.invalidate(TRANSACTION_CAFFEINE_KEY);
//    }

}

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Service\CollegeStudentNeedsTest.java`:

```java
//package Service;
//
//import Service.AIservice.ColledgeStudentThread;
//import Service.AIservice.CollegeStudentNeeds;
//import org.junit.jupiter.api.*;
//
//import java.io.IOException;
//import java.net.URISyntaxException;
//import java.net.URL;
//import java.nio.file.Files;
//import java.nio.file.Path;
//import java.nio.file.Paths;
//import java.util.Arrays;
//
//import static org.junit.jupiter.api.Assertions.*;
//
//// No @ExtendWith needed as we are not using Mockito extensions
//class CollegeStudentNeedsTest {
//
//
//
//    private CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
//    private static final String TEST_CSV_FILENAME = "src/test/resources/001.csv";
//    @Test
//    public void testGenerateBudget() throws IOException, InterruptedException {
//        Thread t=new Thread( new ColledgeStudentThread(TEST_CSV_FILENAME));
//        t.start();
//        t.join();
////        collegeStudentNeeds.generateBudget(TEST_CSV_FILENAME);
//    }
//    @Test
//    public void testParseStringToDouble(){
//        String s="asdas[369.39,1090.1]das";
//        double[] arr=collegeStudentNeeds.parseDoubleArrayFromString(s);
//        System.out.println(arr[0]+" "+arr[1]);
//    }
//
//
//}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Service\Impl\SummaryStatisticServiceTest.java`:

```java
package Service.Impl;

import DAO.Impl.CsvSummaryStatisticDao;
import DAO.Impl.CsvTransactionDao;
import DAO.Impl.CsvUserDao;
import DAO.SummaryStatisticDao;
import DAO.TransactionDao;
import DAO.UserDao;
import model.SummaryStatistic;
import Constants.ConfigConstants;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.List;

public class SummaryStatisticServiceTest {

    private SummaryStatisticService summaryStatisticService;
    private Path tempSummaryFilePath;
    private final String originalSummaryPath = ConfigConstants.SUMMARY_CSV_PATH;

    // For generateAndSaveWeeklyStatistics, we also need user and transaction DAOs and their data
    private UserDao userDao;
    private TransactionDao transactionDao; // This DAO is used by CacheManager within SummaryStatisticService

    @BeforeEach
    void setUp() throws IOException {
        userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        transactionDao = new CsvTransactionDao(); // For CacheManager
        SummaryStatisticDao summaryDao = new CsvSummaryStatisticDao();

        summaryStatisticService = new SummaryStatisticService(userDao, transactionDao, summaryDao);

        // Create a temporary copy of the summary statistics file
        Path originalPathFile = Paths.get(originalSummaryPath);
        if (!Files.exists(originalPathFile)) {
            Files.createDirectories(originalPathFile.getParent());
            Files.createFile(originalPathFile);
            Files.writeString(originalPathFile, "week_identifier,total_income_all_users,total_expense_all_users,top_expense_category,top_expense_category_amount,number_of_users_with_transactions,timestamp_generated\n");
            System.out.println("SummaryStatisticServiceTest: Created dummy original summary file as it was missing: " + originalSummaryPath);
        }
        tempSummaryFilePath = Files.createTempFile("test_summary_service_", ".csv");
        Files.copy(originalPathFile, tempSummaryFilePath, StandardCopyOption.REPLACE_EXISTING);

        // Override the summaryFilePath in the service to use the temp file for write operations
        // This requires SummaryStatisticService to allow setting the path, or we test against the original.
        // For simplicity, generateAndSaveWeeklyStatistics will write to the original path configured in ConfigConstants.
        // So, for that test, we'll back up the original, run the test, then restore.
        // For getAllSummaryStatistics, we can read from the original.
        System.out.println("SummaryStatisticServiceTest: Setup complete. Temp summary file for some tests: " + tempSummaryFilePath);
    }

    @AfterEach
    void tearDown() throws IOException {
        if (tempSummaryFilePath != null && Files.exists(tempSummaryFilePath)) {
            Files.delete(tempSummaryFilePath);
            System.out.println("SummaryStatisticServiceTest: Deleted temp summary file: " + tempSummaryFilePath);
        }
    }

    @Test
    void testGetAllSummaryStatistics() {
        System.out.println("SummaryStatisticServiceTest: Running testGetAllSummaryStatistics...");
        try {
            // This will read from ConfigConstants.SUMMARY_CSV_PATH
            List<SummaryStatistic> stats = summaryStatisticService.getAllSummaryStatistics();
            System.out.println("SummaryStatisticServiceTest (getAll): Loaded " + stats.size() + " summary statistics.");
            if (!stats.isEmpty()) {
                System.out.println("SummaryStatisticServiceTest (getAll): First stat week: " + stats.get(0).getWeekIdentifier());
            }
        } catch (Exception e) {
            System.err.println("SummaryStatisticServiceTest (getAll): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("SummaryStatisticServiceTest: testGetAllSummaryStatistics finished.");
    }

    @Test
    void testGenerateAndSaveWeeklyStatistics() {
        System.out.println("SummaryStatisticServiceTest: Running testGenerateAndSaveWeeklyStatistics...");
        Path backupPath = null;
        Path originalPath = Paths.get(ConfigConstants.SUMMARY_CSV_PATH);
        try {
            // Backup the original summary_statistics.csv
            if (Files.exists(originalPath)) {
                backupPath = Paths.get(originalPath.toString() + ".bak");
                Files.copy(originalPath, backupPath, StandardCopyOption.REPLACE_EXISTING);
                System.out.println("SummaryStatisticServiceTest (generate): Backed up original summary to " + backupPath);
            }

            summaryStatisticService.generateAndSaveWeeklyStatistics();
            System.out.println("SummaryStatisticServiceTest (generate): generateAndSaveWeeklyStatistics completed.");

            // Optionally, load and print some of the generated stats to verify
            List<SummaryStatistic> generatedStats = summaryStatisticService.getAllSummaryStatistics();
            System.out.println("SummaryStatisticServiceTest (generate): Found " + generatedStats.size() + " stats after generation.");
            if(!generatedStats.isEmpty()){
                System.out.println("SummaryStatisticServiceTest (generate): Sample generated stat week: " + generatedStats.get(generatedStats.size()-1).getWeekIdentifier() + " with " + generatedStats.get(generatedStats.size()-1).getNumberOfUsersWithTransactions() + " users.");
            }

        } catch (Exception e) {
            System.err.println("SummaryStatisticServiceTest (generate): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        } finally {
            // Restore the original summary_statistics.csv
            if (backupPath != null && Files.exists(backupPath)) {
                try {
                    Files.move(backupPath, originalPath, StandardCopyOption.REPLACE_EXISTING);
                    System.out.println("SummaryStatisticServiceTest (generate): Restored original summary from " + backupPath);
                } catch (IOException e) {
                    System.err.println("SummaryStatisticServiceTest (generate): Error restoring backup.");
                    e.printStackTrace();
                }
            } else if (backupPath == null && Files.exists(originalPath) && !originalSummaryPath.equals(ConfigConstants.SUMMARY_CSV_PATH)) {
                // If no backup was made (original didn't exist), but test created one, delete it.
                // This case is less likely with current setup.
                try {
                    // Files.delete(originalPath);
                    // System.out.println("SummaryStatisticServiceTest (generate): Deleted summary file created by test.");
                } catch (Exception e) {
                    // ignore
                }
            }
        }
        System.out.println("SummaryStatisticServiceTest: testGenerateAndSaveWeeklyStatistics finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Service\Impl\TransactionServiceImplTest.java`:

```java
package Service.Impl;

import DAO.Impl.CsvTransactionDao; // For direct use in creating temp files if needed
import DAO.Impl.CsvUserDao;
import DAO.UserDao;
import Service.TransactionService;
import Service.User.UserService;
import model.MonthlySummary;
import model.Transaction;
import model.User;
import Constants.ConfigConstants;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
// It's good practice to import static assertions from JUnit 5:
// import static org.junit.jupiter.api.Assertions.*;


import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.Map;
import java.util.UUID;

// Test class for TransactionServiceImpl
public class TransactionServiceImplTest {

    private TransactionService transactionService;
    private User testUser;
    private Path tempUserTransactionFilePath; // Path for the temporary transaction file for the test user
    // Path to an original sample transaction file for user1
    private final String originalUser1CsvPath = "src/test/resources/CSVForm/transactions/user1_transactions.csv";
    // Path to a sample CSV file to be used as a source for import tests
    private final String importTestCsvPath = "src/test/resources/CSVForm/transactions/admin_transactions.csv";

    @BeforeEach
    void setUp() throws IOException {
        // Initialize UserService and authenticate a test user.
        // This setup assumes user authentication and user CSV structure are working.
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH); // Assumes USERS_CSV_PATH is correctly configured.
        UserService userService = new UserService(userDao);
        testUser = userService.authenticate("user1", "pass123"); // Use actual credentials for a test user

        if (testUser == null) {
            throw new IllegalStateException("TransactionServiceImplTest: Cannot authenticate test user 'user1'. Aborting setup.");
        }

        // Create a temporary copy of user1's transaction file to avoid modifying original test data.
        Path originalPath = Paths.get(originalUser1CsvPath);
        if (!Files.exists(originalPath)) {
            throw new IOException("Original user1 transaction file not found: " + originalUser1CsvPath);
        }
        tempUserTransactionFilePath = Files.createTempFile("test_user1_transactions_", ".csv");
        Files.copy(originalPath, tempUserTransactionFilePath, StandardCopyOption.REPLACE_EXISTING);

        // IMPORTANT: Update the testUser's transaction file path to the temporary one for this test run.
        // This ensures the TransactionServiceImpl instance operates on the temporary file.
        testUser.setTransactionFilePath(tempUserTransactionFilePath.toString());

        // Initialize the service to be tested with the path to the temporary transaction file.
        transactionService = new TransactionServiceImpl(testUser.getTransactionFilePath());
        System.out.println("TransactionServiceImplTest: Set up with temp file: " + testUser.getTransactionFilePath());
    }

    @AfterEach
    void tearDown() throws IOException {
        // Delete the temporary transaction file after each test to clean up.
        if (tempUserTransactionFilePath != null && Files.exists(tempUserTransactionFilePath)) {
            Files.delete(tempUserTransactionFilePath);
            System.out.println("TransactionServiceImplTest: Deleted temporary transaction file: " + tempUserTransactionFilePath);
        }
    }

    @Test
    void testGetAllTransactions() {
        System.out.println("TransactionServiceImplTest: Running testGetAllTransactions...");
        try {
            List<Transaction> transactions = transactionService.getAllTransactions();
            System.out.println("TransactionServiceImplTest (getAllTransactions): Loaded " + transactions.size() + " transactions.");
            // Basic check: print info about the first transaction if the list is not empty.
            if (!transactions.isEmpty()) {
                System.out.println("TransactionServiceImplTest (getAllTransactions): First transaction ON: " + transactions.get(0).getOrderNumber());
            }
            // Add assertions here, e.g., assertTrue(!transactions.isEmpty());
        } catch (Exception e) {
            System.err.println("TransactionServiceImplTest (getAllTransactions): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testGetAllTransactions failed", e); // Fail the test
        }
        System.out.println("TransactionServiceImplTest: testGetAllTransactions finished.");
    }

    @Test
    void testAddTransaction() {
        System.out.println("TransactionServiceImplTest: Running testAddTransaction...");
        try {
            String uniqueOrderNumber = "SERVICE_ADD_" + UUID.randomUUID().toString();
            Transaction newTx = new Transaction(
                    "2024/03/01 10:00", "ServiceAdd", "S_Counter", "S_Item", "Expense", // "Expense"
                    55.0, "S_Pay", "Completed", uniqueOrderNumber, "S_M001", "Service add test"
            );
            transactionService.addTransaction(newTx);
            System.out.println("TransactionServiceImplTest (addTransaction): Added transaction with ON: " + uniqueOrderNumber);

            // Verify by fetching all transactions and checking if the new one exists.
            List<Transaction> all = transactionService.getAllTransactions();
            boolean found = all.stream().anyMatch(t -> t.getOrderNumber().equals(uniqueOrderNumber));
            System.out.println("TransactionServiceImplTest (addTransaction): Found after add: " + found);
            if (!found) {
                System.err.println("TransactionServiceImplTest (addTransaction): Added transaction NOT FOUND.");
                // fail("Added transaction was not found.");
            }
            // assertTrue(found, "Transaction should be found after adding.");
        } catch (Exception e) {
            System.err.println("TransactionServiceImplTest (addTransaction): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testAddTransaction failed", e);
        }
        System.out.println("TransactionServiceImplTest: testAddTransaction finished.");
    }

    @Test
    void testChangeTransaction() {
        System.out.println("TransactionServiceImplTest: Running testChangeTransaction...");
        try {
            List<Transaction> initialTransactions = transactionService.getAllTransactions();
            if (initialTransactions.isEmpty()) {
                System.out.println("TransactionServiceImplTest (changeTransaction): No transactions to change. Adding one for the test.");
                // Add a transaction if the list is empty to ensure the test can proceed.
                String uniqueOrderNumber = "SERVICE_CHANGE_" + UUID.randomUUID().toString();
                Transaction newTx = new Transaction("2024/03/02", "ForChange", "FC", "FCI", "Expense", 1.0, "Cash", "OK", uniqueOrderNumber, "FCM", "Original");
                transactionService.addTransaction(newTx);
                initialTransactions = transactionService.getAllTransactions(); // Reload
                if(initialTransactions.isEmpty()){
                    System.err.println("TransactionServiceImplTest (changeTransaction): Still no transactions after add. Test cannot proceed.");
                    // fail("Could not add a transaction to test change operation.");
                    return;
                }
            }

            Transaction toChange = new Transaction(); // Create a new Transaction object for update criteria
            toChange.setOrderNumber(initialTransactions.get(0).getOrderNumber()); // Get OrderNumber of the first transaction
            toChange.setRemarks("Updated via Service Test");
            toChange.setTransactionType("ChangedType");
            // Note: Other fields in 'toChange' will be null/default, changeTransaction should only update specified fields.

            transactionService.changeTransaction(toChange);
            System.out.println("TransactionServiceImplTest (changeTransaction): Changed transaction with ON: " + toChange.getOrderNumber());

            // Verify the changes.
            Transaction changedTx = transactionService.getAllTransactions().stream()
                    .filter(t -> t.getOrderNumber().equals(toChange.getOrderNumber()))
                    .findFirst().orElse(null);

            if(changedTx != null) {
                System.out.println("TransactionServiceImplTest (changeTransaction): New remark: " + changedTx.getRemarks());
                System.out.println("TransactionServiceImplTest (changeTransaction): New type: " + changedTx.getTransactionType());
                if (!"Updated via Service Test".equals(changedTx.getRemarks())) {
                    System.err.println("TransactionServiceImplTest (changeTransaction): Remark NOT updated as expected.");
                    // fail("Remark was not updated correctly.");
                }
                // assertEquals("Updated via Service Test", changedTx.getRemarks());
                // assertEquals("ChangedType", changedTx.getTransactionType());
            } else {
                System.err.println("TransactionServiceImplTest (changeTransaction): Changed transaction NOT FOUND after update.");
                // fail("Transaction not found after change operation.");
            }
        } catch (Exception e) {
            System.err.println("TransactionServiceImplTest (changeTransaction): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testChangeTransaction failed", e);
        }
        System.out.println("TransactionServiceImplTest: testChangeTransaction finished.");
    }

    @Test
    void testDeleteTransaction() {
        System.out.println("TransactionServiceImplTest: Running testDeleteTransaction...");
        try {
            List<Transaction> initialTransactions = transactionService.getAllTransactions();
            if (initialTransactions.isEmpty()) {
                System.out.println("TransactionServiceImplTest (deleteTransaction): No transactions to delete. Adding one for the test.");
                String uniqueOrderNumber = "SERVICE_DELETE_" + UUID.randomUUID().toString();
                Transaction newTx = new Transaction("2024/03/03", "ForDelete", "FD", "FDI", "Expense", 1.0, "Cash", "OK", uniqueOrderNumber, "FDM", "Original to be deleted");
                transactionService.addTransaction(newTx);
                initialTransactions = transactionService.getAllTransactions(); // Reload
                if(initialTransactions.isEmpty()){
                    System.err.println("TransactionServiceImplTest (deleteTransaction): Still no transactions after add. Test cannot proceed.");
                    // fail("Could not add a transaction to test delete operation.");
                    return;
                }
            }
            String orderNumberToDelete = initialTransactions.get(0).getOrderNumber();
            boolean deleted = transactionService.deleteTransaction(orderNumberToDelete);
            System.out.println("TransactionServiceImplTest (deleteTransaction): Deletion result for ON " + orderNumberToDelete + ": " + deleted);
            // assertTrue(deleted, "deleteTransaction should return true for an existing transaction.");

            // Verify the transaction is gone.
            boolean stillExists = transactionService.getAllTransactions().stream()
                    .anyMatch(t -> t.getOrderNumber().equals(orderNumberToDelete));
            System.out.println("TransactionServiceImplTest (deleteTransaction): Still exists after delete: " + stillExists);
            if (stillExists) {
                System.err.println("TransactionServiceImplTest (deleteTransaction): Deleted transaction STILL FOUND.");
                // fail("Transaction should not exist after deletion.");
            }
            // assertFalse(stillExists, "Transaction should be deleted.");
        } catch (Exception e) {
            System.err.println("TransactionServiceImplTest (deleteTransaction): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testDeleteTransaction failed", e);
        }
        System.out.println("TransactionServiceImplTest: testDeleteTransaction finished.");
    }

    @Test
    void testSearchTransaction() {
        System.out.println("TransactionServiceImplTest: Running testSearchTransaction...");
        try {
            Transaction criteria = new Transaction();
            // Assuming "Salary" or a similar term exists as a commodity in user1_transactions.csv for this test.
            // If CSV uses Chinese, and Transaction model uses English, ensure mapping or test with English term.
            criteria.setCommodity("Salary"); // Search for "Salary" in commodity. "工资" in Chinese.
            List<Transaction> results = transactionService.searchTransaction(criteria);
            System.out.println("TransactionServiceImplTest (searchTransaction): Found " + results.size() + " transactions matching commodity 'Salary'.");
            results.forEach(t -> System.out.println("  - Found: " + t.getOrderNumber() + " | " + t.getCommodity()));
            // Add assertions, e.g., assertTrue(!results.isEmpty()) if "Salary" is expected.
        } catch (Exception e) {
            System.err.println("TransactionServiceImplTest (searchTransaction): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testSearchTransaction failed", e);
        }
        System.out.println("TransactionServiceImplTest: testSearchTransaction finished.");
    }

    @Test
    void testGetMonthlyTransactionSummary() {
        System.out.println("TransactionServiceImplTest: Running testGetMonthlyTransactionSummary...");
        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("TransactionServiceImplTest (getMonthlySummary): Generated " + summaries.size() + " monthly summaries.");
            summaries.forEach((month, summary) -> {
                System.out.println("  Month: " + month + ", Income: " + summary.getTotalIncome() + ", Expense: " + summary.getTotalExpense());
                summary.getExpenseByCategory().forEach((cat, amt) -> System.out.println("    - Cat: " + cat + ", Amt: " + amt));
            });
            // Add assertions, e.g., assertFalse(summaries.isEmpty()) if data is expected.
        } catch (Exception e) {
            System.err.println("TransactionServiceImplTest (getMonthlySummary): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testGetMonthlyTransactionSummary failed", e);
        }
        System.out.println("TransactionServiceImplTest: testGetMonthlyTransactionSummary finished.");
    }

    @Test
    void testImportTransactionsFromCsv() {
        System.out.println("TransactionServiceImplTest: Running testImportTransactionsFromCsv...");
        try {
            // Ensure the import source file exists.
            Path importSourcePath = Paths.get(importTestCsvPath);
            if (!Files.exists(importSourcePath)) {
                System.err.println("TransactionServiceImplTest (import): Import source file missing: " + importTestCsvPath + ". Skipping test.");
                // fail("Import source file missing, cannot run test.");
                return;
            }

            long initialCount = transactionService.getAllTransactions().size();
            System.out.println("TransactionServiceImplTest (import): Transactions before import: " + initialCount);

            // Perform import from importTestCsvPath (e.g., admin_transactions.csv) into the temp user1 file.
            int importedCount = transactionService.importTransactionsFromCsv(testUser.getTransactionFilePath(), importTestCsvPath);
            System.out.println("TransactionServiceImplTest (import): Imported " + importedCount + " transactions.");
            // assertTrue(importedCount > 0, "Should import at least one transaction if source is not empty and has new data.");

            long finalCount = transactionService.getAllTransactions().size();
            System.out.println("TransactionServiceImplTest (import): Transactions after import: " + finalCount);

            // Basic check for count. This assumes no duplicates were skipped if importTestCsvPath
            // has unique OrderNumbers not present in the original user1_transactions.csv.
            // This check might need to be more sophisticated based on data and duplicate handling logic.
            // For example, if all imported items are new:
            // assertEquals(initialCount + importedCount, finalCount, "Final count should be initial + imported if all new.");
            // If duplicates are skipped, this assertion needs adjustment.
            if (finalCount >= initialCount + importedCount - 5 && finalCount <= initialCount + importedCount + 5) { // Allow some leeway for duplicates or variations
                System.out.println("TransactionServiceImplTest (import): Count after import seems reasonable.");
            } else {
                System.err.println("TransactionServiceImplTest (import): Count after import seems off. Initial: " + initialCount + ", Imported: " + importedCount + ", Final: " + finalCount);
                // Consider a more precise assertion if duplicate behavior is strictly defined.
            }

        } catch (Exception e) {
            System.err.println("TransactionServiceImplTest (import): Error during test.");
            e.printStackTrace();
            throw new RuntimeException("testImportTransactionsFromCsv failed", e);
        }
        System.out.println("TransactionServiceImplTest: testImportTransactionsFromCsv finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Service\TransactionServiceTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao; // This import implies you might be using it directly, which is okay for test setup
import Service.Impl.TransactionServiceImpl;
import model.Transaction;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.io.IOException;
import java.nio.file.Files; // Added for file operations if needed for setup
import java.nio.file.Path;   // Added for file operations
import java.nio.file.Paths; // Added for file operations
import java.nio.file.StandardCopyOption; // Added for file operations
import java.util.List;

// Test class for TransactionService
class TransactionServiceTest {
    private TransactionService transactionService;
    // Define a temporary file path for tests to operate on, to avoid affecting real data
    private static final String TEST_TRANSACTION_FILE_PATH = "target/test-transactions.csv"; // Example path, adjust as needed
    private static final String SAMPLE_TRANSACTION_FILE_PATH = "src/test/resources/CSVForm/transactions/user1_transactions.csv"; // A sample file to copy from

    @BeforeEach
    void setUp() throws IOException {
        // Initialize DAO and Service
        // For TransactionServiceImpl, it now expects a file path.
        // For isolated testing, it's best to use a temporary or test-specific file.
        // Copy a sample file to the test path before each test.
        Path sourcePath = Paths.get(SAMPLE_TRANSACTION_FILE_PATH);
        Path destinationPath = Paths.get(TEST_TRANSACTION_FILE_PATH);
        // Ensure parent directory for destinationPath exists
        if (destinationPath.getParent() != null) {
            Files.createDirectories(destinationPath.getParent());
        }
        if (Files.exists(sourcePath)) {
            Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);
        } else {
            // If no sample, create an empty file with headers for some tests to work (like add)
            // This part depends on how CsvTransactionDao handles empty files or if it requires headers.
            // For simplicity, this example assumes a sample file is copied.
            // If not, you might need to create an empty file or a file with just headers.
            System.err.println("Warning: Sample transaction file not found at " + SAMPLE_TRANSACTION_FILE_PATH + ". Tests might behave unexpectedly.");
            // Create an empty file if no sample (some tests might fail if they expect data)
            Files.deleteIfExists(destinationPath); // Delete if exists to start fresh
            Files.createFile(destinationPath); // Create empty file
            // Optionally write headers here if your DAO expects them for an "empty" file
        }

        transactionService = new TransactionServiceImpl(TEST_TRANSACTION_FILE_PATH);
    }

    @Test
    void testAddTransaction() throws IOException {
        // Prepare test data
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "Transfer", "Li Si", "Virtual Product", "Expense", 500.0,
                "Bank Card", "Completed", "T123456789", "M987654321", "Test"
        );

        // Perform add operation
        transactionService.addTransaction(transaction);

        // Verify if added successfully
        // Searching with an empty criteria should return all transactions
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertFalse(transactions.isEmpty(), "Transaction list should not be empty after adding.");
        // Check if the added transaction is present
        assertTrue(transactions.stream().anyMatch(t -> "T123456789".equals(t.getOrderNumber())),
                "Added transaction with OrderNumber T123456789 should be found.");
    }

    @Test
    void testChangeTransaction() throws Exception {
        // Prepare test data
        String orderNumber = "T_CHANGE_001";
        Transaction originalTransaction = new Transaction(
                "2023-08-20 15:30:00", "Transfer", "Li Si", "Virtual Product", "Expense", 500.0,
                "Bank Card", "Completed", orderNumber, "M987654321", "Original Test"
        );
        transactionService.addTransaction(originalTransaction); // Add it first

        // Prepare update data
        Transaction updatedTransactionInfo = new Transaction(
                null, "Recharge", null, null, null, 0.0,
                "WeChat Pay", null, orderNumber, null, "Updated Remark"
        ); // Only fields to be updated are set, plus the OrderNumber key

        // Perform update operation
        transactionService.changeTransaction(updatedTransactionInfo);

        // Verify if updated successfully
        Transaction searchCriteria = new Transaction();
        searchCriteria.setOrderNumber(orderNumber); // Search specifically for the updated transaction
        List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);

        assertFalse(transactions.isEmpty(), "Updated transaction should be found.");
        assertEquals(1, transactions.size(), "Should find exactly one transaction with the order number.");
        Transaction fetchedTransaction = transactions.get(0);
        assertEquals("Recharge", fetchedTransaction.getTransactionType(), "Transaction type should be updated.");
        assertEquals("WeChat Pay", fetchedTransaction.getPaymentMethod(), "Payment method should be updated.");
        assertEquals("Updated Remark", fetchedTransaction.getRemarks(), "Remarks should be updated.");
        // Verify that unchanged fields remain the same
        assertEquals("Li Si", fetchedTransaction.getCounterparty(), "Counterparty should remain unchanged.");
        assertEquals(500.0, fetchedTransaction.getPaymentAmount(), 0.01, "Amount should remain unchanged as per update logic.");
    }

    @Test
    void testDeleteTransaction() throws Exception {
        // Prepare test data
        String orderNumberToDelete = "T_DELETE_002";
        Transaction transaction = new Transaction(
                "2023-08-21 10:00:00", "Sale", "Wang Wu", "Physical Product", "Income", 300.0,
                "Alipay", "Completed", orderNumberToDelete, "M_DEL_002", "To Delete"
        );
        transactionService.addTransaction(transaction); // Add it first

        // Perform delete operation
        boolean result = transactionService.deleteTransaction(orderNumberToDelete);

        // Verify if deleted successfully
        assertTrue(result, "Deletion should be successful for an existing transaction.");
        Transaction searchCriteria = new Transaction();
        searchCriteria.setOrderNumber(orderNumberToDelete);
        List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);
        assertTrue(transactions.isEmpty(), "Transaction should no longer be found after deletion.");
    }

    @Test
    void testSearchTransaction() throws IOException {
        // Setup: Add a specific transaction to ensure search criteria can find something
        Transaction txToFind = new Transaction(
                "2023-08-22 11:00:00", "Payment", "Alipay", "Service Fee", "Expense", 25.0,
                "Balance", "Done", "T_SEARCH_003", "M_SEARCH_003", "Alipay search test"
        );
        transactionService.addTransaction(txToFind);


        // Set search criteria
        Transaction searchCriteria = new Transaction();
        searchCriteria.setCounterparty("Alipay"); // Search for transactions with counterparty "Alipay"

        // Perform search operation
        List<Transaction> result = transactionService.searchTransaction(searchCriteria);

        // Verify search result
        assertFalse(result.isEmpty(), "Search results should not be empty if matching data exists/was added.");
        result.forEach(res -> {
            System.out.println("Found Commodity: " + res.getCommodity() + " for Counterparty: " + res.getCounterparty());
            assertEquals("Alipay", res.getCounterparty(), "All results should have 'Alipay' as counterparty.");
        });
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Service\User\UserServiceTest.java`:

```java
package Service.User;

import DAO.Impl.CsvUserDao;
import DAO.UserDao;
import model.User;
import Constants.ConfigConstants;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

public class UserServiceTest {

    private UserService userService;

    @BeforeEach
    void setUp() {
        UserDao userDao = new CsvUserDao(ConfigConstants.USERS_CSV_PATH);
        userService = new UserService(userDao);
    }

    @Test
    void testAuthenticate_Success() {
        System.out.println("UserServiceTest: Running testAuthenticate_Success...");
        User user = userService.authenticate("admin", "admin123");
        if (user != null) {
            System.out.println("UserServiceTest (auth_success): Authenticated user: " + user.getUsername() + " with role: " + user.getRole());
        } else {
            System.err.println("UserServiceTest (auth_success): Authentication FAILED for admin.");
        }
        System.out.println("UserServiceTest: testAuthenticate_Success finished.");
    }

    @Test
    void testAuthenticate_Failure_WrongPassword() {
        System.out.println("UserServiceTest: Running testAuthenticate_Failure_WrongPassword...");
        User user = userService.authenticate("user1", "wrongpassword");
        if (user == null) {
            System.out.println("UserServiceTest (auth_fail_pwd): Authentication correctly failed for user1 with wrong password.");
        } else {
            System.err.println("UserServiceTest (auth_fail_pwd): Authentication INCORRECTLY succeeded for user1 with wrong password.");
        }
        System.out.println("UserServiceTest: testAuthenticate_Failure_WrongPassword finished.");
    }

    @Test
    void testAuthenticate_Failure_UnknownUser() {
        System.out.println("UserServiceTest: Running testAuthenticate_Failure_UnknownUser...");
        User user = userService.authenticate("unknownuser", "somepassword");
        if (user == null) {
            System.out.println("UserServiceTest (auth_fail_user): Authentication correctly failed for unknownuser.");
        } else {
            System.err.println("UserServiceTest (auth_fail_user): Authentication INCORRECTLY succeeded for unknownuser.");
        }
        System.out.println("UserServiceTest: testAuthenticate_Failure_UnknownUser finished.");
    }

    @Test
    void testGetUserByUsername() {
        System.out.println("UserServiceTest: Running testGetUserByUsername...");
        User user = userService.getUserByUsername("user2");
        if (user != null) {
            System.out.println("UserServiceTest (getByUsername): Found user: " + user.getUsername() + ", File: " + user.getTransactionFilePath());
        } else {
            System.err.println("UserServiceTest (getByUsername): User 'user2' NOT FOUND.");
        }

        User nonExistentUser = userService.getUserByUsername("no_such_user");
        if (nonExistentUser == null) {
            System.out.println("UserServiceTest (getByUsername): Correctly did not find 'no_such_user'.");
        } else {
            System.err.println("UserServiceTest (getByUsername): INCORRECTLY found 'no_such_user'.");
        }
        System.out.println("UserServiceTest: testGetUserByUsername finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\java\Utils\CacheManagerTest.java`:

```java
package Utils;

import DAO.Impl.CsvTransactionDao;
import DAO.TransactionDao;
import model.Transaction;
import Constants.CaffeineKeys;
import Constants.ConfigConstants; // For a sample file path

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.List;

public class CacheManagerTest {

    private TransactionDao transactionDao;
    private Path tempFilePath;
    // Use a known existing file for setting up the temp file
    private final String sampleTransactionFilePath = "src/test/resources/CSVForm/transactions/admin_transactions.csv";


    @BeforeEach
    void setUp() throws IOException {
        transactionDao = new CsvTransactionDao();
        Path originalPath = Paths.get(sampleTransactionFilePath);
        tempFilePath = Files.createTempFile("cache_manager_test_", ".csv");
        Files.copy(originalPath, tempFilePath, StandardCopyOption.REPLACE_EXISTING);
        System.out.println("CacheManagerTest: Set up with temp file: " + tempFilePath.toString());
    }

    @AfterEach
    void tearDown() throws IOException {
        if (tempFilePath != null && Files.exists(tempFilePath)) {
            Files.delete(tempFilePath);
            System.out.println("CacheManagerTest: Deleted temp file: " + tempFilePath.toString());
        }
        // Clean up the cache for this file path to avoid interference between tests
        CacheManager.invalidateTransactionCache(tempFilePath.toString());
        // Optionally, if fileCaches map allows removal:
        // CacheManager.fileCaches.remove(tempFilePath.toString());
    }

    @Test
    void testGetTransactions_LoadsAndCaches() {
        System.out.println("CacheManagerTest: Running testGetTransactions_LoadsAndCaches...");
        try {
            System.out.println("CacheManagerTest: First call to getTransactions for: " + tempFilePath.toString());
            List<Transaction> transactions1 = CacheManager.getTransactions(tempFilePath.toString(), transactionDao);
            System.out.println("CacheManagerTest: Loaded " + transactions1.size() + " transactions (call 1).");

            System.out.println("CacheManagerTest: Second call to getTransactions for: " + tempFilePath.toString());
            List<Transaction> transactions2 = CacheManager.getTransactions(tempFilePath.toString(), transactionDao);
            System.out.println("CacheManagerTest: Loaded " + transactions2.size() + " transactions (call 2 - should be cached).");

            // Simple check: sizes should be the same.
            if (transactions1.size() == transactions2.size()) {
                System.out.println("CacheManagerTest: Sizes match, caching likely worked.");
            } else {
                System.err.println("CacheManagerTest: Sizes MISMATCH. Caching might have issues.");
            }

        } catch (Exception e) {
            System.err.println("CacheManagerTest (getTransactions): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("CacheManagerTest: testGetTransactions_LoadsAndCaches finished.");
    }

    @Test
    void testPutAndInvalidateTransactions() {
        System.out.println("CacheManagerTest: Running testPutAndInvalidateTransactions...");
        try {
            // Get initial state
            List<Transaction> initialTransactions = CacheManager.getTransactions(tempFilePath.toString(), transactionDao);
            System.out.println("CacheManagerTest: Initial transactions count: " + initialTransactions.size());

            // Create a new list and put it into cache
            List<Transaction> manualList = new ArrayList<>();
            manualList.add(new Transaction("2024/04/01", "ManualPut", "MP_C", "MP_I", "支出", 1.0, "MP_P", "OK", "MP_ON", "MP_M", "Manual"));

            System.out.println("CacheManagerTest: Putting manual list with " + manualList.size() + " transaction(s) into cache for: " + tempFilePath.toString());
            CacheManager.putTransactions(tempFilePath.toString(), manualList, transactionDao);

            List<Transaction> afterPut = CacheManager.getTransactions(tempFilePath.toString(), transactionDao);
            System.out.println("CacheManagerTest: Transactions count after put: " + afterPut.size());
            if (afterPut.size() == manualList.size()) {
                System.out.println("CacheManagerTest: 'putTransactions' seems to have updated the cache.");
            } else {
                System.err.println("CacheManagerTest: 'putTransactions' did NOT update cache as expected.");
            }

            // Invalidate and get again (should reload from file, which still has original content)
            System.out.println("CacheManagerTest: Invalidating cache for: " + tempFilePath.toString());
            CacheManager.invalidateTransactionCache(tempFilePath.toString());

            List<Transaction> afterInvalidate = CacheManager.getTransactions(tempFilePath.toString(), transactionDao);
            System.out.println("CacheManagerTest: Transactions count after invalidate and get: " + afterInvalidate.size());
            if (afterInvalidate.size() == initialTransactions.size()) {
                System.out.println("CacheManagerTest: Cache invalidation and reload from original file content worked.");
            } else {
                System.err.println("CacheManagerTest: Cache invalidation or reload FAILED. Expected " + initialTransactions.size() + ", got " + afterInvalidate.size());
            }

        } catch (Exception e) {
            System.err.println("CacheManagerTest (putInvalidate): Error.");
            e.printStackTrace();
            throw new RuntimeException(e);
        }
        System.out.println("CacheManagerTest: testPutAndInvalidateTransactions finished.");
    }
}
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\resources\CSVForm\stats\summary_statistics.csv`:

```csv
week_identifier,total_income_all_users,total_expense_all_users,top_expense_category,top_expense_category_amount,number_of_users_with_transactions,timestamp_generated
2022-W37,0.0,5000.0,Other Expenses,5000.0,1,2025-05-22 23:34:23
2025-W09,10000.0,20000.0,No Expense,0.0,3,2025-05-22 23:34:23
2025-W10,0.0,751.5,Other Expenses,751.5,3,2025-05-22 23:34:23
2025-W11,0.0,257.25,Dining,107.25,3,2025-05-22 23:34:23
2025-W12,0.0,15000.0,Other Expenses,10000.0,3,2025-05-22 23:34:23
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\resources\CSVForm\transactions\admin_transactions.csv`:

```csv
Transaction Time,Transaction Type,Counterparty,Commodity,In/Out,Amount(CNY),Payment Method,Current Status,Order Number,Merchant Number,Remarks
2025/03/01 09:00:00,Salary,Company A,March Salary,Expense,¥10000.00,Bank Card,Credited,SALARY_MAR_A,PAYROLL_A_001,This month's base salary
2025/03/05 14:30:00,Groceries,Supermarket B,Groceries,Expense,¥250.50,Alipay,Completed,SHOP_B_001,ALIPAY_12345,Weekend shopping
2025/03/10 10:00:00,Transfer,User 1,Lunch Reimbursement,Expense,¥50.00,WeChat Pay,Completed,TRANSFER_U1_001,WECHAT_56789,Returning lunch money
2025/03/15 11:00:00,Dining,Restaurant C,Lunch Takeaway,Expense,¥35.75,Meituan Pay,Completed,MEAL_C_001,MEITUAN_11223,Workday lunch
2025/03/20 16:00:00,Investment,Stock Account,Stock Purchase,Expense,¥5000.00,Bank Transfer,Completed,INVEST_STOCK_001,BANK_99887,Long-term investment
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\resources\CSVForm\transactions\user1_transactions.csv`:

```csv
Transaction Time,Transaction Type,Counterparty,Commodity,In/Out,Amount(CNY),Payment Method,Current Status,Order Number,Merchant Number,Remarks
2025/03/01 09:00:00,Salary,Company A,March Salary,Expense,¥10000.00,Bank Card,Credited,SALARY_MAR_A,PAYROLL_A_001,This month's base salary
2025/03/05 14:30:00,Groceries,Supermarket B,Groceries,Expense,¥250.50,Alipay,Completed,SHOP_B_001,ALIPAY_12345,Weekend shopping
2025/03/10 10:00:00,Transfer,User 1,Lunch Reimbursement,Expense,¥50.00,WeChat Pay,Completed,TRANSFER_U1_001,WECHAT_56789,Returning lunch money
2025/03/15 11:00:00,Dining,Restaurant C,Lunch Takeaway,Expense,¥35.75,Meituan Pay,Completed,MEAL_C_001,MEITUAN_11223,Workday lunch
2025/03/20 16:00:00,Investment,Stock Account,Stock Purchase,Expense,¥5000.00,Bank Transfer,Completed,INVEST_STOCK_001,BANK_99887,Long-term investment
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\resources\CSVForm\transactions\user2_transactions.csv`:

```csv
Transaction Time,Transaction Type,Counterparty,Commodity,In/Out,Amount(CNY),Payment Method,Current Status,Order Number,Merchant Number,Remarks
2025/03/01 09:00:00,Salary,Company A,March Salary,Expense,¥10000.00,Bank Card,Credited,SALARY_MAR_A,PAYROLL_A_001,This month's base salary
2025/03/05 14:30:00,Groceries,Supermarket B,Groceries,Expense,¥250.50,Alipay,Completed,SHOP_B_001,ALIPAY_12345,Weekend shopping
2025/03/10 10:00:00,Transfer,User 1,Lunch Reimbursement,Expense,¥50.00,WeChat Pay,Completed,TRANSFER_U1_001,WECHAT_56789,Returning lunch money
2025/03/15 11:00:00,Dining,Restaurant C,Lunch Takeaway,Expense,¥35.75,Meituan Pay,Completed,MEAL_C_001,MEITUAN_11223,Workday lunch
2025/03/20 16:00:00,Investment,Stock Account,Stock Purchase,Expense,¥5000.00,Bank Transfer,Completed,INVEST_STOCK_001,BANK_99887,Long-term investment
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\resources\CSVForm\users\users.csv`:

```csv
username,password,role,transaction_csv_path
admin,admin123,admin,Ai Bill Application/src/test/resources/CSVForm/transactions/admin_transactions.csv
user1,pass123,user,Ai Bill Application/src/test/resources/CSVForm/transactions/user1_transactions.csv
user2,securepwd,user,Ai Bill Application/src/test/resources/CSVForm/transactions/user2_transactions.csv

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai Bill Application\src\test\resources\config.properties`:

```properties
# config.properties
#csv.path=src/main/resources/CSVForm/0001.csv # 保持 main 路径，或者指向测试数据
csv.path=src/test/resources/CSVForm/transactions/admin_transactions.csv
csv.users_path=src/test/resources/CSVForm/users/users.csv
csv.summary_path=src/test/resources/CSVForm/stats/summary_statistics.csv
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai-Bill-Application-Prompt.txt`:

```txt
Project Path: Ai-Bill-Application-Group21

Source Tree:

```txt
软工
├── Ai-Bill-Application-Group21
│   ├── Ai Bill Application
│   │   ├── HistogramPanelContainer.java
│   │   ├── pom.xml
│   │   └── src
│   │       ├── main
│   │       │   ├── java
│   │       │   │   ├── Constants
│   │       │   │   │   ├── CaffeineKeys.java
│   │       │   │   │   ├── ConfigConstants.java
│   │       │   │   │   └── StandardCategories.java
│   │       │   │   ├── Controller
│   │       │   │   │   ├── ButtonEditor.java
│   │       │   │   │   ├── ButtonRenderer.java
│   │       │   │   │   ├── HistogramExample.java
│   │       │   │   │   ├── HistogramPanelContainer.java
│   │       │   │   │   ├── MenuUI.java
│   │       │   │   │   └── VisualizationPanel.java
│   │       │   │   ├── DAO
│   │       │   │   │   ├── Impl
│   │       │   │   │   │   ├── CsvSummaryStatisticDao.java
│   │       │   │   │   │   ├── CsvTransactionDao.java
│   │       │   │   │   │   └── CsvUserDao.java
│   │       │   │   │   ├── SummaryStatisticDao.java
│   │       │   │   │   ├── TransactionDao.java
│   │       │   │   │   └── UserDao.java
│   │       │   │   ├── Interceptor
│   │       │   │   │   └── Login
│   │       │   │   │       └── LoginDialog.java
│   │       │   │   ├── Main.java
│   │       │   │   ├── Service
│   │       │   │   │   ├── AIservice
│   │       │   │   │   │   ├── AIAnalyzerThread.java
│   │       │   │   │   │   ├── AITransactionService.java
│   │       │   │   │   │   ├── ColledgeStudentThread.java
│   │       │   │   │   │   └── CollegeStudentNeeds.java
│   │       │   │   │   ├── Impl
│   │       │   │   │   │   ├── SummaryStatisticService.java
│   │       │   │   │   │   └── TransactionServiceImpl.java
│   │       │   │   │   ├── TransactionService.java
│   │       │   │   │   ├── User
│   │       │   │   │   │   └── UserService.java
│   │       │   │   │   └── deepseek
│   │       │   │   │       └── ChatCompletionsExample.java
│   │       │   │   ├── Utils
│   │       │   │   │   ├── CacheManager.java
│   │       │   │   │   └── CacheUtil.java
│   │       │   │   └── model
│   │       │   │       ├── MonthlySummary.java
│   │       │   │       ├── SummaryStatistic.java
│   │       │   │       ├── Transaction.java
│   │       │   │       └── User.java
│   │       │   └── resources
│   │       │       ├── CSVForm
│   │       │       │   ├── stats
│   │       │       │   │   └── summary_statistics.csv
│   │       │       │   ├── transactions
│   │       │       │   │   ├── admin_transactions.csv
│   │       │       │   │   ├── user1_transactions.csv
│   │       │       │   │   └── user2_transactions.csv
│   │       │       │   └── users
│   │       │       │       └── users.csv
│   │       │       └── config.properties
│   │       └── test
│   │           ├── java
│   │           │   ├── ControllerTest
│   │           │   │   ├── AITest.java
│   │           │   │   └── MenuUITest.java
│   │           │   ├── DAOTest
│   │           │   │   └── CsvTransactionDaoTest.java
│   │           │   └── Service
│   │           │       ├── AIAnalyzerThreadTest.java
│   │           │       ├── AIserviceTest.java
│   │           │       ├── AiFunctionTest.java
│   │           │       ├── CacheTest.java
│   │           │       ├── CollegeStudentNeedsTest.java
│   │           │       └── TransactionServiceTest.java
│   │           └── resources
│   │               └── CSVForm
│   │                   ├── transactions
│   │                   │   ├── admin_transactions.csv
│   │                   │   ├── user1_transactions.csv
│   │                   │   └── user2_transactions.csv
│   │                   └── users
│   │                       └── users.csv
│   ├── Ai-Bill-Application-Prompt.txt
│   ├── README.md
│   ├── README.txt
│   ├── img.png
│   ├── 开发文档.docx
│   └── 项目要求.txt
├── Ai-Bill-Application-Group21 - 副本
│   ├── Ai Bill Application
│   │   ├── HistogramPanelContainer.java
│   │   ├── pom.xml
│   │   └── src
│   │       ├── main
│   │       │   ├── java
│   │       │   │   ├── Constants
│   │       │   │   │   ├── CaffeineKeys.java
│   │       │   │   │   └── ConfigConstants.java
│   │       │   │   ├── Controller
│   │       │   │   │   ├── ButtonEditor.java
│   │       │   │   │   ├── ButtonRenderer.java
│   │       │   │   │   ├── HistogramExample.java
│   │       │   │   │   ├── HistogramPanelContainer.java
│   │       │   │   │   └── MenuUI.java
│   │       │   │   ├── DAO
│   │       │   │   │   ├── CsvTransactionDao.java
│   │       │   │   │   └── TransactionDao.java
│   │       │   │   ├── Interceptor
│   │       │   │   │   └── Login
│   │       │   │   │       ├── LoginDialog.java
│   │       │   │   │       └── UserService.java
│   │       │   │   ├── Main.java
│   │       │   │   ├── Service
│   │       │   │   │   ├── AIservice
│   │       │   │   │   │   ├── AIAnalyzerThread.java
│   │       │   │   │   │   ├── AITransactionService.java
│   │       │   │   │   │   ├── ColledgeStudentThread.java
│   │       │   │   │   │   └── CollegeStudentNeeds.java
│   │       │   │   │   ├── Impl
│   │       │   │   │   │   └── TransactionServiceImpl.java
│   │       │   │   │   ├── TransactionService.java
│   │       │   │   │   └── deepseek
│   │       │   │   │       └── ChatCompletionsExample.java
│   │       │   │   ├── Utils
│   │       │   │   │   └── CacheUtil.java
│   │       │   │   └── model
│   │       │   │       └── Transaction.java
│   │       │   └── resources
│   │       │       ├── CSVForm
│   │       │       │   └── 0001.csv
│   │       │       └── config.properties
│   │       └── test
│   │           ├── java
│   │           │   ├── ControllerTest
│   │           │   │   ├── AITest.java
│   │           │   │   └── MenuUITest.java
│   │           │   ├── DAOTest
│   │           │   │   └── CsvTransactionDaoTest.java
│   │           │   └── Service
│   │           │       ├── AIAnalyzerThreadTest.java
│   │           │       ├── AIserviceTest.java
│   │           │       ├── AiFunctionTest.java
│   │           │       ├── CacheTest.java
│   │           │       ├── CollegeStudentNeedsTest.java
│   │           │       └── TransactionServiceTest.java
│   │           └── resources
│   ├── Ai-Bill-Application-Prompt.txt
│   ├── README.md
│   ├── README.txt
│   ├── img.png
│   └── 项目要求.txt
├── Lab5,6-Demostration-Vid.mp4
├── Labs
│   └── lab6
├── Submission
│   ├── Labs
│   │   ├── lab5
│   │   │   ├── lab5.iml
│   │   │   ├── out
│   │   │   │   └── production
│   │   │   │       └── lab5
│   │   │   │           ├── lab5.iml
│   │   │   │           ├── src
│   │   │   │           │   ├── main
│   │   │   │           │   │   └── java
│   │   │   │           │   │       └── DegreeClassifier.class
│   │   │   │           │   └── test
│   │   │   │           │       └── java
│   │   │   │           │           └── DegreeClassifierTest.class
│   │   │   │           └── untitled
│   │   │   ├── src
│   │   │   │   ├── main
│   │   │   │   │   └── java
│   │   │   │   │       └── DegreeClassifier.java
│   │   │   │   └── test
│   │   │   │       └── java
│   │   │   │           └── DegreeClassifierTest.java
│   │   │   └── untitled
│   │   └── lab6
│   │       ├── lab6.iml
│   │       ├── out
│   │       │   └── production
│   │       │       └── lab6
│   │       │           ├── lab6.iml
│   │       │           └── src
│   │       │               ├── main
│   │       │               │   └── java
│   │       │               │       └── DegreeClassifier.class
│   │       │               └── test
│   │       │                   └── java
│   │       │                       └── DegreeClassifierTest.class
│   │       └── src
│   │           ├── main
│   │           │   └── java
│   │           │       └── DegreeClassifier.java
│   │           └── test
│   │               └── java
│   │                   └── DegreeClassifierTest.java
│   └── Submission(Test & Production)
│       ├── Production
│       │   ├── DegreeClassifierLab5.java
│       │   └── DegreeClassifierLab6.java
│       └── Test
│           ├── DegreeClassifierTestLab5.java
│           └── DegreeClassifierTestLab6.java
├── Submission.zip
├── UI.png
└── 大代码
    ├── MenuUI-post.txt
    └── MenuUI-pre.txt

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>Ai-bill</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.2</version>
            <scope>test</scope>
        </dependency>

        <!-- CSV 解析核心库 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-csv</artifactId>
            <version>1.10.0</version>
        </dependency>

        <!-- 文件操作工具 -->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>2.15.1</version>
        </dependency>

        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>5.10.0</version>
            <scope>test</scope>
        </dependency>

        <!-- 断言增强库 -->
        <dependency>
            <groupId>org.assertj</groupId>
            <artifactId>assertj-core</artifactId>
            <version>3.24.2</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.volcengine</groupId>
            <artifactId>volcengine-java-sdk-ark-runtime</artifactId>
            <version>LATEST</version>
        </dependency>
        <dependency>
            <groupId>javax.annotation</groupId>
            <artifactId>javax.annotation-api</artifactId>
            <version>1.3.2</version>
        </dependency>
        <!-- pom.xml -->



        <!-- JSON 处理 -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.15.2</version>
        </dependency>

        <!--        caffeine缓存中间件-->
        <dependency>
            <groupId>com.github.ben-manes.caffeine</groupId>
            <artifactId>caffeine</artifactId>
            <version>3.1.8</version> <!-- 使用最新版本 -->
        </dependency>

    </dependencies>

</project>
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Constants\CaffeineKeys.java`:

```java
package Constants;

public class CaffeineKeys {
    public static final String TRANSACTION_CAFFEINE_KEY = "transactions";

}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Constants\ConfigConstants.java`:

```java
package Constants;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

/**
 * 配置常量类（线程安全初始化）
 */
public final class ConfigConstants {
    // 私有构造防止实例化
    private ConfigConstants() {}

    /**
     * transactionCSV路径加载逻辑
     */
    // CSV路径常量
    public static final String CSV_PATH;
    // 静态初始化块（类加载时执行）
    static {
        Properties prop = new Properties();
        try (InputStream input = ConfigConstants.class.getClassLoader()
                .getResourceAsStream("config.properties")) {

            prop.load(input);
            CSV_PATH = prop.getProperty("csv.path");
        } catch (IOException e) {
            throw new RuntimeException("加载配置文件失败", e); // 转换为运行时异常
        }
    }
}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Controller\ButtonEditor.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.TableCellEditor;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

class ButtonEditor extends AbstractCellEditor implements TableCellEditor {
    private final JPanel panel = new JPanel(new BorderLayout()); // 使用 BorderLayout
    private final JButton button = new JButton();
    private int rowIndex;
    private final MenuUI menuUI;

    public ButtonEditor(MenuUI menuUI) {
        this.menuUI = menuUI;

        // 设置按钮样式
        button.setFocusPainted(false); // 移除按钮的焦点边框
        button.setPreferredSize(new Dimension(80, 30)); // 设置按钮的固定尺寸

        // 添加按钮到面板
        panel.add(button, BorderLayout.CENTER);

        // 为按钮添加事件监听器
        button.addActionListener(e -> {
            System.out.println("按钮点击事件触发: " + button.getText());
            fireEditingStopped(); // 停止编辑
            String buttonText = button.getText();
            if ("Modify".equals(buttonText)) {
                menuUI.editRow(rowIndex); // 调用 MenuUI 的 editRow 方法
            } else if ("Delete".equals(buttonText)) {
                int confirm = JOptionPane.showConfirmDialog(panel, "确定要删除此行吗？", "确认删除", JOptionPane.YES_NO_OPTION);
                if (confirm == JOptionPane.YES_OPTION) {
                    menuUI.deleteRow(rowIndex); // 调用 MenuUI 的 deleteRow 方法
                }
            }
        });
    }

    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
        this.rowIndex = row; // 更新当前行索引
        button.setText(value != null ? value.toString() : ""); // 根据单元格的值设置按钮文本
        return panel;
    }

    @Override
    public Object getCellEditorValue() {
        return button.getText(); // 返回按钮的当前文本
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Controller\ButtonRenderer.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import java.awt.*;

class ButtonRenderer extends DefaultTableCellRenderer {
    private final JPanel panel = new JPanel(new BorderLayout()); // 使用 BorderLayout
    private final JButton button = new JButton();

    public ButtonRenderer() {
        button.setFocusPainted(false); // 移除按钮的焦点边框
        button.setPreferredSize(new Dimension(80, 30)); // 设置按钮的固定尺寸
        panel.add(button, BorderLayout.CENTER); // 将按钮添加到面板中心
    }

    @Override
    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
        // 根据单元格的值设置按钮文本
        button.setText(value != null ? value.toString() : "");
        return panel;
    }
}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Controller\HistogramExample.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;
import java.util.HashMap;
import java.util.Random;

// 数据生成类
class DataGenerator {
    public static int[] generateData(int numberOfDataPoints, int maxValue) {
        Random random = new Random();
        int[] data = new int[numberOfDataPoints];
        for (int i = 0; i < numberOfDataPoints; i++) {
            data[i] = random.nextInt(maxValue);
        }
        return data;
    }
}

// 直方图计算类
class Histogram {
    private int binSize;
    private int[] data;

    public Histogram(int[] data, int binSize) {
        this.data = data;
        this.binSize = binSize;
    }

    public HashMap<Integer, Integer> computeFrequency() {
        HashMap<Integer, Integer> frequencyMap = new HashMap<>();
        for (int number : data) {
            int bin = number / binSize;
            frequencyMap.put(bin, frequencyMap.getOrDefault(bin, 0) + 1);
        }
        return frequencyMap;
    }
}

// 直方图 GUI 绘制类
class HistogramPanel extends JPanel {
    HashMap<Integer, Integer> frequencyMap;

    public HistogramPanel() {
        this.frequencyMap = new HashMap<>();
    }

    public void updateData(HashMap<Integer, Integer> frequencyMap) {
        this.frequencyMap = frequencyMap;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        int barWidth = 40;
        int gap = 10;
        int maxFrequency = frequencyMap.values().stream().mapToInt(v -> v).max().orElse(1);

        int index = 0;
        for (Integer key : frequencyMap.keySet()) {
            int height = (int) ((frequencyMap.get(key) / (double) maxFrequency) * getHeight());
            g.setColor(Color.BLUE);
            g.fillRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.setColor(Color.BLACK);
            g.drawRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.drawString("Bin " + key, index * (barWidth + gap) + 5, getHeight() - 5);
            index++;
        }
    }
}


// 主窗口类
public class HistogramExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("数据分析界面");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Controller\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Controller\MenuUI.java`:

```java
package Controller;

import Constants.ConfigConstants;
import DAO.CsvTransactionDao;

import Service.Impl.TransactionServiceImpl;

import Service.Impl.TransactionServiceImpl;

import Utils.CacheUtil;
import model.Transaction;

import javax.swing.*;
import java.awt.*;
import java.io.IOException;
import java.util.List;
import java.util.Vector;
import javax.swing.table.DefaultTableModel;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class MenuUI {
    private static final String FILE_PATH = CSV_PATH;
    private static DefaultTableModel tableModel;
    private static Vector<Vector<String>> allData = new Vector<>();
    private static TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());
    private JTable table;  // 把table定义为静态字段
    private HistogramPanelContainer histogramPanelContainer; // 添加 HistogramPanelContainer 实例
    private JPanel rightPanel; // 右边的面板，用于显示搜索和表格界面或 AI 界面
    private CardLayout cardLayout; // 用于管理界面切换的布局

    public MenuUI(){
        String[] columnNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注", "Modify", "Delete"};
        tableModel = new DefaultTableModel(columnNames, 0);
        table = new JTable(tableModel);

        histogramPanelContainer = new HistogramPanelContainer(); // 初始化 HistogramPanelContainer
        cardLayout = new CardLayout(); // 初始化 CardLayout
        rightPanel = new JPanel(cardLayout); // 初始化 rightPanel
    }

    public JPanel createMainPanel() {
        // 主面板，使用 BorderLayout
        JPanel mainPanel = new JPanel(new BorderLayout());

        // 左边的面板，包含 Menu 和 AI 按钮
        JPanel leftPanel = createLeftPanel();
        mainPanel.add(leftPanel, BorderLayout.WEST);

        // 右边的面板，用于显示搜索和表格界面或 AI 界面
        setupRightPanel();
        mainPanel.add(rightPanel, BorderLayout.CENTER);

        return mainPanel;
    }

    // 创建左边的面板，包含 Menu 和 AI 按钮
    private JPanel createLeftPanel() {
        JPanel leftPanel = new JPanel(new GridLayout(2, 1));
        JButton menuButton = new JButton("Menu");
        JButton aiButton = new JButton("AI");

        leftPanel.add(menuButton);
        leftPanel.add(aiButton);

        // 为 Menu 按钮添加 ActionListener
        menuButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Table"); // 切换到表格界面
        });

        // 为 AI 按钮添加 ActionListener
        aiButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Histogram"); // 切换到直方图界面
        });

        return leftPanel;
    }

    // 设置右边的面板，包含搜索和表格界面或 AI 界面
    private void setupRightPanel() {
        // 创建搜索和表格的面板
        JPanel tablePanel = createTablePanel();

        // 将表格面板和直方图面板添加到 rightPanel
        rightPanel.add(tablePanel, "Table");
        rightPanel.add(histogramPanelContainer, "Histogram");
    }

    // 创建搜索和表格的面板
    private JPanel createTablePanel() {
        JPanel tablePanel = new JPanel(new BorderLayout());

        // 创建输入面板
        JPanel inputPanel = createInputPanel();
        tablePanel.add(inputPanel, BorderLayout.NORTH);

        // 创建表格的滚动面板
        JScrollPane tableScrollPane = new JScrollPane(table);
        tableScrollPane.setPreferredSize(new Dimension(1000, 250));
        table.setRowHeight(30); // 设置表格的行高

        tablePanel.add(tableScrollPane, BorderLayout.CENTER);

        // 为 Modify 列设置渲染器和编辑器
        table.getColumnModel().getColumn(11).setCellRenderer(new ButtonRenderer());
        table.getColumnModel().getColumn(11).setCellEditor(new ButtonEditor(this));

        // 为 Delete 列设置渲染器和编辑器
        table.getColumnModel().getColumn(12).setCellRenderer(new ButtonRenderer());
        table.getColumnModel().getColumn(12).setCellEditor(new ButtonEditor(this));

        // 加载 CSV 数据
        loadCSVData(FILE_PATH);

        return tablePanel;
    }

    // 创建输入面板
    private JPanel createInputPanel() {
        JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));

        // 创建输入字段
        JTextField transactionTimeField = new JTextField(10); // 交易时间输入框
        JTextField transactionTypeField = new JTextField(10); // 交易类型输入框
        JTextField counterpartyField = new JTextField(10);    // 交易对方输入框
        JTextField commodityField = new JTextField(10);      // 商品输入框
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"}); // 收/支下拉框
        JTextField paymentMethodField = new JTextField(10);  // 支付方式输入框

        // 添加标签和输入字段到输入面板
        inputPanel.add(new JLabel("交易时间:"));
        inputPanel.add(transactionTimeField);
        inputPanel.add(new JLabel("交易类型:"));
        inputPanel.add(transactionTypeField);
        inputPanel.add(new JLabel("交易对方:"));
        inputPanel.add(counterpartyField);
        inputPanel.add(new JLabel("商品:"));
        inputPanel.add(commodityField);
        inputPanel.add(new JLabel("收/支:"));
        inputPanel.add(inOutComboBox);
        inputPanel.add(new JLabel("支付方式:"));
        inputPanel.add(paymentMethodField);

        // 创建 Search 和 Add 按钮
        JButton searchButton = new JButton("Search");
        JButton addButton = new JButton("Add");

        // 将按钮添加到输入面板
        inputPanel.add(searchButton);
        inputPanel.add(addButton);

        // 为 Search 按钮添加 ActionListener
        searchButton.addActionListener(e -> {
            // 获取输入字段的值
            searchData(
                    transactionTimeField.getText().trim(),
                    transactionTypeField.getText().trim(),
                    counterpartyField.getText().trim(),
                    commodityField.getText().trim(),
                    (String) inOutComboBox.getSelectedItem(),
                    paymentMethodField.getText().trim()
            );
        });

        // 为 Add 按钮添加 ActionListener
        addButton.addActionListener(e -> {
            // 弹出对话框，输入交易信息
            showAddTransactionDialog();
        });

        return inputPanel;
    }

    // 弹出对话框，输入交易信息
    private void showAddTransactionDialog() {
        // 创建对话框
        JDialog addDialog = new JDialog();
        addDialog.setTitle("添加交易");
        addDialog.setLayout(new GridLayout(12, 2)); // 11 个字段 + 1 个按钮行

        // 创建输入字段
        JTextField transactionTimeField = new JTextField();
        JTextField transactionTypeField = new JTextField();
        JTextField counterpartyField = new JTextField();
        JTextField commodityField = new JTextField();
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"});
        JTextField paymentAmountField = new JTextField();
        JTextField paymentMethodField = new JTextField();
        JTextField currentStatusField = new JTextField();
        JTextField orderNumberField = new JTextField();
        JTextField merchantNumberField = new JTextField();
        JTextField remarksField = new JTextField();

        // 添加标签和输入字段到对话框
        addDialog.add(new JLabel("交易时间:"));
        addDialog.add(transactionTimeField);
        addDialog.add(new JLabel("交易类型:"));
        addDialog.add(transactionTypeField);
        addDialog.add(new JLabel("交易对方:"));
        addDialog.add(counterpartyField);
        addDialog.add(new JLabel("商品:"));
        addDialog.add(commodityField);
        addDialog.add(new JLabel("收/支:"));
        addDialog.add(inOutComboBox);
        addDialog.add(new JLabel("金额(元):"));
        addDialog.add(paymentAmountField);
        addDialog.add(new JLabel("支付方式:"));
        addDialog.add(paymentMethodField);
        addDialog.add(new JLabel("当前状态:"));
        addDialog.add(currentStatusField);
        addDialog.add(new JLabel("交易单号:"));
        addDialog.add(orderNumberField);
        addDialog.add(new JLabel("商户单号:"));
        addDialog.add(merchantNumberField);
        addDialog.add(new JLabel("备注:"));
        addDialog.add(remarksField);

        // 添加确认按钮
        JButton confirmButton = new JButton("确认");
        confirmButton.addActionListener(e -> {
            // 获取输入字段的值，若为空则设置为默认值
            String transactionTime = emptyIfNull(transactionTimeField.getText().trim());
            String transactionType = emptyIfNull(transactionTypeField.getText().trim());
            String counterparty = emptyIfNull(counterpartyField.getText().trim());
            String commodity = emptyIfNull(commodityField.getText().trim());
            String inOut = (String) inOutComboBox.getSelectedItem();
            String paymentAmountText = paymentAmountField.getText().trim();
            double paymentAmount = paymentAmountText.isEmpty() ? 0.0 : Double.parseDouble(paymentAmountText); // 处理空字符串
            String paymentMethod = emptyIfNull(paymentMethodField.getText().trim());
            String currentStatus = emptyIfNull(currentStatusField.getText().trim());
            String orderNumber = emptyIfNull(orderNumberField.getText().trim());
            String merchantNumber = emptyIfNull(merchantNumberField.getText().trim());
            String remarks = emptyIfNull(remarksField.getText().trim());

            // 创建 Transaction 对象
            Transaction newTransaction = new Transaction(
                    transactionTime,
                    transactionType,
                    counterparty,
                    commodity,
                    inOut,
                    paymentAmount,
                    paymentMethod,
                    currentStatus,
                    orderNumber,
                    merchantNumber,
                    remarks
            );

            try {
                // 调用 TransactionServiceImpl 的 addTransaction 方法
                transactionService.addTransaction(newTransaction);

                // 重新加载 CSV 数据以更新表格
                loadCSVData(TRANSACTION_CAFFEINE_KEY);

                // 关闭对话框
                addDialog.dispose();

                JOptionPane.showMessageDialog(null, "交易添加成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(null, "交易添加失败！", "错误", JOptionPane.ERROR_MESSAGE);
            }
        });

        addDialog.add(confirmButton);

        // 设置对话框大小并显示
        addDialog.setSize(400, 300);
        addDialog.setModal(true); // 设置为模态对话框
        addDialog.setVisible(true);
    }

    // 加载 CSV 数据
    public void loadCSVData(String caffeineKey) {
        allData.clear();
        tableModel.setRowCount(0);

        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;

//        CsvTransactionDao csvTransactionDao = new CsvTransactionDao();

        List<Transaction> transactions = cache.get(caffeineKey);
        for (Transaction transaction : transactions) {
            Vector<String> row = createRowFromTransaction(transaction);
            allData.add(row);
            tableModel.addRow(row);
        }
    }

    // 搜索数据
    public void searchData(String query1, String query2, String query3, String query4, String query6, String query5) {
        tableModel.setRowCount(0);
        Transaction searchCriteria = new Transaction(query1, query2, query3, query4, query6, 0, query5, "", "", "", "");

        try {
            List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);
            for (Transaction transaction : transactions) {
                Vector<String> row = createRowFromTransaction(transaction);
                tableModel.addRow(row);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(null, "查询失败！", "错误", JOptionPane.ERROR_MESSAGE);
        }
    }

    // 从 Transaction 对象创建表格行
    private Vector<String> createRowFromTransaction(Transaction transaction) {
        Vector<String> row = new Vector<>();
        row.add(transaction.getTransactionTime());
        row.add(transaction.getTransactionType());
        row.add(transaction.getCounterparty());
        row.add(transaction.getCommodity());
        row.add(transaction.getInOut());
        row.add(String.valueOf(transaction.getPaymentAmount()));
        row.add(transaction.getPaymentMethod());
        row.add(transaction.getCurrentStatus());
        row.add(transaction.getOrderNumber());
        row.add(transaction.getMerchantNumber());
        row.add(transaction.getRemarks());
        row.add("Modify"); // Modify 按钮
        row.add("Delete"); // 添加 Delete 按钮
        return row;
    }

    // 删除行
    public void deleteRow(int rowIndex) {
        if (rowIndex >= 0 && rowIndex < allData.size()) {
            String orderNumber = allData.get(rowIndex).get(8).trim();
            System.out.println("尝试删除的交易单号: " + orderNumber); // 打印交易单号

            try {
                if (transactionService.deleteTransaction(orderNumber)) {
                    allData.remove(rowIndex);
                    tableModel.removeRow(rowIndex);
                    JOptionPane.showMessageDialog(null, "删除成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                } else {
                    JOptionPane.showMessageDialog(null, "删除失败：未找到对应的交易单号", "错误", JOptionPane.ERROR_MESSAGE);
                }
            } catch (IOException ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(null, "删除失败！", "错误", JOptionPane.ERROR_MESSAGE);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    // 编辑行
    public void editRow(int rowIndex) {
        System.out.println("编辑行: " + rowIndex);
        if (rowIndex >= 0 && rowIndex < allData.size()) {
            Vector<String> rowData = allData.get(rowIndex);

            // 创建一个面板用于显示编辑字段
            JPanel panel = new JPanel(new GridLayout(rowData.size() - 2, 2)); // 排除最后两列

            // 创建字段数组，用于存储用户输入的值
            JTextField[] fields = new JTextField[rowData.size() - 2]; // 排除最后两列

            // 遍历 rowData，跳过最后两列（"Modify" 和 "Delete"）
            for (int i = 0; i < rowData.size() - 2; i++) {
                panel.add(new JLabel(tableModel.getColumnName(i))); // 添加列名标签
                fields[i] = new JTextField(rowData .get(i)); // 添加输入字段
                panel.add(fields[i]);
            }

            // 弹出对话框，让用户修改数据
            int result = JOptionPane.showConfirmDialog(null, panel, "修改交易信息", JOptionPane.OK_CANCEL_OPTION);
            if (result == JOptionPane.OK_OPTION) {
                // 用户点击了确认按钮，更新交易信息
                Transaction transaction = new Transaction(
                        fields[0].getText().trim(), // 交易时间
                        fields[1].getText().trim(), // 交易类型
                        fields[2].getText().trim(), // 交易对方
                        fields[3].getText().trim(), // 商品
                        fields[4].getText().trim(), // 收/支
                        Double.parseDouble(fields[5].getText().trim()), // 金额(元)
                        fields[6].getText().trim(), // 支付方式
                        fields[7].getText().trim(), // 当前状态
                        fields[8].getText().trim(), // 交易单号
                        fields[9].getText().trim(), // 商户单号
                        fields[10].getText().trim() // 备注
                );

                try {
                    // 调用 TransactionServiceImpl 的 changeTransaction 方法更新交易
                    transactionService.changeTransaction(transaction);

                    // 重新加载 CSV 数据以更新表格
                    loadCSVData(TRANSACTION_CAFFEINE_KEY);

                    JOptionPane.showMessageDialog(null, "修改成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                } catch (Exception ex) {
                    ex.printStackTrace();
                    JOptionPane.showMessageDialog(null, "修改失败！", "错误", JOptionPane.ERROR_MESSAGE);
                }
            }
        }
    }

    /**
     * 查找对话框中的输入字段
     *
     * @param dialog 对话框
     * @param index  输入字段的索引
     * @return 输入字段
     */
    /**
     * 查找容器中的输入字段
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0;
        for (Component component : container.getComponents()) {
            if (component instanceof JTextField) {
                if (count == index) {
                    return (JTextField) component;
                }
                count++;
            }
        }
        return null;
    }

    /**
     * 查找对话框中的下拉框
     *
     * @param dialog 对话框
     * @return 下拉框
     */
    /**
     * 查找容器中的下拉框
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) {
            if (component instanceof JComboBox) {
                return (JComboBox<String>) component;
            }
        }
        return null;
    }

    /**
     * 如果字段为 null，则返回空文本
     *
     * @param value 字段值
     * @return 非 null 的字段值
     */
    private String emptyIfNull(String value) {
        return value == null ? "" : value;
    }

    // 添加此方法以便测试时可以获取table
    public JTable getTable() {
        return table;
    }
}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\DAO\CsvTransactionDao.java`:

```java
package DAO;

import Constants.ConfigConstants;
import model.Transaction;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static Constants.ConfigConstants.CSV_PATH;

public class CsvTransactionDao implements TransactionDao {
    //避免每次都调用loadFromCSV() 方法
    private List<Transaction> transactions;
    private boolean isLoad= false;
//HEAD 交易时间	交易类型	交易对方	商品	收/支	金额(元)	支付方式	当前状态	交易单号	商户单号	备注
    //
    @Override
    public List<Transaction> loadFromCSV(String filePath) throws IOException {
        try (
                Reader reader = new InputStreamReader(
                        new BOMInputStream(Files.newInputStream(Paths.get(filePath))),
                        StandardCharsets.UTF_8)) {
            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()    //根据首行的内容设置为表格的头
                    .withIgnoreHeaderCase(false)  // 禁用忽略大小写
                    .withTrim(false);             // 禁用自动trim（防止意外空格问题）

            try (CSVParser csvParser = new CSVParser(reader, format)) {

                List<Transaction> transactions = new ArrayList<>();
                for (CSVRecord record : csvParser) {
                    Transaction transaction = parseRecord(record);
                    transactions.add(transaction);
                }
                reader.close();
                this.transactions = transactions;
                this.isLoad=true;
                return transactions;
            }
        }
    }


    private Transaction parseRecord(CSVRecord record) {
        return new Transaction(
                record.get("交易时间"),
                record.get("交易类型"),
                record.get("交易对方"),
                record.get("商品"),
                record.get("收/支"),
                Double.parseDouble(record.get("金额(元)").substring(1)),
                record.get("支付方式"),
                record.get("当前状态"),
                record.get("交易单号"),
                record.get("商户单号"),
                record.get("备注")
        );
    }

    // 根据交易单号删除交易记录
    public boolean deleteTransaction(String filePath, String orderNumber) throws IOException {
        if(!isLoad){ loadFromCSV(filePath);}

        List<Transaction> updatedTransactions = transactions.stream()
                .filter(t -> !t.getOrderNumber().trim().equals(orderNumber))
                .collect(Collectors.toList());

        if (transactions.size() == updatedTransactions.size()) {
            return false;
        }

        writeTransactionsToCSV(filePath, updatedTransactions);
        return true;
    }

    // 添加交易
    public void addTransaction(String filePath, Transaction newTransaction) throws IOException {
        boolean fileExists = Files.exists(Paths.get(filePath)) && Files.size(Paths.get(filePath)) > 0;

        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(filePath), StandardOpenOption.CREATE, StandardOpenOption.APPEND);
             CSVPrinter csvPrinter = new CSVPrinter(writer, fileExists ? getCsvFormatWithoutHeader() : getCsvFormatWithHeader(filePath))) {

            csvPrinter.printRecord(
                    newTransaction.getTransactionTime(),
                    newTransaction.getTransactionType(),
                    newTransaction.getCounterparty(),
                    newTransaction.getCommodity(),
                    newTransaction.getInOut(),
                    "¥" + newTransaction.getPaymentAmount(),
                    newTransaction.getPaymentMethod(),
                    newTransaction.getCurrentStatus(),
                    newTransaction.getOrderNumber(),
                    newTransaction.getMerchantNumber(),
                    newTransaction.getRemarks()
            );

            csvPrinter.flush();
        }
    }

    // 统一写回 CSV
    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
        // 1. 创建临时文件（确保与原文件同目录）
        File targetFile = new File(filePath);
        File tempFile = File.createTempFile("transaction_temp", ".csv", targetFile.getParentFile());

        // 2. 写入数据到临时文件（使用 try-with-resources 确保资源释放）
        try (BufferedWriter writer = Files.newBufferedWriter(tempFile.toPath());
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(
                     "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"))) {

            for (Transaction t : transactions) {
                csvPrinter.printRecord(
                        t.getTransactionTime(),
                        t.getTransactionType(),
                        t.getCounterparty(),
                        t.getCommodity(),
                        t.getInOut(),
                        "¥" + t.getPaymentAmount(),
                        t.getPaymentMethod(),
                        t.getCurrentStatus(),
                        t.getOrderNumber(),
                        t.getMerchantNumber(),
                        t.getRemarks()
                );
            }
            csvPrinter.flush(); // 强制刷盘
        } catch (IOException e) {
            tempFile.delete(); // 失败时删除临时文件
            throw e;
        }

        // 3. 原子性替换原文件
        Path source = tempFile.toPath();
        Path target = Paths.get(filePath);
        try {
            Files.move(source, target, StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            System.err.println("移动失败原因: " + e.getMessage());
        }
    }

//    // 统一写回 CSV
//    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
//        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(filePath));
//             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(
//                     "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注")))  {
//
//            for (Transaction t : transactions) {
//                csvPrinter.printRecord(
//                        t.getTransactionTime(),
//                        t.getTransactionType(),
//                        t.getCounterparty(),
//                        t.getCommodity(),
//                        t.getInOut(),
//                        "¥" + t.getPaymentAmount(),
//                        t.getPaymentMethod(),
//                        t.getCurrentStatus(),
//                        t.getOrderNumber(),
//                        t.getMerchantNumber(),
//                        t.getRemarks()
//                );
//            }
//        }
//    }

    // 获取 CSV 格式（包含表头）
    private CSVFormat getCsvFormatWithHeader(String filePath) throws IOException {
        try (BufferedReader reader = Files.newBufferedReader(Paths.get(filePath))) {
            String headerLine = reader.readLine();
            if (headerLine == null || headerLine.trim().isEmpty()) {
                // 如果文件为空或不存在，返回默认表头
                return CSVFormat.DEFAULT.withHeader(
                        "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"
                );
            }
            return CSVFormat.DEFAULT.withHeader(headerLine.split(",")).withTrim();
        }
    }

    // 获取 CSV 格式（不包含表头）
    private CSVFormat getCsvFormatWithoutHeader() {
        return CSVFormat.DEFAULT.withTrim();
    }

    public boolean changeInformation(String orderNumber, String head, String value,String path) throws IOException{
        if(isLoad==false){ loadFromCSV(path);}
        for (int i = 0; i < transactions.size(); i++) {
            if(transactions.get(i).getOrderNumber().trim().equals(orderNumber)){
                Transaction newTransaction=transactions.get(i);
                switch (head){
                    case "transactionTime" :{
                        newTransaction.setTransactionTime(value);
                        break;}
                    case "transactionType" :{
                        newTransaction.setTransactionType(value);
                        break;
                    }
                    case "counterparty" :{
                        newTransaction.setCounterparty(value);
                        break;
                    } case "commodity" :{
                        newTransaction.setCommodity(value);
                        break;
                    } case "inOut" :{
                        newTransaction.setInOut(value);
                        break;
                    } case "paymentAmount" :{
                        newTransaction.setPaymentAmount(Double.parseDouble(value));
                        break;
                    } case "paymentMethod" :{
                        newTransaction.setPaymentMethod(value);
                        break;
                    } case "currentStatus" :{
                        newTransaction.setCurrentStatus(value);
                        break;
                    } case "orderNumber" :{
                        newTransaction.setOrderNumber(value);
                        break;
                    } case "merchantNumber" :{
                        newTransaction.setMerchantNumber(value);
                        break;
                    } case "remarks" :{
                        newTransaction.setRemarks(value);
                        break;
                    } default:{
                        System.err.println("error head");
                    }
                }

                boolean flag=deleteTransaction(path,transactions.get(i).getOrderNumber());
                if(flag) {
                    addTransaction(path,newTransaction);
                    System.out.println("success to delete");
                }
                else System.err.println("failed to delete");
            }
        }
        return true;
    }

    @Override
    public List<Transaction> getAllTransactions() throws IOException {
        return List.of();
    }

    @Override
    public void addTransaction(Transaction transaction) throws IOException {

    }

    @Override
    public boolean deleteTransaction(String orderNumber) throws IOException {
        return false;
    }

    @Override
    public boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException {
        return false;
    }

    @Override
    public Transaction getTransactionByOrderNumber(String orderNumber) throws IOException {
        return null;
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\DAO\TransactionDao.java`:

```java
package DAO;

import model.Transaction;

import java.io.IOException;
import java.util.List;

/**
 * Interface for Data Access Object (DAO) operations related to Transactions.
 * Defines the contract for loading, adding, deleting, and updating transaction data.
 */
public interface
TransactionDao {

    //HEAD 交易时间	交易类型	交易对方	商品	收/支	金额(元)	支付方式	当前状态	交易单号	商户单号	备注
        //
    List<Transaction> loadFromCSV(String filePath) throws IOException;

    /**
     * Loads all transactions from the configured data source.
     *
     * @return A list of all transactions.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<Transaction> getAllTransactions() throws IOException;

    /**
     * Adds a new transaction to the data source.
     *
     * @param transaction The new transaction to add.
     * @throws IOException If an I/O error occurs during saving.
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * Deletes a transaction identified by its order number.
     *
     * @param orderNumber The unique order number of the transaction to delete.
     * @return true if a transaction was found and deleted, false otherwise.
     * @throws IOException If an I/O error occurs during loading or saving.
     */
    boolean deleteTransaction(String orderNumber) throws IOException;

    /**
     * Updates a specific field of an existing transaction identified by its order number.
     *
     * @param orderNumber The unique order number of the transaction to update.
     * @param fieldName   The name of the field to update (e.g., "transactionType", "paymentAmount").
     * @param newValue    The new value for the specified field.
     * @return true if the transaction was found and updated, false otherwise.
     * @throws IOException             If an I/O error occurs during loading or saving.
     * @throws NumberFormatException   If updating 'paymentAmount' and newValue is not a valid double.
     * @throws IllegalArgumentException If the fieldName is invalid.
     */
    boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException;

    /**
     * Retrieves a transaction by its unique order number.
     * (Optional but often useful)
     *
     * @param orderNumber The unique order number.
     * @return The Transaction object if found, null otherwise.
     * @throws IOException If an I/O error occurs during loading.
     */
    Transaction getTransactionByOrderNumber(String orderNumber) throws IOException;

}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Interceptor\Login\LoginDialog.java`:

```java
package Interceptor.Login;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class LoginDialog extends JDialog {
    private boolean loginSuccessful = false;
    private JTextField usernameField;
    private JPasswordField passwordField;
    private UserService userService = new UserService();

    public LoginDialog() {
        setTitle("用户登录");
        setLayout(new GridLayout(3, 2));
        setModal(true);
        setSize(300, 150);

        // 输入组件
        usernameField = new JTextField();
        passwordField = new JPasswordField();
        JButton loginButton = new JButton("登录");
        JButton cancelButton = new JButton("取消");

        // 添加组件
        add(new JLabel("用户名:"));
        add(usernameField);
        add(new JLabel("密码:"));
        add(passwordField);
        add(loginButton);
        add(cancelButton);

        // 登录按钮逻辑
        loginButton.addActionListener(e -> {
            String username = usernameField.getText().trim();
            String password = new String(passwordField.getPassword()).trim();

            if (userService.authenticate(username, password)) {
                loginSuccessful = true;
                dispose(); // 关闭对话框
            } else {
                JOptionPane.showMessageDialog(
                        this,
                        "用户名或密码错误！",
                        "登录失败",
                        JOptionPane.ERROR_MESSAGE
                );
                clearFields(); // 登录失败后清空文本框
            }
        });

        // 取消按钮逻辑
        cancelButton.addActionListener(e -> {
            dispose();
            System.exit(0);
        });

        setLocationRelativeTo(null); // 居中显示
    }

    // 清空文本框的方法
    private void clearFields() {
        usernameField.setText("");
        passwordField.setText("");
        usernameField.requestFocus(); // 焦点回到用户名输入框
    }

    public boolean isLoginSuccessful() {
        return loginSuccessful;
    }
}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Interceptor\Login\UserService.java`:

```java
package Interceptor.Login;

import java.util.HashMap;
import java.util.Map;

public class UserService {
    // 模拟用户数据库（用户名 -> 密码哈希值）
    private static final Map<String, String> userDatabase = new HashMap<>();

    public UserService() {
        // 初始化测试用户（密码为 "admin123" 的 SHA-256 哈希）
        userDatabase.put("admin", "admin123");
    }

    public boolean authenticate(String username, String password) {
        if (username.isEmpty() || password.isEmpty()) return false;
        String storedHash = userDatabase.get(username);
        return password.equals(storedHash);
    }

}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Main.java`:

```java
import javax.swing.*;

import Controller.MenuUI;
import DAO.CsvTransactionDao;
import Interceptor.Login.LoginDialog;
import Service.Impl.TransactionServiceImpl;

public class Main {
    public static void main(String[] args) {
        // 初始化服务（依赖注入）
        TransactionServiceImpl.csvTransactionDao = new CsvTransactionDao();

        // 在事件调度线程中启动 GUI（Swing 规范）
        SwingUtilities.invokeLater(() -> {
            // 1. 显示登录对话框
            LoginDialog loginDialog = new LoginDialog();
            loginDialog.setVisible(true);

            // 2. 登录成功后再显示主界面
            if (loginDialog.isLoginSuccessful()) {
                MenuUI menuUI = new MenuUI();
                JPanel mainPanel = menuUI.createMainPanel();
                showMainUI(mainPanel);
            } else {
                System.exit(0); // 登录失败退出
            }
        });
    }

    /**
     * 显示主界面窗口
     */
    private static void showMainUI(JPanel panel) {
        JFrame frame = new JFrame("交易管理系统");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(1200, 600);
        frame.setLocationRelativeTo(null); // 窗口居中
        frame.add(panel);
        frame.setVisible(true);
    }
}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Service\AIservice\AIAnalyzerThread.java`:

```java
package Service.AIservice;

public class AIAnalyzerThread implements Runnable {
    private final String userRequest;
    private final String filePath;
    private final String startTimeStr;
    private final String endTimeStr;

    public AIAnalyzerThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        this.userRequest = userRequest;
        this.filePath = filePath;
        this.startTimeStr = startTimeStr;
        this.endTimeStr = endTimeStr;
    }

    @Override
    public void run() {
        String result = new AITransactionService().analyzeTransactions(userRequest, filePath, startTimeStr, endTimeStr);
        System.out.println("AI分析结果: " + result);
        // TODO: 如果是UI程序，可用 SwingUtilities.invokeLater() 更新UI组件
    }

}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Service\AIservice\AITransactionService.java`:

```java
package Service.AIservice;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Constants.ConfigConstants;
import DAO.CsvTransactionDao;
import Utils.CacheUtil;
import model.Transaction;
import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;

import java.io.IOException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;
import java.util.concurrent.*;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class AITransactionService {
    private static final String API_KEY = System.getenv("ARK_API_KEY");
    private static final ArkService service = ArkService.builder()
            .timeout(Duration.ofSeconds(1800))
            .connectTimeout(Duration.ofSeconds(20))
            .baseUrl("https://ark.cn-beijing.volces.com/api/v3")
            .apiKey(API_KEY)
            .build();

    private final CsvTransactionDao transactionDao = new CsvTransactionDao();

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    private final CacheUtil<String, List<Transaction>, Exception> cache;
    /**
     * 重构构造器初始化Caffeine
     */
    public AITransactionService()  {
        // 1. 注入Dao层接口
        TransactionServiceImpl.csvTransactionDao = transactionDao;
        // 2. 初始化CacheUtil
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return transactionDao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );
    }

    public String analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        try {
            List<Transaction> transactions = cache.get(TRANSACTION_CAFFEINE_KEY);
            List<String> transactionDetails = formatTransactions(transactions, startTimeStr, endTimeStr);

            String aiPrompt = userRequest + "\n" + "以下是我的账单信息：\n" + String.join("\n", transactionDetails);
            return askAi(aiPrompt);
        } catch (Exception e) {
            e.printStackTrace();
            return "AI分析失败: " + e.getMessage();
        }
    }


    //private List<String> formatTransactions(List<Transaction> transactions) {
        //return transactions.stream().map(t -> String.format(
               // "交易时间: %s, 商品: %s, 收/支: %s, 金额: %.2f元",
               // t.getTransactionTime(),
               // t.getCommodity(),
               // t.getInOut(),
               // t.getPaymentAmount()
        //)).collect(Collectors.toList());
    //}

    public List<String> formatTransactions(List<Transaction> transactions, String startTimeStr, String endTimeStr) {
        LocalDateTime startTime = parseDateTime(startTimeStr);
        LocalDateTime endTime = (endTimeStr == null || endTimeStr.isEmpty())
                ? LocalDateTime.now()
                : parseDateTime(endTimeStr);

        if (startTime == null) {
            throw new IllegalArgumentException("起始时间格式不正确");
        }

        List<Transaction> filtered = transactions.stream()
                .filter(t -> {
                    LocalDateTime tTime = parseDateTime(t.getTransactionTime());
                    return tTime != null && !tTime.isBefore(startTime) && !tTime.isAfter(endTime);
                })
                .collect(Collectors.toList());

        Map<String, double[]> grouped = new HashMap<>();
        for (Transaction t : filtered) {
            String counterparty = t.getCounterparty();
            double amount = t.getInOut().equals("支出") ? -t.getPaymentAmount() : t.getPaymentAmount();
            grouped.putIfAbsent(counterparty, new double[]{0.0, 0});
            grouped.get(counterparty)[0] += amount;
            grouped.get(counterparty)[1] += 1;
        }

        List<String> results = grouped.entrySet().stream()
                .map(e -> {
                    String cp = e.getKey();
                    double net = e.getValue()[0];
                    int count = (int) e.getValue()[1];
                    String inOut = net >= 0 ? "收入" : "支出";
                    return String.format("交易对方: %s, 收/支: %s, 金额: %.2f元，交易次数: %d",
                            cp, inOut, Math.abs(net), count);
                })
                .collect(Collectors.toList());

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm");
        results.add(String.format("交易时间范围：%s - %s",
                formatter.format(startTime), formatter.format(endTime)));

        return results.isEmpty() ? List.of("该时间段内没有交易记录。") : results;
    }




    //private LocalDateTime parseDateTime(String timeStr) {
        // 你可以按实际情况支持不同格式，比如 yyyy/MM/dd HH:mm 或 yyyy-MM-dd HH:mm:ss
        //List<String> patterns = Arrays.asList("yyyy/MM/dd HH:mm","yyyy/MM/dd H:mm", "yyyy/M/dd H:mm","yyyy/M/dd HH:mm","yyyy/M/d H:mm","yyyy/M/d HH:mm","yyyy-MM-dd HH:mm:ss", "yyyy/MM/dd");

        //for (String pattern : patterns) {
            //try {
                //DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                //return LocalDateTime.parse(timeStr, formatter);
            //} catch (Exception ignored) {}
        //}
        //return null;
    //}
        private LocalDateTime parseDateTime(String timeStr) {
            if (timeStr == null || timeStr.trim().isEmpty()) return null;

            // 中文空格等统一清理
            timeStr = timeStr.trim().replaceAll("\\s+", " ");

            // 如果只有日期，补 00:00
            if (timeStr.matches("\\d{4}/\\d{1,2}/\\d{1,2}")) {
                timeStr += " 00:00";
            }

            // 多种时间格式尝试解析
            List<String> patterns = Arrays.asList(
                    "yyyy/M/d H:mm", "yyyy/M/d HH:mm",
                    "yyyy/MM/d H:mm", "yyyy/MM/d HH:mm",
                    "yyyy/M/dd H:mm", "yyyy/M/dd HH:mm",
                    "yyyy/MM/dd H:mm", "yyyy/MM/dd HH:mm",
                    "yyyy-MM-dd HH:mm:ss",
                    "yyyy/MM/dd"
            );

            for (String pattern : patterns) {
                try {
                    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                    return LocalDateTime.parse(timeStr, formatter);
                } catch (Exception ignored) {}
            }

            return null;
        }






    public String askAi(String prompt) {
        try {
            List<ChatMessage> messages = List.of(
                    ChatMessage.builder().role(ChatMessageRole.USER).content(prompt).build()
            );

            ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
                    .model("ep-20250308174053-7pbkq")
                    .messages(messages)
                    .build();

            return (String) service.createChatCompletion(chatCompletionRequest)
                    .getChoices().get(0).getMessage().getContent();
        } catch (Exception e) {
            e.printStackTrace();
            return "AI请求失败: " + e.getMessage();
        }
    }

    public void runAiInThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            String result = analyzeTransactions(userRequest, filePath,startTimeStr, endTimeStr);
            System.out.println("AI分析结果: " + result);
        });
        executor.shutdown();
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Service\AIservice\ColledgeStudentThread.java`:

```java
package Service.AIservice;

import java.io.IOException;

public class ColledgeStudentThread implements Runnable{
//    private final int userRequest;
    private final String filePath;
    public String budgetRange;
    public ColledgeStudentThread( String filePath) {
//        this.userRequest = userRequest;
        this.filePath = filePath;
    }

    @Override
    public void run(){
        CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
        try {
            collegeStudentNeeds.generateBudget(filePath);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Service\AIservice\CollegeStudentNeeds.java`:

```java
package Service.AIservice;

import Constants.ConfigConstants;
import DAO.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import model.Transaction;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class CollegeStudentNeeds {
    private final String requestBudge="我是一名预算有限的大学生，请根据下面我给出的花费，帮助我给下周预算范围，必须以[最低预算，最高预算],的方式给出回答，不能有多余的回复。";
    private final String requestTips="我是一名预算有限的大学生，请给我推荐一些省钱方法。";

    private final String requestRecognition="下面我将给你一些账单的信息，请推测这个账单是什么方面的消费: ";
    CsvTransactionDao dao;

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    private final CacheUtil<String, List<Transaction>, Exception> cache;

    public CollegeStudentNeeds() {
        TransactionServiceImpl.csvTransactionDao = dao;
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return dao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );

    }
    public String RecognizeTransaction(Transaction transaction){
        StringBuilder sb=new StringBuilder();
        sb.append("交易类型:").append(transaction.getTransactionType()+",").append("交易对方").append(transaction.getCounterparty()+",")
                .append("商品:").append(transaction.getCommodity()+",").append("收/支:").append(transaction.getInOut()+",")
                        .append("金额(元):").append(transaction.getPaymentAmount()+",").append("支付方式").append(transaction.getPaymentMethod()+",").append("备注:").append(transaction.getRemarks());
        return  new AITransactionService().askAi(requestRecognition+sb.toString());
    }

    public String generateTipsForSaving(){
        return  new AITransactionService().askAi(requestTips);
    }
    //按周统计已有的支出，依靠ai得到下周的预算
    public double[] generateBudget(String path) throws IOException {
        List<Transaction> transactions=cache.get(TRANSACTION_CAFFEINE_KEY);

        int size=transactions.size();
        if(size==0||size==1) return new double[]{-1,-1};
        int count=1;
        int base=0;
        int index=0;//指示首个适合当基准的时间点
        for (index = 0; index < size; index++) {
            int data=convertDateToNumber(transactions.get(index).getTransactionTime().split(" ")[0]);
            if(data>0){
                base=data;
                break;
            }
        }
        List<Double> list=new ArrayList<>();
        double weekConsumption=0;
        for (int i = 0; i < size; i++) {
            int data=convertDateToNumber(transactions.get(i).getTransactionTime().split(" ")[0]);
            if(data<0) continue;
            if((base-data>=0&&base-data<7)&&transactions.get(i).getInOut().equals("支出")){
                weekConsumption+=transactions.get(i).getPaymentAmount();
            }else if(base-data>=7){
                base=data;
                list.add(weekConsumption);
                count++;
                weekConsumption=0;
                if(transactions.get(i).getInOut().equals("支出")){
                    weekConsumption+=transactions.get(i).getPaymentAmount();
                }
            }
        }
        StringBuilder stringBuilder=new StringBuilder();
        for (int i = 0; i < count-1; i++) {
            stringBuilder.append("第");
            stringBuilder.append(i);
            stringBuilder.append("周:花费");
            stringBuilder.append(list.get(i));
            stringBuilder.append("元;");
        }
        String answer=new AITransactionService().askAi(requestBudge+stringBuilder.toString());
        System.out.println(answer);
        double[] ret=new double[2];
        ret=parseDoubleArrayFromString(answer);
        return ret;
    }

    private int convertDateToNumber(String date) {
        // format yyyy/MM/dd
        String[] parts = date.split("/");
        if (parts.length != 3) {
            return -1; // Invalid date format
        }
        try {
            int year = Integer.parseInt(parts[0]);
            int month = Integer.parseInt(parts[1]);
            int day = Integer.parseInt(parts[2]);
            int days = day;
            int[] daysInMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // Days in each month
            if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
                daysInMonth[2] = 29; // February has 29 days in a leap year
            }
            for (int i = 1; i < month; i++) {
                days += daysInMonth[i];
            }
            return year * 365 + (year / 4 - year / 100 + year / 400) + days;
        } catch (NumberFormatException e) {
            return -1;
        }
    }
    public double[] parseDoubleArrayFromString(String input) {
        int length=input.length();
        int l=0,rightindex=input.length();
        // 1. 去除首尾括号
        for (int i = 0; i < length; i++) {
            if(input.charAt(i)<58&&input.charAt(i)>47){
                l=i;
                break;
            }
        }
        for (int r =length-1 ; r >0; r--) {
            if(input.charAt(r)<58&&input.charAt(r)>47){
                rightindex=r;
                break;
            }
        }
        String content = input.substring(l, rightindex+1 ); // 获取 "1.1, 11.0" 或 " 2.5 ,3.14 , -0.5 "

        // 2. 按逗号分割
        String[] numberStrings1 = content.split("，"); // 得到 ["1.1", " 11.0"] 或 [" 2.5 ", "3.14 ", " -0.5 "]
        String[] numberStrings2 = content.split(","); // 得到 ["1.1", " 11.0"] 或 [" 2.5 ", "3.14 ", " -0.5 "]
        String[] numberStrings= numberStrings1.length> numberStrings2.length?numberStrings1:numberStrings2;
//        System.out.println(numberStrings[0]);
//        System.out.println(numberStrings[1]);
        // 3. & 4. 遍历、清理、解析并存储
        List<Double> numberList = new ArrayList<>();
        try {
            for (String numStr : numberStrings) {
                String trimmedStr = numStr.trim(); // 去除首尾空格
                if (!trimmedStr.isEmpty()) { // 避免分割后产生空字符串（例如 "[1.1, , 2.2]"）
                    numberList.add(Double.parseDouble(trimmedStr)); // 解析为 double
                }
            }
        } catch (NumberFormatException e) {
            System.err.println("错误：字符串无法解析为 double 类型。");
            return null; // 或者抛出异常
        }

        // 将 List<Double> 转换为 double[]
        double[] result = new double[numberList.size()];
        for (int i = 0; i < numberList.size(); i++) {
            result[i] = numberList.get(i);
        }
        return result;
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Service\Impl\TransactionServiceImpl.java`:

```java
package Service.Impl;

import Constants.ConfigConstants;
import DAO.CsvTransactionDao;
import Service.TransactionService;
import Utils.CacheUtil;
import model.Transaction;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class TransactionServiceImpl implements TransactionService {
    public static CsvTransactionDao csvTransactionDao;

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    public final CacheUtil<String, List<Transaction>, Exception> cache;

    /**
     * 通过构造函数注入路径和csvTransactionDao
     * @param csvTransactionDao
     * @throws IOException
     */
    public TransactionServiceImpl(CsvTransactionDao csvTransactionDao)  {
        // 1. 注入Dao层接口
        TransactionServiceImpl.csvTransactionDao = csvTransactionDao;
        // 2. 初始化CacheUtil
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return csvTransactionDao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );
    }

    /**
     * 从transactions缓存中读取transactions如果没有则从csv文件中找
     * @return
     * @throws IOException
     */
    private List<Transaction> getAllTransactions() throws Exception {
        return cache.get(TRANSACTION_CAFFEINE_KEY);
    }


    /**
     * 新增交易
     * @param transaction
     */
    @Override
    public void addTransaction(Transaction transaction) throws IOException {
        // 设置交易时间为当前时间
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
        String currentTime = now.format(formatter);
        transaction.setTransactionTime(currentTime);

        // 调用 DAO 层方法添加交易
        csvTransactionDao.addTransaction(CSV_PATH, transaction);
    }

    @Override
    public void changeTransaction(Transaction updatedTransaction) throws Exception {
        // 1. 加载所有交易记录 先加载 caffeine存储的缓存
        List<Transaction> allTransactions = getAllTransactions();

        // 2. 查找并修改目标交易
        boolean found = false;
        for (int i = 0; i < allTransactions.size(); i++) {
            Transaction t = allTransactions.get(i);
            // 根据交易单号匹配记录（唯一标识）
            if (t.getOrderNumber().equals(updatedTransaction.getOrderNumber())) {
                // 3. 更新非空字段
                updateTransactionFields(t, updatedTransaction);
                found = true;
                break;
            }
        }
        if (!found) {
            throw new IllegalArgumentException("未找到交易单号: " + updatedTransaction.getOrderNumber());
        }
        // 使用事务将写后数据写回csv文件
        csvTransactionDao.writeTransactionsToCSV(CSV_PATH, allTransactions);
        // 修改后使缓存失效 （删缓存）
        cache.invalidate("transactions");
    }

    /**
     *  辅助方法：更新非空字段
     * @param target
     * @param source
     */
    private void updateTransactionFields(Transaction target, Transaction source) {
        if (source.getTransactionTime() != null && !source.getTransactionTime().isEmpty()) {
            target.setTransactionTime(source.getTransactionTime());
        }
        if (source.getTransactionType() != null && !source.getTransactionType().isEmpty()) {
            target.setTransactionType(source.getTransactionType());
        }
        if (source.getCounterparty() != null && !source.getCounterparty().isEmpty()) {
            target.setCounterparty(source.getCounterparty());
        }
        if (source.getCommodity() != null && !source.getCommodity().isEmpty()) {
            target.setCommodity(source.getCommodity());
        }
        if (source.getInOut() != null && !source.getInOut().isEmpty()) {
            target.setInOut(source.getInOut());
        }
        if (source.getPaymentAmount() != 0.0) { // 假设金额为0表示未修改
            target.setPaymentAmount(source.getPaymentAmount());
        }
        if (source.getPaymentMethod() != null && !source.getPaymentMethod().isEmpty()) {
            target.setPaymentMethod(source.getPaymentMethod());
        }
        if (source.getCurrentStatus() != null && !source.getCurrentStatus().isEmpty()) {
            target.setCurrentStatus(source.getCurrentStatus());
        }
        if (source.getMerchantNumber() != null && !source.getMerchantNumber().isEmpty()) {
            target.setMerchantNumber(source.getMerchantNumber());
        }
        if (source.getRemarks() != null && !source.getRemarks().isEmpty()) {
            target.setRemarks(source.getRemarks());
        }
    }

    /**
     * 根据订单号删除交易 (若成功则返回true)
     * @param orderNumber
     */
    @Override
    public boolean deleteTransaction(String orderNumber) throws Exception {
        boolean result = csvTransactionDao.deleteTransaction(CSV_PATH, orderNumber);
        if (!result) {
            throw new Exception("未找到交易单号: " + orderNumber); // 或记录日志
        }
        cache.invalidate("transactions");
        return result;
    }

    /**
     * 按照查询条件查询交易信息
     * @param searchCriteria
     * @return
     */
    @Override
    public List<Transaction> searchTransaction(Transaction searchCriteria) {
        try {
            // 1. 读取所有交易记录 首先读取caffeine
            List<Transaction> allTransactions = getAllTransactions();

            // 2. 动态模糊匹配
            List<Transaction> matched = new ArrayList<>();
            for (Transaction t : allTransactions) {
                if (matchesCriteria(t, searchCriteria)) {
                    matched.add(t);
                }
            }

            // 3. 按交易时间倒序排序
            matched.sort((t1, t2) -> compareTransactionTime(t2.getTransactionTime(), t1.getTransactionTime()));

            return matched;
        } catch (IOException e) {
            e.printStackTrace();
            return List.of(); // 实际应用中应处理异常
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * 辅助方法:判断单个交易记录是否匹配条件
     * @param transaction
     * @param criteria
     * @return
     */
    private boolean matchesCriteria(Transaction transaction, Transaction criteria) {
        return (criteria.getTransactionTime() == null || containsIgnoreCase(transaction.getTransactionTime(), criteria.getTransactionTime()))
                && (criteria.getTransactionType() == null || containsIgnoreCase(transaction.getTransactionType(), criteria.getTransactionType()))
                && (criteria.getCounterparty() == null || containsIgnoreCase(transaction.getCounterparty(), criteria.getCounterparty()))
                && (criteria.getCommodity() == null || containsIgnoreCase(transaction.getCommodity(), criteria.getCommodity()))
                && (criteria.getInOut() == null || containsIgnoreCase(transaction.getInOut(), criteria.getInOut()))
                && (criteria.getPaymentMethod() == null || containsIgnoreCase(transaction.getPaymentMethod(), criteria.getPaymentMethod()));
    }

    /**
     * 辅助方法：字符串模糊匹配（空条件视为匹配）
     * @param source
     * @param target
     * @return
     */
    private boolean containsIgnoreCase(String source, String target) {
        if (target == null || target.trim().isEmpty()) return true; // 空条件不参与筛选
        if (source == null) return false;
        return source.toLowerCase().contains(target.toLowerCase().trim());
    }

    /**
     * 辅助方法：安全的时间比较（处理 null 值）
     * @param time1
     * @param time2
     * @return
     */
    private int compareTransactionTime(String time1, String time2) {
        if (time1 == null && time2 == null) return 0;
        if (time1 == null) return -1;
        if (time2 == null) return 1;
        return time2.compareTo(time1); // 倒序排序
    }

}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Service\TransactionService.java`:

```java
package Service;

import model.Transaction;

import java.io.IOException;
import java.util.List;

public interface TransactionService {

    /**
     * 新增交易
     * @param transaction
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * 修改交易
     * @param transaction
     */
    void changeTransaction(Transaction transaction) throws Exception;

    /**
     * 根据订单号删除交易
     * @param orderNumber
     */
    boolean deleteTransaction(String orderNumber) throws Exception;

    /**
     * 根据用户输入信息查询交易
     * @param transaction
     * @return
     */
    List<Transaction> searchTransaction(Transaction transaction);

}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Service\deepseek\ChatCompletionsExample.java`:

```java
package Service.deepseek;

import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;
import okhttp3.ConnectionPool;
import okhttp3.Dispatcher;
import org.apache.commons.lang.StringUtils;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
public class ChatCompletionsExample {
    static String apiKey = System.getenv("ARK_API_KEY");
    static ConnectionPool connectionPool = new ConnectionPool(5, 1, TimeUnit.SECONDS);
    static Dispatcher dispatcher = new Dispatcher();
    // The output time of the reasoning model is relatively long. Please increase the timeout period.//
    static ArkService service = ArkService.builder().timeout(Duration.ofSeconds(1800)).connectTimeout(Duration.ofSeconds(20)).dispatcher(dispatcher).connectionPool(connectionPool).baseUrl("https://ark.cn-beijing.volces.com/api/v3").apiKey(apiKey).build();

//    public static void main(String[] args) {
//        System.out.println(" [Recommended]----- streaming request -----");
//        final List<ChatMessage> streamMessages = new ArrayList<>();
//        final ChatMessage streamUserMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("请回答15.11和15.9哪个大？").build();
//        streamMessages.add(streamUserMessage);
//        ChatCompletionRequest streamChatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(streamMessages)
//                .build();
//        service.streamChatCompletion(streamChatCompletionRequest)
//                .doOnError(Throwable::printStackTrace)
//                .blockingForEach(
//                        delta -> {
//                            if (!delta.getChoices().isEmpty()) {
//                                if (StringUtils.isNotEmpty(delta.getChoices().get(0).getMessage().getReasoningContent())) {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getReasoningContent());
//                                } else {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getContent());
//                                }
//                            }
//                        }
//                );
//        System.out.println(" ----- standard request -----");
//        final List<ChatMessage> messages = new ArrayList<>();
//        final ChatMessage userMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("常见的十字花科植物有哪些？").build();
//        messages.add(userMessage);
//        ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(messages)
//                .build();
//        service.createChatCompletion(chatCompletionRequest).getChoices().forEach(
//                choice -> {
//                    System.out.println(choice.getMessage().getReasoningContent());
//                    System.out.println(choice.getMessage().getContent());
//                }
//        );
//        // shutdown service after all requests is finished
//        service.shutdownExecutor();
//    }
}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\Utils\CacheUtil.java`:

```java
package Utils;

import com.github.benmanes.caffeine.cache.*;

import java.util.concurrent.TimeUnit;
import java.util.function.Function;

import com.github.benmanes.caffeine.cache.Caffeine;

/**
 * 通用缓存工具类（支持泛型和异常传播）
 * @param <K> 键类型
 * @param <V> 值类型
 * @param <E> 异常类型（如 IOException）
 */
public class CacheUtil<K, V, E extends Exception> {
    private final LoadingCache<K, V> cache;

    public CacheUtil(Function<K, V> loader,
                     int maxSize,
                     long expireAfterWrite,
                     long refreshAfterWrite) {

        this.cache = Caffeine.newBuilder()
                .maximumSize(maxSize)
                .expireAfterWrite(expireAfterWrite, TimeUnit.MINUTES)
                .refreshAfterWrite(refreshAfterWrite, TimeUnit.MINUTES)
                .build(loader::apply); // 关键修改：使用build(loader)创建LoadingCache
    }

    /**
     * 获取缓存值
     */
    public V get(K key) {
        return cache.get(key);
    }

    /**
     * 手动更新缓存
     */
    public void put(K key, V value) {
        cache.put(key, value);
    }

    /**
     * 手动移除缓存
     */
    public void invalidate(K key) {
        cache.invalidate(key);
    }
}



```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\java\model\Transaction.java`:

```java
package model;
//Transaction time, transaction type, transaction counterparty,
// commodity receipt/payment amount (yuan), payment method, current status,
// transaction order number, merchant order number, remarks
public class Transaction {
    private String transactionTime;
    private String transactionType;
    private String counterparty;
    private String commodity;
    private String inOut;
    private double paymentAmount;
    private String paymentMethod;
    private String currentStatus;
    private String orderNumber;
    private String merchantNumber;
    private String remarks;

    public Transaction() {
    }

    public Transaction(String transactionTime, String transactionType, String counterparty, String commodity, String inOut, double paymentAmount, String paymentMethod, String currentStatus, String orderNumber, String merchantNumber, String remarks) {
        this.transactionTime = transactionTime;
        this.transactionType = transactionType;
        this.counterparty = counterparty;
        this.commodity = commodity;
        this.inOut = inOut;
        this.paymentAmount = paymentAmount;
        this.paymentMethod = paymentMethod;
        this.currentStatus = currentStatus;
        this.orderNumber = orderNumber;
        this.merchantNumber = merchantNumber;
        this.remarks = remarks;
    }

    public String getInOut() {
        return inOut;
    }

    public void setInOut(String inOut) {
        this.inOut = inOut;
    }

    public void setTransactionTime(String transactionTime) {
        this.transactionTime = transactionTime;
    }

    public void setTransactionType(String transactionType) {
        this.transactionType = transactionType;
    }

    public void setCounterparty(String counterparty) {
        this.counterparty = counterparty;
    }

    public void setCommodity(String commodity) {
        this.commodity = commodity;
    }

    public void setPaymentAmount(double paymentAmount) {
        this.paymentAmount = paymentAmount;
    }

    public void setPaymentMethod(String paymentMethod) {
        this.paymentMethod = paymentMethod;
    }

    public void setCurrentStatus(String currentStatus) {
        this.currentStatus = currentStatus;
    }

    public void setOrderNumber(String orderNumbe) {
        this.orderNumber = orderNumbe;
    }

    public void setMerchantNumber(String merchantNumber) {
        this.merchantNumber = merchantNumber;
    }

    public void setRemarks(String remarks) {
        this.remarks = remarks;
    }

    public String getTransactionTime() {
        return transactionTime;
    }

    public String getTransactionType() {
        return transactionType;
    }

    public String getCounterparty() {
        return counterparty;
    }

    public String getCommodity() {
        return commodity;
    }

    public double getPaymentAmount() {
        return paymentAmount;
    }

    public String getPaymentMethod() {
        return paymentMethod;
    }

    public String getCurrentStatus() {
        return currentStatus;
    }

    public String getOrderNumber() {
        return orderNumber;
    }

    public String getMerchantNumber() {
        return merchantNumber;
    }

    public String getRemarks() {
        return remarks;
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\resources\CSVForm\0001.csv`:

```csv
交易时间,交易类型,交易对方,商品,收/支,金额(元),支付方式,当前状态,交易单号,商户单号,备注
2025/04/22 14:38:46,充值,支付宝,虚拟商品,收入,¥1000.0,微信支付,已完成,T987654321,M123456789,测试
2025/04/22 14:38:06,充值,支付宝,虚拟商品,收入,¥1000.0,微信支付,已完成,T987654322,M123456789,测123
2025/04/22 14:38:46,充值,支付宝,虚拟商品,收入,¥1000.0,微信支付,已完成,T987654323,M123456789,测试
2025/04/22 15:40:01,充值,支付宝,虚拟商品,收入,¥1000.0,微信支付,已完成,T987654324,M123456789,测试

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\main\resources\config.properties`:

```properties
# config.properties
csv.path=Ai Bill Application/src/main/resources/CSVForm/0001.csv
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\test\java\ControllerTest\AITest.java`:

```java
package ControllerTest;

import Controller.HistogramPanelContainer;
import org.junit.Test;

import javax.swing.*;
import java.awt.*;

public class AITest {

    @Test
    public void testHistogramPanel() throws Exception {
        EventQueue.invokeAndWait(() -> {
            JFrame frame = new JFrame("数据分析界面 - 测试");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });




        // 保持窗口显示一段时间，防止测试结束时窗口立即关闭
        Thread.sleep(5000);
    }

}




```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\test\java\ControllerTest\MenuUITest.java`:

```java
package ControllerTest;

import Controller.HistogramExample;
import Controller.HistogramPanelContainer;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.io.IOException;
import Controller.MenuUI;

import Service.Impl.TransactionServiceImpl;

import Service.Impl.TransactionServiceImpl;

import DAO.CsvTransactionDao;

public class MenuUITest {

    private MenuUI menuUI;

    @BeforeEach
    public void setUp() {
        menuUI = new MenuUI();

        // 手动初始化 TransactionServiceImpl 的 csvTransactionDao
        TransactionServiceImpl.csvTransactionDao = new CsvTransactionDao();
    }

    @Test
    public void testSearchFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取输入字段和搜索按钮
        JTextField transactionTimeField = findTextField(inputPanel, 0);
        JTextField transactionTypeField = findTextField(inputPanel, 1);
        JTextField counterpartyField = findTextField(inputPanel, 2);
        JTextField commodityField = findTextField(inputPanel, 3);
        JComboBox<String> inOutComboBox = findComboBox(inputPanel);
        JTextField paymentMethodField = findTextField(inputPanel, 4);
        JButton searchButton = findButton(inputPanel,"Search");

        assertNotNull(transactionTimeField, "交易时间输入字段不应为空");
        assertNotNull(transactionTypeField, "交易类型输入字段不应为空");
        assertNotNull(counterpartyField, "交易对方输入字段不应为空");
        assertNotNull(commodityField, "商品输入字段不应为空");
        assertNotNull(inOutComboBox, "收/支下拉框不应为空");
        assertNotNull(paymentMethodField, "支付方式输入字段不应为空");
        assertNotNull(searchButton, "搜索按钮不应为空");

        // 设置搜索条件
        transactionTimeField.setText("2025/3/14 11:48"); // 交易时间
        transactionTypeField.setText("商户消费");       // 交易类型
        counterpartyField.setText("物美WUMART");         // 交易对方
        commodityField.setText("扫码支付");            // 商品
        inOutComboBox.setSelectedItem("支出");     // 收/支
        paymentMethodField.setText("零钱");    // 支付方式

        // 模拟点击搜索按钮
        searchButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证搜索结果是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);

            // 验证每一行数据是否符合搜索条件
            assertTrue(rowTransactionTime.contains("2025/3/14 11:48"), "交易时间应符合搜索条件");
            assertTrue(rowTransactionType.contains("商户消费"), "交易类型应符合搜索条件");
            assertTrue(rowCounterparty.contains("物美WUMART"), "交易对方应符合搜索条件");
            assertTrue(rowCommodity.contains("扫码支付"), "商品应符合搜索条件");
            assertTrue(rowInOut.contains("支出"), "收/支应符合搜索条件");
            assertTrue(rowPaymentMethod.contains("零钱"), "支付方式应符合搜索条件");
        }
    }

    @Test
    public void testDeleteFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 获取初始行数
        int initialRowCount = tableModel.getRowCount();

        // 模拟删除第一行
        menuUI.deleteRow(0);

        // 验证行数是否减少
        assertEquals(initialRowCount - 1, tableModel.getRowCount(), "删除后行数应减少");

        // 验证删除后的数据是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            assertNotEquals("2025/3/14 11:48", rowTransactionTime, "删除的行不应再出现在表格中");
        }
    }

    @Test
    public void testEditFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 模拟编辑第一行
        menuUI.editRow(0);

        // 验证编辑后的数据是否正确
        String editedTransactionTime = (String) tableModel.getValueAt(0, 0);
        String editedTransactionType = (String) tableModel.getValueAt(0, 1);
        String editedCounterparty = (String) tableModel.getValueAt(0, 2);
        String editedCommodity = (String) tableModel.getValueAt(0, 3);
        String editedInOut = (String) tableModel.getValueAt(0, 4);
        String editedPaymentMethod = (String) tableModel.getValueAt(0, 6);

        // 验证编辑后的数据是否符合预期
        assertNotNull(editedTransactionTime, "编辑后的交易时间不应为空");
        assertNotNull(editedTransactionType, "编辑后的交易类型不应为空");
        assertNotNull(editedCounterparty, "编辑后的交易对方不应为空");
        assertNotNull(editedCommodity, "编辑后的商品不应为空");
        assertNotNull(editedInOut, "编辑后的收/支不应为空");
        assertNotNull(editedPaymentMethod, "编辑后的支付方式不应为空");
    }

    @Test
    public void testAddFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取 Add 按钮
        JButton addButton = findButton(inputPanel, "Add");
        assertNotNull(addButton, "Add 按钮不应为空");

        // 模拟点击 Add 按钮
        addButton.doClick();

        // 获取对话框
        Window[] windows = Window.getWindows();
        JDialog addDialog = null;
        for (Window window : windows) {
            if (window instanceof JDialog && "添加交易".equals(((JDialog) window).getTitle())) {
                addDialog = (JDialog) window;
                break;
            }
        }
        assertNotNull(addDialog, "添加交易的对话框应弹出");

        // 获取对话框中的输入字段
        JTextField transactionTimeField = findTextField(addDialog.getContentPane(), 0);
        JTextField transactionTypeField = findTextField(addDialog.getContentPane(), 1);
        JTextField counterpartyField = findTextField(addDialog.getContentPane(), 2);
        JTextField commodityField = findTextField(addDialog.getContentPane(), 3);
        JComboBox<String> inOutComboBox = findComboBox(addDialog.getContentPane());
        JTextField paymentAmountField = findTextField(addDialog.getContentPane(), 4);
        JTextField paymentMethodField = findTextField(addDialog.getContentPane(), 5);
        JTextField currentStatusField = findTextField(addDialog.getContentPane(), 6);
        JTextField orderNumberField = findTextField(addDialog.getContentPane(), 7);
        JTextField merchantNumberField = findTextField(addDialog.getContentPane(), 8);
        JTextField remarksField = findTextField(addDialog.getContentPane(), 9);

        // 设置新交易的输入值
        transactionTimeField.setText("2025/3/15 12:00"); // 交易时间
        transactionTypeField.setText("转账");            // 交易类型
        counterpartyField.setText("张三");               // 交易对方
        commodityField.setText("转账");                 // 商品
        inOutComboBox.setSelectedItem("支出");          // 收/支
        paymentAmountField.setText("100.0");            // 金额(元)
        paymentMethodField.setText("银行卡");           // 支付方式
        currentStatusField.setText("已完成");           // 当前状态
        orderNumberField.setText("123456789");          // 交易单号
        merchantNumberField.setText("987654321");       // 商户单号
        remarksField.setText("测试备注");               // 备注

        // 获取确认按钮
        JButton confirmButton = findButton(addDialog.getContentPane(), "确认");
        assertNotNull(confirmButton, "确认按钮不应为空");

        // 模拟点击确认按钮
        confirmButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证新交易是否添加到表格中
        boolean isTransactionAdded = false;
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentAmount = (String) tableModel.getValueAt(i, 5);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);
            String rowCurrentStatus = (String) tableModel.getValueAt(i, 7);
            String rowOrderNumber = (String) tableModel.getValueAt(i, 8);
            String rowMerchantNumber = (String) tableModel.getValueAt(i, 9);
            String rowRemarks = (String) tableModel.getValueAt(i, 10);

            if (rowTransactionTime.equals("2025/3/15 12:00") &&
                    rowTransactionType.equals("转账") &&
                    rowCounterparty.equals("张三") &&
                    rowCommodity.equals("转账") &&
                    rowInOut.equals("支出") &&
                    rowPaymentAmount.equals("100.0") &&
                    rowPaymentMethod.equals("银行卡") &&
                    rowCurrentStatus.equals("已完成") &&
                    rowOrderNumber.equals("123456789") &&
                    rowMerchantNumber.equals("987654321") &&
                    rowRemarks.equals("测试备注")) {
                isTransactionAdded = true;
                break;
            }
        }

        // 验证新交易是否成功添加
        assertTrue(isTransactionAdded, "新交易应成功添加到表格中");
    }

    /**
     * 显示界面以便手动验证
     *
     * @param panel 要显示的面板
     */
    private void showUI(JPanel panel) {
        JFrame frame = new JFrame("MenuUI Test");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(1200, 600);
        frame.add(panel);
        frame.setVisible(true);

        // 保持界面显示一段时间（5秒）
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        frame.dispose(); // 关闭界面
    }

    /**
     * 查找输入面板
     *
     * @param mainPanel 主面板
     * @return 输入面板
     */
    private JPanel findInputPanel(JPanel mainPanel) {
        // 获取右边的面板
        Component[] components = mainPanel.getComponents();
        JPanel rightPanel = null;
        for (Component component : components) {
            if (component instanceof JPanel && ((JPanel) component).getComponentCount() > 0) {
                rightPanel = (JPanel) component;
                break;
            }
        }

        if (rightPanel != null) {
            // 在右边面板中查找输入面板
            for (Component component : rightPanel.getComponents()) {
                if (component instanceof JPanel) {
                    JPanel panel = (JPanel) component;
                    System.out.println("Panel found: " + panel.getName()); // 打印面板名称
                    if (panel.getComponentCount() > 0 && panel.getComponent(0) instanceof JLabel) {
                        return panel; // 输入面板通常包含 JLabel
                    }
                }
            }
        }
        return null;
    }

    /**
     * 查找输入字段
     *
     * @param container     输入面板
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0;
        for (Component component : container.getComponents()) {
            if (component instanceof JTextField) {
                if (count == index) {
                    return (JTextField) component;
                }
                count++;
            }
        }
        return null;
    }


    /**
     * 查找下拉框
     *
     * @param container 输入面板
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) {
            if (component instanceof JComboBox) {
                return (JComboBox<String>) component;
            }
        }
        return null;
    }

    /**
     * 查找按钮
     *
     * @param panel 输入面板
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container  容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    private JButton findButton(Container container, String buttonText) {
        for (Component component : container.getComponents()) {
            if (component instanceof JButton) {
                JButton button = (JButton) component;
                if (button.getText().equals(buttonText)) {
                    return button;
                }
            }
        }
        return null;
    }
}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\test\java\DAOTest\CsvTransactionDaoTest.java`:

```java
package DAOTest;

import DAO.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static Constants.ConfigConstants.CSV_PATH;
import static org.assertj.core.api.Assertions.*;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

class CsvTransactionDaoTest {
    // 测试文件路径（根据实际结构调整）
    private static final String TEST_CSV_PATH = CSV_PATH;
    private static CsvTransactionDao dao;

    @Test
    void testLoadFromCSV_ValidFile_ReturnsTransactions() throws Exception {
        // Given
        CsvTransactionDao dao = new CsvTransactionDao();

        // When
        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);

        // 验证第一条记录的字段
        for (int i = 0; i < transactions.size(); i++) {
            System.out.println(transactions.get(i).getRemarks());
            System.out.println(transactions.get(i).getCommodity());
        }


    }
    @Test
    void testAddTransaction() throws IOException {
        dao=new CsvTransactionDao();
        Transaction newTx = new Transaction(
                "2025-03-09 10:00",
                "转账",
                "小明",
                "书籍",
                "支",
                99.99,
                "微信",
                "已完成",
                "TX123456",
                "M789012",
                "");

        dao.addTransaction("src/test/resources/001.csv", newTx);

        List<Transaction> transactions = dao.loadFromCSV(TEST_CSV_PATH);

    }

    @Test
    void testDeleteTransaction() throws IOException {
        dao=new CsvTransactionDao();

        dao.deleteTransaction("CSV_RELATIVE_PATH", "4200057899202502250932735481");

        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);
    }
    @Test
    void testChangeInfo() throws IOException{
        dao=new CsvTransactionDao();
        dao.changeInformation("TX123456","remarks","测试修改信息",TEST_CSV_PATH);
        dao.changeInformation("TX123456","paymentAmount","116156",TEST_CSV_PATH);
    }

}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\test\java\Service\AIAnalyzerThreadTest.java`:

```java
package Service;



import Service.AIservice.AIAnalyzerThread;
import org.junit.jupiter.api.Test;

public class AIAnalyzerThreadTest {

    @Test
    public void testRunAIAnalyzerThread() throws InterruptedException {
        String userRequest = "请帮我分析最近的交易收支情况";
        String filePath = "src/test/resources/sample_transactions.csv";
        String startTimeStr = "2025/03/20";
        String endTimeStr = "";

        // 启动线程
        Thread thread = new Thread(new AIAnalyzerThread(userRequest, filePath, startTimeStr, endTimeStr));
        thread.start();

        // 等待线程执行完成
        thread.join();
    }
}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\test\java\Service\AIserviceTest.java`:

```java
package Service;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

public class AIserviceTest {

    @Test
    public void testAnalyzeTransactions() {
        AITransactionService service = new AITransactionService();

        String userRequest = "请帮我分析这个月的收支情况";
        String filePath = "src/test/resources/sample_transactions.csv";

        String result = service.analyzeTransactions(userRequest, filePath,"2025/03/20","");

        assertNotNull(result, "AI分析结果不能为空");
        System.out.println("AI分析结果: " + result);
    }


}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\test\java\Service\AiFunctionTest.java`:

```java
package Service;

import DAO.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

import java.io.IOException;
import java.util.List;

public class AiFunctionTest {

    @Test
    public void testAnalyzeTransactions() throws IOException {

        String filePath = "src/test/resources/sample_transactions.csv";
        CsvTransactionDao transactionDao = new CsvTransactionDao();

        List<Transaction> transactions = transactionDao.loadFromCSV(filePath);

        // 实例化服务类
        AITransactionService service = new AITransactionService();

        // 调用合并格式化函数
        List<String> result = service.formatTransactions(transactions,"2025/03/29","2025/04/10");

        // 输出结果
        result.forEach(System.out::println);
    }




}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\test\java\Service\CacheTest.java`:

```java
package Service;

import Constants.CaffeineKeys;
import DAO.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import com.github.benmanes.caffeine.cache.Caffeine;
import model.Transaction;
import org.junit.jupiter.api.Test;

import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;

public class CacheTest {

    TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());

    @Test
    void DeleteCache(){
        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;
        cache.invalidate(TRANSACTION_CAFFEINE_KEY);
    }

}

```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\test\java\Service\CollegeStudentNeedsTest.java`:

```java
package Service;

import Service.AIservice.ColledgeStudentThread;
import Service.AIservice.CollegeStudentNeeds;
import org.junit.jupiter.api.*;

import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.*;

// No @ExtendWith needed as we are not using Mockito extensions
class CollegeStudentNeedsTest {



    private CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
    private static final String TEST_CSV_FILENAME = "src/test/resources/001.csv";
    @Test
    public void testGenerateBudget() throws IOException, InterruptedException {
        Thread t=new Thread( new ColledgeStudentThread(TEST_CSV_FILENAME));
        t.start();
        t.join();
//        collegeStudentNeeds.generateBudget(TEST_CSV_FILENAME);
    }
    @Test
    public void testParseStringToDouble(){
        String s="asdas[369.39,1090.1]das";
        double[] arr=collegeStudentNeeds.parseDoubleArrayFromString(s);
        System.out.println(arr[0]+" "+arr[1]);
    }


}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai Bill Application\src\test\java\Service\TransactionServiceTest.java`:

```java
package Service;

import DAO.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import model.Transaction;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.io.IOException;
import java.util.List;

class TransactionServiceTest {
    private TransactionService transactionService;

    @BeforeEach
    void setUp() {
        // 初始化 DAO 和 Service
        CsvTransactionDao csvTransactionDao = new CsvTransactionDao();
        transactionService = new TransactionServiceImpl(csvTransactionDao);
    }

    @Test
    void testAddTransaction() throws IOException {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );

        // 执行添加操作
        transactionService.addTransaction(transaction);

        // 验证是否添加成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertFalse(transactions.isEmpty());
        assertEquals("T123456789", transactions.get(0).getOrderNumber());
    }

    @Test
    void testChangeTransaction() throws Exception {
        // 准备测试数据
        Transaction originalTransaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(originalTransaction);

        // 准备更新数据
        Transaction updatedTransaction = new Transaction(
                null, "充值", null, null, null, 0.0, "微信支付", null, "T123456789", null, "更新备注"
        );

        // 执行更新操作
        transactionService.changeTransaction(updatedTransaction);

        // 验证是否更新成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertEquals("充值", transactions.get(0).getTransactionType());
        assertEquals("微信支付", transactions.get(0).getPaymentMethod());
        assertEquals("更新备注", transactions.get(0).getRemarks());
    }

    @Test
    void testDeleteTransaction() throws Exception {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(transaction);

        // 执行删除操作
        boolean result = transactionService.deleteTransaction("T123456789");

        // 验证是否删除成功
        assertTrue(result);
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertTrue(transactions.isEmpty());
    }

    @Test
    void testSearchTransaction() throws IOException {

        // 设置搜索条件
        Transaction searchCriteria = new Transaction();
        searchCriteria.setCounterparty("支付宝");

        // 执行搜索操作
        List<Transaction> result = transactionService.searchTransaction(searchCriteria);

        // 验证搜索结果
        result.forEach(res -> System.out.println(res.getCommodity()));
    }


}
```

`软工/Ai-Bill-Application-Group21 - 副本\Ai-Bill-Application-Prompt.txt`:

```txt
Project Path: Ai-Bill-Application-Group21

Source Tree:

```txt
Ai-Bill-Application-Group21
└── Ai Bill Application
    ├── HistogramPanelContainer.java
    └── src
        ├── main
        │   └── java
        │       ├── Constants
        │       │   ├── CaffeineKeys.java
        │       │   └── ConfigConstants.java
        │       ├── Controller
        │       │   ├── ButtonEditor.java
        │       │   ├── ButtonRenderer.java
        │       │   ├── HistogramExample.java
        │       │   ├── HistogramPanelContainer.java
        │       │   └── MenuUI.java
        │       ├── DAO
        │       │   ├── CsvTransactionDao.java
        │       │   └── TransactionDao.java
        │       ├── Interceptor
        │       │   └── Login
        │       │       ├── LoginDialog.java
        │       │       └── UserService.java
        │       ├── Main.java
        │       ├── Service
        │       │   ├── AIservice
        │       │   │   ├── AIAnalyzerThread.java
        │       │   │   ├── AITransactionService.java
        │       │   │   ├── ColledgeStudentThread.java
        │       │   │   └── CollegeStudentNeeds.java
        │       │   ├── Impl
        │       │   │   └── TransactionServiceImpl.java
        │       │   ├── TransactionService.java
        │       │   └── deepseek
        │       │       └── ChatCompletionsExample.java
        │       ├── Utils
        │       │   └── CacheUtil.java
        │       └── model
        │           └── Transaction.java
        └── test
            └── java
                ├── ControllerTest
                │   ├── AITest.java
                │   └── MenuUITest.java
                ├── DAOTest
                │   └── CsvTransactionDaoTest.java
                └── Service
                    ├── AIAnalyzerThreadTest.java
                    ├── AIserviceTest.java
                    ├── AiFunctionTest.java
                    ├── CacheTest.java
                    ├── CollegeStudentNeedsTest.java
                    └── TransactionServiceTest.java

```

`Ai-Bill-Application-Group21/Ai Bill Application\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Constants\CaffeineKeys.java`:

```java
package Constants;

public class CaffeineKeys {
    public static final String TRANSACTION_CAFFEINE_KEY = "transactions";

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Constants\ConfigConstants.java`:

```java
package Constants;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

/**
 * 配置常量类（线程安全初始化）
 */
public final class ConfigConstants {
    // 私有构造防止实例化
    private ConfigConstants() {}

    /**
     * transactionCSV路径加载逻辑
     */
    // CSV路径常量
    public static final String CSV_PATH;
    // 静态初始化块（类加载时执行）
    static {
        Properties prop = new Properties();
        try (InputStream input = ConfigConstants.class.getClassLoader()
                .getResourceAsStream("config.properties")) {

            prop.load(input);
            CSV_PATH = prop.getProperty("csv.path");
        } catch (IOException e) {
            throw new RuntimeException("加载配置文件失败", e); // 转换为运行时异常
        }
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\ButtonEditor.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.TableCellEditor;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

class ButtonEditor extends AbstractCellEditor implements TableCellEditor {
    private final JPanel panel = new JPanel(new BorderLayout()); // 使用 BorderLayout
    private final JButton button = new JButton();
    private int rowIndex;
    private final MenuUI menuUI;

    public ButtonEditor(MenuUI menuUI) {
        this.menuUI = menuUI;

        // 设置按钮样式
        button.setFocusPainted(false); // 移除按钮的焦点边框
        button.setPreferredSize(new Dimension(80, 30)); // 设置按钮的固定尺寸

        // 添加按钮到面板
        panel.add(button, BorderLayout.CENTER);

        // 为按钮添加事件监听器
        button.addActionListener(e -> {
            System.out.println("按钮点击事件触发: " + button.getText());
            fireEditingStopped(); // 停止编辑
            String buttonText = button.getText();
            if ("Modify".equals(buttonText)) {
                menuUI.editRow(rowIndex); // 调用 MenuUI 的 editRow 方法
            } else if ("Delete".equals(buttonText)) {
                int confirm = JOptionPane.showConfirmDialog(panel, "确定要删除此行吗？", "确认删除", JOptionPane.YES_NO_OPTION);
                if (confirm == JOptionPane.YES_OPTION) {
                    menuUI.deleteRow(rowIndex); // 调用 MenuUI 的 deleteRow 方法
                }
            }
        });
    }

    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
        this.rowIndex = row; // 更新当前行索引
        button.setText(value != null ? value.toString() : ""); // 根据单元格的值设置按钮文本
        return panel;
    }

    @Override
    public Object getCellEditorValue() {
        return button.getText(); // 返回按钮的当前文本
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\ButtonRenderer.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import java.awt.*;

class ButtonRenderer extends DefaultTableCellRenderer {
    private final JPanel panel = new JPanel(new BorderLayout()); // 使用 BorderLayout
    private final JButton button = new JButton();

    public ButtonRenderer() {
        button.setFocusPainted(false); // 移除按钮的焦点边框
        button.setPreferredSize(new Dimension(80, 30)); // 设置按钮的固定尺寸
        panel.add(button, BorderLayout.CENTER); // 将按钮添加到面板中心
    }

    @Override
    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
        // 根据单元格的值设置按钮文本
        button.setText(value != null ? value.toString() : "");
        return panel;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\HistogramExample.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;
import java.util.HashMap;
import java.util.Random;

// 数据生成类
class DataGenerator {
    public static int[] generateData(int numberOfDataPoints, int maxValue) {
        Random random = new Random();
        int[] data = new int[numberOfDataPoints];
        for (int i = 0; i < numberOfDataPoints; i++) {
            data[i] = random.nextInt(maxValue);
        }
        return data;
    }
}

// 直方图计算类
class Histogram {
    private int binSize;
    private int[] data;

    public Histogram(int[] data, int binSize) {
        this.data = data;
        this.binSize = binSize;
    }

    public HashMap<Integer, Integer> computeFrequency() {
        HashMap<Integer, Integer> frequencyMap = new HashMap<>();
        for (int number : data) {
            int bin = number / binSize;
            frequencyMap.put(bin, frequencyMap.getOrDefault(bin, 0) + 1);
        }
        return frequencyMap;
    }
}

// 直方图 GUI 绘制类
class HistogramPanel extends JPanel {
    HashMap<Integer, Integer> frequencyMap;

    public HistogramPanel() {
        this.frequencyMap = new HashMap<>();
    }

    public void updateData(HashMap<Integer, Integer> frequencyMap) {
        this.frequencyMap = frequencyMap;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        int barWidth = 40;
        int gap = 10;
        int maxFrequency = frequencyMap.values().stream().mapToInt(v -> v).max().orElse(1);

        int index = 0;
        for (Integer key : frequencyMap.keySet()) {
            int height = (int) ((frequencyMap.get(key) / (double) maxFrequency) * getHeight());
            g.setColor(Color.BLUE);
            g.fillRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.setColor(Color.BLACK);
            g.drawRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.drawString("Bin " + key, index * (barWidth + gap) + 5, getHeight() - 5);
            index++;
        }
    }
}


// 主窗口类
public class HistogramExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("数据分析界面");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\MenuUI.java`:

```java
package Controller;

import Constants.ConfigConstants;
import DAO.CsvTransactionDao;

import Service.Impl.TransactionServiceImpl;

import Service.Impl.TransactionServiceImpl;

import Utils.CacheUtil;
import model.Transaction;

import javax.swing.*;
import java.awt.*;
import java.io.IOException;
import java.util.List;
import java.util.Vector;
import javax.swing.table.DefaultTableModel;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class MenuUI {
    private static final String FILE_PATH = CSV_PATH;
    private static DefaultTableModel tableModel;
    private static Vector<Vector<String>> allData = new Vector<>();
    private static TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());
    private JTable table;  // 把table定义为静态字段
    private HistogramPanelContainer histogramPanelContainer; // 添加 HistogramPanelContainer 实例
    private JPanel rightPanel; // 右边的面板，用于显示搜索和表格界面或 AI 界面
    private CardLayout cardLayout; // 用于管理界面切换的布局

    public MenuUI(){
        String[] columnNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注", "Modify", "Delete"};
        tableModel = new DefaultTableModel(columnNames, 0);
        table = new JTable(tableModel);

        histogramPanelContainer = new HistogramPanelContainer(); // 初始化 HistogramPanelContainer
        cardLayout = new CardLayout(); // 初始化 CardLayout
        rightPanel = new JPanel(cardLayout); // 初始化 rightPanel
    }

    public JPanel createMainPanel() {
        // 主面板，使用 BorderLayout
        JPanel mainPanel = new JPanel(new BorderLayout());

        // 左边的面板，包含 Menu 和 AI 按钮
        JPanel leftPanel = createLeftPanel();
        mainPanel.add(leftPanel, BorderLayout.WEST);

        // 右边的面板，用于显示搜索和表格界面或 AI 界面
        setupRightPanel();
        mainPanel.add(rightPanel, BorderLayout.CENTER);

        return mainPanel;
    }

    // 创建左边的面板，包含 Menu 和 AI 按钮
    private JPanel createLeftPanel() {
        JPanel leftPanel = new JPanel(new GridLayout(2, 1));
        JButton menuButton = new JButton("Menu");
        JButton aiButton = new JButton("AI");

        leftPanel.add(menuButton);
        leftPanel.add(aiButton);

        // 为 Menu 按钮添加 ActionListener
        menuButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Table"); // 切换到表格界面
        });

        // 为 AI 按钮添加 ActionListener
        aiButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Histogram"); // 切换到直方图界面
        });

        return leftPanel;
    }

    // 设置右边的面板，包含搜索和表格界面或 AI 界面
    private void setupRightPanel() {
        // 创建搜索和表格的面板
        JPanel tablePanel = createTablePanel();

        // 将表格面板和直方图面板添加到 rightPanel
        rightPanel.add(tablePanel, "Table");
        rightPanel.add(histogramPanelContainer, "Histogram");
    }

    // 创建搜索和表格的面板
    private JPanel createTablePanel() {
        JPanel tablePanel = new JPanel(new BorderLayout());

        // 创建输入面板
        JPanel inputPanel = createInputPanel();
        tablePanel.add(inputPanel, BorderLayout.NORTH);

        // 创建表格的滚动面板
        JScrollPane tableScrollPane = new JScrollPane(table);
        tableScrollPane.setPreferredSize(new Dimension(1000, 250));
        table.setRowHeight(30); // 设置表格的行高

        tablePanel.add(tableScrollPane, BorderLayout.CENTER);

        // 为 Modify 列设置渲染器和编辑器
        table.getColumnModel().getColumn(11).setCellRenderer(new ButtonRenderer());
        table.getColumnModel().getColumn(11).setCellEditor(new ButtonEditor(this));

        // 为 Delete 列设置渲染器和编辑器
        table.getColumnModel().getColumn(12).setCellRenderer(new ButtonRenderer());
        table.getColumnModel().getColumn(12).setCellEditor(new ButtonEditor(this));

        // 加载 CSV 数据
        loadCSVData(FILE_PATH);

        return tablePanel;
    }

    // 创建输入面板
    private JPanel createInputPanel() {
        JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));

        // 创建输入字段
        JTextField transactionTimeField = new JTextField(10); // 交易时间输入框
        JTextField transactionTypeField = new JTextField(10); // 交易类型输入框
        JTextField counterpartyField = new JTextField(10);    // 交易对方输入框
        JTextField commodityField = new JTextField(10);      // 商品输入框
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"}); // 收/支下拉框
        JTextField paymentMethodField = new JTextField(10);  // 支付方式输入框

        // 添加标签和输入字段到输入面板
        inputPanel.add(new JLabel("交易时间:"));
        inputPanel.add(transactionTimeField);
        inputPanel.add(new JLabel("交易类型:"));
        inputPanel.add(transactionTypeField);
        inputPanel.add(new JLabel("交易对方:"));
        inputPanel.add(counterpartyField);
        inputPanel.add(new JLabel("商品:"));
        inputPanel.add(commodityField);
        inputPanel.add(new JLabel("收/支:"));
        inputPanel.add(inOutComboBox);
        inputPanel.add(new JLabel("支付方式:"));
        inputPanel.add(paymentMethodField);

        // 创建 Search 和 Add 按钮
        JButton searchButton = new JButton("Search");
        JButton addButton = new JButton("Add");

        // 将按钮添加到输入面板
        inputPanel.add(searchButton);
        inputPanel.add(addButton);

        // 为 Search 按钮添加 ActionListener
        searchButton.addActionListener(e -> {
            // 获取输入字段的值
            searchData(
                    transactionTimeField.getText().trim(),
                    transactionTypeField.getText().trim(),
                    counterpartyField.getText().trim(),
                    commodityField.getText().trim(),
                    (String) inOutComboBox.getSelectedItem(),
                    paymentMethodField.getText().trim()
            );
        });

        // 为 Add 按钮添加 ActionListener
        addButton.addActionListener(e -> {
            // 弹出对话框，输入交易信息
            showAddTransactionDialog();
        });

        return inputPanel;
    }

    // 弹出对话框，输入交易信息
    private void showAddTransactionDialog() {
        // 创建对话框
        JDialog addDialog = new JDialog();
        addDialog.setTitle("添加交易");
        addDialog.setLayout(new GridLayout(12, 2)); // 11 个字段 + 1 个按钮行

        // 创建输入字段
        JTextField transactionTimeField = new JTextField();
        JTextField transactionTypeField = new JTextField();
        JTextField counterpartyField = new JTextField();
        JTextField commodityField = new JTextField();
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"});
        JTextField paymentAmountField = new JTextField();
        JTextField paymentMethodField = new JTextField();
        JTextField currentStatusField = new JTextField();
        JTextField orderNumberField = new JTextField();
        JTextField merchantNumberField = new JTextField();
        JTextField remarksField = new JTextField();

        // 添加标签和输入字段到对话框
        addDialog.add(new JLabel("交易时间:"));
        addDialog.add(transactionTimeField);
        addDialog.add(new JLabel("交易类型:"));
        addDialog.add(transactionTypeField);
        addDialog.add(new JLabel("交易对方:"));
        addDialog.add(counterpartyField);
        addDialog.add(new JLabel("商品:"));
        addDialog.add(commodityField);
        addDialog.add(new JLabel("收/支:"));
        addDialog.add(inOutComboBox);
        addDialog.add(new JLabel("金额(元):"));
        addDialog.add(paymentAmountField);
        addDialog.add(new JLabel("支付方式:"));
        addDialog.add(paymentMethodField);
        addDialog.add(new JLabel("当前状态:"));
        addDialog.add(currentStatusField);
        addDialog.add(new JLabel("交易单号:"));
        addDialog.add(orderNumberField);
        addDialog.add(new JLabel("商户单号:"));
        addDialog.add(merchantNumberField);
        addDialog.add(new JLabel("备注:"));
        addDialog.add(remarksField);

        // 添加确认按钮
        JButton confirmButton = new JButton("确认");
        confirmButton.addActionListener(e -> {
            // 获取输入字段的值，若为空则设置为默认值
            String transactionTime = emptyIfNull(transactionTimeField.getText().trim());
            String transactionType = emptyIfNull(transactionTypeField.getText().trim());
            String counterparty = emptyIfNull(counterpartyField.getText().trim());
            String commodity = emptyIfNull(commodityField.getText().trim());
            String inOut = (String) inOutComboBox.getSelectedItem();
            String paymentAmountText = paymentAmountField.getText().trim();
            double paymentAmount = paymentAmountText.isEmpty() ? 0.0 : Double.parseDouble(paymentAmountText); // 处理空字符串
            String paymentMethod = emptyIfNull(paymentMethodField.getText().trim());
            String currentStatus = emptyIfNull(currentStatusField.getText().trim());
            String orderNumber = emptyIfNull(orderNumberField.getText().trim());
            String merchantNumber = emptyIfNull(merchantNumberField.getText().trim());
            String remarks = emptyIfNull(remarksField.getText().trim());

            // 创建 Transaction 对象
            Transaction newTransaction = new Transaction(
                    transactionTime,
                    transactionType,
                    counterparty,
                    commodity,
                    inOut,
                    paymentAmount,
                    paymentMethod,
                    currentStatus,
                    orderNumber,
                    merchantNumber,
                    remarks
            );

            try {
                // 调用 TransactionServiceImpl 的 addTransaction 方法
                transactionService.addTransaction(newTransaction);

                // 重新加载 CSV 数据以更新表格
                loadCSVData(TRANSACTION_CAFFEINE_KEY);

                // 关闭对话框
                addDialog.dispose();

                JOptionPane.showMessageDialog(null, "交易添加成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(null, "交易添加失败！", "错误", JOptionPane.ERROR_MESSAGE);
            }
        });

        addDialog.add(confirmButton);

        // 设置对话框大小并显示
        addDialog.setSize(400, 300);
        addDialog.setModal(true); // 设置为模态对话框
        addDialog.setVisible(true);
    }

    // 加载 CSV 数据
    public void loadCSVData(String caffeineKey) {
        allData.clear();
        tableModel.setRowCount(0);

        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;

//        CsvTransactionDao csvTransactionDao = new CsvTransactionDao();

        List<Transaction> transactions = cache.get(caffeineKey);
        for (Transaction transaction : transactions) {
            Vector<String> row = createRowFromTransaction(transaction);
            allData.add(row);
            tableModel.addRow(row);
        }
    }

    // 搜索数据
    public void searchData(String query1, String query2, String query3, String query4, String query6, String query5) {
        tableModel.setRowCount(0);
        Transaction searchCriteria = new Transaction(query1, query2, query3, query4, query6, 0, query5, "", "", "", "");

        try {
            List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);
            for (Transaction transaction : transactions) {
                Vector<String> row = createRowFromTransaction(transaction);
                tableModel.addRow(row);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(null, "查询失败！", "错误", JOptionPane.ERROR_MESSAGE);
        }
    }

    // 从 Transaction 对象创建表格行
    private Vector<String> createRowFromTransaction(Transaction transaction) {
        Vector<String> row = new Vector<>();
        row.add(transaction.getTransactionTime());
        row.add(transaction.getTransactionType());
        row.add(transaction.getCounterparty());
        row.add(transaction.getCommodity());
        row.add(transaction.getInOut());
        row.add(String.valueOf(transaction.getPaymentAmount()));
        row.add(transaction.getPaymentMethod());
        row.add(transaction.getCurrentStatus());
        row.add(transaction.getOrderNumber());
        row.add(transaction.getMerchantNumber());
        row.add(transaction.getRemarks());
        row.add("Modify"); // Modify 按钮
        row.add("Delete"); // 添加 Delete 按钮
        return row;
    }

    // 删除行
    public void deleteRow(int rowIndex) {
        if (rowIndex >= 0 && rowIndex < allData.size()) {
            String orderNumber = allData.get(rowIndex).get(8).trim();
            System.out.println("尝试删除的交易单号: " + orderNumber); // 打印交易单号

            try {
                if (transactionService.deleteTransaction(orderNumber)) {
                    allData.remove(rowIndex);
                    tableModel.removeRow(rowIndex);
                    JOptionPane.showMessageDialog(null, "删除成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                } else {
                    JOptionPane.showMessageDialog(null, "删除失败：未找到对应的交易单号", "错误", JOptionPane.ERROR_MESSAGE);
                }
            } catch (IOException ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(null, "删除失败！", "错误", JOptionPane.ERROR_MESSAGE);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    // 编辑行
    public void editRow(int rowIndex) {
        System.out.println("编辑行: " + rowIndex);
        if (rowIndex >= 0 && rowIndex < allData.size()) {
            Vector<String> rowData = allData.get(rowIndex);

            // 创建一个面板用于显示编辑字段
            JPanel panel = new JPanel(new GridLayout(rowData.size() - 2, 2)); // 排除最后两列

            // 创建字段数组，用于存储用户输入的值
            JTextField[] fields = new JTextField[rowData.size() - 2]; // 排除最后两列

            // 遍历 rowData，跳过最后两列（"Modify" 和 "Delete"）
            for (int i = 0; i < rowData.size() - 2; i++) {
                panel.add(new JLabel(tableModel.getColumnName(i))); // 添加列名标签
                fields[i] = new JTextField(rowData .get(i)); // 添加输入字段
                panel.add(fields[i]);
            }

            // 弹出对话框，让用户修改数据
            int result = JOptionPane.showConfirmDialog(null, panel, "修改交易信息", JOptionPane.OK_CANCEL_OPTION);
            if (result == JOptionPane.OK_OPTION) {
                // 用户点击了确认按钮，更新交易信息
                Transaction transaction = new Transaction(
                        fields[0].getText().trim(), // 交易时间
                        fields[1].getText().trim(), // 交易类型
                        fields[2].getText().trim(), // 交易对方
                        fields[3].getText().trim(), // 商品
                        fields[4].getText().trim(), // 收/支
                        Double.parseDouble(fields[5].getText().trim()), // 金额(元)
                        fields[6].getText().trim(), // 支付方式
                        fields[7].getText().trim(), // 当前状态
                        fields[8].getText().trim(), // 交易单号
                        fields[9].getText().trim(), // 商户单号
                        fields[10].getText().trim() // 备注
                );

                try {
                    // 调用 TransactionServiceImpl 的 changeTransaction 方法更新交易
                    transactionService.changeTransaction(transaction);

                    // 重新加载 CSV 数据以更新表格
                    loadCSVData(TRANSACTION_CAFFEINE_KEY);

                    JOptionPane.showMessageDialog(null, "修改成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                } catch (Exception ex) {
                    ex.printStackTrace();
                    JOptionPane.showMessageDialog(null, "修改失败！", "错误", JOptionPane.ERROR_MESSAGE);
                }
            }
        }
    }

    /**
     * 查找对话框中的输入字段
     *
     * @param dialog 对话框
     * @param index  输入字段的索引
     * @return 输入字段
     */
    /**
     * 查找容器中的输入字段
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0;
        for (Component component : container.getComponents()) {
            if (component instanceof JTextField) {
                if (count == index) {
                    return (JTextField) component;
                }
                count++;
            }
        }
        return null;
    }

    /**
     * 查找对话框中的下拉框
     *
     * @param dialog 对话框
     * @return 下拉框
     */
    /**
     * 查找容器中的下拉框
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) {
            if (component instanceof JComboBox) {
                return (JComboBox<String>) component;
            }
        }
        return null;
    }

    /**
     * 如果字段为 null，则返回空文本
     *
     * @param value 字段值
     * @return 非 null 的字段值
     */
    private String emptyIfNull(String value) {
        return value == null ? "" : value;
    }

    // 添加此方法以便测试时可以获取table
    public JTable getTable() {
        return table;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\DAO\CsvTransactionDao.java`:

```java
package DAO;

import Constants.ConfigConstants;
import model.Transaction;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static Constants.ConfigConstants.CSV_PATH;

public class CsvTransactionDao implements TransactionDao {
    //避免每次都调用loadFromCSV() 方法
    private List<Transaction> transactions;
    private boolean isLoad= false;
//HEAD 交易时间	交易类型	交易对方	商品	收/支	金额(元)	支付方式	当前状态	交易单号	商户单号	备注
    //
    @Override
    public List<Transaction> loadFromCSV(String filePath) throws IOException {
        try (
                Reader reader = new InputStreamReader(
                        new BOMInputStream(Files.newInputStream(Paths.get(filePath))),
                        StandardCharsets.UTF_8)) {
            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()    //根据首行的内容设置为表格的头
                    .withIgnoreHeaderCase(false)  // 禁用忽略大小写
                    .withTrim(false);             // 禁用自动trim（防止意外空格问题）

            try (CSVParser csvParser = new CSVParser(reader, format)) {

                List<Transaction> transactions = new ArrayList<>();
                for (CSVRecord record : csvParser) {
                    Transaction transaction = parseRecord(record);
                    transactions.add(transaction);
                }
                reader.close();
                this.transactions = transactions;
                this.isLoad=true;
                return transactions;
            }
        }
    }


    private Transaction parseRecord(CSVRecord record) {
        return new Transaction(
                record.get("交易时间"),
                record.get("交易类型"),
                record.get("交易对方"),
                record.get("商品"),
                record.get("收/支"),
                Double.parseDouble(record.get("金额(元)").substring(1)),
                record.get("支付方式"),
                record.get("当前状态"),
                record.get("交易单号"),
                record.get("商户单号"),
                record.get("备注")
        );
    }

    // 根据交易单号删除交易记录
    public boolean deleteTransaction(String filePath, String orderNumber) throws IOException {
        if(!isLoad){ loadFromCSV(filePath);}

        List<Transaction> updatedTransactions = transactions.stream()
                .filter(t -> !t.getOrderNumber().trim().equals(orderNumber))
                .collect(Collectors.toList());

        if (transactions.size() == updatedTransactions.size()) {
            return false;
        }

        writeTransactionsToCSV(filePath, updatedTransactions);
        return true;
    }

    // 添加交易
    public void addTransaction(String filePath, Transaction newTransaction) throws IOException {
        boolean fileExists = Files.exists(Paths.get(filePath)) && Files.size(Paths.get(filePath)) > 0;

        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(filePath), StandardOpenOption.CREATE, StandardOpenOption.APPEND);
             CSVPrinter csvPrinter = new CSVPrinter(writer, fileExists ? getCsvFormatWithoutHeader() : getCsvFormatWithHeader(filePath))) {

            csvPrinter.printRecord(
                    newTransaction.getTransactionTime(),
                    newTransaction.getTransactionType(),
                    newTransaction.getCounterparty(),
                    newTransaction.getCommodity(),
                    newTransaction.getInOut(),
                    "¥" + newTransaction.getPaymentAmount(),
                    newTransaction.getPaymentMethod(),
                    newTransaction.getCurrentStatus(),
                    newTransaction.getOrderNumber(),
                    newTransaction.getMerchantNumber(),
                    newTransaction.getRemarks()
            );

            csvPrinter.flush();
        }
    }

    // 统一写回 CSV
    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
        // 1. 创建临时文件（确保与原文件同目录）
        File targetFile = new File(filePath);
        File tempFile = File.createTempFile("transaction_temp", ".csv", targetFile.getParentFile());

        // 2. 写入数据到临时文件（使用 try-with-resources 确保资源释放）
        try (BufferedWriter writer = Files.newBufferedWriter(tempFile.toPath());
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(
                     "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"))) {

            for (Transaction t : transactions) {
                csvPrinter.printRecord(
                        t.getTransactionTime(),
                        t.getTransactionType(),
                        t.getCounterparty(),
                        t.getCommodity(),
                        t.getInOut(),
                        "¥" + t.getPaymentAmount(),
                        t.getPaymentMethod(),
                        t.getCurrentStatus(),
                        t.getOrderNumber(),
                        t.getMerchantNumber(),
                        t.getRemarks()
                );
            }
            csvPrinter.flush(); // 强制刷盘
        } catch (IOException e) {
            tempFile.delete(); // 失败时删除临时文件
            throw e;
        }

        // 3. 原子性替换原文件
        Path source = tempFile.toPath();
        Path target = Paths.get(filePath);
        try {
            Files.move(source, target, StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            System.err.println("移动失败原因: " + e.getMessage());
        }
    }

//    // 统一写回 CSV
//    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
//        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(filePath));
//             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(
//                     "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注")))  {
//
//            for (Transaction t : transactions) {
//                csvPrinter.printRecord(
//                        t.getTransactionTime(),
//                        t.getTransactionType(),
//                        t.getCounterparty(),
//                        t.getCommodity(),
//                        t.getInOut(),
//                        "¥" + t.getPaymentAmount(),
//                        t.getPaymentMethod(),
//                        t.getCurrentStatus(),
//                        t.getOrderNumber(),
//                        t.getMerchantNumber(),
//                        t.getRemarks()
//                );
//            }
//        }
//    }

    // 获取 CSV 格式（包含表头）
    private CSVFormat getCsvFormatWithHeader(String filePath) throws IOException {
        try (BufferedReader reader = Files.newBufferedReader(Paths.get(filePath))) {
            String headerLine = reader.readLine();
            if (headerLine == null || headerLine.trim().isEmpty()) {
                // 如果文件为空或不存在，返回默认表头
                return CSVFormat.DEFAULT.withHeader(
                        "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"
                );
            }
            return CSVFormat.DEFAULT.withHeader(headerLine.split(",")).withTrim();
        }
    }

    // 获取 CSV 格式（不包含表头）
    private CSVFormat getCsvFormatWithoutHeader() {
        return CSVFormat.DEFAULT.withTrim();
    }

    public boolean changeInformation(String orderNumber, String head, String value,String path) throws IOException{
        if(isLoad==false){ loadFromCSV(path);}
        for (int i = 0; i < transactions.size(); i++) {
            if(transactions.get(i).getOrderNumber().trim().equals(orderNumber)){
                Transaction newTransaction=transactions.get(i);
                switch (head){
                    case "transactionTime" :{
                        newTransaction.setTransactionTime(value);
                        break;}
                    case "transactionType" :{
                        newTransaction.setTransactionType(value);
                        break;
                    }
                    case "counterparty" :{
                        newTransaction.setCounterparty(value);
                        break;
                    } case "commodity" :{
                        newTransaction.setCommodity(value);
                        break;
                    } case "inOut" :{
                        newTransaction.setInOut(value);
                        break;
                    } case "paymentAmount" :{
                        newTransaction.setPaymentAmount(Double.parseDouble(value));
                        break;
                    } case "paymentMethod" :{
                        newTransaction.setPaymentMethod(value);
                        break;
                    } case "currentStatus" :{
                        newTransaction.setCurrentStatus(value);
                        break;
                    } case "orderNumber" :{
                        newTransaction.setOrderNumber(value);
                        break;
                    } case "merchantNumber" :{
                        newTransaction.setMerchantNumber(value);
                        break;
                    } case "remarks" :{
                        newTransaction.setRemarks(value);
                        break;
                    } default:{
                        System.err.println("error head");
                    }
                }

                boolean flag=deleteTransaction(path,transactions.get(i).getOrderNumber());
                if(flag) {
                    addTransaction(path,newTransaction);
                    System.out.println("success to delete");
                }
                else System.err.println("failed to delete");
            }
        }
        return true;
    }

    @Override
    public List<Transaction> getAllTransactions() throws IOException {
        return List.of();
    }

    @Override
    public void addTransaction(Transaction transaction) throws IOException {

    }

    @Override
    public boolean deleteTransaction(String orderNumber) throws IOException {
        return false;
    }

    @Override
    public boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException {
        return false;
    }

    @Override
    public Transaction getTransactionByOrderNumber(String orderNumber) throws IOException {
        return null;
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\DAO\TransactionDao.java`:

```java
package DAO;

import model.Transaction;

import java.io.IOException;
import java.util.List;

/**
 * Interface for Data Access Object (DAO) operations related to Transactions.
 * Defines the contract for loading, adding, deleting, and updating transaction data.
 */
public interface
TransactionDao {

    //HEAD 交易时间	交易类型	交易对方	商品	收/支	金额(元)	支付方式	当前状态	交易单号	商户单号	备注
        //
    List<Transaction> loadFromCSV(String filePath) throws IOException;

    /**
     * Loads all transactions from the configured data source.
     *
     * @return A list of all transactions.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<Transaction> getAllTransactions() throws IOException;

    /**
     * Adds a new transaction to the data source.
     *
     * @param transaction The new transaction to add.
     * @throws IOException If an I/O error occurs during saving.
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * Deletes a transaction identified by its order number.
     *
     * @param orderNumber The unique order number of the transaction to delete.
     * @return true if a transaction was found and deleted, false otherwise.
     * @throws IOException If an I/O error occurs during loading or saving.
     */
    boolean deleteTransaction(String orderNumber) throws IOException;

    /**
     * Updates a specific field of an existing transaction identified by its order number.
     *
     * @param orderNumber The unique order number of the transaction to update.
     * @param fieldName   The name of the field to update (e.g., "transactionType", "paymentAmount").
     * @param newValue    The new value for the specified field.
     * @return true if the transaction was found and updated, false otherwise.
     * @throws IOException             If an I/O error occurs during loading or saving.
     * @throws NumberFormatException   If updating 'paymentAmount' and newValue is not a valid double.
     * @throws IllegalArgumentException If the fieldName is invalid.
     */
    boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException;

    /**
     * Retrieves a transaction by its unique order number.
     * (Optional but often useful)
     *
     * @param orderNumber The unique order number.
     * @return The Transaction object if found, null otherwise.
     * @throws IOException If an I/O error occurs during loading.
     */
    Transaction getTransactionByOrderNumber(String orderNumber) throws IOException;

}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Interceptor\Login\LoginDialog.java`:

```java
package Interceptor.Login;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class LoginDialog extends JDialog {
    private boolean loginSuccessful = false;
    private JTextField usernameField;
    private JPasswordField passwordField;
    private UserService userService = new UserService();

    public LoginDialog() {
        setTitle("用户登录");
        setLayout(new GridLayout(3, 2));
        setModal(true);
        setSize(300, 150);

        // 输入组件
        usernameField = new JTextField();
        passwordField = new JPasswordField();
        JButton loginButton = new JButton("登录");
        JButton cancelButton = new JButton("取消");

        // 添加组件
        add(new JLabel("用户名:"));
        add(usernameField);
        add(new JLabel("密码:"));
        add(passwordField);
        add(loginButton);
        add(cancelButton);

        // 登录按钮逻辑
        loginButton.addActionListener(e -> {
            String username = usernameField.getText().trim();
            String password = new String(passwordField.getPassword()).trim();

            if (userService.authenticate(username, password)) {
                loginSuccessful = true;
                dispose(); // 关闭对话框
            } else {
                JOptionPane.showMessageDialog(
                        this,
                        "用户名或密码错误！",
                        "登录失败",
                        JOptionPane.ERROR_MESSAGE
                );
                clearFields(); // 登录失败后清空文本框
            }
        });

        // 取消按钮逻辑
        cancelButton.addActionListener(e -> {
            dispose();
            System.exit(0);
        });

        setLocationRelativeTo(null); // 居中显示
    }

    // 清空文本框的方法
    private void clearFields() {
        usernameField.setText("");
        passwordField.setText("");
        usernameField.requestFocus(); // 焦点回到用户名输入框
    }

    public boolean isLoginSuccessful() {
        return loginSuccessful;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Interceptor\Login\UserService.java`:

```java
package Interceptor.Login;

import java.util.HashMap;
import java.util.Map;

public class UserService {
    // 模拟用户数据库（用户名 -> 密码哈希值）
    private static final Map<String, String> userDatabase = new HashMap<>();

    public UserService() {
        // 初始化测试用户（密码为 "admin123" 的 SHA-256 哈希）
        userDatabase.put("admin", "admin123");
    }

    public boolean authenticate(String username, String password) {
        if (username.isEmpty() || password.isEmpty()) return false;
        String storedHash = userDatabase.get(username);
        return password.equals(storedHash);
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Main.java`:

```java
import javax.swing.*;

import Controller.MenuUI;
import DAO.CsvTransactionDao;
import Interceptor.Login.LoginDialog;
import Service.Impl.TransactionServiceImpl;

public class Main {
    public static void main(String[] args) {
        // 初始化服务（依赖注入）
        TransactionServiceImpl.csvTransactionDao = new CsvTransactionDao();

        // 在事件调度线程中启动 GUI（Swing 规范）
        SwingUtilities.invokeLater(() -> {
            // 1. 显示登录对话框
            LoginDialog loginDialog = new LoginDialog();
            loginDialog.setVisible(true);

            // 2. 登录成功后再显示主界面
            if (loginDialog.isLoginSuccessful()) {
                MenuUI menuUI = new MenuUI();
                JPanel mainPanel = menuUI.createMainPanel();
                showMainUI(mainPanel);
            } else {
                System.exit(0); // 登录失败退出
            }
        });
    }

    /**
     * 显示主界面窗口
     */
    private static void showMainUI(JPanel panel) {
        JFrame frame = new JFrame("交易管理系统");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(1200, 600);
        frame.setLocationRelativeTo(null); // 窗口居中
        frame.add(panel);
        frame.setVisible(true);
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\AIAnalyzerThread.java`:

```java
package Service.AIservice;

public class AIAnalyzerThread implements Runnable {
    private final String userRequest;
    private final String filePath;
    private final String startTimeStr;
    private final String endTimeStr;

    public AIAnalyzerThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        this.userRequest = userRequest;
        this.filePath = filePath;
        this.startTimeStr = startTimeStr;
        this.endTimeStr = endTimeStr;
    }

    @Override
    public void run() {
        String result = new AITransactionService().analyzeTransactions(userRequest, filePath, startTimeStr, endTimeStr);
        System.out.println("AI分析结果: " + result);
        // TODO: 如果是UI程序，可用 SwingUtilities.invokeLater() 更新UI组件
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\AITransactionService.java`:

```java
package Service.AIservice;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Constants.ConfigConstants;
import DAO.CsvTransactionDao;
import Utils.CacheUtil;
import model.Transaction;
import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;

import java.io.IOException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;
import java.util.concurrent.*;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class AITransactionService {
    private static final String API_KEY = System.getenv("ARK_API_KEY");
    private static final ArkService service = ArkService.builder()
            .timeout(Duration.ofSeconds(1800))
            .connectTimeout(Duration.ofSeconds(20))
            .baseUrl("https://ark.cn-beijing.volces.com/api/v3")
            .apiKey(API_KEY)
            .build();

    private final CsvTransactionDao transactionDao = new CsvTransactionDao();

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    private final CacheUtil<String, List<Transaction>, Exception> cache;
    /**
     * 重构构造器初始化Caffeine
     */
    public AITransactionService()  {
        // 1. 注入Dao层接口
        TransactionServiceImpl.csvTransactionDao = transactionDao;
        // 2. 初始化CacheUtil
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return transactionDao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );
    }

    public String analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        try {
            List<Transaction> transactions = cache.get(TRANSACTION_CAFFEINE_KEY);
            List<String> transactionDetails = formatTransactions(transactions, startTimeStr, endTimeStr);

            String aiPrompt = userRequest + "\n" + "以下是我的账单信息：\n" + String.join("\n", transactionDetails);
            return askAi(aiPrompt);
        } catch (Exception e) {
            e.printStackTrace();
            return "AI分析失败: " + e.getMessage();
        }
    }


    //private List<String> formatTransactions(List<Transaction> transactions) {
        //return transactions.stream().map(t -> String.format(
               // "交易时间: %s, 商品: %s, 收/支: %s, 金额: %.2f元",
               // t.getTransactionTime(),
               // t.getCommodity(),
               // t.getInOut(),
               // t.getPaymentAmount()
        //)).collect(Collectors.toList());
    //}

    public List<String> formatTransactions(List<Transaction> transactions, String startTimeStr, String endTimeStr) {
        LocalDateTime startTime = parseDateTime(startTimeStr);
        LocalDateTime endTime = (endTimeStr == null || endTimeStr.isEmpty())
                ? LocalDateTime.now()
                : parseDateTime(endTimeStr);

        if (startTime == null) {
            throw new IllegalArgumentException("起始时间格式不正确");
        }

        List<Transaction> filtered = transactions.stream()
                .filter(t -> {
                    LocalDateTime tTime = parseDateTime(t.getTransactionTime());
                    return tTime != null && !tTime.isBefore(startTime) && !tTime.isAfter(endTime);
                })
                .collect(Collectors.toList());

        Map<String, double[]> grouped = new HashMap<>();
        for (Transaction t : filtered) {
            String counterparty = t.getCounterparty();
            double amount = t.getInOut().equals("支出") ? -t.getPaymentAmount() : t.getPaymentAmount();
            grouped.putIfAbsent(counterparty, new double[]{0.0, 0});
            grouped.get(counterparty)[0] += amount;
            grouped.get(counterparty)[1] += 1;
        }

        List<String> results = grouped.entrySet().stream()
                .map(e -> {
                    String cp = e.getKey();
                    double net = e.getValue()[0];
                    int count = (int) e.getValue()[1];
                    String inOut = net >= 0 ? "收入" : "支出";
                    return String.format("交易对方: %s, 收/支: %s, 金额: %.2f元，交易次数: %d",
                            cp, inOut, Math.abs(net), count);
                })
                .collect(Collectors.toList());

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm");
        results.add(String.format("交易时间范围：%s - %s",
                formatter.format(startTime), formatter.format(endTime)));

        return results.isEmpty() ? List.of("该时间段内没有交易记录。") : results;
    }




    //private LocalDateTime parseDateTime(String timeStr) {
        // 你可以按实际情况支持不同格式，比如 yyyy/MM/dd HH:mm 或 yyyy-MM-dd HH:mm:ss
        //List<String> patterns = Arrays.asList("yyyy/MM/dd HH:mm","yyyy/MM/dd H:mm", "yyyy/M/dd H:mm","yyyy/M/dd HH:mm","yyyy/M/d H:mm","yyyy/M/d HH:mm","yyyy-MM-dd HH:mm:ss", "yyyy/MM/dd");

        //for (String pattern : patterns) {
            //try {
                //DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                //return LocalDateTime.parse(timeStr, formatter);
            //} catch (Exception ignored) {}
        //}
        //return null;
    //}
        private LocalDateTime parseDateTime(String timeStr) {
            if (timeStr == null || timeStr.trim().isEmpty()) return null;

            // 中文空格等统一清理
            timeStr = timeStr.trim().replaceAll("\\s+", " ");

            // 如果只有日期，补 00:00
            if (timeStr.matches("\\d{4}/\\d{1,2}/\\d{1,2}")) {
                timeStr += " 00:00";
            }

            // 多种时间格式尝试解析
            List<String> patterns = Arrays.asList(
                    "yyyy/M/d H:mm", "yyyy/M/d HH:mm",
                    "yyyy/MM/d H:mm", "yyyy/MM/d HH:mm",
                    "yyyy/M/dd H:mm", "yyyy/M/dd HH:mm",
                    "yyyy/MM/dd H:mm", "yyyy/MM/dd HH:mm",
                    "yyyy-MM-dd HH:mm:ss",
                    "yyyy/MM/dd"
            );

            for (String pattern : patterns) {
                try {
                    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                    return LocalDateTime.parse(timeStr, formatter);
                } catch (Exception ignored) {}
            }

            return null;
        }






    public String askAi(String prompt) {
        try {
            List<ChatMessage> messages = List.of(
                    ChatMessage.builder().role(ChatMessageRole.USER).content(prompt).build()
            );

            ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
                    .model("ep-20250308174053-7pbkq")
                    .messages(messages)
                    .build();

            return (String) service.createChatCompletion(chatCompletionRequest)
                    .getChoices().get(0).getMessage().getContent();
        } catch (Exception e) {
            e.printStackTrace();
            return "AI请求失败: " + e.getMessage();
        }
    }

    public void runAiInThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            String result = analyzeTransactions(userRequest, filePath,startTimeStr, endTimeStr);
            System.out.println("AI分析结果: " + result);
        });
        executor.shutdown();
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\ColledgeStudentThread.java`:

```java
package Service.AIservice;

import java.io.IOException;

public class ColledgeStudentThread implements Runnable{
//    private final int userRequest;
    private final String filePath;
    public String budgetRange;
    public ColledgeStudentThread( String filePath) {
//        this.userRequest = userRequest;
        this.filePath = filePath;
    }

    @Override
    public void run(){
        CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
        try {
            collegeStudentNeeds.generateBudget(filePath);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\CollegeStudentNeeds.java`:

```java
package Service.AIservice;

import Constants.ConfigConstants;
import DAO.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import model.Transaction;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class CollegeStudentNeeds {
    private final String requestBudge="我是一名预算有限的大学生，请根据下面我给出的花费，帮助我给下周预算范围，必须以[最低预算，最高预算],的方式给出回答，不能有多余的回复。";
    private final String requestTips="我是一名预算有限的大学生，请给我推荐一些省钱方法。";

    private final String requestRecognition="下面我将给你一些账单的信息，请推测这个账单是什么方面的消费: ";
    CsvTransactionDao dao;

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    private final CacheUtil<String, List<Transaction>, Exception> cache;

    public CollegeStudentNeeds() {
        TransactionServiceImpl.csvTransactionDao = dao;
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return dao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );

    }
    public String RecognizeTransaction(Transaction transaction){
        StringBuilder sb=new StringBuilder();
        sb.append("交易类型:").append(transaction.getTransactionType()+",").append("交易对方").append(transaction.getCounterparty()+",")
                .append("商品:").append(transaction.getCommodity()+",").append("收/支:").append(transaction.getInOut()+",")
                        .append("金额(元):").append(transaction.getPaymentAmount()+",").append("支付方式").append(transaction.getPaymentMethod()+",").append("备注:").append(transaction.getRemarks());
        return  new AITransactionService().askAi(requestRecognition+sb.toString());
    }

    public String generateTipsForSaving(){
        return  new AITransactionService().askAi(requestTips);
    }
    //按周统计已有的支出，依靠ai得到下周的预算
    public double[] generateBudget(String path) throws IOException {
        List<Transaction> transactions=cache.get(TRANSACTION_CAFFEINE_KEY);

        int size=transactions.size();
        if(size==0||size==1) return new double[]{-1,-1};
        int count=1;
        int base=0;
        int index=0;//指示首个适合当基准的时间点
        for (index = 0; index < size; index++) {
            int data=convertDateToNumber(transactions.get(index).getTransactionTime().split(" ")[0]);
            if(data>0){
                base=data;
                break;
            }
        }
        List<Double> list=new ArrayList<>();
        double weekConsumption=0;
        for (int i = 0; i < size; i++) {
            int data=convertDateToNumber(transactions.get(i).getTransactionTime().split(" ")[0]);
            if(data<0) continue;
            if((base-data>=0&&base-data<7)&&transactions.get(i).getInOut().equals("支出")){
                weekConsumption+=transactions.get(i).getPaymentAmount();
            }else if(base-data>=7){
                base=data;
                list.add(weekConsumption);
                count++;
                weekConsumption=0;
                if(transactions.get(i).getInOut().equals("支出")){
                    weekConsumption+=transactions.get(i).getPaymentAmount();
                }
            }
        }
        StringBuilder stringBuilder=new StringBuilder();
        for (int i = 0; i < count-1; i++) {
            stringBuilder.append("第");
            stringBuilder.append(i);
            stringBuilder.append("周:花费");
            stringBuilder.append(list.get(i));
            stringBuilder.append("元;");
        }
        String answer=new AITransactionService().askAi(requestBudge+stringBuilder.toString());
        System.out.println(answer);
        double[] ret=new double[2];
        ret=parseDoubleArrayFromString(answer);
        return ret;
    }

    private int convertDateToNumber(String date) {
        // format yyyy/MM/dd
        String[] parts = date.split("/");
        if (parts.length != 3) {
            return -1; // Invalid date format
        }
        try {
            int year = Integer.parseInt(parts[0]);
            int month = Integer.parseInt(parts[1]);
            int day = Integer.parseInt(parts[2]);
            int days = day;
            int[] daysInMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // Days in each month
            if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
                daysInMonth[2] = 29; // February has 29 days in a leap year
            }
            for (int i = 1; i < month; i++) {
                days += daysInMonth[i];
            }
            return year * 365 + (year / 4 - year / 100 + year / 400) + days;
        } catch (NumberFormatException e) {
            return -1;
        }
    }
    public double[] parseDoubleArrayFromString(String input) {
        int length=input.length();
        int l=0,rightindex=input.length();
        // 1. 去除首尾括号
        for (int i = 0; i < length; i++) {
            if(input.charAt(i)<58&&input.charAt(i)>47){
                l=i;
                break;
            }
        }
        for (int r =length-1 ; r >0; r--) {
            if(input.charAt(r)<58&&input.charAt(r)>47){
                rightindex=r;
                break;
            }
        }
        String content = input.substring(l, rightindex+1 ); // 获取 "1.1, 11.0" 或 " 2.5 ,3.14 , -0.5 "

        // 2. 按逗号分割
        String[] numberStrings1 = content.split("，"); // 得到 ["1.1", " 11.0"] 或 [" 2.5 ", "3.14 ", " -0.5 "]
        String[] numberStrings2 = content.split(","); // 得到 ["1.1", " 11.0"] 或 [" 2.5 ", "3.14 ", " -0.5 "]
        String[] numberStrings= numberStrings1.length> numberStrings2.length?numberStrings1:numberStrings2;
//        System.out.println(numberStrings[0]);
//        System.out.println(numberStrings[1]);
        // 3. & 4. 遍历、清理、解析并存储
        List<Double> numberList = new ArrayList<>();
        try {
            for (String numStr : numberStrings) {
                String trimmedStr = numStr.trim(); // 去除首尾空格
                if (!trimmedStr.isEmpty()) { // 避免分割后产生空字符串（例如 "[1.1, , 2.2]"）
                    numberList.add(Double.parseDouble(trimmedStr)); // 解析为 double
                }
            }
        } catch (NumberFormatException e) {
            System.err.println("错误：字符串无法解析为 double 类型。");
            return null; // 或者抛出异常
        }

        // 将 List<Double> 转换为 double[]
        double[] result = new double[numberList.size()];
        for (int i = 0; i < numberList.size(); i++) {
            result[i] = numberList.get(i);
        }
        return result;
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\Impl\TransactionServiceImpl.java`:

```java
package Service.Impl;

import Constants.ConfigConstants;
import DAO.CsvTransactionDao;
import Service.TransactionService;
import Utils.CacheUtil;
import model.Transaction;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class TransactionServiceImpl implements TransactionService {
    public static CsvTransactionDao csvTransactionDao;

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    public final CacheUtil<String, List<Transaction>, Exception> cache;

    /**
     * 通过构造函数注入路径和csvTransactionDao
     * @param csvTransactionDao
     * @throws IOException
     */
    public TransactionServiceImpl(CsvTransactionDao csvTransactionDao)  {
        // 1. 注入Dao层接口
        TransactionServiceImpl.csvTransactionDao = csvTransactionDao;
        // 2. 初始化CacheUtil
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return csvTransactionDao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );
    }

    /**
     * 从transactions缓存中读取transactions如果没有则从csv文件中找
     * @return
     * @throws IOException
     */
    private List<Transaction> getAllTransactions() throws Exception {
        return cache.get(TRANSACTION_CAFFEINE_KEY);
    }


    /**
     * 新增交易
     * @param transaction
     */
    @Override
    public void addTransaction(Transaction transaction) throws IOException {
        // 设置交易时间为当前时间
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
        String currentTime = now.format(formatter);
        transaction.setTransactionTime(currentTime);

        // 调用 DAO 层方法添加交易
        csvTransactionDao.addTransaction(CSV_PATH, transaction);
    }

    @Override
    public void changeTransaction(Transaction updatedTransaction) throws Exception {
        // 1. 加载所有交易记录 先加载 caffeine存储的缓存
        List<Transaction> allTransactions = getAllTransactions();

        // 2. 查找并修改目标交易
        boolean found = false;
        for (int i = 0; i < allTransactions.size(); i++) {
            Transaction t = allTransactions.get(i);
            // 根据交易单号匹配记录（唯一标识）
            if (t.getOrderNumber().equals(updatedTransaction.getOrderNumber())) {
                // 3. 更新非空字段
                updateTransactionFields(t, updatedTransaction);
                found = true;
                break;
            }
        }
        if (!found) {
            throw new IllegalArgumentException("未找到交易单号: " + updatedTransaction.getOrderNumber());
        }
        // 使用事务将写后数据写回csv文件
        csvTransactionDao.writeTransactionsToCSV(CSV_PATH, allTransactions);
        // 修改后使缓存失效 （删缓存）
        cache.invalidate("transactions");
    }

    /**
     *  辅助方法：更新非空字段
     * @param target
     * @param source
     */
    private void updateTransactionFields(Transaction target, Transaction source) {
        if (source.getTransactionTime() != null && !source.getTransactionTime().isEmpty()) {
            target.setTransactionTime(source.getTransactionTime());
        }
        if (source.getTransactionType() != null && !source.getTransactionType().isEmpty()) {
            target.setTransactionType(source.getTransactionType());
        }
        if (source.getCounterparty() != null && !source.getCounterparty().isEmpty()) {
            target.setCounterparty(source.getCounterparty());
        }
        if (source.getCommodity() != null && !source.getCommodity().isEmpty()) {
            target.setCommodity(source.getCommodity());
        }
        if (source.getInOut() != null && !source.getInOut().isEmpty()) {
            target.setInOut(source.getInOut());
        }
        if (source.getPaymentAmount() != 0.0) { // 假设金额为0表示未修改
            target.setPaymentAmount(source.getPaymentAmount());
        }
        if (source.getPaymentMethod() != null && !source.getPaymentMethod().isEmpty()) {
            target.setPaymentMethod(source.getPaymentMethod());
        }
        if (source.getCurrentStatus() != null && !source.getCurrentStatus().isEmpty()) {
            target.setCurrentStatus(source.getCurrentStatus());
        }
        if (source.getMerchantNumber() != null && !source.getMerchantNumber().isEmpty()) {
            target.setMerchantNumber(source.getMerchantNumber());
        }
        if (source.getRemarks() != null && !source.getRemarks().isEmpty()) {
            target.setRemarks(source.getRemarks());
        }
    }

    /**
     * 根据订单号删除交易 (若成功则返回true)
     * @param orderNumber
     */
    @Override
    public boolean deleteTransaction(String orderNumber) throws Exception {
        boolean result = csvTransactionDao.deleteTransaction(CSV_PATH, orderNumber);
        if (!result) {
            throw new Exception("未找到交易单号: " + orderNumber); // 或记录日志
        }
        cache.invalidate("transactions");
        return result;
    }

    /**
     * 按照查询条件查询交易信息
     * @param searchCriteria
     * @return
     */
    @Override
    public List<Transaction> searchTransaction(Transaction searchCriteria) {
        try {
            // 1. 读取所有交易记录 首先读取caffeine
            List<Transaction> allTransactions = getAllTransactions();

            // 2. 动态模糊匹配
            List<Transaction> matched = new ArrayList<>();
            for (Transaction t : allTransactions) {
                if (matchesCriteria(t, searchCriteria)) {
                    matched.add(t);
                }
            }

            // 3. 按交易时间倒序排序
            matched.sort((t1, t2) -> compareTransactionTime(t2.getTransactionTime(), t1.getTransactionTime()));

            return matched;
        } catch (IOException e) {
            e.printStackTrace();
            return List.of(); // 实际应用中应处理异常
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * 辅助方法:判断单个交易记录是否匹配条件
     * @param transaction
     * @param criteria
     * @return
     */
    private boolean matchesCriteria(Transaction transaction, Transaction criteria) {
        return (criteria.getTransactionTime() == null || containsIgnoreCase(transaction.getTransactionTime(), criteria.getTransactionTime()))
                && (criteria.getTransactionType() == null || containsIgnoreCase(transaction.getTransactionType(), criteria.getTransactionType()))
                && (criteria.getCounterparty() == null || containsIgnoreCase(transaction.getCounterparty(), criteria.getCounterparty()))
                && (criteria.getCommodity() == null || containsIgnoreCase(transaction.getCommodity(), criteria.getCommodity()))
                && (criteria.getInOut() == null || containsIgnoreCase(transaction.getInOut(), criteria.getInOut()))
                && (criteria.getPaymentMethod() == null || containsIgnoreCase(transaction.getPaymentMethod(), criteria.getPaymentMethod()));
    }

    /**
     * 辅助方法：字符串模糊匹配（空条件视为匹配）
     * @param source
     * @param target
     * @return
     */
    private boolean containsIgnoreCase(String source, String target) {
        if (target == null || target.trim().isEmpty()) return true; // 空条件不参与筛选
        if (source == null) return false;
        return source.toLowerCase().contains(target.toLowerCase().trim());
    }

    /**
     * 辅助方法：安全的时间比较（处理 null 值）
     * @param time1
     * @param time2
     * @return
     */
    private int compareTransactionTime(String time1, String time2) {
        if (time1 == null && time2 == null) return 0;
        if (time1 == null) return -1;
        if (time2 == null) return 1;
        return time2.compareTo(time1); // 倒序排序
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\TransactionService.java`:

```java
package Service;

import model.Transaction;

import java.io.IOException;
import java.util.List;

public interface TransactionService {

    /**
     * 新增交易
     * @param transaction
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * 修改交易
     * @param transaction
     */
    void changeTransaction(Transaction transaction) throws Exception;

    /**
     * 根据订单号删除交易
     * @param orderNumber
     */
    boolean deleteTransaction(String orderNumber) throws Exception;

    /**
     * 根据用户输入信息查询交易
     * @param transaction
     * @return
     */
    List<Transaction> searchTransaction(Transaction transaction);

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\deepseek\ChatCompletionsExample.java`:

```java
package Service.deepseek;

import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;
import okhttp3.ConnectionPool;
import okhttp3.Dispatcher;
import org.apache.commons.lang.StringUtils;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
public class ChatCompletionsExample {
    static String apiKey = System.getenv("ARK_API_KEY");
    static ConnectionPool connectionPool = new ConnectionPool(5, 1, TimeUnit.SECONDS);
    static Dispatcher dispatcher = new Dispatcher();
    // The output time of the reasoning model is relatively long. Please increase the timeout period.//
    static ArkService service = ArkService.builder().timeout(Duration.ofSeconds(1800)).connectTimeout(Duration.ofSeconds(20)).dispatcher(dispatcher).connectionPool(connectionPool).baseUrl("https://ark.cn-beijing.volces.com/api/v3").apiKey(apiKey).build();

//    public static void main(String[] args) {
//        System.out.println(" [Recommended]----- streaming request -----");
//        final List<ChatMessage> streamMessages = new ArrayList<>();
//        final ChatMessage streamUserMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("请回答15.11和15.9哪个大？").build();
//        streamMessages.add(streamUserMessage);
//        ChatCompletionRequest streamChatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(streamMessages)
//                .build();
//        service.streamChatCompletion(streamChatCompletionRequest)
//                .doOnError(Throwable::printStackTrace)
//                .blockingForEach(
//                        delta -> {
//                            if (!delta.getChoices().isEmpty()) {
//                                if (StringUtils.isNotEmpty(delta.getChoices().get(0).getMessage().getReasoningContent())) {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getReasoningContent());
//                                } else {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getContent());
//                                }
//                            }
//                        }
//                );
//        System.out.println(" ----- standard request -----");
//        final List<ChatMessage> messages = new ArrayList<>();
//        final ChatMessage userMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("常见的十字花科植物有哪些？").build();
//        messages.add(userMessage);
//        ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(messages)
//                .build();
//        service.createChatCompletion(chatCompletionRequest).getChoices().forEach(
//                choice -> {
//                    System.out.println(choice.getMessage().getReasoningContent());
//                    System.out.println(choice.getMessage().getContent());
//                }
//        );
//        // shutdown service after all requests is finished
//        service.shutdownExecutor();
//    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Utils\CacheUtil.java`:

```java
package Utils;

import com.github.benmanes.caffeine.cache.*;

import java.util.concurrent.TimeUnit;
import java.util.function.Function;

import com.github.benmanes.caffeine.cache.Caffeine;

/**
 * 通用缓存工具类（支持泛型和异常传播）
 * @param <K> 键类型
 * @param <V> 值类型
 * @param <E> 异常类型（如 IOException）
 */
public class CacheUtil<K, V, E extends Exception> {
    private final LoadingCache<K, V> cache;

    public CacheUtil(Function<K, V> loader,
                     int maxSize,
                     long expireAfterWrite,
                     long refreshAfterWrite) {

        this.cache = Caffeine.newBuilder()
                .maximumSize(maxSize)
                .expireAfterWrite(expireAfterWrite, TimeUnit.MINUTES)
                .refreshAfterWrite(refreshAfterWrite, TimeUnit.MINUTES)
                .build(loader::apply); // 关键修改：使用build(loader)创建LoadingCache
    }

    /**
     * 获取缓存值
     */
    public V get(K key) {
        return cache.get(key);
    }

    /**
     * 手动更新缓存
     */
    public void put(K key, V value) {
        cache.put(key, value);
    }

    /**
     * 手动移除缓存
     */
    public void invalidate(K key) {
        cache.invalidate(key);
    }
}



```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\model\Transaction.java`:

```java
package model;
//Transaction time, transaction type, transaction counterparty,
// commodity receipt/payment amount (yuan), payment method, current status,
// transaction order number, merchant order number, remarks
public class Transaction {
    private String transactionTime;
    private String transactionType;
    private String counterparty;
    private String commodity;
    private String inOut;
    private double paymentAmount;
    private String paymentMethod;
    private String currentStatus;
    private String orderNumber;
    private String merchantNumber;
    private String remarks;

    public Transaction() {
    }

    public Transaction(String transactionTime, String transactionType, String counterparty, String commodity, String inOut, double paymentAmount, String paymentMethod, String currentStatus, String orderNumber, String merchantNumber, String remarks) {
        this.transactionTime = transactionTime;
        this.transactionType = transactionType;
        this.counterparty = counterparty;
        this.commodity = commodity;
        this.inOut = inOut;
        this.paymentAmount = paymentAmount;
        this.paymentMethod = paymentMethod;
        this.currentStatus = currentStatus;
        this.orderNumber = orderNumber;
        this.merchantNumber = merchantNumber;
        this.remarks = remarks;
    }

    public String getInOut() {
        return inOut;
    }

    public void setInOut(String inOut) {
        this.inOut = inOut;
    }

    public void setTransactionTime(String transactionTime) {
        this.transactionTime = transactionTime;
    }

    public void setTransactionType(String transactionType) {
        this.transactionType = transactionType;
    }

    public void setCounterparty(String counterparty) {
        this.counterparty = counterparty;
    }

    public void setCommodity(String commodity) {
        this.commodity = commodity;
    }

    public void setPaymentAmount(double paymentAmount) {
        this.paymentAmount = paymentAmount;
    }

    public void setPaymentMethod(String paymentMethod) {
        this.paymentMethod = paymentMethod;
    }

    public void setCurrentStatus(String currentStatus) {
        this.currentStatus = currentStatus;
    }

    public void setOrderNumber(String orderNumbe) {
        this.orderNumber = orderNumbe;
    }

    public void setMerchantNumber(String merchantNumber) {
        this.merchantNumber = merchantNumber;
    }

    public void setRemarks(String remarks) {
        this.remarks = remarks;
    }

    public String getTransactionTime() {
        return transactionTime;
    }

    public String getTransactionType() {
        return transactionType;
    }

    public String getCounterparty() {
        return counterparty;
    }

    public String getCommodity() {
        return commodity;
    }

    public double getPaymentAmount() {
        return paymentAmount;
    }

    public String getPaymentMethod() {
        return paymentMethod;
    }

    public String getCurrentStatus() {
        return currentStatus;
    }

    public String getOrderNumber() {
        return orderNumber;
    }

    public String getMerchantNumber() {
        return merchantNumber;
    }

    public String getRemarks() {
        return remarks;
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\ControllerTest\AITest.java`:

```java
package ControllerTest;

import Controller.HistogramPanelContainer;
import org.junit.Test;

import javax.swing.*;
import java.awt.*;

public class AITest {

    @Test
    public void testHistogramPanel() throws Exception {
        EventQueue.invokeAndWait(() -> {
            JFrame frame = new JFrame("数据分析界面 - 测试");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });




        // 保持窗口显示一段时间，防止测试结束时窗口立即关闭
        Thread.sleep(5000);
    }

}




```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\ControllerTest\MenuUITest.java`:

```java
package ControllerTest;

import Controller.HistogramExample;
import Controller.HistogramPanelContainer;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.io.IOException;
import Controller.MenuUI;

import Service.Impl.TransactionServiceImpl;

import Service.Impl.TransactionServiceImpl;

import DAO.CsvTransactionDao;

public class MenuUITest {

    private MenuUI menuUI;

    @BeforeEach
    public void setUp() {
        menuUI = new MenuUI();

        // 手动初始化 TransactionServiceImpl 的 csvTransactionDao
        TransactionServiceImpl.csvTransactionDao = new CsvTransactionDao();
    }

    @Test
    public void testSearchFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取输入字段和搜索按钮
        JTextField transactionTimeField = findTextField(inputPanel, 0);
        JTextField transactionTypeField = findTextField(inputPanel, 1);
        JTextField counterpartyField = findTextField(inputPanel, 2);
        JTextField commodityField = findTextField(inputPanel, 3);
        JComboBox<String> inOutComboBox = findComboBox(inputPanel);
        JTextField paymentMethodField = findTextField(inputPanel, 4);
        JButton searchButton = findButton(inputPanel,"Search");

        assertNotNull(transactionTimeField, "交易时间输入字段不应为空");
        assertNotNull(transactionTypeField, "交易类型输入字段不应为空");
        assertNotNull(counterpartyField, "交易对方输入字段不应为空");
        assertNotNull(commodityField, "商品输入字段不应为空");
        assertNotNull(inOutComboBox, "收/支下拉框不应为空");
        assertNotNull(paymentMethodField, "支付方式输入字段不应为空");
        assertNotNull(searchButton, "搜索按钮不应为空");

        // 设置搜索条件
        transactionTimeField.setText("2025/3/14 11:48"); // 交易时间
        transactionTypeField.setText("商户消费");       // 交易类型
        counterpartyField.setText("物美WUMART");         // 交易对方
        commodityField.setText("扫码支付");            // 商品
        inOutComboBox.setSelectedItem("支出");     // 收/支
        paymentMethodField.setText("零钱");    // 支付方式

        // 模拟点击搜索按钮
        searchButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证搜索结果是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);

            // 验证每一行数据是否符合搜索条件
            assertTrue(rowTransactionTime.contains("2025/3/14 11:48"), "交易时间应符合搜索条件");
            assertTrue(rowTransactionType.contains("商户消费"), "交易类型应符合搜索条件");
            assertTrue(rowCounterparty.contains("物美WUMART"), "交易对方应符合搜索条件");
            assertTrue(rowCommodity.contains("扫码支付"), "商品应符合搜索条件");
            assertTrue(rowInOut.contains("支出"), "收/支应符合搜索条件");
            assertTrue(rowPaymentMethod.contains("零钱"), "支付方式应符合搜索条件");
        }
    }

    @Test
    public void testDeleteFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 获取初始行数
        int initialRowCount = tableModel.getRowCount();

        // 模拟删除第一行
        menuUI.deleteRow(0);

        // 验证行数是否减少
        assertEquals(initialRowCount - 1, tableModel.getRowCount(), "删除后行数应减少");

        // 验证删除后的数据是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            assertNotEquals("2025/3/14 11:48", rowTransactionTime, "删除的行不应再出现在表格中");
        }
    }

    @Test
    public void testEditFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 模拟编辑第一行
        menuUI.editRow(0);

        // 验证编辑后的数据是否正确
        String editedTransactionTime = (String) tableModel.getValueAt(0, 0);
        String editedTransactionType = (String) tableModel.getValueAt(0, 1);
        String editedCounterparty = (String) tableModel.getValueAt(0, 2);
        String editedCommodity = (String) tableModel.getValueAt(0, 3);
        String editedInOut = (String) tableModel.getValueAt(0, 4);
        String editedPaymentMethod = (String) tableModel.getValueAt(0, 6);

        // 验证编辑后的数据是否符合预期
        assertNotNull(editedTransactionTime, "编辑后的交易时间不应为空");
        assertNotNull(editedTransactionType, "编辑后的交易类型不应为空");
        assertNotNull(editedCounterparty, "编辑后的交易对方不应为空");
        assertNotNull(editedCommodity, "编辑后的商品不应为空");
        assertNotNull(editedInOut, "编辑后的收/支不应为空");
        assertNotNull(editedPaymentMethod, "编辑后的支付方式不应为空");
    }

    @Test
    public void testAddFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取 Add 按钮
        JButton addButton = findButton(inputPanel, "Add");
        assertNotNull(addButton, "Add 按钮不应为空");

        // 模拟点击 Add 按钮
        addButton.doClick();

        // 获取对话框
        Window[] windows = Window.getWindows();
        JDialog addDialog = null;
        for (Window window : windows) {
            if (window instanceof JDialog && "添加交易".equals(((JDialog) window).getTitle())) {
                addDialog = (JDialog) window;
                break;
            }
        }
        assertNotNull(addDialog, "添加交易的对话框应弹出");

        // 获取对话框中的输入字段
        JTextField transactionTimeField = findTextField(addDialog.getContentPane(), 0);
        JTextField transactionTypeField = findTextField(addDialog.getContentPane(), 1);
        JTextField counterpartyField = findTextField(addDialog.getContentPane(), 2);
        JTextField commodityField = findTextField(addDialog.getContentPane(), 3);
        JComboBox<String> inOutComboBox = findComboBox(addDialog.getContentPane());
        JTextField paymentAmountField = findTextField(addDialog.getContentPane(), 4);
        JTextField paymentMethodField = findTextField(addDialog.getContentPane(), 5);
        JTextField currentStatusField = findTextField(addDialog.getContentPane(), 6);
        JTextField orderNumberField = findTextField(addDialog.getContentPane(), 7);
        JTextField merchantNumberField = findTextField(addDialog.getContentPane(), 8);
        JTextField remarksField = findTextField(addDialog.getContentPane(), 9);

        // 设置新交易的输入值
        transactionTimeField.setText("2025/3/15 12:00"); // 交易时间
        transactionTypeField.setText("转账");            // 交易类型
        counterpartyField.setText("张三");               // 交易对方
        commodityField.setText("转账");                 // 商品
        inOutComboBox.setSelectedItem("支出");          // 收/支
        paymentAmountField.setText("100.0");            // 金额(元)
        paymentMethodField.setText("银行卡");           // 支付方式
        currentStatusField.setText("已完成");           // 当前状态
        orderNumberField.setText("123456789");          // 交易单号
        merchantNumberField.setText("987654321");       // 商户单号
        remarksField.setText("测试备注");               // 备注

        // 获取确认按钮
        JButton confirmButton = findButton(addDialog.getContentPane(), "确认");
        assertNotNull(confirmButton, "确认按钮不应为空");

        // 模拟点击确认按钮
        confirmButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证新交易是否添加到表格中
        boolean isTransactionAdded = false;
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentAmount = (String) tableModel.getValueAt(i, 5);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);
            String rowCurrentStatus = (String) tableModel.getValueAt(i, 7);
            String rowOrderNumber = (String) tableModel.getValueAt(i, 8);
            String rowMerchantNumber = (String) tableModel.getValueAt(i, 9);
            String rowRemarks = (String) tableModel.getValueAt(i, 10);

            if (rowTransactionTime.equals("2025/3/15 12:00") &&
                    rowTransactionType.equals("转账") &&
                    rowCounterparty.equals("张三") &&
                    rowCommodity.equals("转账") &&
                    rowInOut.equals("支出") &&
                    rowPaymentAmount.equals("100.0") &&
                    rowPaymentMethod.equals("银行卡") &&
                    rowCurrentStatus.equals("已完成") &&
                    rowOrderNumber.equals("123456789") &&
                    rowMerchantNumber.equals("987654321") &&
                    rowRemarks.equals("测试备注")) {
                isTransactionAdded = true;
                break;
            }
        }

        // 验证新交易是否成功添加
        assertTrue(isTransactionAdded, "新交易应成功添加到表格中");
    }

    /**
     * 显示界面以便手动验证
     *
     * @param panel 要显示的面板
     */
    private void showUI(JPanel panel) {
        JFrame frame = new JFrame("MenuUI Test");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(1200, 600);
        frame.add(panel);
        frame.setVisible(true);

        // 保持界面显示一段时间（5秒）
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        frame.dispose(); // 关闭界面
    }

    /**
     * 查找输入面板
     *
     * @param mainPanel 主面板
     * @return 输入面板
     */
    private JPanel findInputPanel(JPanel mainPanel) {
        // 获取右边的面板
        Component[] components = mainPanel.getComponents();
        JPanel rightPanel = null;
        for (Component component : components) {
            if (component instanceof JPanel && ((JPanel) component).getComponentCount() > 0) {
                rightPanel = (JPanel) component;
                break;
            }
        }

        if (rightPanel != null) {
            // 在右边面板中查找输入面板
            for (Component component : rightPanel.getComponents()) {
                if (component instanceof JPanel) {
                    JPanel panel = (JPanel) component;
                    System.out.println("Panel found: " + panel.getName()); // 打印面板名称
                    if (panel.getComponentCount() > 0 && panel.getComponent(0) instanceof JLabel) {
                        return panel; // 输入面板通常包含 JLabel
                    }
                }
            }
        }
        return null;
    }

    /**
     * 查找输入字段
     *
     * @param container     输入面板
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0;
        for (Component component : container.getComponents()) {
            if (component instanceof JTextField) {
                if (count == index) {
                    return (JTextField) component;
                }
                count++;
            }
        }
        return null;
    }


    /**
     * 查找下拉框
     *
     * @param container 输入面板
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) {
            if (component instanceof JComboBox) {
                return (JComboBox<String>) component;
            }
        }
        return null;
    }

    /**
     * 查找按钮
     *
     * @param panel 输入面板
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container  容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    private JButton findButton(Container container, String buttonText) {
        for (Component component : container.getComponents()) {
            if (component instanceof JButton) {
                JButton button = (JButton) component;
                if (button.getText().equals(buttonText)) {
                    return button;
                }
            }
        }
        return null;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\DAOTest\CsvTransactionDaoTest.java`:

```java
package DAOTest;

import DAO.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static Constants.ConfigConstants.CSV_PATH;
import static org.assertj.core.api.Assertions.*;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

class CsvTransactionDaoTest {
    // 测试文件路径（根据实际结构调整）
    private static final String TEST_CSV_PATH = CSV_PATH;
    private static CsvTransactionDao dao;

    @Test
    void testLoadFromCSV_ValidFile_ReturnsTransactions() throws Exception {
        // Given
        CsvTransactionDao dao = new CsvTransactionDao();

        // When
        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);

        // 验证第一条记录的字段
        for (int i = 0; i < transactions.size(); i++) {
            System.out.println(transactions.get(i).getRemarks());
            System.out.println(transactions.get(i).getCommodity());
        }


    }
    @Test
    void testAddTransaction() throws IOException {
        dao=new CsvTransactionDao();
        Transaction newTx = new Transaction(
                "2025-03-09 10:00",
                "转账",
                "小明",
                "书籍",
                "支",
                99.99,
                "微信",
                "已完成",
                "TX123456",
                "M789012",
                "");

        dao.addTransaction("src/test/resources/001.csv", newTx);

        List<Transaction> transactions = dao.loadFromCSV(TEST_CSV_PATH);

    }

    @Test
    void testDeleteTransaction() throws IOException {
        dao=new CsvTransactionDao();

        dao.deleteTransaction("CSV_RELATIVE_PATH", "4200057899202502250932735481");

        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);
    }
    @Test
    void testChangeInfo() throws IOException{
        dao=new CsvTransactionDao();
        dao.changeInformation("TX123456","remarks","测试修改信息",TEST_CSV_PATH);
        dao.changeInformation("TX123456","paymentAmount","116156",TEST_CSV_PATH);
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\AIAnalyzerThreadTest.java`:

```java
package Service;



import Service.AIservice.AIAnalyzerThread;
import org.junit.jupiter.api.Test;

public class AIAnalyzerThreadTest {

    @Test
    public void testRunAIAnalyzerThread() throws InterruptedException {
        String userRequest = "请帮我分析最近的交易收支情况";
        String filePath = "src/test/resources/sample_transactions.csv";
        String startTimeStr = "2025/03/20";
        String endTimeStr = "";

        // 启动线程
        Thread thread = new Thread(new AIAnalyzerThread(userRequest, filePath, startTimeStr, endTimeStr));
        thread.start();

        // 等待线程执行完成
        thread.join();
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\AIserviceTest.java`:

```java
package Service;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

public class AIserviceTest {

    @Test
    public void testAnalyzeTransactions() {
        AITransactionService service = new AITransactionService();

        String userRequest = "请帮我分析这个月的收支情况";
        String filePath = "src/test/resources/sample_transactions.csv";

        String result = service.analyzeTransactions(userRequest, filePath,"2025/03/20","");

        assertNotNull(result, "AI分析结果不能为空");
        System.out.println("AI分析结果: " + result);
    }


}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\AiFunctionTest.java`:

```java
package Service;

import DAO.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

import java.io.IOException;
import java.util.List;

public class AiFunctionTest {

    @Test
    public void testAnalyzeTransactions() throws IOException {

        String filePath = "src/test/resources/sample_transactions.csv";
        CsvTransactionDao transactionDao = new CsvTransactionDao();

        List<Transaction> transactions = transactionDao.loadFromCSV(filePath);

        // 实例化服务类
        AITransactionService service = new AITransactionService();

        // 调用合并格式化函数
        List<String> result = service.formatTransactions(transactions,"2025/03/29","2025/04/10");

        // 输出结果
        result.forEach(System.out::println);
    }




}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\CacheTest.java`:

```java
package Service;

import Constants.CaffeineKeys;
import DAO.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import com.github.benmanes.caffeine.cache.Caffeine;
import model.Transaction;
import org.junit.jupiter.api.Test;

import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;

public class CacheTest {

    TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());

    @Test
    void DeleteCache(){
        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;
        cache.invalidate(TRANSACTION_CAFFEINE_KEY);
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\CollegeStudentNeedsTest.java`:

```java
package Service;

import Service.AIservice.ColledgeStudentThread;
import Service.AIservice.CollegeStudentNeeds;
import org.junit.jupiter.api.*;

import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.*;

// No @ExtendWith needed as we are not using Mockito extensions
class CollegeStudentNeedsTest {



    private CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
    private static final String TEST_CSV_FILENAME = "src/test/resources/001.csv";
    @Test
    public void testGenerateBudget() throws IOException, InterruptedException {
        Thread t=new Thread( new ColledgeStudentThread(TEST_CSV_FILENAME));
        t.start();
        t.join();
//        collegeStudentNeeds.generateBudget(TEST_CSV_FILENAME);
    }
    @Test
    public void testParseStringToDouble(){
        String s="asdas[369.39,1090.1]das";
        double[] arr=collegeStudentNeeds.parseDoubleArrayFromString(s);
        System.out.println(arr[0]+" "+arr[1]);
    }


}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\TransactionServiceTest.java`:

```java
package Service;

import DAO.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import model.Transaction;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.io.IOException;
import java.util.List;

class TransactionServiceTest {
    private TransactionService transactionService;

    @BeforeEach
    void setUp() {
        // 初始化 DAO 和 Service
        CsvTransactionDao csvTransactionDao = new CsvTransactionDao();
        transactionService = new TransactionServiceImpl(csvTransactionDao);
    }

    @Test
    void testAddTransaction() throws IOException {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );

        // 执行添加操作
        transactionService.addTransaction(transaction);

        // 验证是否添加成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertFalse(transactions.isEmpty());
        assertEquals("T123456789", transactions.get(0).getOrderNumber());
    }

    @Test
    void testChangeTransaction() throws Exception {
        // 准备测试数据
        Transaction originalTransaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(originalTransaction);

        // 准备更新数据
        Transaction updatedTransaction = new Transaction(
                null, "充值", null, null, null, 0.0, "微信支付", null, "T123456789", null, "更新备注"
        );

        // 执行更新操作
        transactionService.changeTransaction(updatedTransaction);

        // 验证是否更新成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertEquals("充值", transactions.get(0).getTransactionType());
        assertEquals("微信支付", transactions.get(0).getPaymentMethod());
        assertEquals("更新备注", transactions.get(0).getRemarks());
    }

    @Test
    void testDeleteTransaction() throws Exception {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(transaction);

        // 执行删除操作
        boolean result = transactionService.deleteTransaction("T123456789");

        // 验证是否删除成功
        assertTrue(result);
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertTrue(transactions.isEmpty());
    }

    @Test
    void testSearchTransaction() throws IOException {

        // 设置搜索条件
        Transaction searchCriteria = new Transaction();
        searchCriteria.setCounterparty("支付宝");

        // 执行搜索操作
        List<Transaction> result = transactionService.searchTransaction(searchCriteria);

        // 验证搜索结果
        result.forEach(res -> System.out.println(res.getCommodity()));
    }


}
```
```

`软工/Ai-Bill-Application-Group21 - 副本\README.md`:

```md
## Project Overview
This module is a transaction record management 
system in the Service layer of the project that connects 
with the Dao layer that provides CRUD (Create, Read, Update
, Delete) functionality and data processing for
transaction data. Core features include transaction 
creation, modification, deletion, and flexible querying,
all accessible through standardized interfaces.

## Structure and Function
Swing GUI (Controller) <- Service <- DAO <-data(CSV/JSON)<-model

##  Model 

### Overview

This Java class, located in the `model` package, serves 
as a Plain Old Java Object (POJO) or data model to 
represent a single financial transaction record. It 
encapsulates all the standard details associated with 
a transaction, such as its time, type, amount, parties 
involved, status, and unique identifiers.

This class is typically used in conjunction with Data 
Access Objects (DAOs) like `TransactionDao` and
`CsvTransactionDao` to load, save, and manipulate 
transaction data from a persistent store (e.g., a CSV 
file or database).

### Package

`model`

### Fields

The `Transaction` class contains the following fields:

* `transactionTime` (String): The date and time when the transaction occurred (e.g., "2023-10-27 15:30:00").
* `transactionType` (String): The category or type of the transaction (e.g., "在线支付" - Online Payment, "转账" - Transfer, "退款" - Refund).
* `counterparty` (String): The name or identifier of the other party involved in the transaction.
* `commodity` (String): A description of the goods, service, or reason for the transaction (e.g., "Coffee", "Salary", "Online Course Fee").
* `inOut` (String): Indicates the direction of the money flow relative to the account holder. Typically:
* `paymentAmount` (double): The monetary value of the transaction. The currency unit (e.g., Yuan) is implied by the context where this class is used (often indicated by header names like "金额(元)" in associated CSV files).
* `paymentMethod` (String): The method used for the payment (e.g., "支付宝" - Alipay, "微信支付" - WeChat Pay, "银行卡" - Bank Card, "现金" - Cash).
* `currentStatus` (String): The current processing status of the transaction (e.g., "交易成功" - Transaction Successful, "等待付款" - Awaiting Payment, "已关闭" - Closed, "退款成功" - Refund Successful).
* `orderNumber` (String): A unique identifier assigned to this specific transaction instance by the payment system or application. Often used as a primary key.
* `merchantNumber` (String): An order number or identifier associated with the merchant's system, often provided for reconciliation purposes. May be empty or null if not applicable.
* `remarks` (String): An optional field for any additional notes, comments, or user-provided descriptions about the transaction.

### Constructors

* **`public Transaction()`**
    * Default no-argument constructor. Creates an empty `Transaction` object with all fields initialized to their default values (null for String, 0.0 for double).

* **`public Transaction(String transactionTime, String transactionType, ..., String remarks)`**
    * Parameterized constructor that accepts values for all fields. Allows for quick instantiation of a fully populated `Transaction` object.

### Methods

The class provides standard public **getter** (`get...()`) and **setter** (`set...()`) methods for all its private fields. These methods allow controlled access and modification of the transaction's attributes from other parts of the application.

* `getTransactionTime()` / `setTransactionTime(String time)`
* `getTransactionType()` / `setTransactionType(String type)`
* `getCounterparty()` / `setCounterparty(String counterparty)`
* `getCommodity()` / `setCommodity(String commodity)`
* `getInOut()` / `setInOut(String inOut)`
* `getPaymentAmount()` / `setPaymentAmount(double amount)`
* `getPaymentMethod()` / `setPaymentMethod(String method)`
* `getCurrentStatus()` / `setCurrentStatus(String status)`
* `getOrderNumber()` / `setOrderNumber(String orderNumber)`
* `getMerchantNumber()` / `setMerchantNumber(String merchantNumber)`
* `getRemarks()` / `setRemarks(String remarks)`

 
### Service (Business logic)
- Responsibilities:
Transaction CRUD operations, calling the DAO layer to read and write local files,
User-defined classification logic (e.g. modifying transaction categories)
  (3) Operations:

Add Transaction:

Transaction t = new Transaction();
// Set field values
service.addTransaction(t);

Modify Transaction:

Transaction update = new Transaction();
update.setOrderNumber("ORD123");
// Set fields to update
service.changeTransaction(update);

Query Transactions:

Transaction criteria = new Transaction();
criteria.setCounterparty("Alipay");
List<Transaction> results = service.searchTransaction(criteria);
Code structure
   Directory Layout:
   src/main/java/
   └── Service/
   ├── Impl/
   │   └── TransactionServiceImpl.java  # Service implementation
   └── TransactionService.java          # Service interface
   TransactionService.java:
   Defines the service interface with business-agnostic method signatures, enforcing decoupling 
   between business logic and implementation details.
   TransactionServiceImpl.java:
   Implements the concrete business logic while depending only on the interface-defined contract, maintaining loose coupling with the data access layer through dependency injection.


- AIService (Intelligent Analytics) Responsibilities: Generate budget recommendations based
on historical data, and detect cost-cutting recommendations for seasonal spending in China
(e.g. Spring Festival) (e.g. marking high-frequency small spending)


- **`AITransactionService`**

The central class that performs the full AI-driven transaction analysis. It:

- Loads transaction data from a CSV file via `CsvTransactionDao`.
- Filters transactions by user-specified time range (`startTimeStr`, `endTimeStr`).
- Aggregates data by counterparty (income/spending, transaction counts).
- Formats the result into concise summaries sent to the AI.
- Sends user questions and formatted data to the Volcengine Ark AI API.
- Returns a response within **400 characters** for efficient display.

Key methods:
- `analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr)`
  → Returns an AI-generated analysis result string.
- `runAiInThread(...)`
  → Runs the AI logic in a background thread (single-threaded executor).
- `formatTransactions(...)`
  → Groups transactions and summarizes them by counterparty and time range.
- `parseDateTime(...)`
  → Supports flexible input formats like `yyyy/MM/dd`, `yyyy/MM/dd HH:mm`, and more. - **`AIAnalyzerThread`** A `Runnable` implementation for threading scenarios (especially GUI usage). It calls `AITransactionService.analyzeTransactions(...)` and prints the result. UI developers can replace the console output with GUI updates using `SwingUtilities.invokeLater()`. --- ### Tests (`test/java/Service/AIservice/`) - **`AIserviceTest`** Unit tests for `AITransactionService`, verifying: - Correct loading and filtering of transactions. - Accurate AI response generation and formatting. - Graceful handling of edge cases (e.g., no transactions in range, invalid time formats). - **`AIAnalyzerThreadTest`** Validates threading logic: - Ensures `AIAnalyzerThread` executes `Runnable` correctly. - Demonstrates clean and concurrent AI analysis flow. - Simulates integration with a GUI environment. - **`AiFunctionTest`** Utility-level tests: - Ensures proper CSV parsing and data transformation. - Verifies output formatting before sending to the AI. - Tests various time formats and edge case behaviors

## DAO (File Storage)
- Responsibilities: Save transaction data in CSV or JSON format and provide interfaces for adding,
  deleting, and modifying in-memory data
### CsvTransactionDao Class

#### Package

`DAO`

#### Dependencies

* **`model.Transaction`**: The data model class representing a single transaction.
* **`DAO.TransactionDao`**: The interface this class is intended to implement (though the implementation is incomplete).
* **Apache Commons CSV (`org.apache.commons.csv.*`)**: Used for robust parsing and writing of CSV data.
* **Apache Commons IO (`org.apache.commons.io.input.BOMInputStream`)**: Used specifically to handle potential Byte Order Marks (BOM) often found in UTF-8 encoded files, particularly those edited in Windows.
* **Java Standard Libraries**: `java.io.*`, `java.nio.*`.

#### Key Features & Implementation Details

* **CSV Loading (`loadFromCSV`)**:
  * Reads data from a specified CSV file path.
  * Expects UTF-8 encoding.
  * Handles potential Byte Order Mark (BOM) at the beginning of the file.
  * Uses the first row of the CSV as the header to map columns to `Transaction` fields. Assumes specific header names (e.g., "交易时间", "交易类型", "金额(元)").
  * Parses transaction records into a `List<Transaction>`.
  * Includes basic caching using an internal `transactions` list and an `isLoad` flag to avoid redundant file reads within the same instance lifecycle (unless forced by methods like `deleteTransaction` or `changeInformation`).
* **Record Parsing (`parseRecord`)**:
  * Converts a `CSVRecord` object (from Apache Commons CSV) into a `Transaction` object.
  * Specifically handles the "金额(元)" (Amount) field by removing the leading "¥" symbol before parsing it as a `double`.
* **Adding Transactions (`addTransaction(String filePath, Transaction newTransaction)`)**:
  * **Appends** a new transaction record to the *end* of the specified CSV file.
  * Creates the file if it doesn't exist.
  * Writes the header row only if the file is new or was empty.
  * Formats the payment amount by prepending "¥".
* **Deleting Transactions (`deleteTransaction(String filePath, String orderNumber)`)**:
  * Loads data from the file if not already cached.
  * Filters the cached list to remove the transaction matching the given `orderNumber`.
  * **Overwrites** the *entire* original CSV file with the filtered list using `writeTransactionsToCSV`.
  * Returns `true` if a transaction was removed, `false` otherwise.
* **Updating Transactions (`changeInformation`)**:
  * Loads data if not already cached.
  * Finds the transaction by `orderNumber`.
  * Modifies the specified field (`head`) of the found transaction object in memory.
  * **Crucially, it attempts the update by first *deleting* the original record (using `deleteTransaction`, which overwrites the file) and then *adding* the modified record (using `addTransaction`, which appends to the file).** This logic is inefficient and potentially problematic due to the conflicting file write strategies (overwrite vs. append).
  * Error handling for invalid `head` parameters prints to `System.err`. The method often returns `true` even if the underlying delete/add fails.
* **CSV Writing (`writeTransactionsToCSV`)**:
  * Helper method used by `deleteTransaction`.
  * Writes a given `List<Transaction>` to the specified file path, **overwriting** any existing content.
  * Writes a standard header row.
  * Formats the payment amount by prepending "¥".

#### Important Issues & Considerations

1.  **Incomplete `TransactionDao` Implementation**: The methods declared in the `TransactionDao` interface (`getAllTransactions`, `addTransaction(Transaction)`, `deleteTransaction(String)`, `updateTransaction`, `getTransactionByOrderNumber`) are present but contain only placeholder/stub code. The actual working logic uses separate methods that require the `filePath` to be passed explicitly each time. **This class, in its current state, does not correctly function as a `TransactionDao` implementation.**
2.  **Inconsistent File Writing Strategy**: `addTransaction` *appends* to the file, while `deleteTransaction` and `writeTransactionsToCSV` (used by `deleteTransaction` and `changeInformation`) *overwrite* the entire file. This inconsistency can lead to unexpected behavior, especially within the `changeInformation` method.
3.  **Inefficient Updates/Deletes**: Rewriting the entire CSV file for every single deletion or modification (`changeInformation`) is highly inefficient, especially for large transaction files.
4.  **Flawed Update Logic (`changeInformation`)**: The delete-then-add approach for updates is problematic due to the inconsistent write strategies and potential race conditions or partial failures. The modified record will likely appear at the *end* of the file, not its original position.
5.  **Basic Caching**: The caching mechanism (`isLoad` flag) is simple and does not account for external modifications to the CSV file during the application's runtime.
6.  **Hardcoded Dependencies**: The code relies on specific header names (in Chinese) and the "¥" currency symbol format within the CSV data. Changes to the CSV format would require code modifications.

#### Usage Example (Using Functional Methods)

```java
import DAO.CsvTransactionDao; // Assuming TransactionDao interface exists but is not used directly here due to stub methods
import model.Transaction;
import java.io.IOException;
import java.util.List;

public class CsvDataManager {

    public static void main(String[] args) {
        // NOTE: Using the class directly, not via the TransactionDao interface
        // because the interface methods are not fully implemented.
        CsvTransactionDao csvDao = new CsvTransactionDao();
        String csvFilePath = "path/to/your/transactions.csv"; // <--- Specify your file path

        try {
            // --- Load Data ---
            System.out.println("Loading transactions...");
            List<Transaction> transactions = csvDao.loadFromCSV(csvFilePath);
            System.out.println("Loaded " + transactions.size() + " transactions.");
            // Display first transaction if available
            if (!transactions.isEmpty()) {
                 System.out.println("First transaction order number: " + transactions.get(0).getOrderNumber());
            }

            // --- Add a New Transaction (Appends) ---
            Transaction newTx = new Transaction(
                 "2025-04-20 08:14:00", "Test Add", "Counterparty", "Item", "支",
                 10.0, "支付宝", "交易成功", "NEW_ORDER_123", "MERCH_456", "Test via DAO add"
            );
            System.out.println("\nAdding new transaction (append): " + newTx.getOrderNumber());
            // csvDao.addTransaction(csvFilePath, newTx); // Uncomment to actually add
            System.out.println("Transaction potentially added.");

            // --- Delete a Transaction (Overwrites File) ---
            String orderToDelete = "SOME_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number from your file
            System.out.println("\nAttempting to delete transaction: " + orderToDelete);
            // boolean deleted = csvDao.deleteTransaction(csvFilePath, orderToDelete); // Uncomment to actually delete
            // if (deleted) {
            //     System.out.println("Transaction deleted successfully (File rewritten).");
            // } else {
            //     System.out.println("Transaction not found for deletion.");
            // }

            // --- Change Information (Overwrites then Appends - Use with Caution) ---
             String orderToChange = "ANOTHER_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number
             String fieldToChange = "remarks";
             String newValue = "Updated remark via changeInformation";
             System.out.println("\nAttempting to change info for: " + orderToChange);
             // boolean changed = csvDao.changeInformation(orderToChange, fieldToChange, newValue, csvFilePath); // Uncomment with caution
             // System.out.println("Change operation attempted (File rewritten and appended). Result: " + changed);


        } catch (IOException e) {
            System.err.println("Error interacting with CSV file: " + e.getMessage());
            e.printStackTrace();
        } catch (NumberFormatException e) {
            System.err.println("Error parsing amount in CSV: " + e.getMessage());
        }
    }
}
```

## Controller (Swing GUI)

Responsibilities: Manage user interface components (buttons, tables, text boxes) to listen for 
events (clicks, inputs) and call service layer methods to update the interface data display

## attention
encoding with UTF-8

```

`软工/Ai-Bill-Application-Group21 - 副本\README.txt`:

```txt
## Project Overview

This module is a transaction record management 
system in the Service layer of the project that connects 
with the Dao layer that provides CRUD (Create, Read, Update
, Delete) functionality and data processing for
transaction data. Core features include transaction 
creation, modification, deletion, and flexible querying,
all accessible through standardized interfaces.

## Structure and Function

Swing GUI (Controller) <- Service <- DAO <-data(CSV/JSON)<-model

##  Model 

### Overview

This Java class, located in the `model` package, serves 
as a Plain Old Java Object (POJO) or data model to 
represent a single financial transaction record. It 
encapsulates all the standard details associated with 
a transaction, such as its time, type, amount, parties 
involved, status, and unique identifiers.

This class is typically used in conjunction with Data 
Access Objects (DAOs) like `TransactionDao` and
`CsvTransactionDao` to load, save, and manipulate 
transaction data from a persistent store (e.g., a CSV 
file or database).

### Package

`model`

### Fields

The `Transaction` class contains the following fields:

* `transactionTime` (String): The date and time when the transaction occurred (e.g., "2023-10-27 15:30:00").
* `transactionType` (String): The category or type of the transaction (e.g., "在线支付" - Online Payment, "转账" - Transfer, "退款" - Refund).
* `counterparty` (String): The name or identifier of the other party involved in the transaction.
* `commodity` (String): A description of the goods, service, or reason for the transaction (e.g., "Coffee", "Salary", "Online Course Fee").
* `inOut` (String): Indicates the direction of the money flow relative to the account holder. Typically:
* `paymentAmount` (double): The monetary value of the transaction. The currency unit (e.g., Yuan) is implied by the context where this class is used (often indicated by header names like "金额(元)" in associated CSV files).
* `paymentMethod` (String): The method used for the payment (e.g., "支付宝" - Alipay, "微信支付" - WeChat Pay, "银行卡" - Bank Card, "现金" - Cash).
* `currentStatus` (String): The current processing status of the transaction (e.g., "交易成功" - Transaction Successful, "等待付款" - Awaiting Payment, "已关闭" - Closed, "退款成功" - Refund Successful).
* `orderNumber` (String): A unique identifier assigned to this specific transaction instance by the payment system or application. Often used as a primary key.
* `merchantNumber` (String): An order number or identifier associated with the merchant's system, often provided for reconciliation purposes. May be empty or null if not applicable.
* `remarks` (String): An optional field for any additional notes, comments, or user-provided descriptions about the transaction.

### Constructors

* **`public Transaction()`**
  * Default no-argument constructor. Creates an empty `Transaction` object with all fields initialized to their default values (null for String, 0.0 for double).

* **`public Transaction(String transactionTime, String transactionType, ..., String remarks)`**
  * Parameterized constructor that accepts values for all fields. Allows for quick instantiation of a fully populated `Transaction` object.

### Methods

The class provides standard public **getter** (`get...()`) and **setter** (`set...()`) methods for all its private fields. These methods allow controlled access and modification of the transaction's attributes from other parts of the application.

* `getTransactionTime()` / `setTransactionTime(String time)`
* `getTransactionType()` / `setTransactionType(String type)`
* `getCounterparty()` / `setCounterparty(String counterparty)`
* `getCommodity()` / `setCommodity(String commodity)`
* `getInOut()` / `setInOut(String inOut)`
* `getPaymentAmount()` / `setPaymentAmount(double amount)`
* `getPaymentMethod()` / `setPaymentMethod(String method)`
* `getCurrentStatus()` / `setCurrentStatus(String status)`
* `getOrderNumber()` / `setOrderNumber(String orderNumber)`
* `getMerchantNumber()` / `setMerchantNumber(String merchantNumber)`
* `getRemarks()` / `setRemarks(String remarks)`


### Service (Business logic)

- Responsibilities:
  Transaction CRUD operations, calling the DAO layer to read and write local files,
  User-defined classification logic (e.g. modifying transaction categories)
  (3) Operations:

Add Transaction:

Transaction t = new Transaction();
// Set field values
service.addTransaction(t);

Modify Transaction:

Transaction update = new Transaction();
update.setOrderNumber("ORD123");
// Set fields to update
service.changeTransaction(update);

Query Transactions:

Transaction criteria = new Transaction();
criteria.setCounterparty("Alipay");
List<Transaction> results = service.searchTransaction(criteria);
Code structure
   Directory Layout:
   src/main/java/
   └── Service/
   ├── Impl/
   │   └── TransactionServiceImpl.java  # Service implementation
   └── TransactionService.java          # Service interface
   TransactionService.java:
   Defines the service interface with business-agnostic method signatures, enforcing decoupling 
   between business logic and implementation details.
   TransactionServiceImpl.java:
   Implements the concrete business logic while depending only on the interface-defined contract, maintaining loose coupling with the data access layer through dependency injection.


- AIService (Intelligent Analytics) Responsibilities: Generate budget recommendations based
  on historical data, and detect cost-cutting recommendations for seasonal spending in China
  (e.g. Spring Festival) (e.g. marking high-frequency small spending)


- **`AITransactionService`**

The central class that performs the full AI-driven transaction analysis. It:

- Loads transaction data from a CSV file via `CsvTransactionDao`.
- Filters transactions by user-specified time range (`startTimeStr`, `endTimeStr`).
- Aggregates data by counterparty (income/spending, transaction counts).
- Formats the result into concise summaries sent to the AI.
- Sends user questions and formatted data to the Volcengine Ark AI API.
- Returns a response within **400 characters** for efficient display.

Key methods:

- `analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr)`
  → Returns an AI-generated analysis result string.
- `runAiInThread(...)`
  → Runs the AI logic in a background thread (single-threaded executor).
- `formatTransactions(...)`
  → Groups transactions and summarizes them by counterparty and time range.
- `parseDateTime(...)`
  → Supports flexible input formats like `yyyy/MM/dd`, `yyyy/MM/dd HH:mm`, and more. - **`AIAnalyzerThread`** A `Runnable` implementation for threading scenarios (especially GUI usage). It calls `AITransactionService.analyzeTransactions(...)` and prints the result. UI developers can replace the console output with GUI updates using `SwingUtilities.invokeLater()`. --- ### Tests (`test/java/Service/AIservice/`) - **`AIserviceTest`** Unit tests for `AITransactionService`, verifying: - Correct loading and filtering of transactions. - Accurate AI response generation and formatting. - Graceful handling of edge cases (e.g., no transactions in range, invalid time formats). - **`AIAnalyzerThreadTest`** Validates threading logic: - Ensures `AIAnalyzerThread` executes `Runnable` correctly. - Demonstrates clean and concurrent AI analysis flow. - Simulates integration with a GUI environment. - **`AiFunctionTest`** Utility-level tests: - Ensures proper CSV parsing and data transformation. - Verifies output formatting before sending to the AI. - Tests various time formats and edge case behaviors

## DAO (File Storage)

- Responsibilities: Save transaction data in CSV or JSON format and provide interfaces for adding,
  deleting, and modifying in-memory data

### CsvTransactionDao Class

#### Package

`DAO`

#### Dependencies

* **`model.Transaction`**: The data model class representing a single transaction.
* **`DAO.TransactionDao`**: The interface this class is intended to implement (though the implementation is incomplete).
* **Apache Commons CSV (`org.apache.commons.csv.*`)**: Used for robust parsing and writing of CSV data.
* **Apache Commons IO (`org.apache.commons.io.input.BOMInputStream`)**: Used specifically to handle potential Byte Order Marks (BOM) often found in UTF-8 encoded files, particularly those edited in Windows.
* **Java Standard Libraries**: `java.io.*`, `java.nio.*`.

#### Key Features & Implementation Details

* **CSV Loading (`loadFromCSV`)**:
  * Reads data from a specified CSV file path.
  * Expects UTF-8 encoding.
  * Handles potential Byte Order Mark (BOM) at the beginning of the file.
  * Uses the first row of the CSV as the header to map columns to `Transaction` fields. Assumes specific header names (e.g., "交易时间", "交易类型", "金额(元)").
  * Parses transaction records into a `List<Transaction>`.
  * Includes basic caching using an internal `transactions` list and an `isLoad` flag to avoid redundant file reads within the same instance lifecycle (unless forced by methods like `deleteTransaction` or `changeInformation`).
* **Record Parsing (`parseRecord`)**:
  * Converts a `CSVRecord` object (from Apache Commons CSV) into a `Transaction` object.
  * Specifically handles the "金额(元)" (Amount) field by removing the leading "¥" symbol before parsing it as a `double`.
* **Adding Transactions (`addTransaction(String filePath, Transaction newTransaction)`)**:
  * **Appends** a new transaction record to the *end* of the specified CSV file.
  * Creates the file if it doesn't exist.
  * Writes the header row only if the file is new or was empty.
  * Formats the payment amount by prepending "¥".
* **Deleting Transactions (`deleteTransaction(String filePath, String orderNumber)`)**:
  * Loads data from the file if not already cached.
  * Filters the cached list to remove the transaction matching the given `orderNumber`.
  * **Overwrites** the *entire* original CSV file with the filtered list using `writeTransactionsToCSV`.
  * Returns `true` if a transaction was removed, `false` otherwise.
* **Updating Transactions (`changeInformation`)**:
  * Loads data if not already cached.
  * Finds the transaction by `orderNumber`.
  * Modifies the specified field (`head`) of the found transaction object in memory.
  * **Crucially, it attempts the update by first *deleting* the original record (using `deleteTransaction`, which overwrites the file) and then *adding* the modified record (using `addTransaction`, which appends to the file).** This logic is inefficient and potentially problematic due to the conflicting file write strategies (overwrite vs. append).
  * Error handling for invalid `head` parameters prints to `System.err`. The method often returns `true` even if the underlying delete/add fails.
* **CSV Writing (`writeTransactionsToCSV`)**:
  * Helper method used by `deleteTransaction`.
  * Writes a given `List<Transaction>` to the specified file path, **overwriting** any existing content.
  * Writes a standard header row.
  * Formats the payment amount by prepending "¥".

#### Important Issues & Considerations

1.  **Incomplete `TransactionDao` Implementation**: The methods declared in the `TransactionDao` interface (`getAllTransactions`, `addTransaction(Transaction)`, `deleteTransaction(String)`, `updateTransaction`, `getTransactionByOrderNumber`) are present but contain only placeholder/stub code. The actual working logic uses separate methods that require the `filePath` to be passed explicitly each time. **This class, in its current state, does not correctly function as a `TransactionDao` implementation.**
2.  **Inconsistent File Writing Strategy**: `addTransaction` *appends* to the file, while `deleteTransaction` and `writeTransactionsToCSV` (used by `deleteTransaction` and `changeInformation`) *overwrite* the entire file. This inconsistency can lead to unexpected behavior, especially within the `changeInformation` method.
3.  **Inefficient Updates/Deletes**: Rewriting the entire CSV file for every single deletion or modification (`changeInformation`) is highly inefficient, especially for large transaction files.
4.  **Flawed Update Logic (`changeInformation`)**: The delete-then-add approach for updates is problematic due to the inconsistent write strategies and potential race conditions or partial failures. The modified record will likely appear at the *end* of the file, not its original position.
5.  **Basic Caching**: The caching mechanism (`isLoad` flag) is simple and does not account for external modifications to the CSV file during the application's runtime.
6.  **Hardcoded Dependencies**: The code relies on specific header names (in Chinese) and the "¥" currency symbol format within the CSV data. Changes to the CSV format would require code modifications.

#### Usage Example (Using Functional Methods)

```java
import DAO.CsvTransactionDao; // Assuming TransactionDao interface exists but is not used directly here due to stub methods
import model.Transaction;
import java.io.IOException;
import java.util.List;

public class CsvDataManager {

    public static void main(String[] args) {
        // NOTE: Using the class directly, not via the TransactionDao interface
        // because the interface methods are not fully implemented.
        CsvTransactionDao csvDao = new CsvTransactionDao();
        String csvFilePath = "path/to/your/transactions.csv"; // <--- Specify your file path

        try {
            // --- Load Data ---
            System.out.println("Loading transactions...");
            List<Transaction> transactions = csvDao.loadFromCSV(csvFilePath);
            System.out.println("Loaded " + transactions.size() + " transactions.");
            // Display first transaction if available
            if (!transactions.isEmpty()) {
                 System.out.println("First transaction order number: " + transactions.get(0).getOrderNumber());
            }

            // --- Add a New Transaction (Appends) ---
            Transaction newTx = new Transaction(
                 "2025-04-20 08:14:00", "Test Add", "Counterparty", "Item", "支",
                 10.0, "支付宝", "交易成功", "NEW_ORDER_123", "MERCH_456", "Test via DAO add"
            );
            System.out.println("\nAdding new transaction (append): " + newTx.getOrderNumber());
            // csvDao.addTransaction(csvFilePath, newTx); // Uncomment to actually add
            System.out.println("Transaction potentially added.");

            // --- Delete a Transaction (Overwrites File) ---
            String orderToDelete = "SOME_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number from your file
            System.out.println("\nAttempting to delete transaction: " + orderToDelete);
            // boolean deleted = csvDao.deleteTransaction(csvFilePath, orderToDelete); // Uncomment to actually delete
            // if (deleted) {
            //     System.out.println("Transaction deleted successfully (File rewritten).");
            // } else {
            //     System.out.println("Transaction not found for deletion.");
            // }

            // --- Change Information (Overwrites then Appends - Use with Caution) ---
             String orderToChange = "ANOTHER_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number
             String fieldToChange = "remarks";
             String newValue = "Updated remark via changeInformation";
             System.out.println("\nAttempting to change info for: " + orderToChange);
             // boolean changed = csvDao.changeInformation(orderToChange, fieldToChange, newValue, csvFilePath); // Uncomment with caution
             // System.out.println("Change operation attempted (File rewritten and appended). Result: " + changed);


        } catch (IOException e) {
            System.err.println("Error interacting with CSV file: " + e.getMessage());
            e.printStackTrace();
        } catch (NumberFormatException e) {
            System.err.println("Error parsing amount in CSV: " + e.getMessage());
        }
    }
}
```

## Controller (Swing GUI)

Responsibilities: Manage user interface components (buttons, tables, text boxes) to listen for 
events (clicks, inputs) and call service layer methods to update the interface data display

## attention

encoding with UTF-8
```

`软工/Ai-Bill-Application-Group21 - 副本\项目要求.txt`:

```txt
1. General Information 
In the next few weeks, your team will be required to develop a software application that 
will serve as a smart personal finance manager that helps users track expenses, set 
savings goals, and analyses spending habits using AI. Agile methods should be applied 
in all activities, from requirements through analysis/design, implementation, and testing. 
Iterations should be planned, and outcomes should be submitted. 
There are no restrictions on what you can include in the final product, and the given 
specification contains only high-level abstract requirements. It should be noted that 
determining the software requirements is one of the most important and complex phases 
in any development project. You should apply requirement-finding techniques and Agile 
methods to identify the actual requirements at an appropriate level. Most importantly, you 
need to prioritize the features that are implemented in accordance with both ease of 
implementation and meeting requirements. As in real software, you should define the 
project scope properly. Keep your design SIMPLE. Bear in mind that there is no absolute 
right answer – your solution may be perfectly appropriate.

2. Project Specification 
2.1 Basic Requirements 
Managing personal finances effectively is crucial in today’s digital economy, where 
transactions occur across multiple platforms like WeChat Pay, Alipay, and traditional 
banking. Many individuals struggle with tracking expenses, categorizing spending, and 
setting realistic budgets. An AI-powered personal finance tracker simplifies financial 
management by automatically classifying transactions, detecting spending patterns, and 
offering personalized savings recommendations. However, AI is not perfect – users must 
manually review to ensure accuracy. By integrating AI with manual validation, this 
software helps users make informed financial decisions while adapting to regional 
spending habits and economic conditions, improving financial literacy and budgeting 
skills. Here are some suggested functions to assist you in getting started. Suggested 
features can include the following, but not limited to: 
• Manual & Automated Data Entry: End users may input transactions manually or 
import structured CSV files from banking/financial apps. 
• Expense Categorisation (AI + Manual Correction): AI classifies transactions into 
categories (e.g., groceries, rent, entertainment), but end users can verify & correct 
misclassifications. 
• Spending Insights & Predictions: AI suggests monthly budgets, savings goals, and 
cost-cutting recommendations based on spending behaviour. 
• Local Financial Context: Customisable to China-specific budgeting habits, for 
example detects seasonal spending habits, such as higher expenses during Chinese 
New Year. 
A full prototype of the application should be produced. It is not required to implement the 
full working code for all functions in the prototype, however your team should implement 
core functions of your choice. 

2.2 Other Requirements 
• The software must be developed using Java as a stand-alone application running 
on computers. A simple graphic user interface (GUI) should be used. The recent 
Java Edition should be used. Do NOT build a Web-based application or Phone 
App. 
• All input and output data should be in simple text file format. You may use plain 
text (txt), CSV, JSON, or XML. Do NOT use a database. 
• Basic restrictions and error checking must be considered. 
• Your design must be flexible and extensible to adapt to future changes, e.g. 
modify existing features and add new features. When doing so, you should be 
able to reuse the existing components and make the least impact on the existing 
code. 
Page 2 of 8 
Your tasks are to define detailed requirements, design, develop and test the above software 
using Agile methods. Feel free to design the software as long as it satisfies the basic 
requirements, define the SCOPE properly.  

2.3 AI-Assisted Development 
To prevent over-reliance on AI, 
the following constraints apply: 
• Live Data Collection: AI cannot generate user-specific data patterns – you must 
gather real data. 请给出相应的数据搜集渠道（但是我们已经设计好了csv表，相应字段也设计了）
• Manual Data Cleaning and Validation: AI assistance is allowed, but the team must 
need to manually check for missing information, inconsistency, and inappropriate 
categorisation, etc. 
• Context-Specific Constraints: AI may struggle with domain-specific rules – you 
must implement real-world constraints (e.g. AI may count a WeChat Red Packet as a 
personal income where it is in fact a gift money and not a regular income.) 
• Oral Spot-Check: During the vivas, you will need to answer questions like “Why did 
AI make this recommendation?”, “How did you modify AI’s solution?”, etc, to 
demonstrate your understanding.
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\pom.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>Ai-bill</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.knowm.xchart</groupId>
            <artifactId>xchart</artifactId>
            <version>3.8.4</version> <!-- Use the latest version -->
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.13.2</version>
            <scope>test</scope>
        </dependency>

        <!-- CSV 解析核心库 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-csv</artifactId>
            <version>1.10.0</version>
        </dependency>

        <!-- 文件操作工具 -->
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>2.15.1</version>
        </dependency>

        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>5.10.0</version>
            <scope>test</scope>
        </dependency>

        <!-- 断言增强库 -->
        <dependency>
            <groupId>org.assertj</groupId>
            <artifactId>assertj-core</artifactId>
            <version>3.24.2</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>com.volcengine</groupId>
            <artifactId>volcengine-java-sdk-ark-runtime</artifactId>
            <version>LATEST</version>
        </dependency>
        <dependency>
            <groupId>javax.annotation</groupId>
            <artifactId>javax.annotation-api</artifactId>
            <version>1.3.2</version>
        </dependency>
        <!-- pom.xml -->



        <!-- JSON 处理 -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.15.2</version>
        </dependency>

        <!--        caffeine缓存中间件-->
        <dependency>
            <groupId>com.github.ben-manes.caffeine</groupId>
            <artifactId>caffeine</artifactId>
            <version>3.1.8</version> <!-- 使用最新版本 -->
        </dependency>

    </dependencies>

</project>
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Constants\CaffeineKeys.java`:

```java
package Constants;

public class CaffeineKeys {
    public static final String TRANSACTION_CAFFEINE_KEY = "transactions";

}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Constants\ConfigConstants.java`:

```java
package Constants;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

/**
 * 配置常量类（线程安全初始化）
 */
public final class ConfigConstants {
    private ConfigConstants() {} // 私有构造防止实例化

    // CSV路径常量
    public static final String CSV_PATH; // Original, may still be referenced in old code
    public static final String USERS_CSV_PATH; // User CSV path
    public static final String SUMMARY_CSV_PATH; // 新增汇总统计CSV路径


    // 静态初始化块（类加载时执行）
    static {
        Properties prop = new Properties();
        try (InputStream input = ConfigConstants.class.getClassLoader()
                .getResourceAsStream("config.properties")) {

            if (input == null) {
                throw new RuntimeException("配置文件 config.properties 未找到在 classpath 中");
            }

            prop.load(input);

            CSV_PATH = prop.getProperty("csv.path");
            USERS_CSV_PATH = prop.getProperty("csv.users_path");
            SUMMARY_CSV_PATH = prop.getProperty("csv.summary_path"); // 读取汇总统计CSV路径


            // Basic validation
            if (USERS_CSV_PATH == null || USERS_CSV_PATH.trim().isEmpty()) {
                throw new RuntimeException("'csv.users_path' not found or is empty in config.properties.");
            }
            if (SUMMARY_CSV_PATH == null || SUMMARY_CSV_PATH.trim().isEmpty()) {
                throw new RuntimeException("'csv.summary_path' not found or is empty in config.properties.");
            }

        } catch (IOException e) {
            throw new RuntimeException("加载配置文件失败", e); // 转换为运行时异常
        }
        System.out.println("Loaded USERS_CSV_PATH: " + USERS_CSV_PATH);
        System.out.println("Loaded SUMMARY_CSV_PATH: " + SUMMARY_CSV_PATH);
        if (CSV_PATH != null) System.out.println("Loaded CSV_PATH: " + CSV_PATH); // Optional print
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Constants\StandardCategories.java`:

```java
package Constants;

import java.util.List;
import java.util.ArrayList;
import java.util.Collections; // For immutable lists
import java.util.stream.Collectors;

public final class StandardCategories {
    private StandardCategories() {} // Prevent instantiation

    // Standard Expense Categories for analysis and filtering
    public static final List<String> EXPENSE_CATEGORIES = Collections.unmodifiableList(List.of(
            "餐饮",
            "食品杂货",
            "服饰",
            "日用品",
            "交通",
            "娱乐",
            "住房",
            "通信",
            "教育",
            "医疗",
            "金融服务",
            "其他支出" // General catch-all for expenses
    ));

    // Standard Income Categories
    public static final List<String> INCOME_CATEGORIES = Collections.unmodifiableList(List.of(
            "工资",
            "兼职收入",
            "投资收益",
            "其他收入" // General catch-all for income
    ));

    // Special Transaction Types (may not be strictly 'expense' or 'income' in analysis)
    public static final List<String> SPECIAL_TYPES = Collections.unmodifiableList(List.of(
            "转账", // Transfers between accounts or people
            "红包" // WeChat/Alipay Red Packets - often social, not regular income/expense
            // Add other special types as needed, e.g., Refund, Credit Card Repayment
    ));

    /**
     * Generates a comma-separated string of all standard categories for AI prompts.
     * @return String like "餐饮,食品杂货,服饰,..."
     */
    public static String getAllCategoriesString() {
        return ALL_KNOWN_TYPES.stream()
                .collect(Collectors.joining(","));
    }

    // All Known Transaction Types (combination of all the above + potentially user-defined ones initially)
    // This list might be used for dropdowns in UI, etc.
    public static final List<String> ALL_KNOWN_TYPES;

    static {
        List<String> allTypesMutable = new ArrayList<>();
        allTypesMutable.addAll(EXPENSE_CATEGORIES);
        allTypesMutable.addAll(INCOME_CATEGORIES);
        allTypesMutable.addAll(SPECIAL_TYPES);
        ALL_KNOWN_TYPES = Collections.unmodifiableList(allTypesMutable);
    }


    /**
     * Helper method to check if a transaction type is a standard expense category.
     * Handles potential variations like "支" vs "支出".
     */
    public static boolean isStandardExpenseCategory(String type) {
        if (type == null) return false;
        String trimmedType = type.trim();
        // First, check if it's directly in the list
        if (EXPENSE_CATEGORIES.contains(trimmedType)) {
            return true;
        }
        // Handle common aliases/variations if necessary, e.g., "交通费" -> "交通"
        // This might require a mapping logic if aliases are common and not handled by AI mapping.
        return false; // For now, strict check
    }

    /**
     * Helper method to get the standardized category for a given transaction type string.
     * This is where mapping from potentially messy user input or AI output to standard categories happens.
     * For now, a simple direct match is used. In the future, this could use AI recognition results
     * or manual mapping rules.
     * @param rawType The transaction type string from data.
     * @return The matched standard category, or the original rawType if no standard match, or "未知" for null/empty.
     */
    public static String getStandardCategory(String rawType) {
        if (rawType == null || rawType.trim().isEmpty()) {
            return "未知"; // Unknown category
        }
        String trimmedType = rawType.trim();
        // Check if it matches any standard category (case-insensitive might be better)
        // Let's do a simple case-sensitive check for now against the predefined lists.
        if (ALL_KNOWN_TYPES.contains(trimmedType)) {
            return trimmedType; // Direct match
        }

        // Future Improvement: Implement smarter mapping here, potentially using AI suggestions
        // or a configuration file for mapping common user inputs to standard categories.
        // E.g., if rawType is "吃饭", map to "餐饮". If "地铁票", map to "交通".

        return trimmedType; // If no standard match, return the original type.
        // We might want a dedicated "Other" if it doesn't fit any *known* type.
    }

    /**
     * Helper method to check if a transaction type is a standard income category.
     */
    public static boolean isStandardIncomeCategory(String type) {
        if (type == null) return false;
        return INCOME_CATEGORIES.contains(type.trim());
    }

    /**
     * Helper method to check if a transaction type is a special type.
     */
    public static boolean isSpecialType(String type) {
        if (type == null) return false;
        return SPECIAL_TYPES.contains(type.trim());
    }


}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Controller\ButtonEditor.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.TableCellEditor;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

class ButtonEditor extends AbstractCellEditor implements TableCellEditor {
    private final JPanel panel = new JPanel(new BorderLayout()); // 使用 BorderLayout
    private final JButton button = new JButton();
    private int rowIndex;
    private final MenuUI menuUI;

    public ButtonEditor(MenuUI menuUI) {
        this.menuUI = menuUI;

        // 设置按钮样式
        button.setFocusPainted(false); // 移除按钮的焦点边框
        button.setPreferredSize(new Dimension(80, 30)); // 设置按钮的固定尺寸

        // 添加按钮到面板
        panel.add(button, BorderLayout.CENTER);

        // 为按钮添加事件监听器
        button.addActionListener(e -> {
            System.out.println("按钮点击事件触发: " + button.getText());
            fireEditingStopped(); // 停止编辑
            String buttonText = button.getText();
            if ("Modify".equals(buttonText)) {
                menuUI.editRow(rowIndex); // 调用 MenuUI 的 editRow 方法
            } else if ("Delete".equals(buttonText)) {
                int confirm = JOptionPane.showConfirmDialog(panel, "确定要删除此行吗？", "确认删除", JOptionPane.YES_NO_OPTION);
                if (confirm == JOptionPane.YES_OPTION) {
                    menuUI.deleteRow(rowIndex); // 调用 MenuUI 的 deleteRow 方法
                }
            }
        });
    }

    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
        this.rowIndex = row; // 更新当前行索引
        button.setText(value != null ? value.toString() : ""); // 根据单元格的值设置按钮文本
        return panel;
    }

    @Override
    public Object getCellEditorValue() {
        return button.getText(); // 返回按钮的当前文本
    }
}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Controller\ButtonRenderer.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import java.awt.*;

class ButtonRenderer extends DefaultTableCellRenderer {
    private final JPanel panel = new JPanel(new BorderLayout()); // 使用 BorderLayout
    private final JButton button = new JButton();

    public ButtonRenderer() {
        button.setFocusPainted(false); // 移除按钮的焦点边框
        button.setPreferredSize(new Dimension(80, 30)); // 设置按钮的固定尺寸
        panel.add(button, BorderLayout.CENTER); // 将按钮添加到面板中心
    }

    @Override
    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
        // 根据单元格的值设置按钮文本
        button.setText(value != null ? value.toString() : "");
        return panel;
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Controller\HistogramExample.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;
import java.util.HashMap;
import java.util.Random;

// 数据生成类
class DataGenerator {
    public static int[] generateData(int numberOfDataPoints, int maxValue) {
        Random random = new Random();
        int[] data = new int[numberOfDataPoints];
        for (int i = 0; i < numberOfDataPoints; i++) {
            data[i] = random.nextInt(maxValue);
        }
        return data;
    }
}

// 直方图计算类
class Histogram {
    private int binSize;
    private int[] data;

    public Histogram(int[] data, int binSize) {
        this.data = data;
        this.binSize = binSize;
    }

    public HashMap<Integer, Integer> computeFrequency() {
        HashMap<Integer, Integer> frequencyMap = new HashMap<>();
        for (int number : data) {
            int bin = number / binSize;
            frequencyMap.put(bin, frequencyMap.getOrDefault(bin, 0) + 1);
        }
        return frequencyMap;
    }
}

// 直方图 GUI 绘制类
class HistogramPanel extends JPanel {
    HashMap<Integer, Integer> frequencyMap;

    public HistogramPanel() {
        this.frequencyMap = new HashMap<>();
    }

    public void updateData(HashMap<Integer, Integer> frequencyMap) {
        this.frequencyMap = frequencyMap;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        int barWidth = 40;
        int gap = 10;
        int maxFrequency = frequencyMap.values().stream().mapToInt(v -> v).max().orElse(1);

        int index = 0;
        for (Integer key : frequencyMap.keySet()) {
            int height = (int) ((frequencyMap.get(key) / (double) maxFrequency) * getHeight());
            g.setColor(Color.BLUE);
            g.fillRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.setColor(Color.BLACK);
            g.drawRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.drawString("Bin " + key, index * (barWidth + gap) + 5, getHeight() - 5);
            index++;
        }
    }
}


// 主窗口类
public class HistogramExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("数据分析界面");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });
    }
}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Controller\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}


```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Ai-Bill-Application-Prompt_2.txt`:

```txt
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Controller\MenuUI.java`:

```java
package Controller;

import Constants.ConfigConstants;
import Constants.StandardCategories; // Import StandardCategories if needed in UI
import DAO.TransactionDao; // Import if needed
import DAO.SummaryStatisticDao; // Import if needed
import Service.AIservice.AITransactionService; // Import AI services
import Service.AIservice.CollegeStudentNeeds;
import Service.Impl.TransactionServiceImpl;
import Service.Impl.SummaryStatisticService; // Import SummaryStatisticService
import Service.TransactionService;
import Utils.CacheManager;
import model.SummaryStatistic; // Import SummaryStatistic
import model.Transaction;
import model.User;
import Constants.StandardCategories;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.io.IOException;
import java.util.List;
import java.util.Vector;
import java.util.Comparator; // For sorting stats display

public class MenuUI extends JPanel { // Extend JPanel for easier use in Main (optional but common)

    private final User currentUser;
    private final TransactionService transactionService;
    private final SummaryStatisticService summaryStatisticService;
    private final AITransactionService aiTransactionService;
    private final CollegeStudentNeeds collegeStudentNeeds;

    private DefaultTableModel tableModel;

    // Fields for search input components
    private JTextField searchTransactionTimeField;
    private JTextField searchTransactionTypeField;
    private JTextField searchCounterpartyField;
    private JTextField searchCommodityField;
    private JComboBox<String> searchInOutComboBox;
    private JTextField searchPaymentMethodField;
    private JButton searchButton;

    private JTable table;
    // REMOVED: private HistogramPanelContainer histogramPanelContainer; // No longer needed

    private JPanel rightPanel;
    private CardLayout cardLayout;

    // UI components for AI panel (existing)
    private JTextArea aiResultArea;
    private JTextField aiStartTimeField;
    private JTextField aiEndTimeField;
    private JButton aiAnalyzeButton;
    private JButton aiBudgetButton;
    private JButton aiTipsButton;
    private JButton aiPersonalSummaryButton;
    private JButton aiSavingsGoalsButton;
    private JButton aiPersonalSavingTipsButton;


    // UI components for Admin Stats panel (existing)
    private JTextArea adminStatsArea;
    private JButton generateStatsButton;
    private JButton refreshDisplayButton;

    // New panel for Visualization
    private VisualizationPanel visualizationPanel; // Add instance field


    // Constructor now accepts all necessary service instances (same as before)
    public MenuUI(User authenticatedUser, TransactionService transactionService,
                  SummaryStatisticService summaryStatisticService,
                  AITransactionService aiTransactionService,
                  CollegeStudentNeeds collegeStudentNeeds) {

        this.currentUser = authenticatedUser;
        this.transactionService = transactionService;
        this.summaryStatisticService = summaryStatisticService;
        this.aiTransactionService = aiTransactionService;
        this.collegeStudentNeeds = collegeStudentNeeds;

        // Initialize table model (same as before)
        String[] columnNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注", "Modify", "Delete"};
        this.tableModel = new DefaultTableModel(columnNames, 0);
        this.table = new JTable(this.tableModel);

        // Initialize the main panel layout (same as before)
        setLayout(new BorderLayout());

        // Add the left panel (will be modified)
        add(createLeftPanel(), BorderLayout.WEST);

        // Add the right panel (will be modified)
        setupRightPanel();
        add(rightPanel, BorderLayout.CENTER);

        // Initial data load is done in createMainPanel (same as before)
        // loadCSVDataForCurrentUser("收入");

        System.out.println("MenuUI initialized for user: " + currentUser.getUsername() + " (" + currentUser.getRole() + ")");
    }

    public JPanel createMainPanel() {
        // MenuUI itself is the main panel, just add the initial data
        loadCSVDataForCurrentUser(""); // Load and display only income initially
        return this; // Return itself
    }


    // Method to load CSV data for the current user with optional initial filter
    // Same logic as before
    public void loadCSVDataForCurrentUser(String initialInOutFilter) {
        // ... existing implementation ...
        this.tableModel.setRowCount(0); // Clear the table model

        try {
            List<Transaction> transactions = transactionService.getAllTransactions();
            System.out.println("Loaded total " + transactions.size() + " transactions from service for user " + currentUser.getUsername());

            List<Transaction> filteredTransactions = new java.util.ArrayList<>();
            if (initialInOutFilter == null || initialInOutFilter.trim().isEmpty()) {
                filteredTransactions.addAll(transactions);
            } else {
                String filter = initialInOutFilter.trim();
                filteredTransactions = transactions.stream()
                        .filter(t -> t.getInOut() != null && (t.getInOut().equalsIgnoreCase(filter) ||
                                (filter.equalsIgnoreCase("收入") && t.getInOut().equalsIgnoreCase("收")) ||
                                (filter.equalsIgnoreCase("支出") && t.getInOut().equalsIgnoreCase("支")) ))
                        .collect(java.util.stream.Collectors.toList());
            }

            for (Transaction transaction : filteredTransactions) {
                Vector<String> row = createRowFromTransaction(transaction);
                this.tableModel.addRow(row);
            }
            System.out.println("Displayed " + filteredTransactions.size() + " transactions in the table.");

        } catch (Exception e) {
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, "加载用户交易数据失败！", "错误", JOptionPane.ERROR_MESSAGE);
        }
    }

    // Method to create the left panel (Menu/AI/Admin/Visualization buttons) - MODIFIED
    private JPanel createLeftPanel() {
        JPanel leftPanel = new JPanel();
        leftPanel.setLayout(new BoxLayout(leftPanel, BoxLayout.Y_AXIS));
        leftPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        JButton menuButton = new JButton("交易列表");
        JButton aiButton = new JButton("AI分析");
        JButton adminButton = new JButton("管理员统计");
        JButton visualizationButton = new JButton("可视化"); // NEW Visualization button

        // Set consistent size for buttons
        Dimension buttonSize = new Dimension(150, 40);
        menuButton.setMaximumSize(buttonSize);
        aiButton.setMaximumSize(buttonSize);
        adminButton.setMaximumSize(buttonSize);
        visualizationButton.setMaximumSize(buttonSize); // Set size for new button


        menuButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        aiButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        adminButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        visualizationButton.setAlignmentX(Component.CENTER_ALIGNMENT); // Align new button


        leftPanel.add(menuButton);
        leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        leftPanel.add(aiButton);
        leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));

        // Add Admin button only if the user is admin (same as before)
        if ("admin".equalsIgnoreCase(currentUser.getRole())) {
            leftPanel.add(adminButton);
            leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));
        }

        // Add Visualization button (visible for all users)
        leftPanel.add(visualizationButton); // Add the visualization button
        leftPanel.add(Box.createRigidArea(new Dimension(0, 10)));


        // Add action listeners (existing for Menu, AI, Admin)
        menuButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Table");
            loadCSVDataForCurrentUser("收入");
        });

        aiButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "AI");
        });

        if ("admin".equalsIgnoreCase(currentUser.getRole())) {
            adminButton.addActionListener(e -> {
                cardLayout.show(rightPanel, "AdminStats");
                displaySummaryStatistics(); // Refresh stats display when switching
            });
        }

        // Add action listener for Visualization button - NEW
        visualizationButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Visualization"); // Switch to visualization view
            // Optional: Trigger initial chart load or setup in VisualizationPanel
            // visualizationPanel.loadAndDisplayCharts(); // Needs a method in VisualizationPanel
        });


        leftPanel.add(Box.createVerticalGlue());

        return leftPanel;
    }

    // Method to set up the right panel, adding different views - MODIFIED
    private void setupRightPanel() {
        this.cardLayout = new CardLayout();
        this.rightPanel = new JPanel(this.cardLayout);

        // Create and add different panels (views)
        JPanel tablePanel = createTablePanel(); // Table view
        JPanel aiPanel = createAIPanel(); // AI view
        JPanel adminStatsPanel = createAdminStatsPanel(); // Admin stats view
        this.visualizationPanel = new VisualizationPanel(this.transactionService); // NEW: Create VisualizationPanel, inject TransactionService


        rightPanel.add(tablePanel, "Table");
        rightPanel.add(aiPanel, "AI");
        if ("admin".equalsIgnoreCase(currentUser.getRole())) {
            rightPanel.add(adminStatsPanel, "AdminStats");
        }
        rightPanel.add(visualizationPanel, "Visualization"); // NEW: Add Visualization panel


        // Set the initially visible card (Table view)
        cardLayout.show(rightPanel, "Table");
    }

    // Method to create the table panel - same as before
    private JPanel createTablePanel() {
        JPanel tablePanel = new JPanel(new BorderLayout());

        JPanel inputPanel = createInputPanel(); // This method now initializes search fields
        tablePanel.add(inputPanel, BorderLayout.NORTH);

        JScrollPane tableScrollPane = new JScrollPane(this.table);
        tableScrollPane.setPreferredSize(new Dimension(1000, 250)); // Preferred size hint
        this.table.setFillsViewportHeight(true); // Make table fill the scroll pane height
        this.table.setRowHeight(30);

        tablePanel.add(tableScrollPane, BorderLayout.CENTER);

        // Set cell renderers and editors
        this.table.getColumnModel().getColumn(11).setCellRenderer(new ButtonRenderer());
        this.table.getColumnModel().getColumn(11).setCellEditor(new ButtonEditor(this));

        this.table.getColumnModel().getColumn(12).setCellRenderer(new ButtonRenderer());
        this.table.getColumnModel().getColumn(12).setCellEditor(new ButtonEditor(this));

        // Initial data load is done in the MenuUI constructor or createMainPanel
        // loadCSVDataForCurrentUser("收入"); // Moved to createMainPanel

        return tablePanel;
    }

    // Inside MenuUI class
    private JPanel createInputPanel() {
        JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));

        // Create input fields and capture references (existing code)
        searchTransactionTimeField = new JTextField(10);
        searchTransactionTypeField = new JTextField(10);
        searchCounterpartyField = new JTextField(10);
        searchCommodityField = new JTextField(10);
        searchInOutComboBox = new JComboBox<>(new String[]{"", "收入", "支出"});
        searchPaymentMethodField = new JTextField(10);

        // Add labels and input fields (existing code)
        inputPanel.add(new JLabel("交易时间:")); inputPanel.add(searchTransactionTimeField);
        inputPanel.add(new JLabel("交易类型:")); inputPanel.add(searchTransactionTypeField);
        inputPanel.add(new JLabel("交易对方:")); inputPanel.add(searchCounterpartyField);
        inputPanel.add(new JLabel("商品:")); inputPanel.add(searchCommodityField);
        inputPanel.add(new JLabel("收/支:")); inputPanel.add(searchInOutComboBox);
        inputPanel.add(new JLabel("支付方式:")); inputPanel.add(searchPaymentMethodField);

        // Create Search, Add, and Import buttons
        searchButton = new JButton("Search");
        JButton addButton = new JButton("Add");
        JButton importButton = new JButton("导入 CSV"); // 新增导入按钮

        // Add buttons
        inputPanel.add(searchButton);
        inputPanel.add(addButton);
        inputPanel.add(importButton); // 添加导入按钮

        // Add ActionListeners (existing code for Search and Add)
        searchButton.addActionListener(e -> triggerCurrentSearch());
        addButton.addActionListener(e -> showAddTransactionDialog());

        // Add ActionListener for Import button
        importButton.addActionListener(e -> {
            showImportDialog(); // Call a new method to handle import
        });

        return inputPanel;
    }

    // Inside MenuUI class
    private void showImportDialog() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("选择要导入的CSV文件");
        // Optional: Add file filter for .csv files
        fileChooser.setFileFilter(new javax.swing.filechooser.FileNameExtensionFilter("CSV Files (*.csv)", "csv"));

        int userSelection = fileChooser.showOpenDialog(this); // Show dialog relative to MenuUI panel

        if (userSelection == JFileChooser.APPROVE_OPTION) {
            java.io.File fileToImport = fileChooser.getSelectedFile();
            String filePath = fileToImport.getAbsolutePath();
            System.out.println("用户选择了导入文件: " + filePath);

            // Display "Importing..." message and disable button (optional UI feedback)
            // This needs a status area, maybe in the main panel or a separate progress dialog.
            // For simplicity now, we'll just show messages.

            // Run import in a background thread
            // Need to pass the file path and the current user's file path to the service
            new Thread(() -> {
                String message;
                try {
                    // Call the service method to handle the import logic
                    int importedCount = transactionService.importTransactionsFromCsv(currentUser.getTransactionFilePath(), filePath);

                    message = "成功导入 " + importedCount + " 条交易记录。";
                    System.out.println(message);

                    // Update UI on EDT after successful import
                    String finalMessage = message;
                    SwingUtilities.invokeLater(() -> {
                        loadCSVDataForCurrentUser(""); // Reload all data to show imported items
                        clearSearchFields(); // Clear search fields after reload
                        JOptionPane.showMessageDialog(this, finalMessage, "导入成功", JOptionPane.INFORMATION_MESSAGE);
                    });

                } catch (Exception ex) { // Catch exceptions from the service layer
                    message = "导入失败！\n" + ex.getMessage();
                    System.err.println("CSV Import failed: " + ex.getMessage());
                    ex.printStackTrace();
                    // Update UI on EDT with error message
                    String finalMessage1 = message;
                    SwingUtilities.invokeLater(() -> {
                        JOptionPane.showMessageDialog(this, finalMessage1, "导入错误", JOptionPane.ERROR_MESSAGE);
                    });
                }
            }).start();
        } else {
            System.out.println("用户取消了文件选择。");
        }
    }

    // Inside MenuUI class, showAddTransactionDialog method
    private void showAddTransactionDialog() {
        JDialog addDialog = new JDialog();
        addDialog.setTitle("添加交易");
        JPanel dialogPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.insets = new Insets(5, 5, 5, 5);

        JTextField transactionTimeField = new JTextField(15);
        JTextField transactionTypeField = new JTextField(15);
        JButton aiSuggestButton = new JButton("AI分类建议");
        // Removed aiStatusLabel as we use a separate waiting dialog


        JTextField counterpartyField = new JTextField(15);
        JTextField commodityField = new JTextField(15);
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"});
        JTextField paymentAmountField = new JTextField(15);
        JTextField paymentMethodField = new JTextField(15);
        JTextField currentStatusField = new JTextField(15);
        JTextField orderNumberField = new JTextField(15);
        JTextField merchantNumberField = new JTextField(15);
        JTextField remarksField = new JTextField(15);


        gbc.gridx = 0; gbc.gridy = 0; dialogPanel.add(new JLabel("交易时间:"), gbc);
        gbc.gridx = 1; gbc.gridy = 0; gbc.gridwidth = 2; dialogPanel.add(transactionTimeField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 1; dialogPanel.add(new JLabel("交易类型:"), gbc);
        gbc.gridx = 1; gbc.gridy = 1; gbc.weightx = 1.0; dialogPanel.add(transactionTypeField, gbc);
        gbc.gridx = 2; gbc.gridy = 1; gbc.weightx = 0.0; dialogPanel.add(aiSuggestButton, gbc);


        gbc.gridx = 0; gbc.gridy = 2; gbc.gridwidth = 1; dialogPanel.add(new JLabel("交易对方:"), gbc);
        gbc.gridx = 1; gbc.gridy = 2; gbc.gridwidth = 2; dialogPanel.add(counterpartyField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 3; gbc.gridwidth = 1; dialogPanel.add(new JLabel("商品:"), gbc);
        gbc.gridx = 1; gbc.gridy = 3; gbc.gridwidth = 2; dialogPanel.add(commodityField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 4; gbc.gridwidth = 1; dialogPanel.add(new JLabel("收/支:"), gbc);
        gbc.gridx = 1; gbc.gridy = 4; gbc.gridwidth = 2; dialogPanel.add(inOutComboBox, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 5; gbc.gridwidth = 1; dialogPanel.add(new JLabel("金额(元):"), gbc);
        gbc.gridx = 1; gbc.gridy = 5; gbc.gridwidth = 2; dialogPanel.add(paymentAmountField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 6; gbc.gridwidth = 1; dialogPanel.add(new JLabel("支付方式:"), gbc);
        gbc.gridx = 1; gbc.gridy = 6; gbc.gridwidth = 2; dialogPanel.add(paymentMethodField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 7; gbc.gridwidth = 1; dialogPanel.add(new JLabel("当前状态:"), gbc);
        gbc.gridx = 1; gbc.gridy = 7; gbc.gridwidth = 2; dialogPanel.add(currentStatusField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 8; gbc.gridwidth = 1; dialogPanel.add(new JLabel("交易单号:"));
        gbc.gridx = 1; gbc.gridy = 8; gbc.gridwidth = 2; dialogPanel.add(orderNumberField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 9; gbc.gridwidth = 1; dialogPanel.add(new JLabel("商户单号:"));
        gbc.gridx = 1; gbc.gridy = 9; gbc.gridwidth = 2; dialogPanel.add(merchantNumberField, gbc); gbc.gridwidth = 1;

        gbc.gridx = 0; gbc.gridy = 10; gbc.gridwidth = 1; dialogPanel.add(new JLabel("备注:"));
        gbc.gridx = 1; gbc.gridy = 10; gbc.gridwidth = 2; dialogPanel.add(remarksField, gbc); gbc.gridwidth = 1;


        // --- Define the modal waiting dialog ---
        JDialog waitingDialog = new JDialog(addDialog, "请稍候", true); // Modal dialog owned by addDialog
        waitingDialog.setLayout(new FlowLayout());
        waitingDialog.add(new JLabel("正在获取AI分类建议..."));
        waitingDialog.setSize(200, 100);
        waitingDialog.setResizable(false);
        // waitingDialog.setLocationRelativeTo(addDialog); // Set location later before showing
        // --- End waiting dialog definition ---


        // Add Confirm and Cancel buttons
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        JButton confirmButton = new JButton("确认");
        JButton cancelButton = new JButton("取消");
        buttonPanel.add(confirmButton);
        buttonPanel.add(cancelButton);

        gbc.gridx = 0; gbc.gridy = 11; gbc.gridwidth = 3; gbc.anchor = GridBagConstraints.CENTER; gbc.fill = GridBagConstraints.NONE; // Adjust gridy
        dialogPanel.add(buttonPanel, gbc);


        addDialog.add(dialogPanel, BorderLayout.CENTER);


        // Add AI Suggest button action listener - MODIFIED LOGIC FLOW
        aiSuggestButton.addActionListener(e -> {
            System.out.println("AI Suggest button clicked (EDT).");

            // 1. Disable button immediately on EDT
            aiSuggestButton.setEnabled(false);
            // confirmButton.setEnabled(false); // Optional: also disable confirm

            // 2. Build temporary transaction object from current fields
            Transaction tempTransaction = new Transaction(
                    emptyIfNull(transactionTimeField.getText().trim()),
                    emptyIfNull(transactionTypeField.getText().trim()), // Capture current potentially incomplete type
                    emptyIfNull(counterpartyField.getText().trim()),
                    emptyIfNull(commodityField.getText().trim()),
                    (String) inOutComboBox.getSelectedItem(),
                    safeParseDouble(paymentAmountField.getText().trim()),
                    emptyIfNull(paymentMethodField.getText().trim()),
                    emptyIfNull(currentStatusField.getText().trim()),
                    emptyIfNull(orderNumberField.getText().trim()),
                    emptyIfNull(merchantNumberField.getText().trim()),
                    emptyIfNull(remarksField.getText().trim())
            );

            // 3. Create and start the background thread FIRST
            new Thread(() -> {
                System.out.println("Background thread started for AI classification...");
                String aiSuggestion = null;
                try {
                    // Simulate delay for testing thread behavior
                    // Thread.sleep(3000); // Uncomment to simulate a 3-second delay
                    aiSuggestion = collegeStudentNeeds.RecognizeTransaction(tempTransaction);
                    System.out.println("AI Classification returned in background thread: " + aiSuggestion);
                } catch (Exception ex) {
                    System.err.println("Error in background AI thread: " + ex.getMessage());
                    ex.printStackTrace();
                    aiSuggestion = "Error: " + ex.getMessage(); // Capture error to display later
                }


                // 4. Schedule the UI update and dialog hiding on the EDT from the background thread
                String finalSuggestion = aiSuggestion; // Need a final variable for use in lambda
                SwingUtilities.invokeLater(() -> {
                    System.out.println("Updating UI on EDT from background thread.");
                    // --- Hide waiting dialog ---
                    waitingDialog.setVisible(false); // This is the call that unblocks the initial setVisible(true)

                    // --- Display AI suggestion ---
                    if (finalSuggestion != null && !finalSuggestion.isEmpty() && !finalSuggestion.startsWith("Error:")) {
                        // Safety Check: Although prompt asks for standard, AI might deviate.
                        // If AI *strictly* follows the prompt, this check might be redundant,
                        // but adding it makes the UI robust against unexpected AI output.
                        if (StandardCategories.ALL_KNOWN_TYPES.contains(finalSuggestion.trim())) {
                            transactionTypeField.setText(finalSuggestion.trim());
                        } else {
                            System.err.println("AI returned non-standard category despite prompt: " + finalSuggestion);
                            // Handle non-standard: Maybe use it anyway, or warn and clear.
                            // According to requirement: "分类严格符合所规定的那几类". If AI fails, we should not inject non-standard.
                            JOptionPane.showMessageDialog(addDialog, "AI返回了非预期的分类格式：\n" + finalSuggestion + "\n请手动输入。", "AI结果异常", JOptionPane.WARNING_MESSAGE);
                            transactionTypeField.setText(""); // Clear or set to default if AI fails strict adherence
                        }
                    } else if (finalSuggestion != null && finalSuggestion.startsWith("Error:")) {
                        // Handle the error case
                        JOptionPane.showMessageDialog(addDialog, "获取AI分类建议失败！\n" + finalSuggestion.substring(6), "AI错误", JOptionPane.ERROR_MESSAGE);
                        transactionTypeField.setText(""); // Clear the field on error
                    }
                    else { // AI returned null or empty
                        JOptionPane.showMessageDialog(addDialog, "AI未能提供分类建议。", "AI提示", JOptionPane.INFORMATION_MESSAGE);
                        transactionTypeField.setText("");
                    }

                    // 5. Re-enable buttons on EDT
                    aiSuggestButton.setEnabled(true);
                    // confirmButton.setEnabled(true);
                    System.out.println("UI update complete, buttons re-enabled.");
                });
            }).start();

            // --- 6. Show the modal waiting dialog LAST in the EDT block ---
            // This call will block the EDT until waitingDialog.setVisible(false) is called from the thread.
            System.out.println("Showing waiting dialog (EDT block continues here).");
            waitingDialog.setLocationRelativeTo(addDialog); // Center relative to add dialog before showing
            waitingDialog.setVisible(true); // THIS IS THE CALL THAT BLOCKS THE EDT
            System.out.println("waiting dialog is now hidden (EDT unblocked)."); // This line prints after dialog is hidden by the thread
        });


        // Add Confirm button action listener (existing validation logic)
        confirmButton.addActionListener(e -> {
            String transactionTime = emptyIfNull(transactionTimeField.getText().trim());
            String finalTransactionType = emptyIfNull(transactionTypeField.getText().trim());
            String counterparty = emptyIfNull(counterpartyField.getText().trim());
            String commodity = emptyIfNull(commodityField.getText().trim());
            String inOut = (String) inOutComboBox.getSelectedItem();
            String paymentAmountText = paymentAmountField.getText().trim();
            String paymentMethod = emptyIfNull(paymentMethodField.getText().trim());
            String currentStatus = emptyIfNull(currentStatusField.getText().trim());
            String orderNumber = emptyIfNull(orderNumberField.getText().trim());
            String merchantNumber = emptyIfNull(merchantNumberField.getText().trim());
            String remarks = emptyIfNull(remarksField.getText().trim());

            // --- Input Validation ---
            if (orderNumber.isEmpty()) {
                JOptionPane.showMessageDialog(addDialog, "交易单号不能为空！", "输入错误", JOptionPane.ERROR_MESSAGE);
                return;
            }

            if (finalTransactionType.isEmpty()) {
                JOptionPane.showMessageDialog(addDialog, "交易类型不能为空！", "输入错误", JOptionPane.ERROR_MESSAGE);
                return;
            }
            // Validate against standard categories if strict input is desired from user too
            if (!StandardCategories.ALL_KNOWN_TYPES.contains(finalTransactionType)) {
                JOptionPane.showMessageDialog(addDialog, "交易类型必须是标准类别之一！\n允许的类别:\n" + StandardCategories.getAllCategoriesString(), "输入错误", JOptionPane.ERROR_MESSAGE);
                return; // Enforce standard categories for manual input
            }


            double paymentAmount = 0.0;
            if (!paymentAmountText.isEmpty()) {
                try {
                    paymentAmount = Double.parseDouble(paymentAmountText);
                    // Optional: Check for non-negative amount for expenses/income
                    if (paymentAmount < 0) {
                        JOptionPane.showMessageDialog(addDialog, "金额不能为负数！", "输入错误", JOptionPane.ERROR_MESSAGE);
                        return;
                    }
                } catch (NumberFormatException ex) {
                    JOptionPane.showMessageDialog(addDialog, "金额格式不正确！请输入数字。", "输入错误", JOptionPane.ERROR_MESSAGE);
                    return;
                }
            }
            // --- End Validation ---


            Transaction newTransaction = new Transaction(
                    transactionTime,
                    finalTransactionType, // Use the final value from the field (now validated to be standard)
                    counterparty,
                    commodity,
                    inOut,
                    paymentAmount,
                    paymentMethod,
                    currentStatus,
                    orderNumber,
                    merchantNumber,
                    remarks
            );

            // Order number uniqueness check is better in service layer before saving

            try {
                // Optional: Check for duplicate order number in service layer before adding
                // if (!transactionService.isOrderNumberUnique(orderNumber)) {
                //      JOptionPane.showMessageDialog(addDialog, "交易单号 '" + orderNumber + "' 已存在！", "输入错误", JOptionPane.ERROR_MESSAGE);
                //      return;
                // }

                transactionService.addTransaction(newTransaction);

                loadCSVDataForCurrentUser(""); // Load all data after adding
                clearSearchFields();

                addDialog.dispose();
                JOptionPane.showMessageDialog(null, "交易添加成功！", "提示", JOptionPane.INFORMATION_MESSAGE);

            } catch (IOException ex) {
                ex.printStackTrace();
                // Change ERROR_ERROR to ERROR_MESSAGE
                JOptionPane.showMessageDialog(null, "交易添加失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
            } catch (Exception ex) {
                ex.printStackTrace();
                // Change ERROR_ERROR to ERROR_MESSAGE
                JOptionPane.showMessageDialog(null, "交易添加失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
            }
        });

        cancelButton.addActionListener(e -> addDialog.dispose());

        // --- Dialog setup and showing ---
        addDialog.pack(); // Pack the dialog to fit its components
        addDialog.setLocationRelativeTo(this); // Center relative to the MenuUI panel
        addDialog.setVisible(true); // Show the add dialog (this is the initial blocking call for the add dialog itself)
        // --- End Dialog setup ---
    }


    // Method to edit row - updated for AI integration and getting data from table model
    public void editRow(int rowIndex) {
        System.out.println("编辑行: " + rowIndex + " for user " + currentUser.getUsername());
        // Define JDialog, JPanel, GridBagConstraints at the start
        JDialog editDialog = new JDialog();
        JPanel dialogPanel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();


        if (rowIndex >= 0 && rowIndex < this.tableModel.getRowCount()) {
            Vector<String> rowData = new Vector<>();
            for (int i = 0; i <= 10; i++) { // Columns 0 to 10 are Transaction fields
                Object value = this.tableModel.getValueAt(rowIndex, i);
                rowData.add(value != null ? value.toString() : "");
            }
            System.out.println("Retrieved row data from table model for editing: " + rowData);

            String originalOrderNumber = rowData.get(8).trim();
            if (originalOrderNumber.isEmpty()) {
                JOptionPane.showMessageDialog(null, "无法编辑：交易单号为空！", "错误", JOptionPane.ERROR_MESSAGE);
                System.err.println("Attempted to edit row " + rowIndex + " but order number is empty.");
                // editDialog remains undefined here if this happens, might crash later if used.
                // Return immediately
                return;
            }


            editDialog.setTitle("修改交易信息 (订单号: " + originalOrderNumber + ")");
            editDialog.setModal(true);

            gbc.fill = GridBagConstraints.HORIZONTAL;
            gbc.insets = new Insets(5, 5, 5, 5);

            JTextField[] fields = new JTextField[11];
            String[] fieldNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"};
            JButton aiSuggestButton = new JButton("AI分类建议");


            for (int i = 0; i < fieldNames.length; i++) {
                gbc.gridx = 0; gbc.gridy = i; gbc.gridwidth = 1; gbc.weightx = 0.0; dialogPanel.add(new JLabel(fieldNames[i] + ":"), gbc);
                fields[i] = new JTextField(rowData.get(i));
                if (i == 1) { // Transaction Type field
                    gbc.gridx = 1; gbc.gridy = i; gbc.weightx = 1.0; dialogPanel.add(fields[i], gbc);
                    gbc.gridx = 2; gbc.gridy = i; gbc.weightx = 0.0; dialogPanel.add(aiSuggestButton, gbc);
                    gbc.gridwidth = 1;
                } else {
                    gbc.gridx = 1; gbc.gridy = i; gbc.gridwidth = 2; gbc.weightx = 1.0; dialogPanel.add(fields[i], gbc);
                    gbc.gridwidth = 1;
                }
            }

            fields[8].setEditable(false); // Disable editing OrderNumber field


            // --- Define the modal waiting dialog ---
            JDialog waitingDialog = new JDialog(editDialog, "请稍候", true); // Modal dialog owned by editDialog
            waitingDialog.setLayout(new FlowLayout());
            waitingDialog.add(new JLabel("正在获取AI分类建议..."));
            waitingDialog.setSize(200, 100);
            waitingDialog.setResizable(false);
            // waitingDialog.setLocationRelativeTo(editDialog); // Set location later before showing
            // --- End waiting dialog definition ---


            // Add Confirm and Cancel buttons
            JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
            JButton confirmButton = new JButton("确认");
            JButton cancelButton = new JButton("取消");
            buttonPanel.add(confirmButton);
            buttonPanel.add(cancelButton);

            gbc.gridx = 0; gbc.gridy = fieldNames.length; gbc.gridwidth = 3; gbc.anchor = GridBagConstraints.CENTER; gbc.fill = GridBagConstraints.NONE; dialogPanel.add(buttonPanel, gbc);


            editDialog.add(dialogPanel, BorderLayout.CENTER);


            // Add AI Suggest button action listener - MODIFIED LOGIC FLOW
            aiSuggestButton.addActionListener(e -> {
                System.out.println("AI Suggest button clicked (EDT) in edit dialog.");
                // 1. Disable button immediately on EDT
                aiSuggestButton.setEnabled(false);
                // confirmButton.setEnabled(false); // Optional: also disable confirm

                // 2. Build temporary transaction object from current fields
                Transaction tempTransaction = new Transaction(
                        fields[0].getText().trim(), fields[1].getText().trim(), fields[2].getText().trim(),
                        fields[3].getText().trim(), fields[4].getText().trim(), safeParseDouble(fields[5].getText().trim()),
                        fields[6].getText().trim(), fields[7].getText().trim(), fields[8].getText().trim(),
                        fields[9].getText().trim(), fields[10].getText().trim()
                );

                // 3. Create and start the background thread FIRST
                new Thread(() -> {
                    System.out.println("Background thread started for AI classification (edit dialog)...");
                    String aiSuggestion = null;
                    try {
                        // Simulate delay for testing thread behavior
                        // Thread.sleep(3000); // Uncomment to simulate a 3-second delay
                        aiSuggestion = collegeStudentNeeds.RecognizeTransaction(tempTransaction);
                        System.out.println("AI Classification returned in background thread (edit dialog): " + aiSuggestion);
                    } catch (Exception ex) {
                        System.err.println("Error in background AI thread (edit dialog): " + ex.getMessage());
                        ex.printStackTrace();
                        aiSuggestion = "Error: " + ex.getMessage(); // Capture error to display later
                    }


                    // 4. Schedule the UI update and dialog hiding on the EDT from the background thread
                    String finalSuggestion = aiSuggestion; // Need a final variable for use in lambda
                    SwingUtilities.invokeLater(() -> {
                        System.out.println("Updating UI on EDT from background thread (edit dialog).");
                        // --- Hide waiting dialog ---
                        waitingDialog.setVisible(false); // This is the call that unblocks the initial setVisible(true)

                        // --- Display AI suggestion ---
                        if (finalSuggestion != null && !finalSuggestion.isEmpty() && !finalSuggestion.startsWith("Error:")) {
                            // Safety Check: Although prompt asks for standard, AI might deviate.
                            if (StandardCategories.ALL_KNOWN_TYPES.contains(finalSuggestion.trim())) {
                                fields[1].setText(finalSuggestion.trim());
                            } else {
                                System.err.println("AI returned non-standard category despite prompt: " + finalSuggestion);
                                // Handle non-standard: Warn and clear/set to default
                                JOptionPane.showMessageDialog(editDialog, "AI返回了非预期的分类格式：\n" + finalSuggestion + "\n请手动输入。", "AI结果异常", JOptionPane.WARNING_MESSAGE);
                                fields[1].setText("");
                            }
                        } else if (finalSuggestion != null && finalSuggestion.startsWith("Error:")) {
                            // Handle the error case
                            JOptionPane.showMessageDialog(editDialog, "获取AI分类建议失败！\n" + finalSuggestion.substring(6), "AI错误", JOptionPane.ERROR_MESSAGE);
                            fields[1].setText("");
                        }
                        else { // AI returned null or empty
                            JOptionPane.showMessageDialog(editDialog, "AI未能提供分类建议。", "AI提示", JOptionPane.INFORMATION_MESSAGE);
                            fields[1].setText("");
                        }

                        // 5. Re-enable buttons on EDT
                        aiSuggestButton.setEnabled(true);
                        // confirmButton.setEnabled(true);
                        System.out.println("UI update complete, buttons re-enabled (edit dialog).");
                    });
                }).start();

                // --- 6. Show the modal waiting dialog LAST in the EDT block ---
                // This call will block the EDT until waitingDialog.setVisible(false) is called from the thread.
                System.out.println("Showing waiting dialog (EDT block continues here in edit dialog).");
                waitingDialog.setLocationRelativeTo(editDialog); // Center relative to edit dialog before showing
                waitingDialog.setVisible(true); // THIS IS THE CALL THAT BLOCKS THE EDT
                System.out.println("waiting dialog is now hidden (EDT unblocked in edit dialog)."); // This line prints after dialog is hidden by the thread
            });


            // Add Confirm and Cancel button listeners
            confirmButton.addActionListener(e -> {
                String transactionTime = fields[0].getText().trim();
                String finalTransactionType = fields[1].getText().trim();
                String counterparty = fields[2].getText().trim();
                String commodity = fields[3].getText().trim();
                String inOut = fields[4].getText().trim();
                String paymentAmountText = fields[5].getText().trim();
                String paymentMethod = fields[6].getText().trim();
                String currentStatus = fields[7].getText().trim();
                // Original ON is used from the variable 'originalOrderNumber' defined outside this listener
                String merchantNumber = fields[9].getText().trim();
                String remarks = fields[10].getText().trim();

                // --- Input Validation ---
                if (finalTransactionType.isEmpty()) {
                    JOptionPane.showMessageDialog(editDialog, "交易类型不能为空！", "输入错误", JOptionPane.ERROR_MESSAGE);
                    return;
                }
                // Validate against standard categories
                if (!StandardCategories.ALL_KNOWN_TYPES.contains(finalTransactionType)) {
                    JOptionPane.showMessageDialog(editDialog, "交易类型必须是标准类别之一！\n允许的类别:\n" + StandardCategories.getAllCategoriesString(), "输入错误", JOptionPane.ERROR_MESSAGE);
                    return; // Enforce standard categories for manual input
                }
                // Validate 收/支 is one of expected values
                if (!inOut.equals("收入") && !inOut.equals("支出") && !inOut.equals("收") && !inOut.equals("支")) {
                    JOptionPane.showMessageDialog(editDialog, "收/支字段必须是 '收入' 或 '支出'。", "输入错误", JOptionPane.ERROR_MESSAGE);
                    return;
                }

                double paymentAmount = 0.0;
                if (!paymentAmountText.isEmpty()) {
                    try {
                        paymentAmount = Double.parseDouble(paymentAmountText);
                        if (paymentAmount < 0) {
                            JOptionPane.showMessageDialog(editDialog, "金额不能为负数！", "输入错误", JOptionPane.ERROR_MESSAGE);
                            return;
                        }
                    } catch (NumberFormatException ex) {
                        JOptionPane.showMessageDialog(editDialog, "金额格式不正确！请输入数字。", "输入错误", JOptionPane.ERROR_MESSAGE);
                        return;
                    }
                }
                // --- End Validation ---


                Transaction updatedTransaction = new Transaction(
                        transactionTime, finalTransactionType, counterparty, commodity, inOut,
                        paymentAmount, paymentMethod, currentStatus, originalOrderNumber, // Use the correct originalOrderNumber
                        merchantNumber, remarks
                );


                try {
                    transactionService.changeTransaction(updatedTransaction);
                    System.out.println("Edit successful. Preparing to refresh display filtered by InOut: " + updatedTransaction.getInOut());
                    clearSearchFields();
                    String updatedInOut = updatedTransaction.getInOut();
                    boolean foundInOut = false;
                    for(int i=0; i < searchInOutComboBox.getItemCount(); i++) {
                        if (updatedInOut != null && updatedInOut.equals(searchInOutComboBox.getItemAt(i))) {
                            searchInOutComboBox.setSelectedItem(updatedInOut);
                            foundInOut = true;
                            break;
                        }
                    }
                    if (!foundInOut) { searchInOutComboBox.setSelectedItem(""); }

                    triggerCurrentSearch();

                    editDialog.dispose();
                    JOptionPane.showMessageDialog(null, "修改成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                    System.out.println("Edited row " + rowIndex + " for order number " + originalOrderNumber + " and refreshed display.");

                } catch (IllegalArgumentException ex) {
                    JOptionPane.showMessageDialog(editDialog, "修改失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
                    ex.printStackTrace();
                } catch (Exception ex) {
                    ex.printStackTrace();
                    // Change ERROR_ERROR to ERROR_MESSAGE
                    JOptionPane.showMessageDialog(editDialog, "修改失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
                }
            });

            cancelButton.addActionListener(e -> editDialog.dispose());

            // --- Dialog setup and showing ---
            editDialog.pack();
            editDialog.setLocationRelativeTo(this);
            editDialog.setVisible(true); // Show the edit dialog (this is the initial blocking call for the edit dialog itself)
            // --- End Dialog setup ---

        } else {
            // This block is for invalid rowIndex. The dialog shouldn't be shown.
            // Remove the confusing editDialog.pack/setLocation/setVisible calls here.
            System.err.println("Attempted to edit row with invalid index: " + rowIndex + ". Table row count: " + this.tableModel.getRowCount());
        }
        // Remove the final redundant pack/setLocation/setVisible calls outside the if block
        // if (editDialog != null) { editDialog.pack(); }
        // if (editDialog != null) { editDialog.setLocationRelativeTo(this); }
        // if (editDialog != null) { editDialog.setVisible(true); } // Redundant if dialog shown in the if block
    }

    // Method to create the AI panel - UPDATED
    private JPanel createAIPanel() {
        JPanel panel = new JPanel(new BorderLayout(10, 10));
        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // Panel for General AI Analysis
        JPanel generalAnalysisPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));
        JTextField userRequestField = new JTextField(40);
        aiStartTimeField = new JTextField(10);
        aiEndTimeField = new JTextField(10);
        aiAnalyzeButton = new JButton("通用分析 (按原始数据)"); // Clarify this uses raw data


        generalAnalysisPanel.add(new JLabel("通用分析要求:"));
        generalAnalysisPanel.add(userRequestField);
        generalAnalysisPanel.add(new JLabel("时间范围 (yyyy/MM/dd HH:mm): 从:"));
        generalAnalysisPanel.add(aiStartTimeField);
        generalAnalysisPanel.add(new JLabel("到:"));
        generalAnalysisPanel.add(aiEndTimeField);
        generalAnalysisPanel.add(aiAnalyzeButton);


        // Panel for Summary-Based AI Analysis (NEW)
        JPanel summaryAnalysisPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));
        aiPersonalSummaryButton = new JButton("个人消费总结"); // New button
        aiSavingsGoalsButton = new JButton("储蓄目标建议"); // New button
        aiPersonalSavingTipsButton = new JButton("个性化节约建议"); // New button

        summaryAnalysisPanel.add(new JLabel("基于月度总结分析:"));
        summaryAnalysisPanel.add(aiPersonalSummaryButton);
        summaryAnalysisPanel.add(aiSavingsGoalsButton);
        summaryAnalysisPanel.add(aiPersonalSavingTipsButton);


        // Panel for College Student Needs buttons (existing)
        JPanel csButtonsPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10)); // Align left for consistency
        aiBudgetButton = new JButton("预算建议 (学生)"); // Clarify this is student-specific
        aiTipsButton = new JButton("省钱技巧 (学生)"); // Clarify this is student-specific
        csButtonsPanel.add(new JLabel("大学生专属功能:"));
        csButtonsPanel.add(aiBudgetButton);
        csButtonsPanel.add(aiTipsButton);


        // Combine all control panels in a box layout
        JPanel topControlPanel = new JPanel();
        topControlPanel.setLayout(new BoxLayout(topControlPanel, BoxLayout.Y_AXIS));
        topControlPanel.add(generalAnalysisPanel);
        topControlPanel.add(Box.createRigidArea(new Dimension(0, 10))); // Spacing
        topControlPanel.add(summaryAnalysisPanel); // Add new panel
        topControlPanel.add(Box.createRigidArea(new Dimension(0, 10))); // Spacing
        topControlPanel.add(csButtonsPanel); // Add existing CS panel
        topControlPanel.add(Box.createRigidArea(new Dimension(0, 10))); // Spacing


        panel.add(topControlPanel, BorderLayout.NORTH);

        // Center area for displaying AI results - same as before
        aiResultArea = new JTextArea();
        aiResultArea.setFont(new Font("微软雅黑", Font.PLAIN, 14));
        aiResultArea.setLineWrap(true);
        aiResultArea.setWrapStyleWord(true);
        aiResultArea.setEditable(false);
        aiResultArea.setText("欢迎使用AI个人财务分析功能。\n\n" +
                "您可以尝试以下操作：\n" +
                "1. 在上方输入框提出通用分析要求（基于原始数据，可指定时间范围），点击\"通用分析\"。\n" +
                "2. 点击\"个人消费总结\"，获取基于您月度收支汇总的详细总结。\n" +
                "3. 点击\"储蓄目标建议\"，获取基于您收支情况的储蓄建议。\n" +
                "4. 点击\"个性化节约建议\"，获取基于您消费类别的节约建议。\n" +
                "5. 大学生用户可点击\"预算建议\"和\"省钱技巧\"获取专属建议。\n");


        JScrollPane resultScrollPane = new JScrollPane(aiResultArea);
        panel.add(resultScrollPane, BorderLayout.CENTER);


        // --- Add Action Listeners for NEW Buttons ---

        aiPersonalSummaryButton.addActionListener(e -> {
            aiResultArea.setText("--- 个人消费总结生成中 ---\n\n正在根据您的月度消费数据生成总结，请稍候...\n");
            setAIButtonsEnabled(false);

            new Thread(() -> {
                String result = aiTransactionService.generatePersonalSummary(currentUser.getTransactionFilePath()); // Call the new method

                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- 个人消费总结 ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        aiSavingsGoalsButton.addActionListener(e -> {
            aiResultArea.setText("--- 储蓄目标建议生成中 ---\n\n正在根据您的收支情况生成储蓄目标建议，请稍候...\n");
            setAIButtonsEnabled(false);

            new Thread(() -> {
                String result = aiTransactionService.suggestSavingsGoals(currentUser.getTransactionFilePath()); // Call the new method

                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- 储蓄目标建议 ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        aiPersonalSavingTipsButton.addActionListener(e -> {
            aiResultArea.setText("--- 个性化节约建议生成中 ---\n\n正在根据您的消费类别生成节约建议，请稍候...\n");
            setAIButtonsEnabled(false);

            new Thread(() -> {
                String result = aiTransactionService.givePersonalSavingTips(currentUser.getTransactionFilePath()); // Call the new method

                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- 个性化节约建议 ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });


        // --- Action Listeners for EXISTING Buttons (UPDATE PROMPTS/HEADERS) ---
        // Update existing listeners to use better headers/messages

        // General Analyze Button
        aiAnalyzeButton.addActionListener(e -> {
            String userRequest = userRequestField.getText().trim();
            String startTimeStr = aiStartTimeField.getText().trim();
            String endTimeStr = aiEndTimeField.getText().trim();

            if (userRequest.isEmpty()) {
                JOptionPane.showMessageDialog(this, "请输入AI通用分析要求。", "输入提示", JOptionPane.INFORMATION_MESSAGE);
                return;
            }
            if (startTimeStr.isEmpty() && !endTimeStr.isEmpty()) {
                JOptionPane.showMessageDialog(this, "请至少输入分析的开始时间。", "输入提示", JOptionPane.INFORMATION_MESSAGE);
                return;
            }


            aiResultArea.setText("--- 通用分析生成中 ---\n\n" + "正在进行AI通用分析，请稍候...\n");
            setAIButtonsEnabled(false);


            new Thread(() -> {
                String result = aiTransactionService.analyzeTransactions(userRequest, currentUser.getTransactionFilePath(), startTimeStr, endTimeStr);

                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- 通用分析结果 ---\n\n" + result);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        // College Student Budget Button
        aiBudgetButton.addActionListener(e -> {
            aiResultArea.setText("--- 大学生预算建议生成中 ---\n\n正在根据您的历史支出生成预算建议，请稍候...\n");
            setAIButtonsEnabled(false);

            new Thread(() -> {
                String resultMessage;
                try {
                    double[] budgetRange = collegeStudentNeeds.generateBudget(currentUser.getTransactionFilePath());
                    if (budgetRange != null && budgetRange.length == 2 && budgetRange[0] != -1) {
                        resultMessage = String.format("根据您的消费记录，下周的建议预算范围是: [%.2f元, %.2f元]", budgetRange[0], budgetRange[1]);
                    } else if (budgetRange != null && budgetRange.length == 2 && budgetRange[0] == -1) {
                        resultMessage = "暂无足够的消费记录来计算周预算建议。";
                    }
                    else {
                        resultMessage = "生成预算建议失败，AI未能返回有效范围。";
                        System.err.println("AI Budget generation failed, invalid response format.");
                    }
                } catch (Exception ex) {
                    resultMessage = "生成预算建议失败！\n" + ex.getMessage();
                    System.err.println("Error generating AI budget:");
                    ex.printStackTrace();
                }

                String finalResultMessage = resultMessage;
                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- 大学生预算建议 ---\n\n" + finalResultMessage);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });

        // College Student Tips Button
        aiTipsButton.addActionListener(e -> {
            aiResultArea.setText("--- 大学生省钱技巧生成中 ---\n\n正在生成省钱技巧，请稍候...\n");
            setAIButtonsEnabled(false);

            new Thread(() -> {
                String resultMessage;
                try {
                    // Call the CollegeStudentNeeds method (now uses monthly summary)
                    resultMessage = collegeStudentNeeds.generateTipsForSaving(currentUser.getTransactionFilePath());

                } catch (Exception ex) {
                    resultMessage = "生成省钱技巧失败！\n" + ex.getMessage();
                    System.err.println("Error generating AI tips:");
                    ex.printStackTrace();
                }

                String finalResultMessage = resultMessage;
                SwingUtilities.invokeLater(() -> {
                    aiResultArea.setText("--- 大学生省钱技巧 ---\n\n" + finalResultMessage);
                    setAIButtonsEnabled(true);
                });
            }).start();
        });


        return panel;
    }

    // Helper method to enable/disable all AI related buttons - UPDATED
    private void setAIButtonsEnabled(boolean enabled) {
        if (aiAnalyzeButton != null) aiAnalyzeButton.setEnabled(enabled);
        if (aiBudgetButton != null) aiBudgetButton.setEnabled(enabled);
        if (aiTipsButton != null) aiTipsButton.setEnabled(enabled);
        // Enable/disable new buttons
        if (aiPersonalSummaryButton != null) aiPersonalSummaryButton.setEnabled(enabled);
        if (aiSavingsGoalsButton != null) aiSavingsGoalsButton.setEnabled(enabled);
        if (aiPersonalSavingTipsButton != null) aiPersonalSavingTipsButton.setEnabled(enabled);
    }


    // Method to create the Admin Stats panel (Implement the placeholder)
    private JPanel createAdminStatsPanel() {
        JPanel panel = new JPanel(new BorderLayout(10, 10));
        panel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        generateStatsButton = new JButton("生成/更新统计数据"); // Assign to instance field
        refreshDisplayButton = new JButton("刷新显示"); // Assign to instance field

        controlPanel.add(generateStatsButton);
        controlPanel.add(refreshDisplayButton);

        panel.add(controlPanel, BorderLayout.NORTH);

        adminStatsArea = new JTextArea(); // Assign to instance field
        adminStatsArea.setFont(new Font("微软雅黑", Font.PLAIN, 14));
        adminStatsArea.setEditable(false);
        adminStatsArea.setLineWrap(true); // Enable line wrapping
        adminStatsArea.setWrapStyleWord(true); // Wrap at word boundaries
        JScrollPane scrollPane = new JScrollPane(adminStatsArea);
        panel.add(scrollPane, BorderLayout.CENTER);


        generateStatsButton.addActionListener(e -> {
            adminStatsArea.setText("正在生成/更新汇总统计数据，请稍候...\n");
            generateStatsButton.setEnabled(false);
            refreshDisplayButton.setEnabled(false);

            new Thread(() -> {
                String message;
                try {
                    // Use the injected SummaryStatisticService
                    summaryStatisticService.generateAndSaveWeeklyStatistics();
                    message = "汇总统计数据生成/更新成功！\n请点击 '刷新显示' 查看最新数据。";
                    System.out.println(message);
                } catch (Exception ex) {
                    message = "汇总统计数据生成/更新失败！\n" + ex.getMessage();
                    System.err.println(message);
                    ex.printStackTrace();
                }

                String finalMessage = message;
                SwingUtilities.invokeLater(() -> {
                    adminStatsArea.setText(finalMessage);
                    generateStatsButton.setEnabled(true);
                    refreshDisplayButton.setEnabled(true);
                });
            }).start();
        });

        refreshDisplayButton.addActionListener(e -> {
            displaySummaryStatistics();
        });

        // Initial display when the panel is first shown (Optional)
        // Load existing stats when the panel is created, before it's potentially shown
        // This avoids a blank screen initially.
        new Thread(() -> {
            SwingUtilities.invokeLater(() -> adminStatsArea.setText("正在加载现有统计数据...\n"));
            try {
                List<SummaryStatistic> initialStats = summaryStatisticService.getAllSummaryStatistics();
                if (!initialStats.isEmpty()) {
                    // If initial stats exist, display them
                    SwingUtilities.invokeLater(this::displaySummaryStatistics);
                } else {
                    SwingUtilities.invokeLater(() -> adminStatsArea.setText("没有找到现有的汇总统计数据。\n请点击 '生成/更新统计数据' 按钮来生成。"));
                }
            } catch (IOException ex) {
                SwingUtilities.invokeLater(() -> adminStatsArea.setText("加载现有统计数据失败！\n" + ex.getMessage()));
                ex.printStackTrace();
            }
        }).start();


        return panel;
    }

    // Method to display summary statistics (Implement the placeholder)
    private void displaySummaryStatistics() {
        adminStatsArea.setText("正在加载汇总统计数据...\n");
        // Optional: Disable buttons while loading
        if(generateStatsButton != null) generateStatsButton.setEnabled(false);
        if(refreshDisplayButton != null) refreshDisplayButton.setEnabled(false);


        new Thread(() -> {
            String displayContent;
            try {
                List<SummaryStatistic> stats = summaryStatisticService.getAllSummaryStatistics();
                if (stats.isEmpty()) {
                    displayContent = "目前没有汇总统计数据。\n请先点击 '生成/更新统计数据' 按钮。";
                } else {
                    StringBuilder sb = new StringBuilder("===== 汇总统计数据 =====\n\n");
                    // Sort stats by week identifier (chronologically) before displaying
                    stats.sort(Comparator.comparing(SummaryStatistic::getWeekIdentifier));

                    // Display newest week first
                    for (int i = stats.size() - 1; i >= 0; i--) {
                        SummaryStatistic stat = stats.get(i);
                        sb.append("周标识: ").append(stat.getWeekIdentifier()).append("\n");
                        sb.append("  总收入: ").append(String.format("%.2f", stat.getTotalIncomeAllUsers())).append("元\n");
                        sb.append("  总支出: ").append(String.format("%.2f", stat.getTotalExpenseAllUsers())).append("元\n");
                        // Only show top category if there was actual expense in that category
                        if (stat.getTopExpenseCategoryAmount() > 0) {
                            sb.append("  最高支出类别: ").append(stat.getTopExpenseCategory()).append(" (").append(String.format("%.2f", stat.getTopExpenseCategoryAmount())).append("元)\n");
                        } else {
                            sb.append("  最高支出类别: 无显著支出类别\n"); // Or "无支出" if total expense is 0
                        }

                        sb.append("  参与用户数: ").append(stat.getNumberOfUsersWithTransactions()).append("\n");
                        sb.append("  生成时间: ").append(stat.getTimestampGenerated()).append("\n");
                        sb.append("--------------------\n");
                    }
                    displayContent = sb.toString();
                }
            } catch (IOException ex) {
                displayContent = "加载汇总统计数据失败！\n" + ex.getMessage();
                ex.printStackTrace();
            }

            String finalDisplayContent = displayContent;
            SwingUtilities.invokeLater(() -> {
                adminStatsArea.setText(finalDisplayContent);
                // Re-enable buttons
                if(generateStatsButton != null) generateStatsButton.setEnabled(true);
                if(refreshDisplayButton != null) refreshDisplayButton.setEnabled(true);
            });
        }).start();
    }

    // Method to delete row - get data from tableModel (remove allData usage)
    public void deleteRow(int rowIndex) {
        System.out.println("尝试删除行: " + rowIndex + " for user " + currentUser.getUsername());
        if (rowIndex >= 0 && rowIndex < this.tableModel.getRowCount()) { // Use tableModel row count

            // Get the order number directly from the displayed table row
            String orderNumber = (String) this.tableModel.getValueAt(rowIndex, 8); // OrderNumber is at index 8
            if (orderNumber == null || orderNumber.trim().isEmpty()) {
                JOptionPane.showMessageDialog(null, "无法删除：交易单号为空！", "错误", JOptionPane.ERROR_MESSAGE);
                System.err.println("Attempted to delete row " + rowIndex + " but order number is null or empty.");
                return; // Cannot delete without an order number
            }
            orderNumber = orderNumber.trim();
            System.out.println("Deleting transaction with order number: " + orderNumber);

            // Optional: Ask for confirmation before deleting
            int confirm = JOptionPane.showConfirmDialog(
                    this, // Parent component
                    "确定要删除订单号为 '" + orderNumber + "' 的交易吗？",
                    "确认删除",
                    JOptionPane.YES_NO_OPTION,
                    JOptionPane.QUESTION_MESSAGE
            );

            if (confirm == JOptionPane.YES_OPTION) {
                try {
                    // Use the injected transactionService instance
                    boolean deleted = transactionService.deleteTransaction(orderNumber);

                    if (deleted) {
                        // Data is removed from CSV and cache invalidated by service.
                        // Update the UI model directly by removing the row.
                        // This is faster than reloading all data for just one deletion.
                        this.tableModel.removeRow(rowIndex);

                        JOptionPane.showMessageDialog(null, "删除成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                        System.out.println("Deleted row " + rowIndex + " with order number " + orderNumber + " from UI.");

                        // After delete, refresh the view by re-applying the current search/filter criteria.
                        triggerCurrentSearch();

                    } else {
                        // This case means the service said it wasn't deleted (likely not found)
                        // This might happen if the underlying data changed between loading and deleting
                        JOptionPane.showMessageDialog(null, "删除失败：未找到对应的交易单号 " + orderNumber, "错误", JOptionPane.ERROR_MESSAGE);
                        System.err.println("Delete failed: order number " + orderNumber + " not found by service.");
                    }
                } catch (Exception ex) {
                    ex.printStackTrace();
                    JOptionPane.showMessageDialog(null, "删除失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
                    System.err.println("Error during deletion for order number " + orderNumber);
                }
            } else {
                System.out.println("Deletion cancelled by user for order number: " + orderNumber);
            }
        } else {
            System.err.println("Attempted to delete row with invalid index: " + rowIndex + ". Table row count: " + this.tableModel.getRowCount());
        }
    }

    // Method to create table row from Transaction object - no changes needed here
    private Vector<String> createRowFromTransaction(Transaction transaction) {
        Vector<String> row = new Vector<>();
        row.add(emptyIfNull(transaction.getTransactionTime()));
        row.add(emptyIfNull(transaction.getTransactionType()));
        row.add(emptyIfNull(transaction.getCounterparty()));
        row.add(emptyIfNull(transaction.getCommodity()));
        row.add(emptyIfNull(transaction.getInOut()));
        row.add(String.valueOf(transaction.getPaymentAmount()));
        row.add(emptyIfNull(transaction.getPaymentMethod()));
        row.add(emptyIfNull(transaction.getCurrentStatus()));
        row.add(emptyIfNull(transaction.getOrderNumber()));
        row.add(emptyIfNull(transaction.getMerchantNumber()));
        row.add(emptyIfNull(transaction.getRemarks()));
        row.add("Modify");
        row.add("Delete");
        return row;
    }

    // Method to search data - same as before
    public void searchData(String query1, String query2, String query3, String query4, String query6, String query5) {
        // ... existing implementation ...
        System.out.println("Searching with criteria: time='" + query1 + "', type='" + query2 + "', counterparty='" + query3 + "', commodity='" + query4 + "', inOut='" + query6 + "', paymentMethod='" + query5 + "'");
        this.tableModel.setRowCount(0);

        Transaction searchCriteria = new Transaction(
                query1, query2, query3, query4, query6,
                0,
                query5,
                "", "", "", ""
        );

        try {
            List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);
            System.out.println("Search results count: " + transactions.size());
            for (Transaction transaction : transactions) {
                Vector<String> row = createRowFromTransaction(transaction);
                this.tableModel.addRow(row);
            }

        } catch (Exception ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(null, "查询失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
        }
    }


    // ... safeParseDouble, clearSearchFields, triggerCurrentSearch, emptyIfNull, getTable methods ...
    private double safeParseDouble(String value) {
        if (value == null || value.trim().isEmpty()) return 0.0;
        try { return Double.parseDouble(value.trim()); }
        catch (NumberFormatException e) { System.err.println("Failed to parse double from string: '" + value + "'"); return 0.0; }
    }
    private void clearSearchFields() {
        searchTransactionTimeField.setText("");
        searchTransactionTypeField.setText("");
        searchCounterpartyField.setText("");
        searchCommodityField.setText("");
        searchInOutComboBox.setSelectedItem("");
        searchPaymentMethodField.setText("");
        System.out.println("Cleared search fields.");
    }
    private void triggerCurrentSearch() {
        searchData(
                searchTransactionTimeField.getText().trim(),
                searchTransactionTypeField.getText().trim(),
                searchCounterpartyField.getText().trim(),
                searchCommodityField.getText().trim(),
                (String) searchInOutComboBox.getSelectedItem(),
                searchPaymentMethodField.getText().trim()
        );
        System.out.println("Triggered search with current field values.");
    }
    private String emptyIfNull(String value) {
        return value == null ? "" : value;
    }
    public JTable getTable() {
        return table;
    }

}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Controller\VisualizationPanel.java`:

```java
package Controller;

import Service.TransactionService;
import model.MonthlySummary;

import java.awt.*;
import java.util.Map;
import java.util.List; // Import List
import java.util.ArrayList; // Import ArrayList
import java.util.HashMap; // Import HashMap
import java.util.Collections; // Import Collections for sorting
import java.util.Comparator; // Import Comparator

import javax.swing.*;

// Import XChart classes
import org.knowm.xchart.CategoryChart;
import org.knowm.xchart.CategoryChartBuilder;
import org.knowm.xchart.PieChart;
import org.knowm.xchart.PieChartBuilder;
import org.knowm.xchart.SwingWrapper; // Might be needed for Swing components
import org.knowm.xchart.XChartPanel; // Use XChartPanel for Swing display
import org.knowm.xchart.style.Styler.LegendPosition; // For chart styling


/**
 * Panel to display transaction data visualizations using XChart.
 */
public class VisualizationPanel extends JPanel {

    private final TransactionService transactionService;

    private JComboBox<String> monthSelector;
    private JComboBox<String> chartTypeSelector;
    private JButton generateChartButton;
    private JPanel chartDisplayPanel;


    /**
     * Constructor to inject the TransactionService.
     * @param transactionService The service to retrieve user transaction data.
     */
    public VisualizationPanel(TransactionService transactionService) {
        this.transactionService = transactionService;
        setLayout(new BorderLayout(10, 10));
        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // --- Control Panel (Top) ---
        JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 5));

        chartTypeSelector = new JComboBox<>(new String[]{"请选择图表类型", "月度支出分类饼图", "月度收支趋势柱状图"});
        controlPanel.add(new JLabel("图表类型:"));
        controlPanel.add(chartTypeSelector);

        monthSelector = new JComboBox<>();
        monthSelector.setEnabled(false);
        controlPanel.add(new JLabel("选择月份:"));
        controlPanel.add(monthSelector);


        generateChartButton = new JButton("生成图表");
        controlPanel.add(generateChartButton);

        add(controlPanel, BorderLayout.NORTH);


        // --- Chart Display Panel (Center) ---
        chartDisplayPanel = new JPanel(new BorderLayout());
        chartDisplayPanel.setBackground(Color.WHITE);
        add(chartDisplayPanel, BorderLayout.CENTER);


        // --- Action Listeners ---
        chartTypeSelector.addActionListener(e -> {
            String selectedType = (String) chartTypeSelector.getSelectedItem();
            boolean needsMonth = "月度支出分类饼图".equals(selectedType);
            monthSelector.setEnabled(needsMonth);
            // Populate months only when Pie Chart is selected
            if (needsMonth) {
                populateMonthSelector();
            } else {
                monthSelector.removeAllItems(); // Clear months if not needed
                monthSelector.addItem("请选择月份"); // Add default item back
            }
        });

        generateChartButton.addActionListener(e -> {
            generateAndDisplayChart();
        });

        // Initial state display
        displayPlaceholderChart("请选择一种图表类型和必要参数来生成图表。");

        // Initial data loading if needed on panel creation - Let's load months when Pie Chart is selected
        // populateMonthSelector(); // Removed, triggered by chart type selection
    }

    /**
     * Populates the month selector combo box with months from available data.
     */
    private void populateMonthSelector() {
        monthSelector.removeAllItems();
        monthSelector.addItem("请选择月份");

        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            if (summaries != null && !summaries.isEmpty()) {
                // Sort month identifiers chronologically
                summaries.keySet().stream().sorted().forEach(monthSelector::addItem);
                // monthSelector.setEnabled(true); // Enabled by chartTypeSelector listener
            } else {
                // monthSelector.setEnabled(false); // Disabled by chartTypeSelector listener
                JOptionPane.showMessageDialog(this, "没有找到月度交易数据来生成图表。", "数据不足", JOptionPane.INFORMATION_MESSAGE);
            }
        } catch (Exception e) {
            System.err.println("Error loading monthly summaries for month selector: " + e.getMessage());
            // monthSelector.setEnabled(false); // Disabled by chartTypeSelector listener
            JOptionPane.showMessageDialog(this, "加载月份数据失败！\n" + e.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
        }
    }


    /**
     * Generates and displays the selected chart based on user selection using XChart.
     */
    private void generateAndDisplayChart() {
        String selectedChartType = (String) chartTypeSelector.getSelectedItem();
        String selectedMonth = (String) monthSelector.getSelectedItem();

        // Clear previous chart
        chartDisplayPanel.removeAll();
        chartDisplayPanel.revalidate();
        chartDisplayPanel.repaint();

        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            if (summaries == null || summaries.isEmpty()) {
                displayPlaceholderChart("没有找到月度交易数据来生成图表。");
                return;
            }

            if ("月度支出分类饼图".equals(selectedChartType)) {
                if (selectedMonth == null || selectedMonth.equals("请选择月份") || selectedMonth.trim().isEmpty()) {
                    JOptionPane.showMessageDialog(this, "请选择要查看的月份。", "提示", JOptionPane.INFORMATION_MESSAGE);
                    displayPlaceholderChart("请选择一个有效的月份来生成饼图。");
                    return;
                }
                // --- Generate Pie Chart ---
                MonthlySummary selectedMonthSummary = summaries.get(selectedMonth);
                if (selectedMonthSummary == null || selectedMonthSummary.getExpenseByCategory().isEmpty()) {
                    displayPlaceholderChart(selectedMonth + " 月没有支出分类数据。");
                    return;
                }

                System.out.println("Generating Pie Chart for " + selectedMonth + "...");
                PieChart chart = new PieChartBuilder()
                        .width(chartDisplayPanel.getWidth())
                        .height(chartDisplayPanel.getHeight())
                        .title(selectedMonth + " 月支出分类")
                        .build();

                selectedMonthSummary.getExpenseByCategory().entrySet().stream()
                        .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                        .forEach(entry -> chart.addSeries(entry.getKey(), entry.getValue()));

                // Customize chart style (optional - COMMENT OUT lines causing errors)
                // chart.getStyler().setLegendVisible(true); // Keep if it works
                // chart.getStyler().setAnnotationType(org.knowm.xchart.style.Styler.AnnotationType.LabelAndPercentage); // COMMENT OUT or FIX
                // chart.getStyler().setDonutTogether(true); // COMMENT OUT or FIX

                // Add the chart to the display panel
                XChartPanel<PieChart> chartPanel = new XChartPanel<>(chart);
                chartDisplayPanel.add(chartPanel, BorderLayout.CENTER);
                System.out.println("Pie Chart generated and displayed.");


            } else if ("月度收支趋势柱状图".equals(selectedChartType)) {
                // --- Generate Bar Chart (Category Chart) ---
                System.out.println("Generating Monthly Income/Expense Trend Bar Chart...");

                List<String> months = new ArrayList<>();
                List<Double> totalIncomes = new ArrayList<>();
                List<Double> totalExpenses = new ArrayList<>();

                List<String> sortedMonths = new ArrayList<>(summaries.keySet());
                Collections.sort(sortedMonths);

                for (String month : sortedMonths) {
                    MonthlySummary ms = summaries.get(month);
                    months.add(month);
                    totalIncomes.add(ms.getTotalIncome());
                    totalExpenses.add(ms.getTotalExpense());
                }

                CategoryChart chart = new CategoryChartBuilder()
                        .width(chartDisplayPanel.getWidth())
                        .height(chartDisplayPanel.getHeight())
                        .title("月度收支趋势")
                        .xAxisTitle("月份")
                        .yAxisTitle("金额 (元)")
                        .build();

                chart.addSeries("总收入", months, totalIncomes);
                chart.addSeries("总支出", months, totalExpenses);

                // Customize chart style (optional - COMMENT OUT lines causing errors)
                // chart.getStyler().setLegendPosition(LegendPosition.OutsideS); // Keep if it works
                // chart.getStyler().setHasAnnotations(true); // COMMENT OUT or FIX
                // chart.getStyler().setStacked(false); // Keep if it works

                // Add the chart to the display panel
                XChartPanel<CategoryChart> chartPanel = new XChartPanel<>(chart);
                chartDisplayPanel.add(chartPanel, BorderLayout.CENTER);
                System.out.println("Bar Chart generated and displayed.");


            } else {
                displayPlaceholderChart("请选择一种图表类型和必要参数来生成图表。");
            }

        } catch (Exception e) {
            System.err.println("Error generating chart: " + selectedChartType);
            e.printStackTrace();
            displayPlaceholderChart("生成图表失败！\n" + e.getMessage());
            JOptionPane.showMessageDialog(this, "生成图表失败！\n" + e.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
        } finally {
            chartDisplayPanel.revalidate();
            chartDisplayPanel.repaint();
        }
    }

    /**
     * Helper method to display a placeholder message.
     */
    private void displayPlaceholderChart(String message) {
        // Clear previous content first
        chartDisplayPanel.removeAll();

        JLabel placeholderLabel = new JLabel(message, SwingConstants.CENTER);
        placeholderLabel.setFont(new Font("微软雅黑", Font.PLAIN, 16));
        chartDisplayPanel.add(placeholderLabel, BorderLayout.CENTER);

        chartDisplayPanel.revalidate();
        chartDisplayPanel.repaint();
    }

    // Optional: Method to trigger initial setup when panel is displayed
    // Call this from MenuUI's ActionListener for the Visualization button
    public void refreshPanelData() {
        System.out.println("VisualizationPanel refreshPanelData called.");
        // Populate month selector when the panel is visible
        // It's populated by the chartTypeSelector listener when Pie chart is selected.
        // So, no need to call populateMonthSelector here directly.

        // Reset chart type selector to default on refresh
        chartTypeSelector.setSelectedItem("请选择图表类型");
        // This action will trigger monthSelector logic

        // Display initial instruction message
        displayPlaceholderChart("请选择一种图表类型和必要参数来生成图表。");
    }

}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\DAO\Impl\CsvSummaryStatisticDao.java`:

```java
package DAO.Impl;

import DAO.SummaryStatisticDao;
import model.SummaryStatistic;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class CsvSummaryStatisticDao implements SummaryStatisticDao {

    // Define the header for the summary statistics CSV
    private static final String[] HEADERS = {
            "week_identifier", "total_income_all_users", "total_expense_all_users",
            "top_expense_category", "top_expense_category_amount",
            "number_of_users_with_transactions", "timestamp_generated"
    };

    @Override
    public List<SummaryStatistic> loadAllStatistics(String filePath) throws IOException {
        List<SummaryStatistic> statistics = new ArrayList<>();
        Path path = Paths.get(filePath);

        if (!Files.exists(path) || Files.size(path) == 0) {
            System.out.println("Summary statistics CSV file not found or is empty: " + filePath);
            return statistics;
        }

        try (Reader reader = new InputStreamReader(
                new BOMInputStream(Files.newInputStream(path)),
                StandardCharsets.UTF_8)) {

            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()
                    .withIgnoreHeaderCase(true)
                    .withTrim(true);

            try (CSVParser csvParser = new CSVParser(reader, format)) {
                Map<String, Integer> headerMap = csvParser.getHeaderMap();
                // Basic header validation
                List<String> requiredHeaders = List.of(HEADERS);
                if (headerMap == null || !headerMap.keySet().containsAll(requiredHeaders)) {
                    throw new IOException("Missing required headers in summary statistics CSV file: " + requiredHeaders +
                            " Found: " + (headerMap == null ? "null" : headerMap.keySet()));
                }

                for (CSVRecord record : csvParser) {
                    try {
                        SummaryStatistic stat = parseRecord(record);
                        if (stat != null) { // parseRecord might return null on error
                            statistics.add(stat);
                        }
                    } catch (Exception e) {
                        System.err.println("Skipping malformed summary statistic record at line " + record.getRecordNumber() + ": " + record.toString());
                        e.printStackTrace();
                    }
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading summary statistics from CSV: " + filePath);
            e.printStackTrace();
            throw e;
        }
        System.out.println("Successfully loaded " + statistics.size() + " summary statistics from " + filePath);
        return statistics;
    }

    // Helper to parse a single CSV record into a SummaryStatistic object
    private SummaryStatistic parseRecord(CSVRecord record) {
        // Defensive getting of values to prevent exceptions on missing columns
        String weekIdentifier = record.get("week_identifier");
        String totalIncomeStr = record.get("total_income_all_users");
        String totalExpenseStr = record.get("total_expense_all_users");
        String topExpenseCategory = record.get("top_expense_category");
        String topExpenseAmountStr = record.get("top_expense_category_amount");
        String numUsersStr = record.get("number_of_users_with_transactions");
        String timestampGenerated = record.get("timestamp_generated");

        // Basic validation for essential fields
        if (weekIdentifier == null || weekIdentifier.trim().isEmpty() ||
                totalIncomeStr == null || totalIncomeStr.trim().isEmpty() ||
                totalExpenseStr == null || totalExpenseStr.trim().isEmpty() ||
                numUsersStr == null || numUsersStr.trim().isEmpty() ||
                timestampGenerated == null || timestampGenerated.trim().isEmpty()) {
            System.err.println("Skipping summary record due to missing essential fields: " + record.toMap());
            return null; // Indicate parsing failed for this record
        }

        try {
            double totalIncome = Double.parseDouble(totalIncomeStr.trim());
            double totalExpense = Double.parseDouble(totalExpenseStr.trim());
            double topExpenseAmount = (topExpenseAmountStr != null && !topExpenseAmountStr.trim().isEmpty()) ? Double.parseDouble(topExpenseAmountStr.trim()) : 0.0;
            int numUsers = Integer.parseInt(numUsersStr.trim());

            return new SummaryStatistic(
                    weekIdentifier.trim(),
                    totalIncome,
                    totalExpense,
                    topExpenseCategory != null ? topExpenseCategory.trim() : "N/A", // Top category might be empty if no expenses
                    topExpenseAmount,
                    numUsers,
                    timestampGenerated.trim()
            );
        } catch (NumberFormatException e) {
            System.err.println("Skipping summary record due to number format error: " + record.toMap());
            e.printStackTrace();
            return null; // Indicate parsing failed
        }
    }


    @Override
    public void writeAllStatistics(String filePath, List<SummaryStatistic> statistics) throws IOException {
        Path path = Paths.get(filePath);
        // Ensure the directory exists
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }

        // Use a temporary file for atomic write
        File targetFile = path.toFile();
        File tempFile = File.createTempFile("summary_temp", ".csv", targetFile.getParentFile());

        try (BufferedWriter writer = Files.newBufferedWriter(tempFile.toPath(), StandardCharsets.UTF_8);
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(HEADERS).withTrim())) { // Always write header for overwrite

            for (SummaryStatistic stat : statistics) {
                csvPrinter.printRecord(
                        stat.getWeekIdentifier(),
                        stat.getTotalIncomeAllUsers(),
                        stat.getTotalExpenseAllUsers(),
                        stat.getTopExpenseCategory(),
                        stat.getTopExpenseCategoryAmount(),
                        stat.getNumberOfUsersWithTransactions(),
                        stat.getTimestampGenerated()
                );
            }
            // csvPrinter.flush(); // Auto-flushed on close
        } catch (IOException e) {
            tempFile.delete(); // Clean up temp file on failure
            System.err.println("Error writing summary statistics to temporary CSV file: " + tempFile.toPath());
            e.printStackTrace();
            throw e; // Re-throw
        }

        // Atomic replacement
        try {
            Files.move(tempFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
            System.out.println("Atomically replaced " + filePath + " with updated summary statistics.");
        } catch (IOException e) {
            System.err.println("Failed to atomically replace original summary file: " + targetFile.toPath());
            tempFile.delete(); // Clean up temp file
            e.printStackTrace();
            throw e; // Re-throw
        }
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\DAO\Impl\CsvTransactionDao.java`:

```java
package DAO.Impl; // Changed package

import Constants.ConfigConstants;
import DAO.TransactionDao; // Implement the interface
import model.Transaction;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional; // Using Optional for getTransactionByOrderNumber
import java.util.stream.Collectors;


public class CsvTransactionDao implements TransactionDao { // Implement TransactionDao interface

    // Remove the 'transactions' field and 'isLoad' flag, the cache/service layer will handle loading
    // private List<Transaction> transactions;
    // private boolean isLoad= false;

    // Keep the load method, it will be used by the cache loader
    @Override
    public List<Transaction> loadFromCSV(String filePath) throws IOException {
        List<Transaction> transactions = new ArrayList<>();
        Path path = Paths.get(filePath);

        // Check if file exists and is not empty before attempting to read
        if (!Files.exists(path) || Files.size(path) == 0) {
            System.out.println("CSV file not found or is empty: " + filePath);
            return transactions; // Return empty list if file doesn't exist or is empty
        }

        // Use BOMInputStream and InputStreamReader with UTF-8
        try (Reader reader = new InputStreamReader(
                new BOMInputStream(Files.newInputStream(path)), // Use path here directly
                StandardCharsets.UTF_8)) {

            // *** Simplified Header Handling: Let CSVParser handle the header detection ***
            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()    // Tell parser to treat the first line as header
                    .withIgnoreHeaderCase(true)  // Ignore case for robustness
                    .withTrim(true);             // Trim fields

            try (CSVParser csvParser = new CSVParser(reader, format)) {
                // After creating the parser with withFirstRecordAsHeader,
                // the header map should be available *if* a header was found.
                // Check if the required headers are present
                List<String> requiredHeaders = List.of(
                        "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)",
                        "支付方式", "当前状态", "交易单号", "商户单号", "备注"
                );

                // Now check the header map obtained *by the parser*
                Map<String, Integer> headerMap = csvParser.getHeaderMap();
                if (headerMap == null || !headerMap.keySet().containsAll(requiredHeaders)) {
                    // If headerMap is null (no header found) or incomplete
                    throw new IOException("Missing required headers in CSV file: " + requiredHeaders +
                            " Found: " + (headerMap == null ? "null" : headerMap.keySet()));
                }
                System.out.println("Successfully identified headers: " + headerMap.keySet() + " in file: " + filePath);


                for (CSVRecord record : csvParser) {
                    try {
                        transactions.add(parseRecord(record));
                    } catch (Exception e) {
                        System.err.println("Skipping malformed record at line " + record.getRecordNumber() + ": " + record.toString());
                        e.printStackTrace();
                    }
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading CSV file: " + filePath);
            e.printStackTrace();
            throw e;
        }
        System.out.println("Successfully loaded " + transactions.size() + " records from " + filePath);
        return transactions;
    }


    // Keep parseRecord private as it's an internal helper
    private Transaction parseRecord(CSVRecord record) {
        // Safely get and trim values, handle potential missing columns gracefully if needed
        String amountStr = record.get("金额(元)").trim();
        double paymentAmount = 0.0;
        try {
            if (amountStr.startsWith("¥")) {
                amountStr = amountStr.substring(1);
            }
            paymentAmount = Double.parseDouble(amountStr);
        } catch (NumberFormatException e) {
            System.err.println("Warning: Could not parse payment amount '" + record.get("金额(元)") + "' at line " + record.getRecordNumber());
            // Keep paymentAmount as 0.0 or handle as an error depending on strictness
        } catch (IllegalArgumentException e) {
            System.err.println("Warning: Missing '金额(元)' column or empty value at line " + record.getRecordNumber());
        }


        return new Transaction(
                record.get("交易时间").trim(),
                record.get("交易类型").trim(),
                record.get("交易对方").trim(),
                record.get("商品").trim(),
                record.get("收/支").trim(),
                paymentAmount, // Use parsed amount
                record.get("支付方式").trim(),
                record.get("当前状态").trim(),
                record.get("交易单号").trim(),
                record.get("商户单号").trim(),
                record.get("备注").trim()
        );
    }

    // Implement DAO interface methods properly
    public List<Transaction> getAllTransactions() throws IOException {
        // This method is now handled by the service layer using the cache.
        // The DAO should focus on direct file operations.
        // This interface method might be redundant if service layer always uses cache.
        // For clarity, let's make it load from CSV directly, but the service will prefer cache.
        // Note: This might re-read the file even if cached. Service layer needs to manage this.
        // Alternatively, this method could be removed from the interface/DAO if only cache loader uses loadFromCSV.
        // Let's keep it for now, assuming it's a direct file read fallback.
        System.out.println("DAO: Calling getAllTransactions directly from file (consider using service/cache)");
        // We need a way to know *which* file here. This method signature is problematic for multi-user.
        // The interface needs filePath, or the DAO instance needs to be created per file.
        // Let's adjust the interface/DAO to be file-specific or pass path to methods.
        // Option 1: DAO instance per file.
        // Option 2: Add filePath parameter to all relevant interface methods.
        // Option 2 seems more flexible for a single CsvTransactionDao class.
        // Let's add filePath to interface methods and implement here.

        // *** Decision: Modify TransactionDao interface to include filePath ***
        throw new UnsupportedOperationException("This method signature is not suitable for multi-user. Use the overloaded method with filePath.");
    }

    // Adding filePath parameter to relevant interface methods definition (will update interface next)
    // This implementation will be part of the updated DAO after interface change.
    public List<Transaction> getAllTransactions(String filePath) throws IOException {
        return loadFromCSV(filePath); // Simple implementation using the existing load method
    }


    // Add transaction
    public void addTransaction(Transaction newTransaction) throws IOException {
        throw new UnsupportedOperationException("This method signature is not suitable for multi-user. Use the overloaded method with filePath.");
    }

    public void addTransaction(String filePath, Transaction newTransaction) throws IOException {
        // Ensure the directory exists
        Path path = Paths.get(filePath);
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }

        boolean fileExists = Files.exists(path) && Files.size(path) > 0;

        // Define the header based on your CSV structure
        String[] headers = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"};

        // Use StandardOpenOption.CREATE and StandardOpenOption.APPEND
        // If the file doesn't exist, CREATE will create it. If it exists, APPEND will add to the end.
        // We need to handle writing the header only if the file is new or empty.
        try (BufferedWriter writer = Files.newBufferedWriter(path, StandardOpenOption.CREATE, StandardOpenOption.APPEND)) {

            // Check if header needs to be written. A simple way is to check file size before opening in APPEND mode.
            // However, opening in CREATE/APPEND and then checking size *after* opening might not work as expected if the file is created.
            // A better approach is to check size *before* getting the writer or read the first line after opening if needed.
            // The Apache CSVPrinter can handle writing headers IF the file is new.
            // Let's adapt the existing logic slightly. Check exists and non-empty *before* opening.

            // Re-check file state after potential creation by StandardOpenOption.CREATE
            boolean fileWasEmptyBeforeAppend = !fileExists; // Or check if file size is 0 after creation if needed

            // Configure CSV format - with header if file is new/empty, without if appending
            CSVFormat format;
            if (fileWasEmptyBeforeAppend) {
                format = CSVFormat.DEFAULT.withHeader(headers).withTrim();
            } else {
                format = CSVFormat.DEFAULT.withTrim(); // Assume header is already there
            }

            // Create CSVPrinter
            try (CSVPrinter csvPrinter = new CSVPrinter(writer, format)) {
                csvPrinter.printRecord(
                        newTransaction.getTransactionTime(),
                        newTransaction.getTransactionType(),
                        newTransaction.getCounterparty(),
                        newTransaction.getCommodity(),
                        newTransaction.getInOut(),
                        // Format amount with ¥ sign and two decimal places
                        String.format("¥%.2f", newTransaction.getPaymentAmount()),
                        newTransaction.getPaymentMethod(),
                        newTransaction.getCurrentStatus(),
                        newTransaction.getOrderNumber(),
                        newTransaction.getMerchantNumber(),
                        newTransaction.getRemarks()
                );
                // No need to flush immediately, writer will be closed by try-with-resources.
                // csvPrinter.flush();
            }
            System.out.println("Added transaction to " + filePath);
        } catch (IOException e) {
            System.err.println("Error adding transaction to CSV: " + filePath);
            e.printStackTrace();
            throw e; // Re-throw
        }
    }


    // Delete transaction by order number
    public boolean deleteTransaction(String orderNumber) throws IOException {
        throw new UnsupportedOperationException("This method signature is not suitable for multi-user. Use the overloaded method with filePath.");
    }

    public boolean deleteTransaction(String filePath, String orderNumber) throws IOException {
        // Load all transactions first
        List<Transaction> allTransactions = loadFromCSV(filePath);

        // Filter out the transaction to be deleted
        List<Transaction> updatedTransactions = allTransactions.stream()
                .filter(t -> !t.getOrderNumber().trim().equals(orderNumber.trim()))
                .collect(Collectors.toList());

        // Check if any transaction was actually removed
        boolean deleted = allTransactions.size() > updatedTransactions.size();

        if (deleted) {
            // Write the remaining transactions back to the CSV file
            writeTransactionsToCSV(filePath, updatedTransactions);
            System.out.println("Deleted transaction with order number " + orderNumber + " from " + filePath);
        } else {
            System.out.println("Transaction with order number " + orderNumber + " not found in " + filePath);
        }

        return deleted;
    }


    // Update a specific field (implementing the interface method)
    public boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException {
        // This interface method needs a filePath parameter to be useful in a multi-user context.
        // Let's add an overloaded method that includes filePath.
        throw new UnsupportedOperationException("This method signature is not suitable for multi-user. Use the overloaded method with filePath.");
    }

    public boolean updateTransaction(String filePath, String orderNumber, String fieldName, String newValue) throws IOException {
        // Load all transactions
        List<Transaction> allTransactions = loadFromCSV(filePath);

        // Find the transaction by order number
        Optional<Transaction> transactionToUpdateOpt = allTransactions.stream()
                .filter(t -> t.getOrderNumber().trim().equals(orderNumber.trim()))
                .findFirst();

        if (!transactionToUpdateOpt.isPresent()) {
            System.out.println("Transaction with order number " + orderNumber + " not found for update in " + filePath);
            return false; // Transaction not found
        }

        Transaction transactionToUpdate = transactionToUpdateOpt.get();
        boolean updated = false;

        // Use reflection or a switch/if-else block to update the specific field
        // A switch is more explicit and safer than reflection here.
        switch (fieldName) {
            case "transactionTime": transactionToUpdate.setTransactionTime(newValue); updated = true; break;
            case "transactionType": transactionToUpdate.setTransactionType(newValue); updated = true; break;
            case "counterparty": transactionToUpdate.setCounterparty(newValue); updated = true; break;
            case "commodity": transactionToUpdate.setCommodity(newValue); updated = true; break;
            case "inOut": transactionToUpdate.setInOut(newValue); updated = true; break;
            case "paymentAmount":
                try {
                    transactionToUpdate.setPaymentAmount(Double.parseDouble(newValue));
                    updated = true;
                } catch (NumberFormatException e) {
                    System.err.println("Invalid number format for paymentAmount update: " + newValue);
                    throw new NumberFormatException("Invalid number format for paymentAmount: " + newValue);
                }
                break;
            case "paymentMethod": transactionToUpdate.setPaymentMethod(newValue); updated = true; break;
            case "currentStatus": transactionToUpdate.setCurrentStatus(newValue); updated = true; break;
            case "orderNumber": transactionToUpdate.setOrderNumber(newValue); updated = true; break; // Caution: Updating ID can be tricky
            case "merchantNumber": transactionToUpdate.setMerchantNumber(newValue); updated = true; break;
            case "remarks": transactionToUpdate.setRemarks(newValue); updated = true; break;
            default:
                System.err.println("Invalid field name for update: " + fieldName);
                throw new IllegalArgumentException("Invalid field name: " + fieldName);
        }

        if (updated) {
            // Write the modified list back to the CSV file
            writeTransactionsToCSV(filePath, allTransactions);
            System.out.println("Updated transaction with order number " + orderNumber + " in " + filePath + " field: " + fieldName);
        }

        return updated;
    }


    // Keep writeTransactionsToCSV, ensure it uses the filePath parameter correctly
    // This method seems OK as it already accepts filePath.
    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
        // Ensure the directory exists
        Path path = Paths.get(filePath);
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }

        File targetFile = path.toFile();
        // Create temporary file in the same directory
        File tempFile = File.createTempFile("transaction_temp", ".csv", targetFile.getParentFile());

        // Define the header explicitly
        String[] headers = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"};

        try (BufferedWriter writer = Files.newBufferedWriter(tempFile.toPath(), StandardCharsets.UTF_8);
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(headers).withTrim())) { // Always write header for overwrite

            for (Transaction t : transactions) {
                csvPrinter.printRecord(
                        t.getTransactionTime(),
                        t.getTransactionType(),
                        t.getCounterparty(),
                        t.getCommodity(),
                        t.getInOut(),
                        String.format("¥%.2f", t.getPaymentAmount()), // Format amount
                        t.getPaymentMethod(),
                        t.getCurrentStatus(),
                        t.getOrderNumber(),
                        t.getMerchantNumber(),
                        t.getRemarks()
                );
            }
            // csvPrinter.flush(); // Auto-flushed on close
        } catch (IOException e) {
            tempFile.delete(); // Clean up temp file on failure
            System.err.println("Error writing transactions to temporary CSV file: " + tempFile.toPath());
            e.printStackTrace();
            throw e; // Re-throw
        }

        // Atomic replacement of the original file
        try {
            Files.move(tempFile.toPath(), targetFile.toPath(), StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE);
            System.out.println("Atomically replaced " + filePath + " with updated data.");
        } catch (IOException e) {
            System.err.println("Failed to atomically replace original file: " + targetFile.toPath() + " with " + tempFile.toPath());
            tempFile.delete(); // Clean up temp file
            e.printStackTrace();
            throw e; // Re-throw
        }
    }

    // Implement getTransactionByOrderNumber from the interface
    public Transaction getTransactionByOrderNumber(String orderNumber) throws IOException {
        throw new UnsupportedOperationException("This method signature is not suitable for multi-user. Use the overloaded method with filePath.");
    }

    public Transaction getTransactionByOrderNumber(String filePath, String orderNumber) throws IOException {
        // Load all transactions
        List<Transaction> allTransactions = loadFromCSV(filePath);

        // Find the transaction by order number
        Optional<Transaction> transactionOpt = allTransactions.stream()
                .filter(t -> t.getOrderNumber().trim().equals(orderNumber.trim()))
                .findFirst();

        return transactionOpt.orElse(null); // Return Transaction object or null
    }


    // Remove or update these old methods
    // private CSVFormat getCsvFormatWithHeader(String filePath) throws IOException { ... } // No longer needed with explicit headers
    // private CSVFormat getCsvFormatWithoutHeader() { ... } // No longer needed with explicit headers
    // boolean changeInformation(String orderNumber, String head, String value,String path) throws IOException // This is similar to updateTransaction, prefer the standard update method
    // Let's remove changeInformation and update the service to use updateTransaction

    // Removed changeInformation method based on the plan to use updateTransaction instead.
    // Removed getCsvFormatWithHeader/WithoutHeader as we now use explicit headers in writeTransactionsToCSV.
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\DAO\Impl\CsvUserDao.java`:

```java
package DAO.Impl;

import Constants.ConfigConstants;
import DAO.UserDao;
import model.User;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

public class CsvUserDao implements UserDao {

    private final String filePath;

    public CsvUserDao(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public List<User> getAllUsers() throws IOException {
        List<User> users = new ArrayList<>();
        // Use BOMInputStream to handle potential Byte Order Mark issues
        try (Reader reader = new InputStreamReader(
                new BOMInputStream(Files.newInputStream(Paths.get(filePath))),
                StandardCharsets.UTF_8)) {

            // Configure CSVFormat to handle headers
            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()
                    .withIgnoreHeaderCase(true) // Ignore header case for robustness
                    .withTrim(true); // Trim leading/trailing whitespace

            try (CSVParser csvParser = new CSVParser(reader, format)) {
                // Check if the required headers are present
                List<String> requiredHeaders = List.of("username", "password", "role", "transaction_csv_path");
                if (!csvParser.getHeaderMap().keySet().containsAll(requiredHeaders)) {
                    throw new IOException("Missing required headers in users CSV file: " + requiredHeaders);
                }

                for (CSVRecord record : csvParser) {
                    // Basic error handling for potentially missing fields in a row
                    String username = record.get("username");
                    String password = record.get("password");
                    String role = record.get("role");
                    String transactionFilePath = record.get("transaction_csv_path");

                    if (username == null || username.trim().isEmpty() || password == null || password.trim().isEmpty() || role == null || role.trim().isEmpty() || transactionFilePath == null || transactionFilePath.trim().isEmpty()) {
                        System.err.println("Skipping malformed user record: " + record.toMap());
                        continue; // Skip this row
                    }

                    User user = new User(username.trim(), password.trim(), role.trim(), transactionFilePath.trim());
                    users.add(user);
                }
            }
        } catch (IOException e) {
            System.err.println("Error loading users from CSV file: " + filePath);
            e.printStackTrace();
            throw e; // Re-throw the exception after logging
        }
        return users;
    }

    // Helper method to parse a single record (optional, can be in getAllUsers)
    // private User parseRecord(CSVRecord record) { ... }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\DAO\SummaryStatisticDao.java`:

```java
package DAO;

import model.SummaryStatistic;

import java.io.IOException;
import java.util.List;

public interface SummaryStatisticDao {

    /**
     * Loads all summary statistics from the configured data source.
     * @param filePath The path to the summary statistics CSV file.
     * @return A list of all summary statistics.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<SummaryStatistic> loadAllStatistics(String filePath) throws IOException;

    /**
     * Writes a list of summary statistics to the configured data source, overwriting existing data.
     * @param filePath The path to the summary statistics CSV file.
     * @param statistics The list of statistics to write.
     * @throws IOException If an I/O error occurs during saving.
     */
    void writeAllStatistics(String filePath, List<SummaryStatistic> statistics) throws IOException;

    // Optional: Add method to get statistic by week identifier if needed
    // SummaryStatistic getStatisticByWeek(String filePath, String weekIdentifier) throws IOException;
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\DAO\TransactionDao.java`:

```java
package DAO;

import model.Transaction;

import java.io.IOException;
import java.util.List;

/**
 * Interface for Data Access Object (DAO) operations related to Transactions.
 * Defines the contract for loading, adding, deleting, and updating transaction data.
 */
public interface TransactionDao {

    // Keep loadFromCSV - used by cache loader
    List<Transaction> loadFromCSV(String filePath) throws IOException;

    /**
     * Loads all transactions from the specified data source file.
     * @param filePath The path to the user's CSV file.
     * @return A list of all transactions.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<Transaction> getAllTransactions(String filePath) throws IOException;


    /**
     * Adds a new transaction to the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param transaction The new transaction to add.
     * @throws IOException If an I/O error occurs during saving.
     */
    void addTransaction(String filePath, Transaction transaction) throws IOException;

    /**
     * Deletes a transaction identified by its order number from the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param orderNumber The unique order number of the transaction to delete.
     * @return true if a transaction was found and deleted, false otherwise.
     * @throws IOException If an I/O error occurs during loading or saving.
     */
    boolean deleteTransaction(String filePath, String orderNumber) throws IOException;

    /**
     * Updates a specific field of an existing transaction identified by its order number
     * in the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param orderNumber The unique order number of the transaction to update.
     * @param fieldName   The name of the field to update (e.g., "transactionType", "paymentAmount").
     * @param newValue    The new value for the specified field.
     * @return true if the transaction was found and updated, false otherwise.
     * @throws IOException             If an I/O error occurs during loading or saving.
     * @throws NumberFormatException   If updating 'paymentAmount' and newValue is not a valid double.
     * @throws IllegalArgumentException If the fieldName is invalid.
     */
    boolean updateTransaction(String filePath, String orderNumber, String fieldName, String newValue) throws IOException;

    /**
     * Retrieves a transaction by its unique order number from the specified data source file.
     *
     * @param filePath The path to the user's CSV file.
     * @param orderNumber The unique order number.
     * @return The Transaction object if found, null otherwise.
     * @throws IOException If an I/O error occurs during loading.
     */
    Transaction getTransactionByOrderNumber(String filePath, String orderNumber) throws IOException;

    void writeTransactionsToCSV(String currentUserTransactionFilePath, List<Transaction> updatedList) throws IOException;

    // Remove the old methods without filePath parameter from the interface
    // List<Transaction> getAllTransactions() throws IOException; // Removed
    // void addTransaction(Transaction transaction) throws IOException; // Removed
    // boolean deleteTransaction(String orderNumber) throws IOException; // Removed
    // boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException; // Removed
    // Transaction getTransactionByOrderNumber(String orderNumber) throws IOException; // Removed
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\DAO\UserDao.java`:

```java
package DAO;

import model.User;

import java.io.IOException;
import java.util.List;

/**
 * Interface for Data Access Object (DAO) operations related to Users.
 */
public interface UserDao {

    /**
     * Loads all users from the configured data source.
     *
     * @return A list of all users.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<User> getAllUsers() throws IOException;

    // Add other user-related methods if needed later (e.g., addUser, deleteUser)
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Interceptor\Login\LoginDialog.java`:

```java
package Interceptor.Login;

import Service.User.UserService; // Import the new UserService
import model.User;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class LoginDialog extends JDialog {
    private User authenticatedUser = null; // Change from boolean flag to User object
    private JTextField usernameField;
    private JPasswordField passwordField;
    // UserService should ideally be injected, but for simplicity in LoginDialog,
    // we might initialize it here or pass it from Main. Let's pass it from Main.
    private final UserService userService;

    // Constructor now accepts UserService
    public LoginDialog(UserService userService) {
        this.userService = userService; // Inject UserService

        setTitle("用户登录");
        setLayout(new GridLayout(3, 2));
        setModal(true);
        setSize(300, 150);
        setResizable(false); // Prevent resizing

        // Input components
        usernameField = new JTextField();
        passwordField = new JPasswordField();
        JButton loginButton = new JButton("登录");
        JButton cancelButton = new JButton("取消");

        // Add components
        add(new JLabel("用户名:"));
        add(usernameField);
        add(new JLabel("密码:"));
        add(passwordField);
        add(loginButton);
        add(cancelButton);

        // Login button logic
        loginButton.addActionListener(e -> {
            String username = usernameField.getText().trim();
            String password = new String(passwordField.getPassword()).trim();

            authenticatedUser = userService.authenticate(username, password); // Use new authenticate method

            if (authenticatedUser != null) { // Check if a User object was returned
                dispose(); // Close dialog
            } else {
                JOptionPane.showMessageDialog(
                        this,
                        "用户名或密码错误！",
                        "登录失败",
                        JOptionPane.ERROR_MESSAGE
                );
                clearFields(); // Clear fields on failure
            }
        });

        // Cancel button logic
        cancelButton.addActionListener(e -> {
            authenticatedUser = null; // Ensure no user is set on cancel
            dispose();
            System.exit(0); // Exit application on cancel
        });

        setLocationRelativeTo(null); // Center dialog
    }

    // Method to clear input fields
    private void clearFields() {
        usernameField.setText("");
        passwordField.setText("");
        usernameField.requestFocusInWindow(); // Focus back to username field
    }

    /**
     * Shows the login dialog and returns the authenticated user upon successful login.
     * Blocking call.
     * @return The authenticated User object, or null if login failed or was cancelled.
     */
    public User showDialogAndGetResult() {
        setVisible(true); // Show the dialog (this call is blocking because modal is true)
        return authenticatedUser; // Return the result after dialog is closed
    }

    // Remove isLoginSuccessful() as we now return the User object
    // public boolean isLoginSuccessful() { return loginSuccessful; }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Main.java`:

```java
import javax.swing.*;

import Controller.MenuUI;
import DAO.Impl.CsvTransactionDao;
import DAO.Impl.CsvUserDao;
import DAO.Impl.CsvSummaryStatisticDao;
import DAO.UserDao;
import DAO.TransactionDao;
import DAO.SummaryStatisticDao;
import Interceptor.Login.LoginDialog;
import Service.Impl.TransactionServiceImpl;
import Service.Impl.SummaryStatisticService;
import Service.AIservice.AITransactionService; // Import AI Service classes
import Service.AIservice.CollegeStudentNeeds;
import Service.TransactionService;
import Service.User.UserService;
import model.User;
import Constants.ConfigConstants;

public class Main {
    public static void main(String[] args) {
        // Ensure ConfigConstants is loaded first
        String usersCsvPath = ConfigConstants.USERS_CSV_PATH;
        String summaryCsvPath = ConfigConstants.SUMMARY_CSV_PATH;
        System.out.println("Attempting to load users from: " + usersCsvPath);
        System.out.println("Summary statistics will be saved to: " + summaryCsvPath);


        // Initialize DAOs
        UserDao userDao = new CsvUserDao(usersCsvPath);
        TransactionDao transactionDao = new CsvTransactionDao();
        SummaryStatisticDao summaryStatisticDao = new CsvSummaryStatisticDao();


        // Initialize Services
        UserService userService = new UserService(userDao);
        // TransactionServiceImpl is initialized per user in MenuUI -> NO, initialize it here and pass it!
        // The TransactionServiceImpl instance *is* user-specific, so it's better to create it *after* login.
        // But AI Services need it *before* MenuUI is fully constructed and shows the panel.
        // Option 1: Pass TransactionService to MenuUI constructor and AI/CS services are initialized in MenuUI. (Current approach)
        // Option 2: Create AI/CS services here in Main and pass them to MenuUI. They would need the user-specific TS instance.
        // Let's stick with Option 1 for now, initializing AI/CS in MenuUI after getting TS.

        SummaryStatisticService summaryStatisticService = new SummaryStatisticService(userDao, transactionDao, summaryStatisticDao);


        // In the event dispatch thread (EDT) start GUI
        SwingUtilities.invokeLater(() -> {
            LoginDialog loginDialog = new LoginDialog(userService);
            User authenticatedUser = loginDialog.showDialogAndGetResult();

            if (authenticatedUser != null) {
                System.out.println("Logged in as: " + authenticatedUser.getUsername() + " (" + authenticatedUser.getRole() + ")");
                System.out.println("User's transaction file: " + authenticatedUser.getTransactionFilePath());

                // Initialize TransactionServiceImpl *for the logged-in user*
                TransactionService transactionServiceForCurrentUser = new TransactionServiceImpl(authenticatedUser.getTransactionFilePath());

                // Initialize AI Services *with* the user-specific TransactionService
                // This is where AI/CS services are created with their dependency injected
                AITransactionService aiTransactionService = new AITransactionService(transactionServiceForCurrentUser);
                CollegeStudentNeeds collegeStudentNeeds = new CollegeStudentNeeds(transactionServiceForCurrentUser);


                // Pass the authenticated user, their transaction service, summary statistic service, AND AI services to MenuUI
                MenuUI menuUI = new MenuUI(authenticatedUser, transactionServiceForCurrentUser, summaryStatisticService, aiTransactionService, collegeStudentNeeds); // Modify MenuUI constructor


                JFrame frame = new JFrame("交易管理系统 - " + authenticatedUser.getUsername());
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                frame.setSize(1200, 600);
                frame.setLocationRelativeTo(null);
                frame.add(menuUI.createMainPanel());
                frame.setVisible(true);
            } else {
                System.out.println("Login failed or cancelled. Exiting.");
                System.exit(0);
            }
        });
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\AIservice\AIAnalyzerThread.java`:

```java
package Service.AIservice;

// Add required imports
import Service.TransactionService; // Import if analyzeTransactions throws Exception


public class AIAnalyzerThread implements Runnable {
    private final String userRequest;
    private final String filePath; // Still needed for analyzeTransactions method signature
    private final String startTimeStr;
    private final String endTimeStr;

    // Field to hold the injected AITransactionService service instance
    private final AITransactionService aiTransactionService;


    /**
     * Constructor now accepts the AITransactionService service instance
     * and the parameters for the analysis request.
     *
     * @param aiTransactionService The AITransactionService service instance to use.
     * @param userRequest The user's natural language request.
     * @param filePath The path to the user's transaction data file.
     * @param startTimeStr The start time string for filtering.
     * @param endTimeStr The end time string for filtering.
     */
    public AIAnalyzerThread(AITransactionService aiTransactionService, String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        this.aiTransactionService = aiTransactionService; // Inject the service
        this.userRequest = userRequest;
        this.filePath = filePath; // Still needed for analyzeTransactions call
        this.startTimeStr = startTimeStr;
        this.endTimeStr = endTimeStr;
        System.out.println("AIAnalyzerThread initialized for file: " + filePath);
    }

    @Override
    public void run() {
        System.out.println("AIAnalyzerThread started for analysis request: '" + userRequest + "' on file: " + filePath);
        try {
            // Call the analyzeTransactions method on the injected service instance
            String result = aiTransactionService.analyzeTransactions(userRequest, filePath, startTimeStr, endTimeStr);

            // Print the result or handle it as needed by the test/caller that starts this thread
            System.out.println("AI analysis result from thread: " + result);

            // TODO: If this thread is used by a UI program, use SwingUtilities.invokeLater() to update a UI component with 'result'
            // This indicates this class might be intended for background tasks separate from the main UI refresh cycle handled in MenuUI.
        } catch (Exception e) { // Catch Exception as analyzeTransactions throws Exception
            System.err.println("Error during AI analysis in thread for file " + filePath + ": " + e.getMessage());
            e.printStackTrace();
            // You might want to pass this error back to the caller if it's a UI context.
        }
        System.out.println("AIAnalyzerThread finished for file: " + filePath);
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\AIservice\AITransactionService.java`:

```java
package Service.AIservice;
// Remove import Service.Impl.TransactionServiceImpl;
// Remove import Service.TransactionService;
// Remove import Constants.ConfigConstants; // ConfigConstants might still be needed for API key logic if not elsewhere
// Remove import DAO.CsvTransactionDao; // No longer directly used
// Remove import Utils.CacheUtil; // No longer directly used

import DAO.TransactionDao; // Use the interface
import DAO.Impl.CsvTransactionDao; // Use the implementation to create instance for loader
import Service.TransactionService;
import Utils.CacheManager; // Import CacheManager
import model.MonthlySummary;
import model.Transaction; // Import Transaction

import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;

import java.io.IOException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;
import java.util.concurrent.*;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
// Remove import static Constants.ConfigConstants.CSV_PATH; // No longer use static CSV_PATH

public class AITransactionService {
    // Keep static ArkService as it's typically thread-safe and stateless
    private static final String API_KEY = System.getenv("ARK_API_KEY"); // Or load from config.properties
    private static final ArkService service = ArkService.builder()
            .timeout(Duration.ofSeconds(1800))
            .connectTimeout(Duration.ofSeconds(20))
            .baseUrl("https://ark.cn-beijing.volces.com/api/v3")
            .apiKey(API_KEY) // Ensure API_KEY is loaded
            .build();

    // Need access to TransactionService to get monthly summaries
    private final TransactionService transactionService; // Inject TransactionService


    /**
     * Constructor now accepts TransactionService instance.
     */
    public AITransactionService(TransactionService transactionService) {
        this.transactionService = transactionService; // Inject the service
        System.out.println("AITransactionService initialized with TransactionService.");
    }

    /**
     * Analyzes transactions from a specific user's file based on user request and time range.
     *
     * @param userRequest The user's natural language request.
     * @param filePath The path to the user's transaction CSV file.
     * @param startTimeStr The start time string for filtering.
     * @param endTimeStr The end time string for filtering.
     * @return AI analysis result as a String.
     */
    public String analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        try {
            // Get transactions for the specified file path using CacheManager
            // Need to pass a DAO instance for the CacheManager's loader if it needs to load from file.
            TransactionDao transactionDaoForLoading = new CsvTransactionDao(); // Create a DAO instance for loading
            List<Transaction> transactions = CacheManager.getTransactions(filePath, transactionDaoForLoading);
            System.out.println("AI Service: Retrieved " + transactions.size() + " transactions for file: " + filePath);


            // Format filtered transactions for the AI prompt
            List<String> transactionDetails = formatTransactions(transactions, startTimeStr, endTimeStr);
            System.out.println("AI Service: Formatted " + transactionDetails.size() + " transactions for AI.");


            // Check if any transactions were found after filtering
            if (transactionDetails.isEmpty() || (transactionDetails.size() == 1 && transactionDetails.get(0).startsWith("该时间段内没有交易记录"))) {
                return "在该时间段内没有找到符合条件的交易记录，无法进行分析。请检查时间和交易数据。";
            }

            String aiPrompt = userRequest + "\n" + "以下是我的账单信息：\n" + String.join("\n", transactionDetails);
            System.out.println("AI Service: Sending prompt to AI. Prompt length: " + aiPrompt.length());
            return askAi(aiPrompt);
        } catch (IllegalArgumentException e) {
            System.err.println("AI analysis failed due to invalid time format: " + e.getMessage());
            return "AI分析失败: 时间格式不正确。" + e.getMessage();
        }
        catch (Exception e) {
            System.err.println("AI analysis failed during data retrieval or AI call for file: " + filePath);
            e.printStackTrace();
            return "AI分析失败: 获取数据或调用AI服务时发生错误。" + e.getMessage();
        }
    }


    // Keep formatTransactions, parseDateTime, askAi methods. Ensure parseDateTime is robust.
    // The formatTransactions method relies on parseDateTime, ensure consistency with TransactionServiceImpl's parser.

    public List<String> formatTransactions(List<Transaction> transactions, String startTimeStr, String endTimeStr) {
        LocalDateTime startTime = parseDateTime(startTimeStr);
        // If end time is empty, use current time
        LocalDateTime endTime = (endTimeStr == null || endTimeStr.trim().isEmpty())
                ? LocalDateTime.now()
                : parseDateTime(endTimeStr);

        if (startTime == null) {
            // Handle the case where start time is invalid.
            // Depending on requirements, you might throw an exception or return an error message list.
            // Throwing IllegalArgumentException is better for analyzeTransactions to catch.
            throw new IllegalArgumentException("起始时间格式不正确: " + startTimeStr);
        }
        // If endTime parsing fails, treat it as current time as per original logic if endTimeStr was not empty
        if ((endTimeStr != null && !endTimeStr.trim().isEmpty()) && endTime == null) {
            throw new IllegalArgumentException("结束时间格式不正确: " + endTimeStr);
        }
        // If endTimeStr was empty, endTime is already LocalDateTime.now() which is not null.

        System.out.println("Filtering transactions from " + startTime + " to " + endTime);


        List<Transaction> filtered = transactions.stream()
                .filter(t -> {
                    LocalDateTime tTime = parseDateTime(t.getTransactionTime());
                    // Include transactions exactly at startTime, exclude transactions exactly at endTime (standard range behavior [start, end))
                    // If endTime should be inclusive, change isBefore(startTime) to !isAfter(startTime) and isAfter(endTime) to !isBefore(endTime)
                    // Or use isBefore(startTime) || isAfter(endTime) and negate.
                    // Let's use !isBefore(startTime) && !isAfter(endTime) as it seems more intuitive for a date range, inclusive.
                    return tTime != null && !tTime.isBefore(startTime) && !tTime.isAfter(endTime); // Range [startTime, endTime]
                })
                .collect(Collectors.toList());
        System.out.println("Filtered down to " + filtered.size() + " transactions within range.");


        // Group by Counterparty and summarize net amount and count
        Map<String, double[]> grouped = new HashMap<>(); // double[0] = net amount, double[1] = count
        for (Transaction t : filtered) {
            String counterparty = t.getCounterparty();
            double amount = t.getPaymentAmount();
            if (t.getInOut().equals("支出") || t.getInOut().equals("支")) { // Normalize "支" to "支出" internally if needed, but compare against source
                amount = -amount;
            } else if (!t.getInOut().equals("收入") && !t.getInOut().equals("收")) {
                System.err.println("Warning: Unknown 收/支 type for transaction: " + t.getOrderNumber() + " - " + t.getInOut());
                // Decide how to handle unknown types - ignore from analysis? Treat as 0?
                continue; // Skip unknown types for aggregation
            }

            grouped.putIfAbsent(counterparty, new double[]{0.0, 0});
            grouped.get(counterparty)[0] += amount;
            grouped.get(counterparty)[1] += 1;
        }
        System.out.println("Grouped transactions by counterparty. Found " + grouped.size() + " counterparties.");


        List<String> results = grouped.entrySet().stream()
                .map(e -> {
                    String cp = e.getKey();
                    double net = e.getValue()[0];
                    int count = (int) e.getValue()[1];
                    String inOut = net >= 0 ? "总收入" : "总支出"; // Changed label to reflect aggregate
                    if (Math.abs(net) < 0.01 && count > 0) { // If net is near zero but there were transactions
                        inOut = "净零"; // Or specify "收支相抵"
                    }
                    return String.format("交易对方: %s, 净%s: %.2f元，交易次数: %d",
                            cp, inOut, Math.abs(net), count);
                })
                .collect(Collectors.toList());
        System.out.println("Formatted grouped results.");


        // Add time range information to the results list
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm");
        String rangeInfo = String.format("分析交易时间范围：%s - %s",
                formatter.format(startTime), formatter.format(endTime));
        results.add(0, rangeInfo); // Add range info at the beginning

        return results.isEmpty() ? List.of(rangeInfo, "该时间段内没有交易记录。") : results; // Ensure range info is always included
    }


    // Keep parseDateTime method - ensure it matches the one in TransactionServiceImpl
    private LocalDateTime parseDateTime(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // Clean whitespace
        timeStr = timeStr.trim().replaceAll("\\s+", " ");

        // Append time if only date
        if (timeStr.matches("\\d{4}/\\d{1,2}/\\d{1,2}")) {
            timeStr += " 00:00"; // Assuming minutes format
        } else if (timeStr.matches("\\d{4}-\\d{1,2}-\\d{1,2}")) {
            timeStr += " 00:00:00"; // Assuming seconds format
        }


        // Try parsing with multiple formats
        List<String> patterns = List.of(
                "yyyy/M/d H:mm", "yyyy/M/d HH:mm",
                "yyyy/MM/d H:mm", "yyyy/MM/d HH:mm",
                "yyyy/M/dd H:mm", "yyyy/M/dd HH:mm",
                "yyyy/MM/dd H:mm", "yyyy/MM/dd HH:mm",
                "yyyy/MM/dd HH:mm:ss", // Added seconds format
                "yyyy-MM-dd HH:mm:ss", // Added dash format
                "yyyy/MM/dd" // Date only (handled above)
                // Add more patterns if needed based on your CSV data
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDateTime.parse(timeStr, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern and try the next
            }
        }
        System.err.println("AI Service: Failed to parse date string: " + timeStr);
        return null; // Return null if no pattern matches
    }


    // Keep askAi method
    public String askAi(String prompt) {
        try {
            if (API_KEY == null || API_KEY.trim().isEmpty()) {
                System.err.println("ARK_API_KEY environment variable is not set.");
                return "AI服务配置错误: ARK_API_KEY 未设置。";
            }
            // Ensure the static service instance is properly built with the key
            // This might be better done once at application startup if API_KEY is loaded from config.
            // For now, relying on the static final initialization is acceptable if the env var is set before class loading.


            List<ChatMessage> messages = List.of(
                    ChatMessage.builder().role(ChatMessageRole.USER).content(prompt).build()
            );

            ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
                    .model("ep-20250308174053-7pbkq") // Use your model name
                    .messages(messages)
                    .build();

            System.out.println("AI Service: Sending request to VolcEngine Ark...");
            // Use the static service instance
            String responseContent = (String) service.createChatCompletion(chatCompletionRequest)
                    .getChoices().get(0).getMessage().getContent();
            System.out.println("AI Service: Received response from AI.");
            return responseContent;

        } catch (Exception e) {
            System.err.println("AI Service: AI request failed.");
            e.printStackTrace();
            return "AI请求失败: " + e.getMessage();
        }
    }

    // Keep runAiInThread method, ensure it uses the correct analyzeTransactions method
    public void runAiInThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        // ExecutorService should ideally be managed at a higher level in a larger app,
        // but a simple single thread executor per request is acceptable for this scale.
        // However, this creates a new thread and executor every time.
        // A fixed thread pool managed statically or by a dedicated AI Service Manager would be more efficient.
        // For now, let's keep it simple as in the original code.

        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            // Call the instance method analyzeTransactions
            String result = this.analyzeTransactions(userRequest, filePath,startTimeStr, endTimeStr);
            System.out.println("AI analysis thread finished. Result: " + result);
            // TODO: How to pass the result back to the UI?
            // This thread doesn't have access to the UI components directly.
            // Need a mechanism like a callback or SwingUtilities.invokeLater.
            // This will be addressed when integrating AI output into the UI (Step 10).
        });
        // Consider shutting down the executor more gracefully, e.g., when the app exits.
        // executor.shutdown(); // Shutting down immediately might cancel the task
        // A better approach is `executor.shutdown()` after submitting, but manage the executor lifecycle elsewhere.
    }

    /**
     * Generates a personal consumption summary based on monthly data.
     * @param userFilePath The path to the user's transaction CSV file. (Might not be strictly needed if service handles context)
     * @return AI analysis result as a String.
     */
    public String generatePersonalSummary(String userFilePath) {
        try {
            // Get monthly summary data from TransactionService
            // Note: TransactionService already operates on the current user's data implicitly if passed correctly.
            // We might not need userFilePath explicitly in this method signature if the service instance is user-specific.
            // Let's assume the injected transactionService is already scoped to the current user.
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("AI Service: Retrieved " + summaries.size() + " months of summary data.");

            if (summaries.isEmpty()) {
                return "没有找到足够的交易数据来生成个人消费总结。";
            }

            // Format the summary data for the AI prompt
            StringBuilder summaryPromptBuilder = new StringBuilder();
            summaryPromptBuilder.append("请根据以下月度消费总结数据，生成一份个人消费习惯总结，分析主要开销类别、月度变化趋势，并评估我的消费健康度：\n\n");

            // Sort months chronologically for better trend analysis by AI
            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                summaryPromptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                summaryPromptBuilder.append("  总收入: ").append(String.format("%.2f", ms.getTotalIncome())).append("元\n");
                summaryPromptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                summaryPromptBuilder.append("  支出明细:\n");
                if (ms.getExpenseByCategory().isEmpty()) {
                    summaryPromptBuilder.append("    (无支出)\n");
                } else {
                    // Sort categories by amount descending for AI to easily see major categories
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    summaryPromptBuilder.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                            );
                }
                summaryPromptBuilder.append("\n"); // Add space between months
            }

            String aiPrompt = summaryPromptBuilder.toString();
            System.out.println("AI Service: Sending personal summary prompt to AI. Prompt length: " + aiPrompt.length());

            return askAi(aiPrompt); // Call the generic AI method
        } catch (Exception e) {
            System.err.println("AI Service: Failed to generate personal summary.");
            e.printStackTrace();
            return "生成个人消费总结失败: " + e.getMessage();
        }
    }

    /**
     * Generates suggestions for savings goals based on monthly data.
     * @param userFilePath The path to the user's transaction CSV file. (Might not be strictly needed)
     * @return AI suggestions as a String.
     */
    public String suggestSavingsGoals(String userFilePath) {
        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("AI Service: Retrieved " + summaries.size() + " months of summary data for savings goal suggestion.");

            if (summaries.isEmpty()) {
                return "没有找到足够的交易数据来建议储蓄目标。";
            }

            StringBuilder promptBuilder = new StringBuilder();
            promptBuilder.append("请根据以下月度收支总结数据，为我这个消费习惯提供一些合理的储蓄目标建议：\n\n");

            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  总收入: ").append(String.format("%.2f", ms.getTotalIncome())).append("元\n");
                promptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                double net = ms.getTotalIncome() - ms.getTotalExpense();
                promptBuilder.append("  月度净收支: ").append(String.format("%.2f", net)).append("元\n");
                promptBuilder.append("\n");
            }

            String aiPrompt = promptBuilder.toString();
            System.out.println("AI Service: Sending savings goals prompt to AI. Prompt length: " + aiPrompt.length());

            return askAi(aiPrompt);
        } catch (Exception e) {
            System.err.println("AI Service: Failed to suggest savings goals.");
            e.printStackTrace();
            return "建议储蓄目标失败: " + e.getMessage();
        }
    }

    /**
     * Generates personalized cost-cutting recommendations based on monthly data.
     * @param userFilePath The path to the user's transaction CSV file. (Might not be strictly needed)
     * @return AI recommendations as a String.
     */
    public String givePersonalSavingTips(String userFilePath) {
        try {
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary();
            System.out.println("AI Service: Retrieved " + summaries.size() + " months of summary data for saving tips.");

            if (summaries.isEmpty()) {
                return "没有找到足够的交易数据来提供个性化节约建议。";
            }

            StringBuilder promptBuilder = new StringBuilder();
            promptBuilder.append("请根据以下月度消费总结数据，为我提供一些针对性的节约开销建议：\n\n");

            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                promptBuilder.append("  支出明细:\n");
                if (ms.getExpenseByCategory().isEmpty()) {
                    promptBuilder.append("    (无支出)\n");
                } else {
                    // Sort categories by amount descending
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    promptBuilder.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                            );
                }
                promptBuilder.append("\n");
            }

            String aiPrompt = promptBuilder.toString();
            System.out.println("AI Service: Sending personal saving tips prompt to AI. Prompt length: " + aiPrompt.length());

            return askAi(aiPrompt);
        } catch (Exception e) {
            System.err.println("AI Service: Failed to give personal saving tips.");
            e.printStackTrace();
            return "生成个性化节约建议失败: " + e.getMessage();
        }
    }


    // ... Keep other methods like analyzeTransactions, formatTransactions, parseDateTime, askAi ...

    // The existing CollegeStudentNeeds class also has budget and tips methods.
    // We need to decide: should AITransactionService offer general AI for anyone,
    // and CollegeStudentNeeds offer student-specific prompts/logic?
    // Or should AITransactionService be the main AI interaction point,
    // and CollegeStudentNeeds just holds student-specific logic/prompts used by AITransactionService?
    // Given the project structure, it might be better to keep student logic in CollegeStudentNeeds
    // and call it from MenuUI or a wrapper service.
    // Let's adjust: generatePersonalSummary, suggestSavingsGoals, givePersonalSavingTips will use monthly summary.
    // CollegeStudentNeeds.generateBudget and generateTipsForSaving can remain using their current logic
    // (budget uses weekly expenses, tips is generic for now).
    // The prompt for CollegeStudentNeeds.generateBudget might need to be updated to use the monthly summary data too for better context.
    // Let's refine CollegeStudentNeeds methods in the next step.

    // For now, the three new methods above will use the monthly summary.
    // The existing analyzeTransactions method in AITransactionService and the methods in CollegeStudentNeeds remain as is for now,
    // but their usage in UI might change slightly.

}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\AIservice\ColledgeStudentThread.java`:

```java
package Service.AIservice;

// Add required imports
import Service.TransactionService; // Keep import if generateBudget throws Exception
// import java.io.IOException; // Removed specific IOException import if using general Exception


public class ColledgeStudentThread implements Runnable{
    // Remove the old budgetRange field, it's not used here
    // public String budgetRange;

    // Field to hold the injected CollegeStudentNeeds service instance
    private final CollegeStudentNeeds collegeStudentNeeds;
    // The file path is still needed to pass to the generateBudget method
    private final String filePath;


    /**
     * Constructor now accepts the CollegeStudentNeeds service instance and the file path.
     * The injected service instance already contains the necessary TransactionService.
     *
     * @param collegeStudentNeeds The CollegeStudentNeeds service instance to use for generating the budget.
     * @param filePath The path to the user's transaction data file.
     */
    public ColledgeStudentThread(CollegeStudentNeeds collegeStudentNeeds, String filePath) {
        this.collegeStudentNeeds = collegeStudentNeeds;
        this.filePath = filePath;
        System.out.println("ColledgeStudentThread initialized for file: " + filePath);
    }

    @Override
    public void run(){
        System.out.println("ColledgeStudentThread started for file: " + filePath);
        try {
            // Call the generateBudget method on the injected service instance
            double[] budget = collegeStudentNeeds.generateBudget(filePath);

            // Print the result or handle it as needed by the test/caller that starts this thread
            if (budget != null && budget.length == 2 && budget[0] != -1) {
                System.out.println("Budget generated in thread for file " + filePath + ": [" + budget[0] + ", " + budget[1] + "]");
            } else {
                // handle the case where budget generation failed or returned -1
                System.out.println("Budget generation in thread finished, but no valid budget was returned for file " + filePath + ".");
                // You might want to distinguish between "no data" (-1,-1) and other exceptions here.
            }
        } catch (Exception e) { // Catch Exception as generateBudget throws Exception
            System.err.println("Error generating budget in thread for file " + filePath + ": " + e.getMessage());
            e.printStackTrace();
        }
        System.out.println("ColledgeStudentThread finished for file: " + filePath);
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\AIservice\CollegeStudentNeeds.java`:

```java
package Service.AIservice;

// ... existing imports ...
import Constants.StandardCategories;
import DAO.TransactionDao;
import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheManager;
import model.Transaction;
import model.MonthlySummary; // Import MonthlySummary
import Service.TransactionService; // Import TransactionService interface


import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.Map; // Import Map
import java.util.Collections; // For sorting map entries
import java.util.Optional;
import java.util.stream.Collectors;


public class CollegeStudentNeeds {
    // Keep existing prompts, maybe refine them to mention using the data provided
    private final String requestBudge="我是一名预算有限的大学生，请根据下面我给出的历史周花费和月度收支总结，帮助我给下周预算范围，必须以[最低预算，最高预算],的方式给出回答，不能有多余的回复。";
    private final String requestTips="我是一名预算有限的大学生，请结合下面我给出的月度消费总结数据，为我推荐一些有针对性的省钱方法。"; // Refined prompt
    // Add the missing constant:
    private final String requestRecognition =
            "请根据以下账单信息推测最合适的交易类型。返回的类型必须精确匹配以下列表中的一个条目：\n" +
                    StandardCategories.getAllCategoriesString() + "\n" + // Include the list of valid categories
                    "如果无法确定，请返回 '其他支出' 或 '其他收入'（取决于收支方向）。只返回类型字符串，不要包含额外文本或解释。账单信息：";
    // AITransactionService is used for asking AI, can be an instance or created on demand
    // private final AITransactionService aiService = new AITransactionService(); // This instance won't have injected TransactionService

    // Need a way to get TransactionService here to generate monthly summaries
    // Option 1: Inject TransactionService into CollegeStudentNeeds constructor
    private final TransactionService transactionService; // Inject TransactionService

    /**
     * Constructor now accepts TransactionService instance.
     */
    public CollegeStudentNeeds(TransactionService transactionService) {
        this.transactionService = transactionService; // Inject the service
        System.out.println("CollegeStudentNeeds initialized with TransactionService.");
    }


    /**
     * Recognizes the spending category of a single transaction using AI. (Keep as is, uses raw transaction)
     *
     * @param transaction The transaction to recognize.
     * @return The AI's suggested category.
     */
    public String RecognizeTransaction(Transaction transaction){
        if (transaction == null) {
            return "无法识别空交易信息";
        }
        StringBuilder sb=new StringBuilder();
        sb.append("交易类型:").append(transaction.getTransactionType()).append(",")
                .append("交易对方:").append(transaction.getCounterparty()).append(",")
                .append("商品:").append(transaction.getCommodity()).append(",")
                .append("收/支:").append(transaction.getInOut()).append(",")
                .append("金额(元):").append(String.format("%.2f", transaction.getPaymentAmount())).append(",") // Format amount
                .append("支付方式:").append(transaction.getPaymentMethod()).append(",")
                .append("备注:").append(transaction.getRemarks());

        System.out.println("CollegeStudentNeeds: Sending recognition request to AI: " + sb.toString());
        // Need a separate AITransactionService instance or method call that doesn't depend on injected TransactionService
        // Option 2: Create a local AITransactionService instance just for askAi calls
        AITransactionService localAiService = new AITransactionService(null); // Pass null for TransactionService as it's not needed by askAi
        return  localAiService.askAi(requestRecognition + sb.toString());
    }

    /**
     * Generates saving tips for college students using AI, now based on monthly summary.
     * @param userFilePath The path to the user's transaction CSV file. (Not strictly needed if service is user-scoped)
     * @return AI's suggested saving tips.
     */
    // Refined to use monthly summary data
    public String generateTipsForSaving(String userFilePath){ // Keep filePath parameter for consistency or remove if service is user-scoped
        try {
            // Get monthly summary data from TransactionService
            Map<String, MonthlySummary> summaries = transactionService.getMonthlyTransactionSummary(); // Use injected service
            System.out.println("CollegeStudentNeeds: Retrieved " + summaries.size() + " months of summary data for tips.");

            if (summaries.isEmpty()) {
                return "没有找到足够的交易数据来提供个性化节约建议。";
            }

            StringBuilder promptBuilder = new StringBuilder();
            promptBuilder.append(requestTips).append("\n\n以下是我的月度消费总结数据：\n\n");

            // Sort months chronologically
            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                promptBuilder.append("  支出明细:\n");
                if (ms.getExpenseByCategory().isEmpty()) {
                    promptBuilder.append("    (无支出)\n");
                } else {
                    // Sort categories by amount descending
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    promptBuilder.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                            );
                }
                promptBuilder.append("\n");
            }

            String aiPrompt = promptBuilder.toString();
            System.out.println("CollegeStudentNeeds: Sending saving tips prompt to AI. Prompt length: " + aiPrompt.length());

            // Need a separate AITransactionService instance or method call that doesn't depend on injected TransactionService
            AITransactionService localAiService = new AITransactionService(null); // Pass null for TransactionService
            return localAiService.askAi(aiPrompt);

        } catch (Exception e) {
            System.err.println("CollegeStudentNeeds: Failed to generate saving tips.");
            e.printStackTrace();
            return "生成个性化节约建议失败: " + e.getMessage();
        }
    }

    /**
     * Analyzes weekly spending and asks AI for a budget range, now also includes monthly summary context.
     * @param filePath The path to the user's transaction CSV file.
     * @return A double array [minBudget, maxBudget] parsed from AI response, or [-1, -1] on failure.
     * @throws Exception If there's an error accessing the transaction data.
     */
    // Inside CollegeStudentNeeds class, modify the generateBudget method:

    public double[] generateBudget(String filePath) throws Exception {
        List<Transaction> transactions;
        Map<String, MonthlySummary> summaries; // Declare the summaries variable here

        try {
            // Get transactions using CacheManager
            TransactionDao transactionDaoForLoading = new CsvTransactionDao();
            transactions = CacheManager.getTransactions(filePath, transactionDaoForLoading);
            System.out.println("CollegeStudentNeeds: Retrieved " + transactions.size() + " transactions for budget analysis from: " + filePath);

            // Get monthly summary data for context
            summaries = transactionService.getMonthlyTransactionSummary(); // Assign to the declared variable
            System.out.println("CollegeStudentNeeds: Retrieved " + summaries.size() + " months of summary data for budget context.");

        } catch (Exception e) {
            System.err.println("CollegeStudentNeeds: Error retrieving transactions or summary for budget analysis: " + filePath);
            e.printStackTrace();
            throw e;
        }

        int size = transactions.size();
        if (size == 0) {
            System.out.println("CollegeStudentNeeds: No transactions found for budget analysis.");
            // If no transactions, prompt AI using only the monthly summary (if available)
            if (!summaries.isEmpty()) {
                // Build prompt with only monthly summary
                StringBuilder promptBuilder = new StringBuilder();
                promptBuilder.append("以下是我的月度收支总结数据：\n\n");
                // ... (Code to format monthly summaries for prompt - copy from generatePersonalSummary or generateTipsForSaving) ...
                List<String> sortedMonths = new ArrayList<>(summaries.keySet());
                Collections.sort(sortedMonths);
                for (String month : sortedMonths) {
                    MonthlySummary ms = summaries.get(month);
                    promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                    promptBuilder.append("  总收入: ").append(String.format("%.2f", ms.getTotalIncome())).append("元\n");
                    promptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                    double net = ms.getTotalIncome() - ms.getTotalExpense();
                    promptBuilder.append("  月度净收支: ").append(String.format("%.2f", net)).append("元\n");
                    promptBuilder.append("  主要支出类别:\n"); // Include expense category details
                    if (ms.getExpenseByCategory().isEmpty()) {
                        promptBuilder.append("    (无支出)\n");
                    } else {
                        ms.getExpenseByCategory().entrySet().stream()
                                .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                                .forEach(entry ->
                                        promptBuilder.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                                );
                    }
                    promptBuilder.append("\n");
                }
                // Use the local AI service instance to ask AI
                String answer = new AITransactionService(null).askAi(requestBudge + "\n\n没有找到周支出数据。\n" + promptBuilder.toString());
                return parseDoubleArrayFromString(answer);

            }
            return new double[]{-1, -1}; // No data at all
        }

        // Filter for '支出' transactions and sort them by date (newest first)
        List<Transaction> expenseTransactions = transactions.stream()
                .filter(t -> t.getInOut() != null && (t.getInOut().equals("支出") || t.getInOut().equals("支")))
                .sorted((t1, t2) -> {
                    LocalDate date1 = parseDateSafe(t1.getTransactionTime());
                    LocalDate date2 = parseDateSafe(t2.getTransactionTime());
                    if (date1 != null && date2 != null) { return date2.compareTo(date1); } else if (date1 == null && date2 == null) { return 0; } else if (date1 == null) { return 1; } else { return -1; }
                })
                .collect(Collectors.toList());
        System.out.println("CollegeStudentNeeds: Filtered " + expenseTransactions.size() + " expense transactions for budget analysis.");


        if (expenseTransactions.isEmpty()) {
            System.out.println("CollegeStudentNeeds: No expense transactions found for budget analysis.");
            // Still provide monthly summary context to AI if available
            if (!summaries.isEmpty()) {
                // Build prompt with only monthly summary
                StringBuilder promptBuilder = new StringBuilder();
                promptBuilder.append("以下是我的月度收支总结数据：\n\n");
                // ... (Code to format monthly summaries for prompt - copy from above) ...
                List<String> sortedMonths = new ArrayList<>(summaries.keySet());
                Collections.sort(sortedMonths);
                for (String month : sortedMonths) {
                    MonthlySummary ms = summaries.get(month);
                    promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                    promptBuilder.append("  总收入: ").append(String.format("%.2f", ms.getTotalIncome())).append("元\n");
                    promptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                    double net = ms.getTotalIncome() - ms.getTotalExpense();
                    promptBuilder.append("  月度净收支: ").append(String.format("%.2f", net)).append("元\n");
                    promptBuilder.append("  主要支出类别:\n"); // Include expense category details
                    if (ms.getExpenseByCategory().isEmpty()) {
                        promptBuilder.append("    (无支出)\n");
                    } else {
                        ms.getExpenseByCategory().entrySet().stream()
                                .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                                .forEach(entry ->
                                        promptBuilder.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                                );
                    }
                    promptBuilder.append("\n");
                }
                String answer = new AITransactionService(null).askAi(requestBudge + "\n\n没有找到周支出数据。\n" + promptBuilder.toString());
                return parseDoubleArrayFromString(answer);
            }
            return new double[]{-1, -1}; // No expense data and no summary data
        }

        // --- Weekly Expense Calculation (Keep existing logic) ---
        List<Double> weeklyExpenses = new ArrayList<>();
        LocalDate currentWeekStart = null;
        double currentWeekTotal = 0;

        for (Transaction expense : expenseTransactions) {
            LocalDate transactionDate = parseDateSafe(expense.getTransactionTime());
            if (transactionDate == null) continue;

            if (currentWeekStart == null) {
                currentWeekStart = transactionDate;
            }

            long daysDifference = ChronoUnit.DAYS.between(transactionDate, currentWeekStart);

            if (daysDifference >= 0 && daysDifference < 7) {
                currentWeekTotal += expense.getPaymentAmount();
            } else if (daysDifference >= 7) {
                weeklyExpenses.add(currentWeekTotal);
                currentWeekStart = transactionDate;
                currentWeekTotal = expense.getPaymentAmount();
            }
        }
        if (currentWeekTotal > 0 || currentWeekStart != null) {
            weeklyExpenses.add(currentWeekTotal);
        }
        System.out.println("CollegeStudentNeeds: Calculated weekly expenses for " + weeklyExpenses.size() + " weeks: " + weeklyExpenses);


        // --- Format Prompt including Weekly Expenses and Monthly Summary ---
        StringBuilder promptBuilder = new StringBuilder();
        promptBuilder.append(requestBudge).append("\n\n"); // Start with the budget request prompt

        // Add Weekly Expenses Section
        promptBuilder.append("以下是我最近的每周花费数据：\n");
        if (weeklyExpenses.isEmpty()) {
            promptBuilder.append("(没有找到足够周期的支出数据)\n");
        } else {
            for (int i = 0; i < weeklyExpenses.size(); i++) {
                promptBuilder.append("第");
                promptBuilder.append(weeklyExpenses.size() - 1 - i);
                promptBuilder.append("周:花费");
                promptBuilder.append(String.format("%.2f", weeklyExpenses.get(i)));
                promptBuilder.append("元; ");
            }
            promptBuilder.append("\n");
        }

        // Add Monthly Summary Section
        promptBuilder.append("\n同时，以下是我的月度收支总结数据：\n\n");
        if (summaries.isEmpty()) {
            promptBuilder.append("(没有找到月度总结数据)\n");
        } else {
            List<String> sortedMonths = new ArrayList<>(summaries.keySet());
            Collections.sort(sortedMonths);

            for (String month : sortedMonths) {
                MonthlySummary ms = summaries.get(month);
                promptBuilder.append("--- ").append(ms.getMonthIdentifier()).append(" ---\n");
                promptBuilder.append("  总收入: ").append(String.format("%.2f", ms.getTotalIncome())).append("元\n");
                promptBuilder.append("  总支出: ").append(String.format("%.2f", ms.getTotalExpense())).append("元\n");
                double net = ms.getTotalIncome() - ms.getTotalExpense();
                promptBuilder.append("  月度净收支: ").append(String.format("%.2f", net)).append("元\n");
                promptBuilder.append("  主要支出类别:\n"); // Include expense category details
                if (ms.getExpenseByCategory().isEmpty()) {
                    promptBuilder.append("    (无支出)\n");
                } else {
                    ms.getExpenseByCategory().entrySet().stream()
                            .sorted(Map.Entry.comparingByValue(Collections.reverseOrder()))
                            .forEach(entry ->
                                    promptBuilder.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                            );
                }
                promptBuilder.append("\n");
            }
        }


        String aiPrompt = promptBuilder.toString(); // This now contains the full prompt
        System.out.println("CollegeStudentNeeds: Sending budget request to AI. Prompt length: " + aiPrompt.length());

        // Use the local AI service instance to ask AI
        String answer = new AITransactionService(null).askAi(aiPrompt); // Pass null as askAi doesn't need TransactionService
        System.out.println("CollegeStudentNeeds: Received budget response from AI: " + answer);

        double[] ret = parseDoubleArrayFromString(answer);
        if (ret == null || ret.length != 2) {
            System.err.println("CollegeStudentNeeds: Failed to parse budget array from AI response: " + answer + ". Full AI Response: " + answer); // Log the full response
            return new double[]{-1, -1};
        }

        return ret;
    }

    // Helper method to safely parse date from transaction time string (must be consistent!)
    private LocalDate parseDateSafe(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // Clean whitespace and potential hyphens if the expected format is slash-separated
        String datePart = timeStr.split(" ")[0]; // Get the date part

        datePart = datePart.trim().replace('-', '/').replaceAll("\\s+", "");

        List<String> patterns = List.of(
                "yyyy/M/d", "yyyy/MM/d", "yyyy/M/dd", "yyyy/MM/dd",
                "yyyy-MM-dd" // Add dash format just in case
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDate.parse(datePart, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern
            }
        }
        System.err.println("CollegeStudentNeeds: Failed to parse date part '" + datePart + "' from transaction time: " + timeStr);
        return null; // Return null if no pattern matches
    }

    // Keep parseDoubleArrayFromString method - ensure robustness
    public double[] parseDoubleArrayFromString(String input) {
        // ... existing robust implementation ...
        if (input == null) { return null; }
        String trimmedInput = input.trim();
        System.out.println("CollegeStudentNeeds: Attempting to parse budget string: '" + trimmedInput + "'");
        int startIndex = trimmedInput.indexOf('[');
        int endIndex = trimmedInput.lastIndexOf(']');
        if (startIndex == -1 || endIndex == -1 || endIndex < startIndex) {
            System.err.println("CollegeStudentNeeds: Budget string does not contain valid []. Input: " + trimmedInput);
            return null;
        }
        String content = trimmedInput.substring(startIndex + 1, endIndex).trim();
        String[] numberStrings = content.split("\\s*,\\s*");
        if (numberStrings.length != 2) {
            System.err.println("CollegeStudentNeeds: Budget string content does not contain exactly two numbers separated by comma. Content: " + content);
            return null;
        }
        double[] result = new double[2];
        try {
            result[0] = Double.parseDouble(numberStrings[0].trim());
            result[1] = Double.parseDouble(numberStrings[1].trim());
            System.out.println("CollegeStudentNeeds: Successfully parsed budget: [" + result[0] + ", " + result[1] + "]");
            return result;
        } catch (NumberFormatException e) {
            System.err.println("CollegeStudentNeeds: Error parsing numbers from budget string: " + content);
            e.printStackTrace();
            return null;
        }
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\Impl\SummaryStatisticService.java`:

```java
package Service.Impl;

import Constants.StandardCategories; // Import StandardCategories
import DAO.TransactionDao; // Import TransactionDao interface
import DAO.UserDao; // Import UserDao interface
import DAO.SummaryStatisticDao; // Import SummaryStatisticDao interface
import model.SummaryStatistic;
import model.Transaction;
import model.User;
import Utils.CacheManager; // Import CacheManager
import Constants.ConfigConstants; // Import ConfigConstants for summary file path

import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.temporal.WeekFields; // For getting week of year
import java.util.*;
import java.util.stream.Collectors;
import java.time.format.DateTimeFormatter; // For generating timestamp

public class SummaryStatisticService {

    private final UserDao userDao;
    private final TransactionDao transactionDao; // Need a DAO instance for CacheManager loading
    private final SummaryStatisticDao summaryStatisticDao;
    private final String summaryFilePath;

    /**
     * Constructor to inject dependencies.
     * @param userDao DAO for user data.
     * @param transactionDao DAO for transaction data (used by CacheManager loader).
     * @param summaryStatisticDao DAO for summary statistics data.
     */
    public SummaryStatisticService(UserDao userDao, TransactionDao transactionDao, SummaryStatisticDao summaryStatisticDao) {
        this.userDao = userDao;
        this.transactionDao = transactionDao; // Injected for use in CacheManager loader
        this.summaryStatisticDao = summaryStatisticDao;
        this.summaryFilePath = ConfigConstants.SUMMARY_CSV_PATH; // Get summary file path from config
        System.out.println("SummaryStatisticService initialized. Summary file: " + summaryFilePath);
    }

    /**
     * Helper method to load all transactions from all user files.
     * Uses CacheManager to benefit from caching.
     * @param users List of all users.
     * @return A single list containing all transactions from all users.
     * @throws Exception If loading from any user file fails.
     */
    private List<Transaction> loadAllTransactionsFromAllUsers(List<User> users) throws Exception {
        List<Transaction> allTransactions = new ArrayList<>();
        for (User user : users) {
            String userFilePath = user.getTransactionFilePath();
            if (userFilePath != null && !userFilePath.trim().isEmpty()) {
                try {
                    // Use CacheManager to get transactions for this user's file
                    // Pass the transactionDao instance for the loader
                    List<Transaction> userTransactions = CacheManager.getTransactions(userFilePath, transactionDao);
                    allTransactions.addAll(userTransactions);
                    System.out.println("Loaded " + userTransactions.size() + " transactions for user: " + user.getUsername() + " from " + userFilePath);
                } catch (Exception e) {
                    System.err.println("Error loading transactions for user " + user.getUsername() + " from " + userFilePath + ". Skipping this user.");
                    e.printStackTrace();
                    // Decide whether to stop or continue if one user's file fails.
                    // Continuing is more robust for aggregate statistics.
                    // throw e; // Uncomment to stop processing if any user file fails
                }
            } else {
                System.out.println("User " + user.getUsername() + " has no transaction file path configured. Skipping.");
            }
        }
        return allTransactions;
    }


    /**
     * Helper method to group transactions by week identifier (YYYY-Www).
     * @param transactions The list of transactions.
     * @return A map where keys are week identifiers and values are lists of transactions in that week.
     */
    private Map<String, List<Transaction>> groupTransactionsByWeek(List<Transaction> transactions) {
        WeekFields weekFields = WeekFields.ISO; // ISO 8601 week numbering (Monday is the first day of the week)
        DateTimeFormatter weekFormatter = DateTimeFormatter.ofPattern("yyyy-'W'ww"); // Format as "YYYY-Www"

        return transactions.stream()
                .filter(t -> t.getTransactionTime() != null && !t.getTransactionTime().trim().isEmpty()) // Filter out transactions with no time
                .collect(Collectors.groupingBy(t -> {
                    try {
                        // Safely parse the transaction date (only date part is needed for week)
                        // Need to ensure the parser is consistent with the one in TransactionServiceImpl/AITransactionService
                        // Let's re-use the safe parsing logic or ensure consistency.
                        // Simplest: Use a helper method for date parsing just for this service, matching expected formats.
                        LocalDate date = parseDateFromTransactionTime(t.getTransactionTime());
                        if (date != null) {
                            return date.format(weekFormatter); // Format date to week identifier
                        }
                    } catch (Exception e) {
                        System.err.println("Failed to parse date for week grouping: " + t.getTransactionTime() + ". Skipping transaction.");
                        // Transaction with unparseable date will be grouped under 'null' or skipped by filter
                    }
                    return "未知周"; // Group unparseable dates under an 'unknown' key
                }));
    }

    // Helper method to parse date from transaction time string (should match other parsers)
    private LocalDate parseDateFromTransactionTime(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // Clean whitespace and potential hyphens if the expected format is slash-separated
        // Assume the format used in CSV/Transaction model is one of the parsers in other services
        // Let's use a robust set of date patterns matching parseDateTimeSafe in TransactionServiceImpl
        String datePart = timeStr.split(" ")[0]; // Get the date part

        datePart = datePart.trim().replace('-', '/').replaceAll("\\s+", "");


        // Try parsing with multiple slash formats
        List<String> patterns = List.of(
                "yyyy/M/d", "yyyy/MM/d", "yyyy/M/dd", "yyyy/MM/dd",
                "yyyy-MM-dd" // Add dash format just in case
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDate.parse(datePart, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern
            }
        }
        System.err.println("SummaryStatisticService: Failed to parse date part '" + datePart + "' from transaction time: " + timeStr);
        return null; // Return null if no pattern matches
    }


    /**
     * Retrieves all summary statistics from the data source.
     * @return List of summary statistics.
     * @throws IOException If loading fails.
     */
    public List<SummaryStatistic> getAllSummaryStatistics() throws IOException {
        // Simply delegate to the DAO
        return summaryStatisticDao.loadAllStatistics(summaryFilePath);
    }


    // --- Revised Plan for generateAndSaveWeeklyStatistics ---
    // The previous approach of loading all transactions and then grouping by week
    // doesn't easily allow counting unique users per week unless we augment the Transaction object
    // or wrap it with User info during loading.
    // A better approach for unique user count is to process user by user.

    public void generateAndSaveWeeklyStatistics() throws Exception {
        System.out.println("Generating weekly summary statistics (Revised approach)...");
        List<User> allUsers = userDao.getAllUsers();
        System.out.println("Loaded " + allUsers.size() + " users.");

        // Map to hold weekly stats per user (WeekId -> Map<UserId, UserWeeklyStats>)
        // This intermediate structure is complex.

        // Map to hold aggregated stats for each week (WeekId -> AggregatedWeeklyStats)
        Map<String, Double> totalIncomeByWeek = new HashMap<>();
        Map<String, Double> totalExpenseByWeek = new HashMap<>();
        Map<String, Map<String, Double>> expenseByCategoryByWeek = new HashMap<>(); // WeekId -> (Category -> Amount)
        Map<String, Set<String>> usersByWeek = new HashMap<>(); // WeekId -> Set<Username>

        WeekFields weekFields = WeekFields.ISO;
        DateTimeFormatter weekFormatter = DateTimeFormatter.ofPattern("yyyy-'W'ww");


        // Iterate through each user
        for (User user : allUsers) {
            String userFilePath = user.getTransactionFilePath();
            String username = user.getUsername();

            if (userFilePath != null && !userFilePath.trim().isEmpty()) {
                try {
                    // Load transactions for this user
                    List<Transaction> userTransactions = CacheManager.getTransactions(userFilePath, transactionDao);
                    System.out.println("Processing " + userTransactions.size() + " transactions for user: " + username);

                    // Iterate through transactions for this user
                    for (Transaction t : userTransactions) {
                        if (t.getTransactionTime() == null || t.getTransactionTime().trim().isEmpty()) {
                            System.err.println("Skipping transaction with no time for user " + username + ": " + t.getOrderNumber());
                            continue; // Skip transactions with no time
                        }

                        LocalDate date = parseDateFromTransactionTime(t.getTransactionTime());
                        if (date == null) {
                            System.err.println("Skipping transaction with unparseable date for user " + username + ": " + t.getTransactionTime());
                            continue; // Skip transactions with invalid date
                        }

                        String weekIdentifier = date.format(weekFormatter);

                        // Add user to the set for this week
                        usersByWeek.computeIfAbsent(weekIdentifier, k -> new HashSet<>()).add(username);

                        // Aggregate income/expense
                        if (t.getInOut() != null) {
                            String inOut = t.getInOut().trim();
                            if (inOut.equals("收入") || inOut.equals("收")) {
                                totalIncomeByWeek.put(weekIdentifier, totalIncomeByWeek.getOrDefault(weekIdentifier, 0.0) + t.getPaymentAmount());
                            } else if (inOut.equals("支出") || inOut.equals("支")) {
                                totalExpenseByWeek.put(weekIdentifier, totalExpenseByWeek.getOrDefault(weekIdentifier, 0.0) + t.getPaymentAmount());

                                // Aggregate expense by standard category
                                String rawType = t.getTransactionType();
                                String standardCategory = StandardCategories.getStandardCategory(rawType);
                                // Only aggregate standard expense categories for the top category calculation
                                if (StandardCategories.isStandardExpenseCategory(standardCategory) || !StandardCategories.ALL_KNOWN_TYPES.contains(standardCategory)) {
                                    String effectiveExpenseCategoryForTop = StandardCategories.isStandardExpenseCategory(standardCategory) ? standardCategory : "其他支出";
                                    expenseByCategoryByWeek.computeIfAbsent(weekIdentifier, k -> new HashMap<>())
                                            .put(effectiveExpenseCategoryForTop, expenseByCategoryByWeek.get(weekIdentifier).getOrDefault(effectiveExpenseCategoryForTop, 0.0) + t.getPaymentAmount());
                                }
                            }
                        }
                    }
                } catch (Exception e) {
                    System.err.println("Error loading transactions for user " + user.getUsername() + " from " + userFilePath + ". Skipping this user's data for statistics.");
                    e.printStackTrace();
                    // Continue processing other users
                }
            } else {
                System.out.println("User " + user.getUsername() + " has no transaction file path configured. Skipping for statistics.");
            }
        }
        System.out.println("Completed aggregation across all users by week.");


        // 5. Consolidate aggregated data into SummaryStatistic objects
        List<SummaryStatistic> calculatedStatistics = new ArrayList<>();
        DateTimeFormatter timestampFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String timestamp = LocalDateTime.now().format(timestampFormatter);

        // Iterate through all week identifiers found
        Set<String> allWeeks = new HashSet<>();
        allWeeks.addAll(totalIncomeByWeek.keySet());
        allWeeks.addAll(totalExpenseByWeek.keySet());
        allWeeks.addAll(usersByWeek.keySet());
        allWeeks.addAll(expenseByCategoryByWeek.keySet());

        List<String> sortedWeekIdentifiers = allWeeks.stream().sorted().collect(Collectors.toList());

        for (String weekIdentifier : sortedWeekIdentifiers) {
            double totalIncome = totalIncomeByWeek.getOrDefault(weekIdentifier, 0.0);
            double totalExpense = totalExpenseByWeek.getOrDefault(weekIdentifier, 0.0);
            int numberOfUsers = usersByWeek.getOrDefault(weekIdentifier, Collections.emptySet()).size();

            // Find top expense category for this week
            Map<String, Double> weeklyExpenseByCategory = expenseByCategoryByWeek.getOrDefault(weekIdentifier, Collections.emptyMap());
            String topExpenseCategory = "无支出";
            double topExpenseCategoryAmount = 0.0;

            Optional<Map.Entry<String, Double>> maxEntry = weeklyExpenseByCategory.entrySet().stream()
                    .max(Map.Entry.comparingByValue());

            if (maxEntry.isPresent()) {
                topExpenseCategory = maxEntry.get().getKey();
                topExpenseCategoryAmount = maxEntry.get().getValue();
            }

            calculatedStatistics.add(new SummaryStatistic(
                    weekIdentifier,
                    totalIncome,
                    totalExpense,
                    topExpenseCategory,
                    topExpenseCategoryAmount,
                    numberOfUsers,
                    timestamp // Timestamp is when the stats were generated, not per week
            ));
        }
        System.out.println("Created " + calculatedStatistics.size() + " SummaryStatistic objects.");


        // 6. Load existing statistics
        List<SummaryStatistic> existingStatistics = getAllSummaryStatistics();
        System.out.println("Loaded " + existingStatistics.size() + " existing summary statistics.");

        // 7. Merge existing and newly calculated statistics (overwrite new weeks, keep old)
        Map<String, SummaryStatistic> finalStatisticsMap = new HashMap<>();
        for(SummaryStatistic stat : existingStatistics) {
            finalStatisticsMap.put(stat.getWeekIdentifier(), stat);
        }
        for(SummaryStatistic stat : calculatedStatistics) {
            finalStatisticsMap.put(stat.getWeekIdentifier(), stat); // New calculation replaces old for the week
        }

        // 8. Sort merged statistics by week identifier (chronologically)
        List<SummaryStatistic> finalStatistics = finalStatisticsMap.values().stream()
                .sorted(Comparator.comparing(SummaryStatistic::getWeekIdentifier))
                .collect(Collectors.toList());

        // 9. Save the final list
        summaryStatisticDao.writeAllStatistics(summaryFilePath, finalStatistics);
        System.out.println("Weekly summary statistics generated and saved successfully to " + summaryFilePath);
    }


}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\Impl\TransactionServiceImpl.java`:

```java
package Service.Impl;

import Constants.StandardCategories;
import DAO.TransactionDao; // Import the interface
import DAO.Impl.CsvTransactionDao; // Import the implementation
import Service.TransactionService;
import Utils.CacheManager; // Import the new CacheManager
import model.MonthlySummary;
import model.Transaction;

import javax.swing.*;
import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.YearMonth;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors; // Needed for search

// Remove static field
// public static CsvTransactionDao csvTransactionDao;

// Remove direct CacheUtil instance
// public final CacheUtil<String, List<Transaction>, Exception> cache;

public class TransactionServiceImpl implements TransactionService {

    private final String currentUserTransactionFilePath; // Store the user's file path
    // TransactionDao instance needed to load data if cache misses
    private final TransactionDao transactionDao;

    /**
     * Constructor now accepts the user's transaction file path.
     *
     * @param currentUserTransactionFilePath The file path for the current user's transactions.
     */
    public TransactionServiceImpl(String currentUserTransactionFilePath) {
        this.currentUserTransactionFilePath = currentUserTransactionFilePath;
        // Create a DAO instance for this service instance.
        this.transactionDao = new CsvTransactionDao(); // One DAO instance per service instance
        System.out.println("TransactionServiceImpl initialized for file: " + currentUserTransactionFilePath);
        // Cache is managed by CacheManager, not directly by this instance.
    }

    @Override // Implement the new interface method
    public List<Transaction> getAllTransactions() throws Exception {
        // Simply call the internal method that uses the cache
        return getAllTransactionsForCurrentUser();
    }

    /**
     * Imports transactions from a given CSV file path into the current user's transactions.
     * Reads the import file, merges with existing data, and saves back.
     *
     * @param userFilePath The file path for the current user's transactions (target).
     * @param importFilePath The file path of the CSV to import from (source).
     * @return The number of transactions successfully imported.
     * @throws Exception If an error occurs during reading, parsing, or saving.
     */
    @Override // Implement the new interface method
    public int importTransactionsFromCsv(String userFilePath, String importFilePath) throws Exception {
        System.out.println("Starting import from " + importFilePath + " to user file " + userFilePath);
        List<Transaction> existingTransactions;
        List<Transaction> transactionsToImport;

        try {
            // 1. Load existing transactions for the current user (from cache/file)
            // Use the method that uses the CacheManager
            existingTransactions = getAllTransactions(); // Already uses CacheManager

            // 2. Read and parse transactions from the import file
            // Use the DAO's loadFromCSV method with the import file path
            // Need a *separate* DAO instance or method call that targets the import file
            TransactionDao importDao = new CsvTransactionDao(); // Create a temporary DAO for reading the import file
            transactionsToImport = importDao.loadFromCSV(importFilePath); // Load from the selected file
            System.out.println("Read " + transactionsToImport.size() + " transactions from import file.");

        } catch (IOException e) {
            System.err.println("Error loading files during import process.");
            e.printStackTrace();
            throw new Exception("读取交易数据失败！", e); // Wrap and re-throw
        }

        // 3. Merge imported transactions with existing ones
        // Simple merge: add all imported transactions.
        // Handle potential duplicates: check if order number exists.
        // If order numbers are not guaranteed unique in imported file or against existing,
        // consider generating new unique IDs for imported items if their ON is empty or conflicts.
        List<Transaction> mergedTransactions = new ArrayList<>(existingTransactions);
        int importedCount = 0;

        for (Transaction importedTx : transactionsToImport) {
            // Basic Check: Ensure imported transaction has an order number or generate one
            if (importedTx.getOrderNumber() == null || importedTx.getOrderNumber().trim().isEmpty()) {
                // Generate a unique ID for transactions without one
                String uniqueId = "IMPORT_" + UUID.randomUUID().toString();
                importedTx.setOrderNumber(uniqueId);
                System.out.println("Generated unique order number for imported transaction: " + uniqueId);
            } else {
                // Check for potential duplicate order number against existing transactions
                boolean duplicate = existingTransactions.stream()
                        .anyMatch(t -> t.getOrderNumber().trim().equals(importedTx.getOrderNumber().trim()));
                if (duplicate) {
                    System.err.println("Skipping imported transaction due to duplicate order number: " + importedTx.getOrderNumber());
                    // Decide: skip, overwrite, or generate new ID. Skipping for now.
                    JOptionPane.showMessageDialog(null, "发现重复交易单号: " + importedTx.getOrderNumber() + ", 已跳过。", "导入警告", JOptionPane.WARNING_MESSAGE);
                    continue; // Skip this duplicate transaction
                }
            }

            // Add the transaction to the merged list
            mergedTransactions.add(importedTx);
            importedCount++;
        }
        System.out.println("Merged transactions. Total after merge: " + mergedTransactions.size() + ". Successfully imported count: " + importedCount);


        // 4. Save the merged list back to the current user's file
        try {
            // Use the DAO instance associated with this service (which knows the user's file implicitly via CacheManager interactions, but writeAllStatistics needs the path explicitly)
            // The transactionDao field is initialized as CsvTransactionDao, which has writeAllStatistics.
            transactionDao.writeTransactionsToCSV(userFilePath, mergedTransactions);
            System.out.println("Saved merged transactions to user file: " + userFilePath);

            // 5. Invalidate or update the cache for the current user's file
            // Invalidation is simpler: forces CacheManager to reload from the updated file next time.
            CacheManager.invalidateTransactionCache(userFilePath);
            System.out.println("Cache invalidated for user file: " + userFilePath);


        } catch (IOException e) {
            System.err.println("Error saving merged transactions after import.");
            e.printStackTrace();
            // Consider leaving the original file untouched on save failure
            throw new Exception("保存导入的交易数据失败！", e); // Wrap and re-throw
        }

        System.out.println("Import process finished.");
        return importedCount; // Return the count of transactions actually added
    }

    /**
     * Gets all transactions for the current user from the cache (loading if necessary).
     * Made protected or public if needed by subclasses, but private is fine for now.
     * @return List of transactions.
     * @throws Exception If an error occurs during loading.
     */
    private List<Transaction> getAllTransactionsForCurrentUser() throws Exception { // Kept as private or change if needed
        // Get transactions using the CacheManager for the current user's file
        return CacheManager.getTransactions(currentUserTransactionFilePath, transactionDao);
    }


//    /**
//     * Gets all transactions for the current user from the cache (loading if necessary).
//     *
//     * @return List of transactions.
//     * @throws Exception If an error occurs during loading.
//     */
//    private List<Transaction> getAllTransactionsForCurrentUser() throws Exception {
//        // Get transactions using the CacheManager for the current user's file
//        return CacheManager.getTransactions(currentUserTransactionFilePath, transactionDao);
//    }


    /**
     * Add transaction for the current user.
     *
     * @param transaction The new transaction to add.
     */
    @Override
    public void addTransaction(Transaction transaction) throws IOException {
        // Set transaction time to current time if not already set
        if (transaction.getTransactionTime() == null || transaction.getTransactionTime().isEmpty()) {
            LocalDateTime now = LocalDateTime.now();
            // Using a flexible format, match parseDateTime in AITransactionService
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
            String currentTime = now.format(formatter);
            transaction.setTransactionTime(currentTime);
        }

        try {
            // Call DAO layer to add transaction to the user's specific file
            transactionDao.addTransaction(currentUserTransactionFilePath, transaction);

            // After adding, invalidate the cache for this user's file
            // Or, ideally, reload the data and put the new list into the cache.
            // Invalidation is simpler for now, forcing a reload on next get.
            CacheManager.invalidateTransactionCache(currentUserTransactionFilePath);
            System.out.println("Transaction added and cache invalidated for " + currentUserTransactionFilePath);

        } catch (IOException e) {
            System.err.println("Error adding transaction for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e; // Re-throw
        }
    }

    /**
     * Change transaction information for the current user.
     *
     * @param updatedTransaction The transaction object with updated information.
     */
    @Override
    public void changeTransaction(Transaction updatedTransaction) throws Exception {
        try {
            // Load existing transactions (from cache/file)
            List<Transaction> allTransactions = getAllTransactionsForCurrentUser();

            // Find and update the target transaction in the list
            boolean foundAndUpdatedInMemory = false;
            List<Transaction> updatedList = new ArrayList<>(allTransactions.size()); // Create a new list or modify in place
            for (Transaction t : allTransactions) {
                if (t.getOrderNumber().trim().equals(updatedTransaction.getOrderNumber().trim())) {
                    // Found the transaction, apply updates
                    updateTransactionFields(t, updatedTransaction); // Helper method to apply updates
                    updatedList.add(t); // Add the modified transaction
                    foundAndUpdatedInMemory = true;
                    System.out.println("Transaction with order number " + updatedTransaction.getOrderNumber() + " found and updated in memory.");
                } else {
                    updatedList.add(t); // Add unchanged transactions
                }
            }


            if (!foundAndUpdatedInMemory) {
                throw new IllegalArgumentException("未找到交易单号: " + updatedTransaction.getOrderNumber() + " 在文件 " + currentUserTransactionFilePath + " 中");
            }

            // Write the entire updated list back to the CSV file
            transactionDao.writeTransactionsToCSV(currentUserTransactionFilePath, updatedList);
            System.out.println("Updated transaction with order number " + updatedTransaction.getOrderNumber() + " and wrote back to file.");

            // Update the cache with the modified list
            CacheManager.putTransactions(currentUserTransactionFilePath, updatedList, transactionDao);
            System.out.println("Cache updated with the modified transaction list for " + currentUserTransactionFilePath);

        } catch (IOException e) {
            System.err.println("Error changing transaction for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e;
        } catch (Exception e) { // Catch exception from getAllTransactionsForCurrentUser
            System.err.println("Error loading transactions for change operation: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e;
        }
    }

    /**
     * Helper method: Updates non-empty fields from source to target.
     */
    private void updateTransactionFields(Transaction target, Transaction source) {
        // Assuming orderNumber is the key and shouldn't be updated this way
        // Add checks for null and empty strings before updating
        if (source.getTransactionTime() != null && !source.getTransactionTime().trim().isEmpty()) {
            target.setTransactionTime(source.getTransactionTime().trim());
        }
        if (source.getTransactionType() != null && !source.getTransactionType().trim().isEmpty()) {
            target.setTransactionType(source.getTransactionType().trim());
        }
        if (source.getCounterparty() != null && !source.getCounterparty().trim().isEmpty()) {
            target.setCounterparty(source.getCounterparty().trim());
        }
        if (source.getCommodity() != null && !source.getCommodity().trim().isEmpty()) {
            target.setCommodity(source.getCommodity().trim());
        }
        // Handle InOut specifically if it's from a ComboBox with predefined options
        if (source.getInOut() != null && !source.getInOut().trim().isEmpty()) {
            String inOut = source.getInOut().trim();
            if (inOut.equals("收入") || inOut.equals("支出") || inOut.equals("支") || inOut.equals("收")) { // Be flexible with input
                target.setInOut(inOut);
            } else {
                System.err.println("Warning: Invalid value for 收/支: " + source.getInOut() + ". Keeping original.");
                // Optionally throw an IllegalArgumentException
            }
        }
        // Handle paymentAmount - 0.0 might be a valid amount, check if it was explicitly set
        // A better approach for primitive types is to check if the source object
        // represents a "partial update" and how unset primitives are marked.
        // For simplicity here, let's assume 0.0 *is* a valid amount that can be set.
        // If you need to differentiate "not set" from "set to 0.0", the source object
        // would need flags or use wrapper types (Double) and check for null.
        // Let's refine this: Only update if the source amount is NOT 0.0, or if the source object signals it's a full update.
        // Assuming the UI passes a new Transaction object where primitive 0.0 means 'not updated'.
        // This is a common pattern but needs careful handling.
        // If the UI explicitly allows setting 0.0, this logic needs adjustment.
        // For now, let's assume 0.0 is treated as 'no update' UNLESS the original transaction amount was also 0.0.
        // A safer way: If the user edited the amount field in the dialog, we *should* update it, even to 0.0.
        // The MenuUI's editRow extracts values into fields, so we can assume the value from fields[5].getText()
        // represents the user's intended new value. The Double.parseDouble already happened in MenuUI.
        // So, if the source object has a non-zero amount, update. What if the user wants to set it to 0?
        // The current dialog doesn't distinguish. Let's assume for now that any double value from the dialog
        // should be applied. This might need refinement based on UI behavior.
        target.setPaymentAmount(source.getPaymentAmount()); // Simply update the amount


        if (source.getPaymentMethod() != null && !source.getPaymentMethod().trim().isEmpty()) {
            target.setPaymentMethod(source.getPaymentMethod().trim());
        }
        if (source.getCurrentStatus() != null && !source.getCurrentStatus().trim().isEmpty()) {
            target.setCurrentStatus(source.getCurrentStatus().trim());
        }
        // OrderNumber is typically the key, updating it is risky and often disallowed.
        // If allowed, need to ensure uniqueness and handle file operations carefully.
        // Let's assume OrderNumber should NOT be changed via this method.
        // if (source.getOrderNumber() != null && !source.getOrderNumber().trim().isEmpty()) {
        //     target.setOrderNumber(source.getOrderNumber().trim()); // Potential issue if new ON conflicts
        // }
        if (source.getMerchantNumber() != null && !source.getMerchantNumber().trim().isEmpty()) {
            target.setMerchantNumber(source.getMerchantNumber().trim());
        }
        if (source.getRemarks() != null && !source.getRemarks().trim().isEmpty()) {
            target.setRemarks(source.getRemarks().trim());
        }
        System.out.println("Applied updates to transaction: " + target.getOrderNumber());
    }


    /**
     * Delete transaction for the current user by order number.
     *
     * @param orderNumber The unique order number of the transaction to delete.
     * @return true if deletion was successful.
     * @throws Exception If an error occurs or transaction is not found.
     */
    @Override
    public boolean deleteTransaction(String orderNumber) throws Exception {
        try {
            // Call DAO layer to delete transaction from the user's specific file
            boolean deleted = transactionDao.deleteTransaction(currentUserTransactionFilePath, orderNumber);

            if (deleted) {
                // After deleting, invalidate the cache for this user's file
                CacheManager.invalidateTransactionCache(currentUserTransactionFilePath);
                System.out.println("Transaction with order number " + orderNumber + " deleted and cache invalidated for " + currentUserTransactionFilePath);
            } else {
                // If DAO returns false, it means the order number was not found.
                System.out.println("Transaction with order number " + orderNumber + " not found for deletion in " + currentUserTransactionFilePath);
            }
            return deleted; // Return true if deletion occurred, false if not found

        } catch (IOException e) {
            System.err.println("Error deleting transaction for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            throw e; // Re-throw
        }
        // No need for explicit "未找到交易单号" exception here if DAO returns false,
        // MenuUI can check the boolean result and show a message.
    }

    /**
     * Search transactions for the current user based on criteria.
     *
     * @param searchCriteria The Transaction object containing search criteria.
     * @return List of matched transactions.
     */
    @Override
    public List<Transaction> searchTransaction(Transaction searchCriteria) {
        try {
            // 1. Get all transactions for the current user (from cache/file)
            List<Transaction> allTransactions = getAllTransactionsForCurrentUser();
            System.out.println("Searching through " + allTransactions.size() + " transactions for user " + currentUserTransactionFilePath);


            // 2. Filter transactions based on criteria
            // Use stream().filter() for conciseness and potential parallelism (though unlikely needed here)
            List<Transaction> matched = allTransactions.stream()
                    .filter(t -> matchesCriteria(t, searchCriteria))
                    .collect(Collectors.toList());
            System.out.println("Found " + matched.size() + " matching transactions.");


            // 3. Sort matched transactions by time, newest first
            matched.sort((t1, t2) -> {
                // Safely parse and compare dates, fall back to string comparison if parsing fails
                LocalDateTime time1 = parseDateTimeSafe(t1.getTransactionTime());
                LocalDateTime time2 = parseDateTimeSafe(t2.getTransactionTime());

                if (time1 != null && time2 != null) {
                    return time2.compareTo(time1); // Newest first
                } else if (time1 == null && time2 == null) {
                    return 0; // Both unparseable, treat as equal
                } else if (time1 == null) {
                    return 1; // Unparseable times come later
                } else { // time2 == null
                    return -1; // Unparseable times come later
                }
            });
            System.out.println("Matched transactions sorted.");

            return matched;
        } catch (Exception e) { // Catch exception from getAllTransactionsForCurrentUser
            System.err.println("Error during search operation for user file: " + currentUserTransactionFilePath);
            e.printStackTrace();
            // Depending on UI, you might want to return an empty list or propagate the exception
            // For search, returning empty list and logging error is often user-friendly.
            return List.of();
        }
    }

    /**
     * Helper method: Checks if a single transaction matches the search criteria.
     */
    private boolean matchesCriteria(Transaction transaction, Transaction criteria) {
        // Criteria fields are implicitly ANDed. Null/empty criteria fields match everything.
        return containsIgnoreCase(transaction.getTransactionTime(), criteria.getTransactionTime())
                && containsIgnoreCase(transaction.getTransactionType(), criteria.getTransactionType())
                && containsIgnoreCase(transaction.getCounterparty(), criteria.getCounterparty())
                && containsIgnoreCase(transaction.getCommodity(), criteria.getCommodity())
                && matchesInOutCriteria(transaction.getInOut(), criteria.getInOut()) // Specific check for In/Out
                && containsIgnoreCase(transaction.getPaymentMethod(), criteria.getPaymentMethod());
        // Note: paymentAmount is not used as a search criterion in MenuUI's search panel currently.
        // If needed, add logic here, e.g., checking if criteria.getPaymentAmount() is set
        // and if transaction.getPaymentAmount() falls within a range or matches exactly.
    }

    /**
     * Helper method: Fuzzy match string, ignoring case and trimming whitespace.
     * An empty/null target criteria matches everything.
     */
    private boolean containsIgnoreCase(String source, String target) {
        if (target == null || target.trim().isEmpty()) {
            return true; // Empty criteria matches everything
        }
        if (source == null) {
            return false; // Source is null, cannot contain non-empty target
        }
        return source.trim().toLowerCase().contains(target.trim().toLowerCase());
    }

    /**
     * Helper method: Matches In/Out criteria. Handles cases like "收入" vs "收", "支出" vs "支".
     * An empty/null target criteria matches everything.
     */
    private boolean matchesInOutCriteria(String source, String target) {
        if (target == null || target.trim().isEmpty()) {
            return true; // Empty criteria matches everything
        }
        if (source == null) {
            return false; // Source is null
        }
        String sourceTrimmed = source.trim();
        String targetTrimmed = target.trim();

        if (targetTrimmed.equalsIgnoreCase("收入") || targetTrimmed.equalsIgnoreCase("收")) {
            return sourceTrimmed.equalsIgnoreCase("收入") || sourceTrimmed.equalsIgnoreCase("收");
        }
        if (targetTrimmed.equalsIgnoreCase("支出") || targetTrimmed.equalsIgnoreCase("支")) {
            return sourceTrimmed.equalsIgnoreCase("支出") || sourceTrimmed.equalsIgnoreCase("支");
        }
        // If target is something else, do a simple contains check
        return sourceTrimmed.toLowerCase().contains(targetTrimmed.toLowerCase());
    }


    /**
     * Helper method: Safely parses a time string into LocalDateTime.
     * Returns null if parsing fails.
     * Should match the formats used in AITransactionService.parseDateTime.
     */
    private LocalDateTime parseDateTimeSafe(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // 中文空格等统一清理
        timeStr = timeStr.trim().replaceAll("\\s+", " ");

        // If only date is present, append 00:00
        if (timeStr.matches("\\d{4}/\\d{1,2}/\\d{1,2}")) {
            timeStr += " 00:00";
        } else if (timeStr.matches("\\d{4}-\\d{1,2}-\\d{1,2}")) {
            timeStr += " 00:00:00"; // Assuming yyyy-MM-dd uses seconds format
        }


        // Try parsing with multiple formats
        List<String> patterns = List.of(
                "yyyy/M/d H:mm", "yyyy/M/d HH:mm",
                "yyyy/MM/d H:mm", "yyyy/MM/d HH:mm",
                "yyyy/M/dd H:mm", "yyyy/M/dd HH:mm",
                "yyyy/MM/dd H:mm", "yyyy/MM/dd HH:mm",
                "yyyy/MM/dd HH:mm:ss", // Added seconds format
                "yyyy-MM-dd HH:mm:ss", // Added dash format
                "yyyy/MM/dd" // Added date only format (already handled by adding 00:00)
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDateTime.parse(timeStr, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern and try the next
            }
        }
        System.err.println("Failed to parse date string: " + timeStr);
        return null; // Return null if no pattern matches
    }

    /**
     * Aggregates transactions for the current user by month and standard category.
     *
     * @return A map where keys are month identifiers (e.g., "YYYY-MM") and values are MonthlySummary objects.
     * @throws Exception If an error occurs during data retrieval.
     */
    @Override // Implement the new interface method
    public Map<String, MonthlySummary> getMonthlyTransactionSummary() throws Exception {
        System.out.println("Generating monthly transaction summary for user file: " + currentUserTransactionFilePath);
        List<Transaction> allTransactions;
        try {
            // 1. Get all transactions for the current user (from cache/file)
            allTransactions = getAllTransactions(); // Uses CacheManager
            System.out.println("Retrieved " + allTransactions.size() + " transactions for summary.");

        } catch (Exception e) {
            System.err.println("Error retrieving transactions for summary generation.");
            e.printStackTrace();
            throw new Exception("获取交易数据失败！", e);
        }

        // 2. Aggregate transactions by month and category
        Map<String, MonthlySummary> monthlySummaries = new HashMap<>();
        DateTimeFormatter monthFormatter = DateTimeFormatter.ofPattern("yyyy-MM"); // Format for month identifier


        for (Transaction t : allTransactions) {
            if (t.getTransactionTime() == null || t.getTransactionTime().trim().isEmpty()) {
                System.err.println("Skipping transaction with no time for summary aggregation: " + t.getOrderNumber());
                continue; // Skip transactions with no time
            }

            // Safely parse the transaction date to get the month
            LocalDate date = parseDateFromTransactionTimeSafe(t.getTransactionTime()); // Use a robust date parser
            if (date == null) {
                System.err.println("Skipping transaction with unparseable date for summary aggregation: " + t.getTransactionTime() + " - " + t.getOrderNumber());
                continue; // Skip transactions with invalid date
            }

            // Get month identifier (e.g., "2025-03")
            String monthIdentifier = YearMonth.from(date).format(monthFormatter);

            // Get or create the MonthlySummary object for this month
            monthlySummaries.putIfAbsent(monthIdentifier, new MonthlySummary(monthIdentifier));
            MonthlySummary currentMonthSummary = monthlySummaries.get(monthIdentifier);

            // Add transaction amount to the summary based on type (Income/Expense)
            if (t.getInOut() != null) {
                String inOut = t.getInOut().trim();
                if (inOut.equals("收入") || inOut.equals("收")) {
                    currentMonthSummary.addIncome(t.getPaymentAmount());
                } else if (inOut.equals("支出") || inOut.equals("支")) {
                    // Get the standard category for the expense
                    String rawType = t.getTransactionType();
                    // Use the helper to map to a standard category, defaulting to "其他支出" if no direct standard match
                    String standardCategory = StandardCategories.getStandardCategory(rawType);
                    // For aggregation, we might want to map any non-standard expense type to "其他支出"
                    String effectiveExpenseCategoryForSummary = StandardCategories.isStandardExpenseCategory(standardCategory) ? standardCategory : "其他支出";

                    currentMonthSummary.addExpense(t.getPaymentAmount(), effectiveExpenseCategoryForSummary);
                }
                // Ignore special types (like Transfer, Red Packet) for simple income/expense summary, or handle them separately if needed
            }
        }
        System.out.println("Generated summary for " + monthlySummaries.size() + " months.");

        return monthlySummaries; // Return the map of monthly summaries
    }

    // Helper method to parse date from transaction time string safely
    // This should be consistent across all services/DAOs that parse dates.
    // Let's use a consistent, robust parser.
    // This method is similar to parseDateTimeSafe in this class and parseDateFromTransactionTime in SummaryStatisticService.
    // Consider extracting this to a shared Util class if many places need it.
    // For now, keep a consistent copy.
    private LocalDate parseDateFromTransactionTimeSafe(String timeStr) {
        if (timeStr == null || timeStr.trim().isEmpty()) return null;

        // Clean whitespace and replace potential hyphens with slashes if the expected format is slash-separated
        String datePart = timeStr.split(" ")[0]; // Get the date part

        datePart = datePart.trim().replace('-', '/').replaceAll("\\s+", "");


        // Try parsing with multiple slash formats
        List<String> patterns = List.of(
                "yyyy/M/d", "yyyy/MM/d", "yyyy/M/dd", "yyyy/MM/dd",
                "yyyy-MM-dd" // Add dash format just in case
        );

        for (String pattern : patterns) {
            try {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                return LocalDate.parse(datePart, formatter);
            } catch (Exception ignored) {
                // Ignore parsing errors for this pattern
            }
        }
        System.err.println("TransactionServiceImpl: Failed to parse date part '" + datePart + "' from transaction time: " + timeStr);
        return null; // Return null if no pattern matches
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\TransactionService.java`:

```java
package Service;

import model.MonthlySummary;
import model.Transaction;

import java.io.IOException;
import java.util.List;
import java.util.Map;

public interface TransactionService {

    /**
     * Gets all transactions for the current user.
     * @return List of all transactions.
     * @throws Exception If data retrieval fails (e.g., IO error, cache issue).
     */
    List<Transaction> getAllTransactions() throws Exception; // Added this method


    /**
     * 新增交易
     * @param transaction
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * 修改交易
     * @param transaction
     * @throws Exception If modification fails.
     */
    void changeTransaction(Transaction transaction) throws Exception;

    /**
     * 根据订单号删除交易
     * @param orderNumber
     * @return true if deletion was successful, false if transaction not found.
     * @throws Exception If deletion fails (e.g., IO error).
     */
    boolean deleteTransaction(String orderNumber) throws Exception; // Changed return type to boolean

    /**
     * 根据用户输入信息查询交易
     * @param transaction Search criteria.
     * @return List of matched transactions.
     */
    List<Transaction> searchTransaction(Transaction transaction);

    /**
     * Imports transactions from a given CSV file path into the current user's transactions.
     *
     * @param userFilePath The file path for the current user's transactions (target).
     * @param importFilePath The file path of the CSV to import from (source).
     * @return The number of transactions successfully imported.
     * @throws Exception If an error occurs during reading, parsing, or saving.
     */
    int importTransactionsFromCsv(String userFilePath, String importFilePath) throws Exception; // Added this method


    /**
     * Aggregates transactions for the current user by month and standard category.
     *
     * @return A map where keys are month identifiers (e.g., "YYYY-MM") and values are MonthlySummary objects.
     * @throws Exception If an error occurs during data retrieval.
     */
    Map<String, MonthlySummary> getMonthlyTransactionSummary() throws Exception; // Added this method
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\User\UserService.java`:

```java
package Service.User; // Changed package

import DAO.UserDao;
import model.User;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class UserService {
    private final UserDao userDao;
    private final Map<String, User> userCache = new HashMap<>(); // Cache users in memory

    public UserService(UserDao userDao) {
        this.userDao = userDao;
        loadUsers(); // Load users when the service is initialized
    }

    private void loadUsers() {
        try {
            List<User> users = userDao.getAllUsers();
            userCache.clear(); // Clear previous cache
            for (User user : users) {
                userCache.put(user.getUsername(), user);
            }
            System.out.println("Loaded " + userCache.size() + " users into cache.");
        } catch (IOException e) {
            System.err.println("Failed to load users from data source.");
            e.printStackTrace();
            // Depending on requirements, you might want to exit or handle this more gracefully
            // For now, we'll allow the app to run with an empty user list, though login will fail.
        }
    }

    /**
     * Authenticates a user.
     *
     * @param username The username.
     * @param password The password.
     * @return The authenticated User object if successful, null otherwise.
     */
    public User authenticate(String username, String password) {
        if (username == null || username.trim().isEmpty() || password == null || password.trim().isEmpty()) {
            return null;
        }

        User user = userCache.get(username.trim());
        if (user != null && user.getPassword().equals(password.trim())) { // Simple password check
            System.out.println("Authentication successful for user: " + username);
            return user; // Authentication successful, return the User object
        }
        System.out.println("Authentication failed for username: " + username);
        return null; // Authentication failed
    }

    /**
     * Retrieves a user by username from the cache.
     * @param username The username.
     * @return The User object or null if not found.
     */
    public User getUserByUsername(String username) {
        if (username == null || username.trim().isEmpty()) {
            return null;
        }
        return userCache.get(username.trim());
    }


    // Add other user management methods if needed (e.g., registerUser, deleteUser)
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Service\deepseek\ChatCompletionsExample.java`:

```java
package Service.deepseek;

import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;
import okhttp3.ConnectionPool;
import okhttp3.Dispatcher;
import org.apache.commons.lang.StringUtils;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
public class ChatCompletionsExample {
    static String apiKey = System.getenv("ARK_API_KEY");
    static ConnectionPool connectionPool = new ConnectionPool(5, 1, TimeUnit.SECONDS);
    static Dispatcher dispatcher = new Dispatcher();
    // The output time of the reasoning model is relatively long. Please increase the timeout period.//
    static ArkService service = ArkService.builder().timeout(Duration.ofSeconds(1800)).connectTimeout(Duration.ofSeconds(20)).dispatcher(dispatcher).connectionPool(connectionPool).baseUrl("https://ark.cn-beijing.volces.com/api/v3").apiKey(apiKey).build();

//    public static void main(String[] args) {
//        System.out.println(" [Recommended]----- streaming request -----");
//        final List<ChatMessage> streamMessages = new ArrayList<>();
//        final ChatMessage streamUserMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("请回答15.11和15.9哪个大？").build();
//        streamMessages.add(streamUserMessage);
//        ChatCompletionRequest streamChatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(streamMessages)
//                .build();
//        service.streamChatCompletion(streamChatCompletionRequest)
//                .doOnError(Throwable::printStackTrace)
//                .blockingForEach(
//                        delta -> {
//                            if (!delta.getChoices().isEmpty()) {
//                                if (StringUtils.isNotEmpty(delta.getChoices().get(0).getMessage().getReasoningContent())) {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getReasoningContent());
//                                } else {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getContent());
//                                }
//                            }
//                        }
//                );
//        System.out.println(" ----- standard request -----");
//        final List<ChatMessage> messages = new ArrayList<>();
//        final ChatMessage userMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("常见的十字花科植物有哪些？").build();
//        messages.add(userMessage);
//        ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(messages)
//                .build();
//        service.createChatCompletion(chatCompletionRequest).getChoices().forEach(
//                choice -> {
//                    System.out.println(choice.getMessage().getReasoningContent());
//                    System.out.println(choice.getMessage().getContent());
//                }
//        );
//        // shutdown service after all requests is finished
//        service.shutdownExecutor();
//    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Utils\CacheManager.java`:

```java
package Utils;

import Constants.CaffeineKeys;
import DAO.Impl.CsvTransactionDao; // Assuming CsvTransactionDao is in DAO.Impl
import DAO.TransactionDao; // Assuming TransactionDao interface is in DAO
import model.Transaction;
import com.github.benmanes.caffeine.cache.Cache; // Use general Cache interface
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.LoadingCache;

import java.io.IOException;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

/**
 * Manages Caffeine caches for different transaction data files (per user).
 * Uses the file path as the cache key.
 */
public class CacheManager {

    // Use a map to hold caches, keyed by file path
    // The value is the Caffeine LoadingCache for that specific file path
    private static final ConcurrentHashMap<String, LoadingCache<String, List<Transaction>>> fileCaches = new ConcurrentHashMap<>();

    // Define default cache parameters
    private static final int DEFAULT_MAX_SIZE = 1; // Only cache one instance (the list of transactions) per file
    private static final long DEFAULT_EXPIRE_AFTER_WRITE_MINUTES = 10; // Cache entry expires after 10 minutes
    private static final long DEFAULT_REFRESH_AFTER_WRITE_MINUTES = 1; // Refresh entry after 1 minute

    // Private constructor to prevent instantiation
    private CacheManager() {}

    /**
     * Gets or creates a LoadingCache for the specified transaction file path.
     * The cache loads List<Transaction> from the file using TransactionDao.
     *
     * @param filePath The path to the user's transaction CSV file.
     * @param transactionDao The TransactionDao instance to use for loading.
     * @return The LoadingCache instance for the given file path.
     */
    public static LoadingCache<String, List<Transaction>> getTransactionCache(String filePath, TransactionDao transactionDao) {
        // Use computeIfAbsent to get or create the cache atomically
        return fileCaches.computeIfAbsent(filePath, key -> {
            System.out.println("CacheManager: Creating new cache for file: " + filePath);
            // Create a new LoadingCache for this specific file path
            return Caffeine.newBuilder()
                    .maximumSize(DEFAULT_MAX_SIZE)
                    .expireAfterWrite(DEFAULT_EXPIRE_AFTER_WRITE_MINUTES, TimeUnit.MINUTES)
                    .refreshAfterWrite(DEFAULT_REFRESH_AFTER_WRITE_MINUTES, TimeUnit.MINUTES)
                    // Define the loader function: how to load data when cache is missed or refreshed
                    .build(cacheKey -> {
                        System.out.println("CacheManager: Loading transactions from file: " + filePath + " (Cache Miss/Refresh)");
                        try {
                            // The cacheKey here will likely be a constant like "transactions"
                            // We use the outer filePath variable to load from the correct file
                            return transactionDao.loadFromCSV(filePath);
                        } catch (IOException e) {
                            System.err.println("CacheManager: Error loading data for file " + filePath);
                            e.printStackTrace();
                            throw new RuntimeException("Error loading transactions from " + filePath, e); // Wrap IOException in RuntimeException for Caffeine loader
                        }
                    });
        });
    }

    /**
     * Invalidates the cache for a specific transaction file path.
     * @param filePath The path to the user's transaction CSV file.
     */
    public static void invalidateTransactionCache(String filePath) {
        LoadingCache<String, List<Transaction>> cache = fileCaches.get(filePath);
        if (cache != null) {
            System.out.println("CacheManager: Invalidating cache for file: " + filePath);
            // The cache key for List<Transaction> is likely a constant like "transactions"
            cache.invalidate(CaffeineKeys.TRANSACTION_CAFFEINE_KEY); // Invalidate the entry storing the transaction list
        }
        // Optionally, remove the cache itself if the file is no longer needed
        // fileCaches.remove(filePath); // Might do this on user logout, etc.
    }

    /**
     * Gets the transaction list from the cache for the specified file path.
     * Loads data if not present or expired. Handles exceptions thrown by the loader.
     *
     * @param filePath The path to the user's transaction CSV file.
     * @param transactionDao The TransactionDao instance to use for loading if cache misses.
     * @return The list of transactions.
     * @throws Exception If an error occurs during loading (e.g., IOException).
     */
    public static List<Transaction> getTransactions(String filePath, TransactionDao transactionDao) throws Exception {
        LoadingCache<String, List<Transaction>> cache = getTransactionCache(filePath, transactionDao);
        // The cache key for the list of transactions from a specific file is a constant.
        // This constant key maps to the *entire list* of transactions for that file.
        return cache.get(CaffeineKeys.TRANSACTION_CAFFEINE_KEY);
    }

    /**
     * Manually puts a list of transactions into the cache for a specific file path.
     * This is useful after a write operation (add, delete, update) to refresh the cache.
     *
     * @param filePath The path to the user's transaction CSV file.
     * @param transactions The updated list of transactions.
     * @param transactionDao The TransactionDao instance (needed to get/create cache if not exists).
     */
    public static void putTransactions(String filePath, List<Transaction> transactions, TransactionDao transactionDao) {
        LoadingCache<String, List<Transaction>> cache = getTransactionCache(filePath, transactionDao);
        cache.put(CaffeineKeys.TRANSACTION_CAFFEINE_KEY, transactions);
        System.out.println("CacheManager: Manually updated cache for file: " + filePath);
    }

    /**
     * Shutdown any resources if necessary (though Caffeine typically manages its threads).
     */
    public static void shutdown() {
        // Caffeine cache doesn't require explicit shutdown in most cases
        // If using custom executors, they might need shutdown.
        System.out.println("CacheManager: Shutdown completed.");
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\Utils\CacheUtil.java`:

```java
package Utils;

import com.github.benmanes.caffeine.cache.*;

import java.util.concurrent.TimeUnit;
import java.util.function.Function;

import com.github.benmanes.caffeine.cache.Caffeine;

/**
 * 通用缓存工具类（支持泛型和异常传播）
 * @param <K> 键类型
 * @param <V> 值类型
 * @param <E> 异常类型（如 IOException）
 */
public class CacheUtil<K, V, E extends Exception> {
    private final LoadingCache<K, V> cache;

    public CacheUtil(Function<K, V> loader,
                     int maxSize,
                     long expireAfterWrite,
                     long refreshAfterWrite) {

        this.cache = Caffeine.newBuilder()
                .maximumSize(maxSize)
                .expireAfterWrite(expireAfterWrite, TimeUnit.MINUTES)
                .refreshAfterWrite(refreshAfterWrite, TimeUnit.MINUTES)
                .build(loader::apply); // 关键修改：使用build(loader)创建LoadingCache
    }

    /**
     * 获取缓存值
     */
    public V get(K key) {
        return cache.get(key);
    }

    /**
     * 手动更新缓存
     */
    public void put(K key, V value) {
        cache.put(key, value);
    }

    /**
     * 手动移除缓存
     */
    public void invalidate(K key) {
        cache.invalidate(key);
    }
}



```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\model\MonthlySummary.java`:

```java
package model;

import java.util.HashMap;
import java.util.Map;

// Represents a summary of transactions for a specific month
public class MonthlySummary {
    private String monthIdentifier; // e.g., "2025-03"
    private double totalIncome;
    private double totalExpense;
    // Map from standard expense category to total amount spent in that category
    private Map<String, Double> expenseByCategory;

    public MonthlySummary(String monthIdentifier) {
        this.monthIdentifier = monthIdentifier;
        this.totalIncome = 0.0;
        this.totalExpense = 0.0;
        this.expenseByCategory = new HashMap<>();
    }

    // Getters
    public String getMonthIdentifier() {
        return monthIdentifier;
    }

    public double getTotalIncome() {
        return totalIncome;
    }

    public double getTotalExpense() {
        return totalExpense;
    }

    public Map<String, Double> getExpenseByCategory() {
        return expenseByCategory;
    }

    // Methods to add transaction amounts
    public void addIncome(double amount) {
        this.totalIncome += amount;
    }

    public void addExpense(double amount, String standardCategory) {
        this.totalExpense += amount;
        // Aggregate by standard category
        expenseByCategory.put(standardCategory, expenseByCategory.getOrDefault(standardCategory, 0.0) + amount);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Month: ").append(monthIdentifier).append("\n");
        sb.append("  Total Income: ").append(String.format("%.2f", totalIncome)).append("元\n");
        sb.append("  Total Expense: ").append(String.format("%.2f", totalExpense)).append("元\n");
        sb.append("  Expenses by Category:\n");
        if (expenseByCategory.isEmpty()) {
            sb.append("    (None)\n");
        } else {
            // Sort categories alphabetically for consistent output
            expenseByCategory.entrySet().stream()
                    .sorted(Map.Entry.comparingByKey())
                    .forEach(entry ->
                            sb.append(String.format("    %s: %.2f元\n", entry.getKey(), entry.getValue()))
                    );
        }
        return sb.toString();
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\model\SummaryStatistic.java`:

```java
package model;

// Represents a summary statistic for a specific week across all users
public class SummaryStatistic {
    private String weekIdentifier; // e.g., "2025-W14"
    private double totalIncomeAllUsers;
    private double totalExpenseAllUsers;
    private String topExpenseCategory; // e.g., "餐饮"
    private double topExpenseCategoryAmount; // Amount spent in the top category
    private int numberOfUsersWithTransactions; // Number of users who had any transaction this week
    private String timestampGenerated; // When this statistic record was created

    // Constructors
    public SummaryStatistic() {
    }

    public SummaryStatistic(String weekIdentifier, double totalIncomeAllUsers, double totalExpenseAllUsers, String topExpenseCategory, double topExpenseCategoryAmount, int numberOfUsersWithTransactions, String timestampGenerated) {
        this.weekIdentifier = weekIdentifier;
        this.totalIncomeAllUsers = totalIncomeAllUsers;
        this.totalExpenseAllUsers = totalExpenseAllUsers;
        this.topExpenseCategory = topExpenseCategory;
        this.topExpenseCategoryAmount = topExpenseCategoryAmount;
        this.numberOfUsersWithTransactions = numberOfUsersWithTransactions;
        this.timestampGenerated = timestampGenerated;
    }

    // Getters
    public String getWeekIdentifier() {
        return weekIdentifier;
    }

    public double getTotalIncomeAllUsers() {
        return totalIncomeAllUsers;
    }

    public double getTotalExpenseAllUsers() {
        return totalExpenseAllUsers;
    }

    public String getTopExpenseCategory() {
        return topExpenseCategory;
    }

    public double getTopExpenseCategoryAmount() {
        return topExpenseCategoryAmount;
    }

    public int getNumberOfUsersWithTransactions() {
        return numberOfUsersWithTransactions;
    }

    public String getTimestampGenerated() {
        return timestampGenerated;
    }

    // Setters (if needed for creation/population)
    public void setWeekIdentifier(String weekIdentifier) {
        this.weekIdentifier = weekIdentifier;
    }

    public void setTotalIncomeAllUsers(double totalIncomeAllUsers) {
        this.totalIncomeAllUsers = totalIncomeAllUsers;
    }

    public void setTotalExpenseAllUsers(double totalExpenseAllUsers) {
        this.totalExpenseAllUsers = totalExpenseAllUsers;
    }

    public void setTopExpenseCategory(String topExpenseCategory) {
        this.topExpenseCategory = topExpenseCategory;
    }

    public void setTopExpenseCategoryAmount(double topExpenseCategoryAmount) {
        this.topExpenseCategoryAmount = topExpenseCategoryAmount;
    }

    public void setNumberOfUsersWithTransactions(int numberOfUsersWithTransactions) {
        this.numberOfUsersWithTransactions = numberOfUsersWithTransactions;
    }

    public void setTimestampGenerated(String timestampGenerated) {
        this.timestampGenerated = timestampGenerated;
    }

    @Override
    public String toString() {
        return "SummaryStatistic{" +
                "weekIdentifier='" + weekIdentifier + '\'' +
                ", totalIncomeAllUsers=" + totalIncomeAllUsers +
                ", totalExpenseAllUsers=" + totalExpenseAllUsers +
                ", topExpenseCategory='" + topExpenseCategory + '\'' +
                ", topExpenseCategoryAmount=" + topExpenseCategoryAmount +
                ", numberOfUsersWithTransactions=" + numberOfUsersWithTransactions +
                ", timestampGenerated='" + timestampGenerated + '\'' +
                '}';
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\model\Transaction.java`:

```java
package model;
//Transaction time, transaction type, transaction counterparty,
// commodity receipt/payment amount (yuan), payment method, current status,
// transaction order number, merchant order number, remarks
public class Transaction {
    private String transactionTime;
    private String transactionType;
    private String counterparty;
    private String commodity;
    private String inOut;
    private double paymentAmount;
    private String paymentMethod;
    private String currentStatus;
    private String orderNumber;
    private String merchantNumber;
    private String remarks;

    public Transaction() {
    }

    public Transaction(String transactionTime, String transactionType, String counterparty, String commodity, String inOut, double paymentAmount, String paymentMethod, String currentStatus, String orderNumber, String merchantNumber, String remarks) {
        this.transactionTime = transactionTime;
        this.transactionType = transactionType;
        this.counterparty = counterparty;
        this.commodity = commodity;
        this.inOut = inOut;
        this.paymentAmount = paymentAmount;
        this.paymentMethod = paymentMethod;
        this.currentStatus = currentStatus;
        this.orderNumber = orderNumber;
        this.merchantNumber = merchantNumber;
        this.remarks = remarks;
    }

    public String getInOut() {
        return inOut;
    }

    public void setInOut(String inOut) {
        this.inOut = inOut;
    }

    public void setTransactionTime(String transactionTime) {
        this.transactionTime = transactionTime;
    }

    public void setTransactionType(String transactionType) {
        this.transactionType = transactionType;
    }

    public void setCounterparty(String counterparty) {
        this.counterparty = counterparty;
    }

    public void setCommodity(String commodity) {
        this.commodity = commodity;
    }

    public void setPaymentAmount(double paymentAmount) {
        this.paymentAmount = paymentAmount;
    }

    public void setPaymentMethod(String paymentMethod) {
        this.paymentMethod = paymentMethod;
    }

    public void setCurrentStatus(String currentStatus) {
        this.currentStatus = currentStatus;
    }

    public void setOrderNumber(String orderNumbe) {
        this.orderNumber = orderNumbe;
    }

    public void setMerchantNumber(String merchantNumber) {
        this.merchantNumber = merchantNumber;
    }

    public void setRemarks(String remarks) {
        this.remarks = remarks;
    }

    public String getTransactionTime() {
        return transactionTime;
    }

    public String getTransactionType() {
        return transactionType;
    }

    public String getCounterparty() {
        return counterparty;
    }

    public String getCommodity() {
        return commodity;
    }

    public double getPaymentAmount() {
        return paymentAmount;
    }

    public String getPaymentMethod() {
        return paymentMethod;
    }

    public String getCurrentStatus() {
        return currentStatus;
    }

    public String getOrderNumber() {
        return orderNumber;
    }

    public String getMerchantNumber() {
        return merchantNumber;
    }

    public String getRemarks() {
        return remarks;
    }
}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\java\model\User.java`:

```java
package model;

// 用户模型类
public class User {
    private String username;
    private String password;
    private String role; // e.g., "user", "admin"
    private String transactionFilePath; // Path to the user's transaction CSV file

    // Constructors
    public User() {
    }

    public User(String username, String password, String role, String transactionFilePath) {
        this.username = username;
        this.password = password;
        this.role = role;
        this.transactionFilePath = transactionFilePath;
    }

    // Getters and Setters
    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getRole() {
        return role;
    }

    public void setRole(String role) {
        this.role = role;
    }

    public String getTransactionFilePath() {
        return transactionFilePath;
    }

    public void setTransactionFilePath(String transactionFilePath) {
        this.transactionFilePath = transactionFilePath;
    }

    @Override
    public String toString() {
        return "User{" +
                "username='" + username + '\'' +
                ", role='" + role + '\'' +
                ", transactionFilePath='" + transactionFilePath + '\'' +
                '}';
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\resources\CSVForm\stats\summary_statistics.csv`:

```csv
week_identifier,total_income_all_users,total_expense_all_users,top_expense_category,top_expense_category_amount,number_of_users_with_transactions,timestamp_generated
2022-W37,0.0,5000.0,其他支出,5000.0,1,2025-05-22 23:34:23
2025-W09,10000.0,20000.0,无支出,0.0,3,2025-05-22 23:34:23
2025-W10,0.0,751.5,其他支出,751.5,3,2025-05-22 23:34:23
2025-W11,0.0,257.25,餐饮,107.25,3,2025-05-22 23:34:23
2025-W12,0.0,15000.0,其他支出,10000.0,3,2025-05-22 23:34:23

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\resources\CSVForm\transactions\admin_transactions.csv`:

```csv
交易时间,交易类型,交易对方,商品,收/支,金额(元),支付方式,当前状态,交易单号,商户单号,备注
2025/03/01 09:00:00,工资,公司A,三月工资,收入,¥10000.00,银行卡,已入账,SALARY_MAR_A,PAYROLL_A_001,本月基本工资
2025/03/05 14:30:00,购物,超市B,食品杂货,支出,¥250.50,支付宝,已完成,SHOP_B_001,ALIPAY_12345,周末采购
2025/03/15 11:00:00,餐饮,餐厅C,午餐外卖,支出,¥35.75,美团支付,已完成,MEAL_C_001,MEITUAN_11223,工作日午餐
2025/03/20 16:00:00,金融服务,股票账户,购入股票,支出,¥5000.00,美团支付,已完成,INVEST_STOCK_001,BANK_99887,长期投资
2022/09/10 16:00:00,投资,股票账户,购入股票,支出,¥5000.00,同花顺,未完成,INVEST_STOCK_002,BANK_99887,短线投资
2025/03/10 10:00:00,转账,用户1,报销午餐,支出,¥50.00,微信支付,已完成,TRANSFER_U1_001,WECHAT_56789,归还午餐费

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\resources\CSVForm\transactions\user1_transactions.csv`:

```csv
交易时间,交易类型,交易对方,商品,收/支,金额(元),支付方式,当前状态,交易单号,商户单号,备注
2025/03/01 09:00:00,工资,公司A,三月工资,支出,¥10000.00,银行卡,已入账,SALARY_MAR_A,PAYROLL_A_001,本月基本工资
2025/03/05 14:30:00,购物,超市B,食品杂货,支出,¥250.50,支付宝,已完成,SHOP_B_001,ALIPAY_12345,周末采购
2025/03/10 10:00:00,转账,用户1,报销午餐,支出,¥50.00,微信支付,已完成,TRANSFER_U1_001,WECHAT_56789,归还午餐费
2025/03/15 11:00:00,餐饮,餐厅C,午餐外卖,支出,¥35.75,美团支付,已完成,MEAL_C_001,MEITUAN_11223,工作日午餐
2025/03/20 16:00:00,投资,股票账户,购入股票,支出,¥5000.00,银行转账,已完成,INVEST_STOCK_001,BANK_99887,长期投资

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\resources\CSVForm\transactions\user2_transactions.csv`:

```csv
交易时间,交易类型,交易对方,商品,收/支,金额(元),支付方式,当前状态,交易单号,商户单号,备注
2025/03/01 09:00:00,工资,公司A,三月工资,支出,¥10000.00,银行卡,已入账,SALARY_MAR_A,PAYROLL_A_001,本月基本工资
2025/03/05 14:30:00,购物,超市B,食品杂货,支出,¥250.50,支付宝,已完成,SHOP_B_001,ALIPAY_12345,周末采购
2025/03/10 10:00:00,转账,用户1,报销午餐,支出,¥50.00,微信支付,已完成,TRANSFER_U1_001,WECHAT_56789,归还午餐费
2025/03/15 11:00:00,餐饮,餐厅C,午餐外卖,支出,¥35.75,美团支付,已完成,MEAL_C_001,MEITUAN_11223,工作日午餐
2025/03/20 16:00:00,投资,股票账户,购入股票,支出,¥5000.00,银行转账,已完成,INVEST_STOCK_001,BANK_99887,长期投资
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\resources\CSVForm\users\users.csv`:

```csv
username,password,role,transaction_csv_path
admin,admin123,admin,Ai Bill Application/src/main/resources/CSVForm/transactions/admin_transactions.csv
user1,pass123,user,Ai Bill Application/src/main/resources/CSVForm/transactions/user1_transactions.csv
user2,securepwd,user,Ai Bill Application/src/main/resources/CSVForm/transactions/user2_transactions.csv

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\main\resources\config.properties`:

```properties
# config.properties
#csv.path=Ai Bill Application/src/main/resources/CSVForm/0001.csv
csv.path=Ai Bill Application/src/main/resources/CSVForm/transactions/admin_transactions.csv
csv.users_path=Ai Bill Application/src/main/resources/CSVForm/users/users.csv
csv.summary_path=Ai Bill Application/src/main/resources/CSVForm/stats/summary_statistics.csv
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\ControllerTest\AITest.java`:

```java
package ControllerTest;

import Controller.HistogramPanelContainer;
import org.junit.Test;

import javax.swing.*;
import java.awt.*;

public class AITest {

    @Test
    public void testHistogramPanel() throws Exception {
        EventQueue.invokeAndWait(() -> {
            JFrame frame = new JFrame("数据分析界面 - 测试");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });




        // 保持窗口显示一段时间，防止测试结束时窗口立即关闭
        Thread.sleep(5000);
    }

}




```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\ControllerTest\MenuUITest.java`:

```java
package ControllerTest;

import model.User;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.io.IOException;
import Controller.MenuUI;

import Service.Impl.TransactionServiceImpl;

import DAO.Impl.CsvTransactionDao;

public class MenuUITest {

    private MenuUI menuUI;

    @BeforeEach
    public void setUp() {
//        menuUI = new MenuUI(new User());

        // 手动初始化 TransactionServiceImpl 的 csvTransactionDao
//        TransactionServiceImpl.csvTransactionDao = new CsvTransactionDao();
    }

    @Test
    public void testSearchFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取输入字段和搜索按钮
        JTextField transactionTimeField = findTextField(inputPanel, 0);
        JTextField transactionTypeField = findTextField(inputPanel, 1);
        JTextField counterpartyField = findTextField(inputPanel, 2);
        JTextField commodityField = findTextField(inputPanel, 3);
        JComboBox<String> inOutComboBox = findComboBox(inputPanel);
        JTextField paymentMethodField = findTextField(inputPanel, 4);
        JButton searchButton = findButton(inputPanel,"Search");

        assertNotNull(transactionTimeField, "交易时间输入字段不应为空");
        assertNotNull(transactionTypeField, "交易类型输入字段不应为空");
        assertNotNull(counterpartyField, "交易对方输入字段不应为空");
        assertNotNull(commodityField, "商品输入字段不应为空");
        assertNotNull(inOutComboBox, "收/支下拉框不应为空");
        assertNotNull(paymentMethodField, "支付方式输入字段不应为空");
        assertNotNull(searchButton, "搜索按钮不应为空");

        // 设置搜索条件
        transactionTimeField.setText("2025/3/14 11:48"); // 交易时间
        transactionTypeField.setText("商户消费");       // 交易类型
        counterpartyField.setText("物美WUMART");         // 交易对方
        commodityField.setText("扫码支付");            // 商品
        inOutComboBox.setSelectedItem("支出");     // 收/支
        paymentMethodField.setText("零钱");    // 支付方式

        // 模拟点击搜索按钮
        searchButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证搜索结果是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);

            // 验证每一行数据是否符合搜索条件
            assertTrue(rowTransactionTime.contains("2025/3/14 11:48"), "交易时间应符合搜索条件");
            assertTrue(rowTransactionType.contains("商户消费"), "交易类型应符合搜索条件");
            assertTrue(rowCounterparty.contains("物美WUMART"), "交易对方应符合搜索条件");
            assertTrue(rowCommodity.contains("扫码支付"), "商品应符合搜索条件");
            assertTrue(rowInOut.contains("支出"), "收/支应符合搜索条件");
            assertTrue(rowPaymentMethod.contains("零钱"), "支付方式应符合搜索条件");
        }
    }

    @Test
    public void testDeleteFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 获取初始行数
        int initialRowCount = tableModel.getRowCount();

        // 模拟删除第一行
        menuUI.deleteRow(0);

        // 验证行数是否减少
        assertEquals(initialRowCount - 1, tableModel.getRowCount(), "删除后行数应减少");

        // 验证删除后的数据是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            assertNotEquals("2025/3/14 11:48", rowTransactionTime, "删除的行不应再出现在表格中");
        }
    }

    @Test
    public void testEditFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 模拟编辑第一行
        menuUI.editRow(0);

        // 验证编辑后的数据是否正确
        String editedTransactionTime = (String) tableModel.getValueAt(0, 0);
        String editedTransactionType = (String) tableModel.getValueAt(0, 1);
        String editedCounterparty = (String) tableModel.getValueAt(0, 2);
        String editedCommodity = (String) tableModel.getValueAt(0, 3);
        String editedInOut = (String) tableModel.getValueAt(0, 4);
        String editedPaymentMethod = (String) tableModel.getValueAt(0, 6);

        // 验证编辑后的数据是否符合预期
        assertNotNull(editedTransactionTime, "编辑后的交易时间不应为空");
        assertNotNull(editedTransactionType, "编辑后的交易类型不应为空");
        assertNotNull(editedCounterparty, "编辑后的交易对方不应为空");
        assertNotNull(editedCommodity, "编辑后的商品不应为空");
        assertNotNull(editedInOut, "编辑后的收/支不应为空");
        assertNotNull(editedPaymentMethod, "编辑后的支付方式不应为空");
    }

    @Test
    public void testAddFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取 Add 按钮
        JButton addButton = findButton(inputPanel, "Add");
        assertNotNull(addButton, "Add 按钮不应为空");

        // 模拟点击 Add 按钮
        addButton.doClick();

        // 获取对话框
        Window[] windows = Window.getWindows();
        JDialog addDialog = null;
        for (Window window : windows) {
            if (window instanceof JDialog && "添加交易".equals(((JDialog) window).getTitle())) {
                addDialog = (JDialog) window;
                break;
            }
        }
        assertNotNull(addDialog, "添加交易的对话框应弹出");

        // 获取对话框中的输入字段
        JTextField transactionTimeField = findTextField(addDialog.getContentPane(), 0);
        JTextField transactionTypeField = findTextField(addDialog.getContentPane(), 1);
        JTextField counterpartyField = findTextField(addDialog.getContentPane(), 2);
        JTextField commodityField = findTextField(addDialog.getContentPane(), 3);
        JComboBox<String> inOutComboBox = findComboBox(addDialog.getContentPane());
        JTextField paymentAmountField = findTextField(addDialog.getContentPane(), 4);
        JTextField paymentMethodField = findTextField(addDialog.getContentPane(), 5);
        JTextField currentStatusField = findTextField(addDialog.getContentPane(), 6);
        JTextField orderNumberField = findTextField(addDialog.getContentPane(), 7);
        JTextField merchantNumberField = findTextField(addDialog.getContentPane(), 8);
        JTextField remarksField = findTextField(addDialog.getContentPane(), 9);

        // 设置新交易的输入值
        transactionTimeField.setText("2025/3/15 12:00"); // 交易时间
        transactionTypeField.setText("转账");            // 交易类型
        counterpartyField.setText("张三");               // 交易对方
        commodityField.setText("转账");                 // 商品
        inOutComboBox.setSelectedItem("支出");          // 收/支
        paymentAmountField.setText("100.0");            // 金额(元)
        paymentMethodField.setText("银行卡");           // 支付方式
        currentStatusField.setText("已完成");           // 当前状态
        orderNumberField.setText("123456789");          // 交易单号
        merchantNumberField.setText("987654321");       // 商户单号
        remarksField.setText("测试备注");               // 备注

        // 获取确认按钮
        JButton confirmButton = findButton(addDialog.getContentPane(), "确认");
        assertNotNull(confirmButton, "确认按钮不应为空");

        // 模拟点击确认按钮
        confirmButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证新交易是否添加到表格中
        boolean isTransactionAdded = false;
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentAmount = (String) tableModel.getValueAt(i, 5);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);
            String rowCurrentStatus = (String) tableModel.getValueAt(i, 7);
            String rowOrderNumber = (String) tableModel.getValueAt(i, 8);
            String rowMerchantNumber = (String) tableModel.getValueAt(i, 9);
            String rowRemarks = (String) tableModel.getValueAt(i, 10);

            if (rowTransactionTime.equals("2025/3/15 12:00") &&
                    rowTransactionType.equals("转账") &&
                    rowCounterparty.equals("张三") &&
                    rowCommodity.equals("转账") &&
                    rowInOut.equals("支出") &&
                    rowPaymentAmount.equals("100.0") &&
                    rowPaymentMethod.equals("银行卡") &&
                    rowCurrentStatus.equals("已完成") &&
                    rowOrderNumber.equals("123456789") &&
                    rowMerchantNumber.equals("987654321") &&
                    rowRemarks.equals("测试备注")) {
                isTransactionAdded = true;
                break;
            }
        }

        // 验证新交易是否成功添加
        assertTrue(isTransactionAdded, "新交易应成功添加到表格中");
    }

    /**
     * 显示界面以便手动验证
     *
     * @param panel 要显示的面板
     */
    private void showUI(JPanel panel) {
        JFrame frame = new JFrame("MenuUI Test");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(1200, 600);
        frame.add(panel);
        frame.setVisible(true);

        // 保持界面显示一段时间（5秒）
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        frame.dispose(); // 关闭界面
    }

    /**
     * 查找输入面板
     *
     * @param mainPanel 主面板
     * @return 输入面板
     */
    private JPanel findInputPanel(JPanel mainPanel) {
        // 获取右边的面板
        Component[] components = mainPanel.getComponents();
        JPanel rightPanel = null;
        for (Component component : components) {
            if (component instanceof JPanel && ((JPanel) component).getComponentCount() > 0) {
                rightPanel = (JPanel) component;
                break;
            }
        }

        if (rightPanel != null) {
            // 在右边面板中查找输入面板
            for (Component component : rightPanel.getComponents()) {
                if (component instanceof JPanel) {
                    JPanel panel = (JPanel) component;
                    System.out.println("Panel found: " + panel.getName()); // 打印面板名称
                    if (panel.getComponentCount() > 0 && panel.getComponent(0) instanceof JLabel) {
                        return panel; // 输入面板通常包含 JLabel
                    }
                }
            }
        }
        return null;
    }

    /**
     * 查找输入字段
     *
     * @param container     输入面板
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0;
        for (Component component : container.getComponents()) {
            if (component instanceof JTextField) {
                if (count == index) {
                    return (JTextField) component;
                }
                count++;
            }
        }
        return null;
    }


    /**
     * 查找下拉框
     *
     * @param container 输入面板
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) {
            if (component instanceof JComboBox) {
                return (JComboBox<String>) component;
            }
        }
        return null;
    }

    /**
     * 查找按钮
     *
     * @param panel 输入面板
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container  容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    private JButton findButton(Container container, String buttonText) {
        for (Component component : container.getComponents()) {
            if (component instanceof JButton) {
                JButton button = (JButton) component;
                if (button.getText().equals(buttonText)) {
                    return button;
                }
            }
        }
        return null;
    }
}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\DAOTest\CsvTransactionDaoTest.java`:

```java
package DAOTest;

import DAO.Impl.CsvTransactionDao;
import model.Transaction;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static Constants.ConfigConstants.CSV_PATH;
import static org.junit.Assert.*;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;


class CsvTransactionDaoTest {
    private static final String TEST_ADMIN_CSV_PATH = "Ai Bill Application/src/test/resources/CSVForm/transactions/admin_transactions.csv"; //

    // 测试文件路径（根据实际结构调整）
    private static final String TEST_CSV_PATH = CSV_PATH;
    private static CsvTransactionDao dao;

    @Test
    void testLoadFromCSV_ValidFile_ReturnsTransactions() throws Exception {
        // Given
        CsvTransactionDao dao = new CsvTransactionDao();

        // When
        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);

        // 验证第一条记录的字段
        for (int i = 0; i < transactions.size(); i++) {
            System.out.println(transactions.get(i).getRemarks());
            System.out.println(transactions.get(i).getCommodity());
        }


    }
    @Test
    void testAddTransaction() throws IOException {
        dao=new CsvTransactionDao();
        Transaction newTx = new Transaction(
                "2025-03-09 10:00",
                "转账",
                "小明",
                "书籍",
                "支",
                99.99,
                "微信",
                "已完成",
                "TX123456",
                "M789012",
                "");

        dao.addTransaction("src/test/resources/001.csv", newTx);

        List<Transaction> transactions = dao.loadFromCSV(TEST_CSV_PATH);

    }

    @BeforeEach
        // This runs before each test method
    void setUp() {
        // Initialize DAO before each test
        dao = new CsvTransactionDao();
        // Ensure the test file exists - maybe create it programmatically here for reliable testing
        // or rely on it being present in src/test/resources and copied to classpath
    }

    @Test
    void testLoadAdminCSV() throws IOException {
        System.out.println("Attempting to load test CSV: " + TEST_ADMIN_CSV_PATH);
        Path csvPath = Paths.get(TEST_ADMIN_CSV_PATH);
        assertTrue("Test CSV file should exist at " + TEST_ADMIN_CSV_PATH, Files.exists(csvPath));
        assertTrue("Test CSV file should not be empty.", Files.size(csvPath) > 0);


        // When loading the specific admin CSV
        List<Transaction> transactions = dao.loadFromCSV(TEST_ADMIN_CSV_PATH);

        // Then assert that loading was successful and data is present
        assertNotNull(transactions.toString(), "Loaded transactions list should not be null");
        assertFalse("Loaded transactions list should not be empty", transactions.isEmpty());
        assertEquals(String.valueOf(5), transactions.size(), "Should load 5 transaction records"); // Assuming 5 rows plus header

        // Optional: Verify content of a specific row
        Transaction firstTx = transactions.get(0);
        assertEquals("公司A", firstTx.getCounterparty());
        assertEquals("三月工资", firstTx.getCommodity());
        assertEquals(10000.00, firstTx.getPaymentAmount(), 0.01); // Use delta for double comparison
    }

    // Add other tests like testAddTransaction, testDeleteTransaction, testChangeInformation etc.
    // Ensure these tests also use the correct file paths and verify file content changes.
    // For modification/deletion tests, you might need to create a temporary CSV file
    // or use a file specifically for testing that can be modified without affecting other tests.

    // Example of a helper method to create a test CSV file programmatically
    // This is more reliable than relying on manual copying/pasting for tests.
    private void createTestCsvFile(String filePath, List<Transaction> transactions) throws IOException {
        Path path = Paths.get(filePath);
        if (path.getParent() != null) {
            Files.createDirectories(path.getParent());
        }
        // Delete old file if it exists
        if (Files.exists(path)) {
            Files.delete(path);
        }

        String[] headers = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"};
        try (BufferedWriter writer = Files.newBufferedWriter(path, StandardCharsets.UTF_8);
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(headers).withTrim())) {

            for (Transaction t : transactions) {
                csvPrinter.printRecord(
                        t.getTransactionTime(),
                        t.getTransactionType(),
                        t.getCounterparty(),
                        t.getCommodity(),
                        t.getInOut(),
                        String.format("¥%.2f", t.getPaymentAmount()),
                        t.getPaymentMethod(),
                        t.getCurrentStatus(),
                        t.getOrderNumber(),
                        t.getMerchantNumber(),
                        t.getRemarks()
                );
            }
        }
    }

    @Test
    void testAddTransactionToFile() throws IOException {
        // Create a temporary test file path or use a dedicated test file name
        String tempFilePath = "Ai Bill Application/src/main/resources/CSVForm/transactions/test_add.csv";
        // Create an empty or initial test file
        createTestCsvFile(tempFilePath, List.of()); // Start with an empty file

        CsvTransactionDao testDao = new CsvTransactionDao(); // Or reuse the instance from BeforeEach if path is managed

        Transaction newTx = new Transaction(
                "2025/04/11 08:00:00", "测试类型", "测试对方", "测试商品", "收入",
                123.45, "测试方式", "测试状态", "TEST001", "MERCHANT001", "测试备注"
        );

        // Add the transaction
        testDao.addTransaction(tempFilePath, newTx);

        // Load the file back and verify
        List<Transaction> transactions = testDao.loadFromCSV(tempFilePath);

        assertNotNull(transactions);
        assertEquals(1, transactions.size());
        Transaction addedTx = transactions.get(0);
        assertEquals("TEST001", addedTx.getOrderNumber());
        assertEquals(123.45, addedTx.getPaymentAmount(), 0.01);

        // Clean up the test file (optional but good practice)
        Files.deleteIfExists(Paths.get(tempFilePath));
    }

    @Test
    void testDeleteTransaction() throws IOException {
        dao=new CsvTransactionDao();

        dao.deleteTransaction("CSV_RELATIVE_PATH", "4200057899202502250932735481");

        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);
    }
//    @Test
//    void testChangeInfo() throws IOException{
//        dao=new CsvTransactionDao();
//        dao.changeInformation("TX123456","remarks","测试修改信息",TEST_CSV_PATH);
//        dao.changeInformation("TX123456","paymentAmount","116156",TEST_CSV_PATH);
//    }

}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\Service\AIAnalyzerThreadTest.java`:

```java
package Service;



import Service.AIservice.AIAnalyzerThread;
import org.junit.jupiter.api.Test;

public class AIAnalyzerThreadTest {

//    @Test
//    public void testRunAIAnalyzerThread() throws InterruptedException {
//        String userRequest = "请帮我分析最近的交易收支情况";
//        String filePath = "src/test/resources/sample_transactions.csv";
//        String startTimeStr = "2025/03/20";
//        String endTimeStr = "";
//
//        // 启动线程
//        Thread thread = new Thread(new AIAnalyzerThread(userRequest, filePath, startTimeStr, endTimeStr));
//        thread.start();
//
//        // 等待线程执行完成
//        thread.join();
//    }
}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\Service\AIserviceTest.java`:

```java
package Service;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

public class AIserviceTest {

    @Test
    public void testAnalyzeTransactions() {
        AITransactionService service = new AITransactionService();

        String userRequest = "请帮我分析这个月的收支情况";
        String filePath = "src/test/resources/sample_transactions.csv";

        String result = service.analyzeTransactions(userRequest, filePath,"2025/03/20","");

        assertNotNull(result, "AI分析结果不能为空");
        System.out.println("AI分析结果: " + result);
    }


}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\Service\AiFunctionTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.Test;
import Service.AIservice.AITransactionService;

import java.io.IOException;
import java.util.List;

public class AiFunctionTest {

    @Test
    public void testAnalyzeTransactions() throws IOException {

        String filePath = "src/test/resources/sample_transactions.csv";
        CsvTransactionDao transactionDao = new CsvTransactionDao();

        List<Transaction> transactions = transactionDao.loadFromCSV(filePath);

        // 实例化服务类
        AITransactionService service = new AITransactionService();

        // 调用合并格式化函数
        List<String> result = service.formatTransactions(transactions,"2025/03/29","2025/04/10");

        // 输出结果
        result.forEach(System.out::println);
    }




}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\Service\CacheTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import model.Transaction;
import org.junit.jupiter.api.Test;

import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;

public class CacheTest {

//    TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());
//
//    @Test
//    void DeleteCache(){
//        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;
//        cache.invalidate(TRANSACTION_CAFFEINE_KEY);
//    }

}

```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\Service\CollegeStudentNeedsTest.java`:

```java
//package Service;
//
//import Service.AIservice.ColledgeStudentThread;
//import Service.AIservice.CollegeStudentNeeds;
//import org.junit.jupiter.api.*;
//
//import java.io.IOException;
//import java.net.URISyntaxException;
//import java.net.URL;
//import java.nio.file.Files;
//import java.nio.file.Path;
//import java.nio.file.Paths;
//import java.util.Arrays;
//
//import static org.junit.jupiter.api.Assertions.*;
//
//// No @ExtendWith needed as we are not using Mockito extensions
//class CollegeStudentNeedsTest {
//
//
//
//    private CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
//    private static final String TEST_CSV_FILENAME = "src/test/resources/001.csv";
//    @Test
//    public void testGenerateBudget() throws IOException, InterruptedException {
//        Thread t=new Thread( new ColledgeStudentThread(TEST_CSV_FILENAME));
//        t.start();
//        t.join();
////        collegeStudentNeeds.generateBudget(TEST_CSV_FILENAME);
//    }
//    @Test
//    public void testParseStringToDouble(){
//        String s="asdas[369.39,1090.1]das";
//        double[] arr=collegeStudentNeeds.parseDoubleArrayFromString(s);
//        System.out.println(arr[0]+" "+arr[1]);
//    }
//
//
//}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\java\Service\TransactionServiceTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import model.Transaction;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.io.IOException;
import java.util.List;

class TransactionServiceTest {
    private TransactionService transactionService;

    @BeforeEach
    void setUp() {
//        // 初始化 DAO 和 Service
//        CsvTransactionDao csvTransactionDao = new CsvTransactionDao();
//        transactionService = new TransactionServiceImpl(csvTransactionDao);
    }

    @Test
    void testAddTransaction() throws IOException {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );

        // 执行添加操作
        transactionService.addTransaction(transaction);

        // 验证是否添加成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertFalse(transactions.isEmpty());
        assertEquals("T123456789", transactions.get(0).getOrderNumber());
    }

    @Test
    void testChangeTransaction() throws Exception {
        // 准备测试数据
        Transaction originalTransaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(originalTransaction);

        // 准备更新数据
        Transaction updatedTransaction = new Transaction(
                null, "充值", null, null, null, 0.0, "微信支付", null, "T123456789", null, "更新备注"
        );

        // 执行更新操作
        transactionService.changeTransaction(updatedTransaction);

        // 验证是否更新成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertEquals("充值", transactions.get(0).getTransactionType());
        assertEquals("微信支付", transactions.get(0).getPaymentMethod());
        assertEquals("更新备注", transactions.get(0).getRemarks());
    }

    @Test
    void testDeleteTransaction() throws Exception {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(transaction);

        // 执行删除操作
        boolean result = transactionService.deleteTransaction("T123456789");

        // 验证是否删除成功
        assertTrue(result);
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertTrue(transactions.isEmpty());
    }

    @Test
    void testSearchTransaction() throws IOException {

        // 设置搜索条件
        Transaction searchCriteria = new Transaction();
        searchCriteria.setCounterparty("支付宝");

        // 执行搜索操作
        List<Transaction> result = transactionService.searchTransaction(searchCriteria);

        // 验证搜索结果
        result.forEach(res -> System.out.println(res.getCommodity()));
    }


}
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\resources\CSVForm\transactions\admin_transactions.csv`:

```csv
交易时间,交易类型,交易对方,商品,收/支,金额(元),支付方式,当前状态,交易单号,商户单号,备注
2025/03/01 09:00:00,工资,公司A,"三月工资",收入,"¥10000.00",银行卡,已入账,SALARY_MAR_A,PAYROLL_A_001,"本月基本工资"
2025/03/05 14:30:00,购物,超市B,"食品杂货",支出,"¥250.50",支付宝,已完成,SHOP_B_001,ALIPAY_12345,"周末采购"
2025/03/10 10:00:00,转账,用户1,"报销午餐",支出,"¥50.00",微信支付,已完成,TRANSFER_U1_001,WECHAT_56789,"归还午餐费"
2025/03/15 11:00:00,餐饮,餐厅C,"午餐外卖",支出,"¥35.75",美团支付,已完成,MEAL_C_001,MEITUAN_11223,"工作日午餐"
2025/03/20 16:00:00,投资,股票账户,"购入股票",支出,"¥5000.00",银行转账,已完成,INVEST_STOCK_001,BANK_99887,"长期投资"
```

`软工/Ai-Bill-Application-Group21\Ai Bill Application\src\test\resources\CSVForm\users\users.csv`:

```csv
username,password,role,transaction_csv_path
admin,admin123,admin,Ai Bill Application/src/main/resources/CSVForm/transactions/admin_transactions.csv
user1,pass123,user,Ai Bill Application/src/main/resources/CSVForm/transactions/user1_transactions.csv
user2,securepwd,user,Ai Bill Application/src/main/resources/CSVForm/transactions/user2_transactions.csv

```

`软工/Ai-Bill-Application-Group21\Ai-Bill-Application-Prompt.txt`:

```txt
Project Path: Ai-Bill-Application-Group21

Source Tree:

```txt
Ai-Bill-Application-Group21
└── Ai Bill Application
    ├── HistogramPanelContainer.java
    └── src
        ├── main
        │   └── java
        │       ├── Constants
        │       │   ├── CaffeineKeys.java
        │       │   └── ConfigConstants.java
        │       ├── Controller
        │       │   ├── ButtonEditor.java
        │       │   ├── ButtonRenderer.java
        │       │   ├── HistogramExample.java
        │       │   ├── HistogramPanelContainer.java
        │       │   └── MenuUI.java
        │       ├── DAO
        │       │   ├── CsvTransactionDao.java
        │       │   └── TransactionDao.java
        │       ├── Interceptor
        │       │   └── Login
        │       │       ├── LoginDialog.java
        │       │       └── UserService.java
        │       ├── Main.java
        │       ├── Service
        │       │   ├── AIservice
        │       │   │   ├── AIAnalyzerThread.java
        │       │   │   ├── AITransactionService.java
        │       │   │   ├── ColledgeStudentThread.java
        │       │   │   └── CollegeStudentNeeds.java
        │       │   ├── Impl
        │       │   │   └── TransactionServiceImpl.java
        │       │   ├── TransactionService.java
        │       │   └── deepseek
        │       │       └── ChatCompletionsExample.java
        │       ├── Utils
        │       │   └── CacheUtil.java
        │       └── model
        │           └── Transaction.java
        └── test
            └── java
                ├── ControllerTest
                │   ├── AITest.java
                │   └── MenuUITest.java
                ├── DAOTest
                │   └── CsvTransactionDaoTest.java
                └── Service
                    ├── AIAnalyzerThreadTest.java
                    ├── AIserviceTest.java
                    ├── AiFunctionTest.java
                    ├── CacheTest.java
                    ├── CollegeStudentNeedsTest.java
                    └── TransactionServiceTest.java

```

`Ai-Bill-Application-Group21/Ai Bill Application\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Constants\CaffeineKeys.java`:

```java
package Constants;

public class CaffeineKeys {
    public static final String TRANSACTION_CAFFEINE_KEY = "transactions";

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Constants\ConfigConstants.java`:

```java
package Constants;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

/**
 * 配置常量类（线程安全初始化）
 */
public final class ConfigConstants {
    // 私有构造防止实例化
    private ConfigConstants() {}

    /**
     * transactionCSV路径加载逻辑
     */
    // CSV路径常量
    public static final String CSV_PATH;
    // 静态初始化块（类加载时执行）
    static {
        Properties prop = new Properties();
        try (InputStream input = ConfigConstants.class.getClassLoader()
                .getResourceAsStream("config.properties")) {

            prop.load(input);
            CSV_PATH = prop.getProperty("csv.path");
        } catch (IOException e) {
            throw new RuntimeException("加载配置文件失败", e); // 转换为运行时异常
        }
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\ButtonEditor.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.TableCellEditor;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

class ButtonEditor extends AbstractCellEditor implements TableCellEditor {
    private final JPanel panel = new JPanel(new BorderLayout()); // 使用 BorderLayout
    private final JButton button = new JButton();
    private int rowIndex;
    private final MenuUI menuUI;

    public ButtonEditor(MenuUI menuUI) {
        this.menuUI = menuUI;

        // 设置按钮样式
        button.setFocusPainted(false); // 移除按钮的焦点边框
        button.setPreferredSize(new Dimension(80, 30)); // 设置按钮的固定尺寸

        // 添加按钮到面板
        panel.add(button, BorderLayout.CENTER);

        // 为按钮添加事件监听器
        button.addActionListener(e -> {
            System.out.println("按钮点击事件触发: " + button.getText());
            fireEditingStopped(); // 停止编辑
            String buttonText = button.getText();
            if ("Modify".equals(buttonText)) {
                menuUI.editRow(rowIndex); // 调用 MenuUI 的 editRow 方法
            } else if ("Delete".equals(buttonText)) {
                int confirm = JOptionPane.showConfirmDialog(panel, "确定要删除此行吗？", "确认删除", JOptionPane.YES_NO_OPTION);
                if (confirm == JOptionPane.YES_OPTION) {
                    menuUI.deleteRow(rowIndex); // 调用 MenuUI 的 deleteRow 方法
                }
            }
        });
    }

    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
        this.rowIndex = row; // 更新当前行索引
        button.setText(value != null ? value.toString() : ""); // 根据单元格的值设置按钮文本
        return panel;
    }

    @Override
    public Object getCellEditorValue() {
        return button.getText(); // 返回按钮的当前文本
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\ButtonRenderer.java`:

```java
package Controller;

import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import java.awt.*;

class ButtonRenderer extends DefaultTableCellRenderer {
    private final JPanel panel = new JPanel(new BorderLayout()); // 使用 BorderLayout
    private final JButton button = new JButton();

    public ButtonRenderer() {
        button.setFocusPainted(false); // 移除按钮的焦点边框
        button.setPreferredSize(new Dimension(80, 30)); // 设置按钮的固定尺寸
        panel.add(button, BorderLayout.CENTER); // 将按钮添加到面板中心
    }

    @Override
    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
        // 根据单元格的值设置按钮文本
        button.setText(value != null ? value.toString() : "");
        return panel;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\HistogramExample.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;
import java.util.HashMap;
import java.util.Random;

// 数据生成类
class DataGenerator {
    public static int[] generateData(int numberOfDataPoints, int maxValue) {
        Random random = new Random();
        int[] data = new int[numberOfDataPoints];
        for (int i = 0; i < numberOfDataPoints; i++) {
            data[i] = random.nextInt(maxValue);
        }
        return data;
    }
}

// 直方图计算类
class Histogram {
    private int binSize;
    private int[] data;

    public Histogram(int[] data, int binSize) {
        this.data = data;
        this.binSize = binSize;
    }

    public HashMap<Integer, Integer> computeFrequency() {
        HashMap<Integer, Integer> frequencyMap = new HashMap<>();
        for (int number : data) {
            int bin = number / binSize;
            frequencyMap.put(bin, frequencyMap.getOrDefault(bin, 0) + 1);
        }
        return frequencyMap;
    }
}

// 直方图 GUI 绘制类
class HistogramPanel extends JPanel {
    HashMap<Integer, Integer> frequencyMap;

    public HistogramPanel() {
        this.frequencyMap = new HashMap<>();
    }

    public void updateData(HashMap<Integer, Integer> frequencyMap) {
        this.frequencyMap = frequencyMap;
        repaint();
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        int barWidth = 40;
        int gap = 10;
        int maxFrequency = frequencyMap.values().stream().mapToInt(v -> v).max().orElse(1);

        int index = 0;
        for (Integer key : frequencyMap.keySet()) {
            int height = (int) ((frequencyMap.get(key) / (double) maxFrequency) * getHeight());
            g.setColor(Color.BLUE);
            g.fillRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.setColor(Color.BLACK);
            g.drawRect(index * (barWidth + gap), getHeight() - height, barWidth, height);
            g.drawString("Bin " + key, index * (barWidth + gap) + 5, getHeight() - 5);
            index++;
        }
    }
}


// 主窗口类
public class HistogramExample {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            JFrame frame = new JFrame("数据分析界面");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\HistogramPanelContainer.java`:

```java
package Controller;

import javax.swing.*;
import java.awt.*;

// 直方图面板容器
public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> toggleText("这是一段非常长的文本..."));
        btnShowText2.addActionListener(e -> toggleText("222222222222222"));
    }

    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }

    private void toggleText(String text) {
        if (isTextVisible) {
            textArea.setText("");
        } else {
            textArea.setText(text);
        }
        isTextVisible = !isTextVisible;
    }



    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Controller\MenuUI.java`:

```java
package Controller;

import Constants.ConfigConstants;
import DAO.Impl.CsvTransactionDao;

import Service.Impl.TransactionServiceImpl;

import Service.Impl.TransactionServiceImpl;

import Utils.CacheUtil;
import model.Transaction;

import javax.swing.*;
import java.awt.*;
import java.io.IOException;
import java.util.List;
import java.util.Vector;
import javax.swing.table.DefaultTableModel;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class MenuUI {
    private static final String FILE_PATH = CSV_PATH;
    private static DefaultTableModel tableModel;
    private static Vector<Vector<String>> allData = new Vector<>();
    private static TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());
    private JTable table;  // 把table定义为静态字段
    private HistogramPanelContainer histogramPanelContainer; // 添加 HistogramPanelContainer 实例
    private JPanel rightPanel; // 右边的面板，用于显示搜索和表格界面或 AI 界面
    private CardLayout cardLayout; // 用于管理界面切换的布局

    public MenuUI(){
        String[] columnNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注", "Modify", "Delete"};
        tableModel = new DefaultTableModel(columnNames, 0);
        table = new JTable(tableModel);

        histogramPanelContainer = new HistogramPanelContainer(); // 初始化 HistogramPanelContainer
        cardLayout = new CardLayout(); // 初始化 CardLayout
        rightPanel = new JPanel(cardLayout); // 初始化 rightPanel
    }

    public JPanel createMainPanel() {
        // 主面板，使用 BorderLayout
        JPanel mainPanel = new JPanel(new BorderLayout());

        // 左边的面板，包含 Menu 和 AI 按钮
        JPanel leftPanel = createLeftPanel();
        mainPanel.add(leftPanel, BorderLayout.WEST);

        // 右边的面板，用于显示搜索和表格界面或 AI 界面
        setupRightPanel();
        mainPanel.add(rightPanel, BorderLayout.CENTER);

        return mainPanel;
    }

    // 创建左边的面板，包含 Menu 和 AI 按钮
    private JPanel createLeftPanel() {
        JPanel leftPanel = new JPanel(new GridLayout(2, 1));
        JButton menuButton = new JButton("Menu");
        JButton aiButton = new JButton("AI");

        leftPanel.add(menuButton);
        leftPanel.add(aiButton);

        // 为 Menu 按钮添加 ActionListener
        menuButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Table"); // 切换到表格界面
        });

        // 为 AI 按钮添加 ActionListener
        aiButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Histogram"); // 切换到直方图界面
        });

        return leftPanel;
    }

    // 设置右边的面板，包含搜索和表格界面或 AI 界面
    private void setupRightPanel() {
        // 创建搜索和表格的面板
        JPanel tablePanel = createTablePanel();

        // 将表格面板和直方图面板添加到 rightPanel
        rightPanel.add(tablePanel, "Table");
        rightPanel.add(histogramPanelContainer, "Histogram");
    }

    // 创建搜索和表格的面板
    private JPanel createTablePanel() {
        JPanel tablePanel = new JPanel(new BorderLayout());

        // 创建输入面板
        JPanel inputPanel = createInputPanel();
        tablePanel.add(inputPanel, BorderLayout.NORTH);

        // 创建表格的滚动面板
        JScrollPane tableScrollPane = new JScrollPane(table);
        tableScrollPane.setPreferredSize(new Dimension(1000, 250));
        table.setRowHeight(30); // 设置表格的行高

        tablePanel.add(tableScrollPane, BorderLayout.CENTER);

        // 为 Modify 列设置渲染器和编辑器
        table.getColumnModel().getColumn(11).setCellRenderer(new ButtonRenderer());
        table.getColumnModel().getColumn(11).setCellEditor(new ButtonEditor(this));

        // 为 Delete 列设置渲染器和编辑器
        table.getColumnModel().getColumn(12).setCellRenderer(new ButtonRenderer());
        table.getColumnModel().getColumn(12).setCellEditor(new ButtonEditor(this));

        // 加载 CSV 数据
        loadCSVData(FILE_PATH);

        return tablePanel;
    }

    // 创建输入面板
    private JPanel createInputPanel() {
        JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));

        // 创建输入字段
        JTextField transactionTimeField = new JTextField(10); // 交易时间输入框
        JTextField transactionTypeField = new JTextField(10); // 交易类型输入框
        JTextField counterpartyField = new JTextField(10);    // 交易对方输入框
        JTextField commodityField = new JTextField(10);      // 商品输入框
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"}); // 收/支下拉框
        JTextField paymentMethodField = new JTextField(10);  // 支付方式输入框

        // 添加标签和输入字段到输入面板
        inputPanel.add(new JLabel("交易时间:"));
        inputPanel.add(transactionTimeField);
        inputPanel.add(new JLabel("交易类型:"));
        inputPanel.add(transactionTypeField);
        inputPanel.add(new JLabel("交易对方:"));
        inputPanel.add(counterpartyField);
        inputPanel.add(new JLabel("商品:"));
        inputPanel.add(commodityField);
        inputPanel.add(new JLabel("收/支:"));
        inputPanel.add(inOutComboBox);
        inputPanel.add(new JLabel("支付方式:"));
        inputPanel.add(paymentMethodField);

        // 创建 Search 和 Add 按钮
        JButton searchButton = new JButton("Search");
        JButton addButton = new JButton("Add");

        // 将按钮添加到输入面板
        inputPanel.add(searchButton);
        inputPanel.add(addButton);

        // 为 Search 按钮添加 ActionListener
        searchButton.addActionListener(e -> {
            // 获取输入字段的值
            searchData(
                    transactionTimeField.getText().trim(),
                    transactionTypeField.getText().trim(),
                    counterpartyField.getText().trim(),
                    commodityField.getText().trim(),
                    (String) inOutComboBox.getSelectedItem(),
                    paymentMethodField.getText().trim()
            );
        });

        // 为 Add 按钮添加 ActionListener
        addButton.addActionListener(e -> {
            // 弹出对话框，输入交易信息
            showAddTransactionDialog();
        });

        return inputPanel;
    }

    // 弹出对话框，输入交易信息
    private void showAddTransactionDialog() {
        // 创建对话框
        JDialog addDialog = new JDialog();
        addDialog.setTitle("添加交易");
        addDialog.setLayout(new GridLayout(12, 2)); // 11 个字段 + 1 个按钮行

        // 创建输入字段
        JTextField transactionTimeField = new JTextField();
        JTextField transactionTypeField = new JTextField();
        JTextField counterpartyField = new JTextField();
        JTextField commodityField = new JTextField();
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"});
        JTextField paymentAmountField = new JTextField();
        JTextField paymentMethodField = new JTextField();
        JTextField currentStatusField = new JTextField();
        JTextField orderNumberField = new JTextField();
        JTextField merchantNumberField = new JTextField();
        JTextField remarksField = new JTextField();

        // 添加标签和输入字段到对话框
        addDialog.add(new JLabel("交易时间:"));
        addDialog.add(transactionTimeField);
        addDialog.add(new JLabel("交易类型:"));
        addDialog.add(transactionTypeField);
        addDialog.add(new JLabel("交易对方:"));
        addDialog.add(counterpartyField);
        addDialog.add(new JLabel("商品:"));
        addDialog.add(commodityField);
        addDialog.add(new JLabel("收/支:"));
        addDialog.add(inOutComboBox);
        addDialog.add(new JLabel("金额(元):"));
        addDialog.add(paymentAmountField);
        addDialog.add(new JLabel("支付方式:"));
        addDialog.add(paymentMethodField);
        addDialog.add(new JLabel("当前状态:"));
        addDialog.add(currentStatusField);
        addDialog.add(new JLabel("交易单号:"));
        addDialog.add(orderNumberField);
        addDialog.add(new JLabel("商户单号:"));
        addDialog.add(merchantNumberField);
        addDialog.add(new JLabel("备注:"));
        addDialog.add(remarksField);

        // 添加确认按钮
        JButton confirmButton = new JButton("确认");
        confirmButton.addActionListener(e -> {
            // 获取输入字段的值，若为空则设置为默认值
            String transactionTime = emptyIfNull(transactionTimeField.getText().trim());
            String transactionType = emptyIfNull(transactionTypeField.getText().trim());
            String counterparty = emptyIfNull(counterpartyField.getText().trim());
            String commodity = emptyIfNull(commodityField.getText().trim());
            String inOut = (String) inOutComboBox.getSelectedItem();
            String paymentAmountText = paymentAmountField.getText().trim();
            double paymentAmount = paymentAmountText.isEmpty() ? 0.0 : Double.parseDouble(paymentAmountText); // 处理空字符串
            String paymentMethod = emptyIfNull(paymentMethodField.getText().trim());
            String currentStatus = emptyIfNull(currentStatusField.getText().trim());
            String orderNumber = emptyIfNull(orderNumberField.getText().trim());
            String merchantNumber = emptyIfNull(merchantNumberField.getText().trim());
            String remarks = emptyIfNull(remarksField.getText().trim());

            // 创建 Transaction 对象
            Transaction newTransaction = new Transaction(
                    transactionTime,
                    transactionType,
                    counterparty,
                    commodity,
                    inOut,
                    paymentAmount,
                    paymentMethod,
                    currentStatus,
                    orderNumber,
                    merchantNumber,
                    remarks
            );

            try {
                // 调用 TransactionServiceImpl 的 addTransaction 方法
                transactionService.addTransaction(newTransaction);

                // 重新加载 CSV 数据以更新表格
                loadCSVData(TRANSACTION_CAFFEINE_KEY);

                // 关闭对话框
                addDialog.dispose();

                JOptionPane.showMessageDialog(null, "交易添加成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(null, "交易添加失败！", "错误", JOptionPane.ERROR_MESSAGE);
            }
        });

        addDialog.add(confirmButton);

        // 设置对话框大小并显示
        addDialog.setSize(400, 300);
        addDialog.setModal(true); // 设置为模态对话框
        addDialog.setVisible(true);
    }

    // 加载 CSV 数据
    public void loadCSVData(String caffeineKey) {
        allData.clear();
        tableModel.setRowCount(0);

        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;

//        CsvTransactionDao csvTransactionDao = new CsvTransactionDao();

        List<Transaction> transactions = cache.get(caffeineKey);
        for (Transaction transaction : transactions) {
            Vector<String> row = createRowFromTransaction(transaction);
            allData.add(row);
            tableModel.addRow(row);
        }
    }

    // 搜索数据
    public void searchData(String query1, String query2, String query3, String query4, String query6, String query5) {
        tableModel.setRowCount(0);
        Transaction searchCriteria = new Transaction(query1, query2, query3, query4, query6, 0, query5, "", "", "", "");

        try {
            List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);
            for (Transaction transaction : transactions) {
                Vector<String> row = createRowFromTransaction(transaction);
                tableModel.addRow(row);
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(null, "查询失败！", "错误", JOptionPane.ERROR_MESSAGE);
        }
    }

    // 从 Transaction 对象创建表格行
    private Vector<String> createRowFromTransaction(Transaction transaction) {
        Vector<String> row = new Vector<>();
        row.add(transaction.getTransactionTime());
        row.add(transaction.getTransactionType());
        row.add(transaction.getCounterparty());
        row.add(transaction.getCommodity());
        row.add(transaction.getInOut());
        row.add(String.valueOf(transaction.getPaymentAmount()));
        row.add(transaction.getPaymentMethod());
        row.add(transaction.getCurrentStatus());
        row.add(transaction.getOrderNumber());
        row.add(transaction.getMerchantNumber());
        row.add(transaction.getRemarks());
        row.add("Modify"); // Modify 按钮
        row.add("Delete"); // 添加 Delete 按钮
        return row;
    }

    // 删除行
    public void deleteRow(int rowIndex) {
        if (rowIndex >= 0 && rowIndex < allData.size()) {
            String orderNumber = allData.get(rowIndex).get(8).trim();
            System.out.println("尝试删除的交易单号: " + orderNumber); // 打印交易单号

            try {
                if (transactionService.deleteTransaction(orderNumber)) {
                    allData.remove(rowIndex);
                    tableModel.removeRow(rowIndex);
                    JOptionPane.showMessageDialog(null, "删除成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                } else {
                    JOptionPane.showMessageDialog(null, "删除失败：未找到对应的交易单号", "错误", JOptionPane.ERROR_MESSAGE);
                }
            } catch (IOException ex) {
                ex.printStackTrace();
                JOptionPane.showMessageDialog(null, "删除失败！", "错误", JOptionPane.ERROR_MESSAGE);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }

    // 编辑行
    public void editRow(int rowIndex) {
        System.out.println("编辑行: " + rowIndex);
        if (rowIndex >= 0 && rowIndex < allData.size()) {
            Vector<String> rowData = allData.get(rowIndex);

            // 创建一个面板用于显示编辑字段
            JPanel panel = new JPanel(new GridLayout(rowData.size() - 2, 2)); // 排除最后两列

            // 创建字段数组，用于存储用户输入的值
            JTextField[] fields = new JTextField[rowData.size() - 2]; // 排除最后两列

            // 遍历 rowData，跳过最后两列（"Modify" 和 "Delete"）
            for (int i = 0; i < rowData.size() - 2; i++) {
                panel.add(new JLabel(tableModel.getColumnName(i))); // 添加列名标签
                fields[i] = new JTextField(rowData .get(i)); // 添加输入字段
                panel.add(fields[i]);
            }

            // 弹出对话框，让用户修改数据
            int result = JOptionPane.showConfirmDialog(null, panel, "修改交易信息", JOptionPane.OK_CANCEL_OPTION);
            if (result == JOptionPane.OK_OPTION) {
                // 用户点击了确认按钮，更新交易信息
                Transaction transaction = new Transaction(
                        fields[0].getText().trim(), // 交易时间
                        fields[1].getText().trim(), // 交易类型
                        fields[2].getText().trim(), // 交易对方
                        fields[3].getText().trim(), // 商品
                        fields[4].getText().trim(), // 收/支
                        Double.parseDouble(fields[5].getText().trim()), // 金额(元)
                        fields[6].getText().trim(), // 支付方式
                        fields[7].getText().trim(), // 当前状态
                        fields[8].getText().trim(), // 交易单号
                        fields[9].getText().trim(), // 商户单号
                        fields[10].getText().trim() // 备注
                );

                try {
                    // 调用 TransactionServiceImpl 的 changeTransaction 方法更新交易
                    transactionService.changeTransaction(transaction);

                    // 重新加载 CSV 数据以更新表格
                    loadCSVData(TRANSACTION_CAFFEINE_KEY);

                    JOptionPane.showMessageDialog(null, "修改成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                } catch (Exception ex) {
                    ex.printStackTrace();
                    JOptionPane.showMessageDialog(null, "修改失败！", "错误", JOptionPane.ERROR_MESSAGE);
                }
            }
        }
    }

    /**
     * 查找对话框中的输入字段
     *
     * @param dialog 对话框
     * @param index  输入字段的索引
     * @return 输入字段
     */
    /**
     * 查找容器中的输入字段
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0;
        for (Component component : container.getComponents()) {
            if (component instanceof JTextField) {
                if (count == index) {
                    return (JTextField) component;
                }
                count++;
            }
        }
        return null;
    }

    /**
     * 查找对话框中的下拉框
     *
     * @param dialog 对话框
     * @return 下拉框
     */
    /**
     * 查找容器中的下拉框
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) {
            if (component instanceof JComboBox) {
                return (JComboBox<String>) component;
            }
        }
        return null;
    }

    /**
     * 如果字段为 null，则返回空文本
     *
     * @param value 字段值
     * @return 非 null 的字段值
     */
    private String emptyIfNull(String value) {
        return value == null ? "" : value;
    }

    // 添加此方法以便测试时可以获取table
    public JTable getTable() {
        return table;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\DAO\CsvTransactionDao.java`:

```java
package DAO;

import Constants.ConfigConstants;
import model.Transaction;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static Constants.ConfigConstants.CSV_PATH;

public class CsvTransactionDao implements TransactionDao {
    //避免每次都调用loadFromCSV() 方法
    private List<Transaction> transactions;
    private boolean isLoad= false;
//HEAD 交易时间	交易类型	交易对方	商品	收/支	金额(元)	支付方式	当前状态	交易单号	商户单号	备注
    //
    @Override
    public List<Transaction> loadFromCSV(String filePath) throws IOException {
        try (
                Reader reader = new InputStreamReader(
                        new BOMInputStream(Files.newInputStream(Paths.get(filePath))),
                        StandardCharsets.UTF_8)) {
            CSVFormat format = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()    //根据首行的内容设置为表格的头
                    .withIgnoreHeaderCase(false)  // 禁用忽略大小写
                    .withTrim(false);             // 禁用自动trim（防止意外空格问题）

            try (CSVParser csvParser = new CSVParser(reader, format)) {

                List<Transaction> transactions = new ArrayList<>();
                for (CSVRecord record : csvParser) {
                    Transaction transaction = parseRecord(record);
                    transactions.add(transaction);
                }
                reader.close();
                this.transactions = transactions;
                this.isLoad=true;
                return transactions;
            }
        }
    }


    private Transaction parseRecord(CSVRecord record) {
        return new Transaction(
                record.get("交易时间"),
                record.get("交易类型"),
                record.get("交易对方"),
                record.get("商品"),
                record.get("收/支"),
                Double.parseDouble(record.get("金额(元)").substring(1)),
                record.get("支付方式"),
                record.get("当前状态"),
                record.get("交易单号"),
                record.get("商户单号"),
                record.get("备注")
        );
    }

    // 根据交易单号删除交易记录
    public boolean deleteTransaction(String filePath, String orderNumber) throws IOException {
        if(!isLoad){ loadFromCSV(filePath);}

        List<Transaction> updatedTransactions = transactions.stream()
                .filter(t -> !t.getOrderNumber().trim().equals(orderNumber))
                .collect(Collectors.toList());

        if (transactions.size() == updatedTransactions.size()) {
            return false;
        }

        writeTransactionsToCSV(filePath, updatedTransactions);
        return true;
    }

    // 添加交易
    public void addTransaction(String filePath, Transaction newTransaction) throws IOException {
        boolean fileExists = Files.exists(Paths.get(filePath)) && Files.size(Paths.get(filePath)) > 0;

        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(filePath), StandardOpenOption.CREATE, StandardOpenOption.APPEND);
             CSVPrinter csvPrinter = new CSVPrinter(writer, fileExists ? getCsvFormatWithoutHeader() : getCsvFormatWithHeader(filePath))) {

            csvPrinter.printRecord(
                    newTransaction.getTransactionTime(),
                    newTransaction.getTransactionType(),
                    newTransaction.getCounterparty(),
                    newTransaction.getCommodity(),
                    newTransaction.getInOut(),
                    "¥" + newTransaction.getPaymentAmount(),
                    newTransaction.getPaymentMethod(),
                    newTransaction.getCurrentStatus(),
                    newTransaction.getOrderNumber(),
                    newTransaction.getMerchantNumber(),
                    newTransaction.getRemarks()
            );

            csvPrinter.flush();
        }
    }

    // 统一写回 CSV
    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
        // 1. 创建临时文件（确保与原文件同目录）
        File targetFile = new File(filePath);
        File tempFile = File.createTempFile("transaction_temp", ".csv", targetFile.getParentFile());

        // 2. 写入数据到临时文件（使用 try-with-resources 确保资源释放）
        try (BufferedWriter writer = Files.newBufferedWriter(tempFile.toPath());
             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(
                     "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"))) {

            for (Transaction t : transactions) {
                csvPrinter.printRecord(
                        t.getTransactionTime(),
                        t.getTransactionType(),
                        t.getCounterparty(),
                        t.getCommodity(),
                        t.getInOut(),
                        "¥" + t.getPaymentAmount(),
                        t.getPaymentMethod(),
                        t.getCurrentStatus(),
                        t.getOrderNumber(),
                        t.getMerchantNumber(),
                        t.getRemarks()
                );
            }
            csvPrinter.flush(); // 强制刷盘
        } catch (IOException e) {
            tempFile.delete(); // 失败时删除临时文件
            throw e;
        }

        // 3. 原子性替换原文件
        Path source = tempFile.toPath();
        Path target = Paths.get(filePath);
        try {
            Files.move(source, target, StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            System.err.println("移动失败原因: " + e.getMessage());
        }
    }

//    // 统一写回 CSV
//    public void writeTransactionsToCSV(String filePath, List<Transaction> transactions) throws IOException {
//        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(filePath));
//             CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(
//                     "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注")))  {
//
//            for (Transaction t : transactions) {
//                csvPrinter.printRecord(
//                        t.getTransactionTime(),
//                        t.getTransactionType(),
//                        t.getCounterparty(),
//                        t.getCommodity(),
//                        t.getInOut(),
//                        "¥" + t.getPaymentAmount(),
//                        t.getPaymentMethod(),
//                        t.getCurrentStatus(),
//                        t.getOrderNumber(),
//                        t.getMerchantNumber(),
//                        t.getRemarks()
//                );
//            }
//        }
//    }

    // 获取 CSV 格式（包含表头）
    private CSVFormat getCsvFormatWithHeader(String filePath) throws IOException {
        try (BufferedReader reader = Files.newBufferedReader(Paths.get(filePath))) {
            String headerLine = reader.readLine();
            if (headerLine == null || headerLine.trim().isEmpty()) {
                // 如果文件为空或不存在，返回默认表头
                return CSVFormat.DEFAULT.withHeader(
                        "交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"
                );
            }
            return CSVFormat.DEFAULT.withHeader(headerLine.split(",")).withTrim();
        }
    }

    // 获取 CSV 格式（不包含表头）
    private CSVFormat getCsvFormatWithoutHeader() {
        return CSVFormat.DEFAULT.withTrim();
    }

    public boolean changeInformation(String orderNumber, String head, String value,String path) throws IOException{
        if(isLoad==false){ loadFromCSV(path);}
        for (int i = 0; i < transactions.size(); i++) {
            if(transactions.get(i).getOrderNumber().trim().equals(orderNumber)){
                Transaction newTransaction=transactions.get(i);
                switch (head){
                    case "transactionTime" :{
                        newTransaction.setTransactionTime(value);
                        break;}
                    case "transactionType" :{
                        newTransaction.setTransactionType(value);
                        break;
                    }
                    case "counterparty" :{
                        newTransaction.setCounterparty(value);
                        break;
                    } case "commodity" :{
                        newTransaction.setCommodity(value);
                        break;
                    } case "inOut" :{
                        newTransaction.setInOut(value);
                        break;
                    } case "paymentAmount" :{
                        newTransaction.setPaymentAmount(Double.parseDouble(value));
                        break;
                    } case "paymentMethod" :{
                        newTransaction.setPaymentMethod(value);
                        break;
                    } case "currentStatus" :{
                        newTransaction.setCurrentStatus(value);
                        break;
                    } case "orderNumber" :{
                        newTransaction.setOrderNumber(value);
                        break;
                    } case "merchantNumber" :{
                        newTransaction.setMerchantNumber(value);
                        break;
                    } case "remarks" :{
                        newTransaction.setRemarks(value);
                        break;
                    } default:{
                        System.err.println("error head");
                    }
                }

                boolean flag=deleteTransaction(path,transactions.get(i).getOrderNumber());
                if(flag) {
                    addTransaction(path,newTransaction);
                    System.out.println("success to delete");
                }
                else System.err.println("failed to delete");
            }
        }
        return true;
    }

    @Override
    public List<Transaction> getAllTransactions() throws IOException {
        return List.of();
    }

    @Override
    public void addTransaction(Transaction transaction) throws IOException {

    }

    @Override
    public boolean deleteTransaction(String orderNumber) throws IOException {
        return false;
    }

    @Override
    public boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException {
        return false;
    }

    @Override
    public Transaction getTransactionByOrderNumber(String orderNumber) throws IOException {
        return null;
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\DAO\TransactionDao.java`:

```java
package DAO;

import model.Transaction;

import java.io.IOException;
import java.util.List;

/**
 * Interface for Data Access Object (DAO) operations related to Transactions.
 * Defines the contract for loading, adding, deleting, and updating transaction data.
 */
public interface
TransactionDao {

    //HEAD 交易时间	交易类型	交易对方	商品	收/支	金额(元)	支付方式	当前状态	交易单号	商户单号	备注
        //
    List<Transaction> loadFromCSV(String filePath) throws IOException;

    /**
     * Loads all transactions from the configured data source.
     *
     * @return A list of all transactions.
     * @throws IOException If an I/O error occurs during loading.
     */
    List<Transaction> getAllTransactions() throws IOException;

    /**
     * Adds a new transaction to the data source.
     *
     * @param transaction The new transaction to add.
     * @throws IOException If an I/O error occurs during saving.
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * Deletes a transaction identified by its order number.
     *
     * @param orderNumber The unique order number of the transaction to delete.
     * @return true if a transaction was found and deleted, false otherwise.
     * @throws IOException If an I/O error occurs during loading or saving.
     */
    boolean deleteTransaction(String orderNumber) throws IOException;

    /**
     * Updates a specific field of an existing transaction identified by its order number.
     *
     * @param orderNumber The unique order number of the transaction to update.
     * @param fieldName   The name of the field to update (e.g., "transactionType", "paymentAmount").
     * @param newValue    The new value for the specified field.
     * @return true if the transaction was found and updated, false otherwise.
     * @throws IOException             If an I/O error occurs during loading or saving.
     * @throws NumberFormatException   If updating 'paymentAmount' and newValue is not a valid double.
     * @throws IllegalArgumentException If the fieldName is invalid.
     */
    boolean updateTransaction(String orderNumber, String fieldName, String newValue) throws IOException;

    /**
     * Retrieves a transaction by its unique order number.
     * (Optional but often useful)
     *
     * @param orderNumber The unique order number.
     * @return The Transaction object if found, null otherwise.
     * @throws IOException If an I/O error occurs during loading.
     */
    Transaction getTransactionByOrderNumber(String orderNumber) throws IOException;

}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Interceptor\Login\LoginDialog.java`:

```java
package Interceptor.Login;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class LoginDialog extends JDialog {
    private boolean loginSuccessful = false;
    private JTextField usernameField;
    private JPasswordField passwordField;
    private UserService userService = new UserService();

    public LoginDialog() {
        setTitle("用户登录");
        setLayout(new GridLayout(3, 2));
        setModal(true);
        setSize(300, 150);

        // 输入组件
        usernameField = new JTextField();
        passwordField = new JPasswordField();
        JButton loginButton = new JButton("登录");
        JButton cancelButton = new JButton("取消");

        // 添加组件
        add(new JLabel("用户名:"));
        add(usernameField);
        add(new JLabel("密码:"));
        add(passwordField);
        add(loginButton);
        add(cancelButton);

        // 登录按钮逻辑
        loginButton.addActionListener(e -> {
            String username = usernameField.getText().trim();
            String password = new String(passwordField.getPassword()).trim();

            if (userService.authenticate(username, password)) {
                loginSuccessful = true;
                dispose(); // 关闭对话框
            } else {
                JOptionPane.showMessageDialog(
                        this,
                        "用户名或密码错误！",
                        "登录失败",
                        JOptionPane.ERROR_MESSAGE
                );
                clearFields(); // 登录失败后清空文本框
            }
        });

        // 取消按钮逻辑
        cancelButton.addActionListener(e -> {
            dispose();
            System.exit(0);
        });

        setLocationRelativeTo(null); // 居中显示
    }

    // 清空文本框的方法
    private void clearFields() {
        usernameField.setText("");
        passwordField.setText("");
        usernameField.requestFocus(); // 焦点回到用户名输入框
    }

    public boolean isLoginSuccessful() {
        return loginSuccessful;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Interceptor\Login\UserService.java`:

```java
package Interceptor.Login;

import java.util.HashMap;
import java.util.Map;

public class UserService {
    // 模拟用户数据库（用户名 -> 密码哈希值）
    private static final Map<String, String> userDatabase = new HashMap<>();

    public UserService() {
        // 初始化测试用户（密码为 "admin123" 的 SHA-256 哈希）
        userDatabase.put("admin", "admin123");
    }

    public boolean authenticate(String username, String password) {
        if (username.isEmpty() || password.isEmpty()) return false;
        String storedHash = userDatabase.get(username);
        return password.equals(storedHash);
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Main.java`:

```java
import javax.swing.*;

import Controller.MenuUI;
import DAO.Impl.CsvTransactionDao;
import Interceptor.Login.LoginDialog;
import Service.Impl.TransactionServiceImpl;

public class Main {
    public static void main(String[] args) {
        // 初始化服务（依赖注入）
        TransactionServiceImpl.csvTransactionDao = new CsvTransactionDao();

        // 在事件调度线程中启动 GUI（Swing 规范）
        SwingUtilities.invokeLater(() -> {
            // 1. 显示登录对话框
            LoginDialog loginDialog = new LoginDialog();
            loginDialog.setVisible(true);

            // 2. 登录成功后再显示主界面
            if (loginDialog.isLoginSuccessful()) {
                MenuUI menuUI = new MenuUI();
                JPanel mainPanel = menuUI.createMainPanel();
                showMainUI(mainPanel);
            } else {
                System.exit(0); // 登录失败退出
            }
        });
    }

    /**
     * 显示主界面窗口
     */
    private static void showMainUI(JPanel panel) {
        JFrame frame = new JFrame("交易管理系统");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(1200, 600);
        frame.setLocationRelativeTo(null); // 窗口居中
        frame.add(panel);
        frame.setVisible(true);
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\AIAnalyzerThread.java`:

```java
package Service.AIservice;

public class AIAnalyzerThread implements Runnable {
    private final String userRequest;
    private final String filePath;
    private final String startTimeStr;
    private final String endTimeStr;

    public AIAnalyzerThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        this.userRequest = userRequest;
        this.filePath = filePath;
        this.startTimeStr = startTimeStr;
        this.endTimeStr = endTimeStr;
    }

    @Override
    public void run() {
        String result = new AITransactionService().analyzeTransactions(userRequest, filePath, startTimeStr, endTimeStr);
        System.out.println("AI分析结果: " + result);
        // TODO: 如果是UI程序，可用 SwingUtilities.invokeLater() 更新UI组件
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\AITransactionService.java`:

```java
package Service.AIservice;
import Service.Impl.TransactionServiceImpl;
import Service.TransactionService;
import Constants.ConfigConstants;
import DAO.Impl.CsvTransactionDao;
import Utils.CacheUtil;
import model.Transaction;
import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;

import java.io.IOException;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;
import java.util.concurrent.*;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class AITransactionService {
    private static final String API_KEY = System.getenv("ARK_API_KEY");
    private static final ArkService service = ArkService.builder()
            .timeout(Duration.ofSeconds(1800))
            .connectTimeout(Duration.ofSeconds(20))
            .baseUrl("https://ark.cn-beijing.volces.com/api/v3")
            .apiKey(API_KEY)
            .build();

    private final CsvTransactionDao transactionDao = new CsvTransactionDao();

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    private final CacheUtil<String, List<Transaction>, Exception> cache;
    /**
     * 重构构造器初始化Caffeine
     */
    public AITransactionService()  {
        // 1. 注入Dao层接口
        TransactionServiceImpl.csvTransactionDao = transactionDao;
        // 2. 初始化CacheUtil
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return transactionDao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );
    }

    public String analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        try {
            List<Transaction> transactions = cache.get(TRANSACTION_CAFFEINE_KEY);
            List<String> transactionDetails = formatTransactions(transactions, startTimeStr, endTimeStr);

            String aiPrompt = userRequest + "\n" + "以下是我的账单信息：\n" + String.join("\n", transactionDetails);
            return askAi(aiPrompt);
        } catch (Exception e) {
            e.printStackTrace();
            return "AI分析失败: " + e.getMessage();
        }
    }


    //private List<String> formatTransactions(List<Transaction> transactions) {
        //return transactions.stream().map(t -> String.format(
               // "交易时间: %s, 商品: %s, 收/支: %s, 金额: %.2f元",
               // t.getTransactionTime(),
               // t.getCommodity(),
               // t.getInOut(),
               // t.getPaymentAmount()
        //)).collect(Collectors.toList());
    //}

    public List<String> formatTransactions(List<Transaction> transactions, String startTimeStr, String endTimeStr) {
        LocalDateTime startTime = parseDateTime(startTimeStr);
        LocalDateTime endTime = (endTimeStr == null || endTimeStr.isEmpty())
                ? LocalDateTime.now()
                : parseDateTime(endTimeStr);

        if (startTime == null) {
            throw new IllegalArgumentException("起始时间格式不正确");
        }

        List<Transaction> filtered = transactions.stream()
                .filter(t -> {
                    LocalDateTime tTime = parseDateTime(t.getTransactionTime());
                    return tTime != null && !tTime.isBefore(startTime) && !tTime.isAfter(endTime);
                })
                .collect(Collectors.toList());

        Map<String, double[]> grouped = new HashMap<>();
        for (Transaction t : filtered) {
            String counterparty = t.getCounterparty();
            double amount = t.getInOut().equals("支出") ? -t.getPaymentAmount() : t.getPaymentAmount();
            grouped.putIfAbsent(counterparty, new double[]{0.0, 0});
            grouped.get(counterparty)[0] += amount;
            grouped.get(counterparty)[1] += 1;
        }

        List<String> results = grouped.entrySet().stream()
                .map(e -> {
                    String cp = e.getKey();
                    double net = e.getValue()[0];
                    int count = (int) e.getValue()[1];
                    String inOut = net >= 0 ? "收入" : "支出";
                    return String.format("交易对方: %s, 收/支: %s, 金额: %.2f元，交易次数: %d",
                            cp, inOut, Math.abs(net), count);
                })
                .collect(Collectors.toList());

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm");
        results.add(String.format("交易时间范围：%s - %s",
                formatter.format(startTime), formatter.format(endTime)));

        return results.isEmpty() ? List.of("该时间段内没有交易记录。") : results;
    }




    //private LocalDateTime parseDateTime(String timeStr) {
        // 你可以按实际情况支持不同格式，比如 yyyy/MM/dd HH:mm 或 yyyy-MM-dd HH:mm:ss
        //List<String> patterns = Arrays.asList("yyyy/MM/dd HH:mm","yyyy/MM/dd H:mm", "yyyy/M/dd H:mm","yyyy/M/dd HH:mm","yyyy/M/d H:mm","yyyy/M/d HH:mm","yyyy-MM-dd HH:mm:ss", "yyyy/MM/dd");

        //for (String pattern : patterns) {
            //try {
                //DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                //return LocalDateTime.parse(timeStr, formatter);
            //} catch (Exception ignored) {}
        //}
        //return null;
    //}
        private LocalDateTime parseDateTime(String timeStr) {
            if (timeStr == null || timeStr.trim().isEmpty()) return null;

            // 中文空格等统一清理
            timeStr = timeStr.trim().replaceAll("\\s+", " ");

            // 如果只有日期，补 00:00
            if (timeStr.matches("\\d{4}/\\d{1,2}/\\d{1,2}")) {
                timeStr += " 00:00";
            }

            // 多种时间格式尝试解析
            List<String> patterns = Arrays.asList(
                    "yyyy/M/d H:mm", "yyyy/M/d HH:mm",
                    "yyyy/MM/d H:mm", "yyyy/MM/d HH:mm",
                    "yyyy/M/dd H:mm", "yyyy/M/dd HH:mm",
                    "yyyy/MM/dd H:mm", "yyyy/MM/dd HH:mm",
                    "yyyy-MM-dd HH:mm:ss",
                    "yyyy/MM/dd"
            );

            for (String pattern : patterns) {
                try {
                    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern);
                    return LocalDateTime.parse(timeStr, formatter);
                } catch (Exception ignored) {}
            }

            return null;
        }






    public String askAi(String prompt) {
        try {
            List<ChatMessage> messages = List.of(
                    ChatMessage.builder().role(ChatMessageRole.USER).content(prompt).build()
            );

            ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
                    .model("ep-20250308174053-7pbkq")
                    .messages(messages)
                    .build();

            return (String) service.createChatCompletion(chatCompletionRequest)
                    .getChoices().get(0).getMessage().getContent();
        } catch (Exception e) {
            e.printStackTrace();
            return "AI请求失败: " + e.getMessage();
        }
    }

    public void runAiInThread(String userRequest, String filePath,String startTimeStr, String endTimeStr) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            String result = analyzeTransactions(userRequest, filePath,startTimeStr, endTimeStr);
            System.out.println("AI分析结果: " + result);
        });
        executor.shutdown();
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\ColledgeStudentThread.java`:

```java
package Service.AIservice;

import java.io.IOException;

public class ColledgeStudentThread implements Runnable{
//    private final int userRequest;
    private final String filePath;
    public String budgetRange;
    public ColledgeStudentThread( String filePath) {
//        this.userRequest = userRequest;
        this.filePath = filePath;
    }

    @Override
    public void run(){
        CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
        try {
            collegeStudentNeeds.generateBudget(filePath);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\AIservice\CollegeStudentNeeds.java`:

```java
package Service.AIservice;

import Constants.ConfigConstants;
import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import model.Transaction;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class CollegeStudentNeeds {
    private final String requestBudge="我是一名预算有限的大学生，请根据下面我给出的花费，帮助我给下周预算范围，必须以[最低预算，最高预算],的方式给出回答，不能有多余的回复。";
    private final String requestTips="我是一名预算有限的大学生，请给我推荐一些省钱方法。";

    private final String requestRecognition="下面我将给你一些账单的信息，请推测这个账单是什么方面的消费: ";
    CsvTransactionDao dao;

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    private final CacheUtil<String, List<Transaction>, Exception> cache;

    public CollegeStudentNeeds() {
        TransactionServiceImpl.csvTransactionDao = dao;
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return dao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );

    }
    public String RecognizeTransaction(Transaction transaction){
        StringBuilder sb=new StringBuilder();
        sb.append("交易类型:").append(transaction.getTransactionType()+",").append("交易对方").append(transaction.getCounterparty()+",")
                .append("商品:").append(transaction.getCommodity()+",").append("收/支:").append(transaction.getInOut()+",")
                        .append("金额(元):").append(transaction.getPaymentAmount()+",").append("支付方式").append(transaction.getPaymentMethod()+",").append("备注:").append(transaction.getRemarks());
        return  new AITransactionService().askAi(requestRecognition+sb.toString());
    }

    public String generateTipsForSaving(){
        return  new AITransactionService().askAi(requestTips);
    }
    //按周统计已有的支出，依靠ai得到下周的预算
    public double[] generateBudget(String path) throws IOException {
        List<Transaction> transactions=cache.get(TRANSACTION_CAFFEINE_KEY);

        int size=transactions.size();
        if(size==0||size==1) return new double[]{-1,-1};
        int count=1;
        int base=0;
        int index=0;//指示首个适合当基准的时间点
        for (index = 0; index < size; index++) {
            int data=convertDateToNumber(transactions.get(index).getTransactionTime().split(" ")[0]);
            if(data>0){
                base=data;
                break;
            }
        }
        List<Double> list=new ArrayList<>();
        double weekConsumption=0;
        for (int i = 0; i < size; i++) {
            int data=convertDateToNumber(transactions.get(i).getTransactionTime().split(" ")[0]);
            if(data<0) continue;
            if((base-data>=0&&base-data<7)&&transactions.get(i).getInOut().equals("支出")){
                weekConsumption+=transactions.get(i).getPaymentAmount();
            }else if(base-data>=7){
                base=data;
                list.add(weekConsumption);
                count++;
                weekConsumption=0;
                if(transactions.get(i).getInOut().equals("支出")){
                    weekConsumption+=transactions.get(i).getPaymentAmount();
                }
            }
        }
        StringBuilder stringBuilder=new StringBuilder();
        for (int i = 0; i < count-1; i++) {
            stringBuilder.append("第");
            stringBuilder.append(i);
            stringBuilder.append("周:花费");
            stringBuilder.append(list.get(i));
            stringBuilder.append("元;");
        }
        String answer=new AITransactionService().askAi(requestBudge+stringBuilder.toString());
        System.out.println(answer);
        double[] ret=new double[2];
        ret=parseDoubleArrayFromString(answer);
        return ret;
    }

    private int convertDateToNumber(String date) {
        // format yyyy/MM/dd
        String[] parts = date.split("/");
        if (parts.length != 3) {
            return -1; // Invalid date format
        }
        try {
            int year = Integer.parseInt(parts[0]);
            int month = Integer.parseInt(parts[1]);
            int day = Integer.parseInt(parts[2]);
            int days = day;
            int[] daysInMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // Days in each month
            if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
                daysInMonth[2] = 29; // February has 29 days in a leap year
            }
            for (int i = 1; i < month; i++) {
                days += daysInMonth[i];
            }
            return year * 365 + (year / 4 - year / 100 + year / 400) + days;
        } catch (NumberFormatException e) {
            return -1;
        }
    }
    public double[] parseDoubleArrayFromString(String input) {
        int length=input.length();
        int l=0,rightindex=input.length();
        // 1. 去除首尾括号
        for (int i = 0; i < length; i++) {
            if(input.charAt(i)<58&&input.charAt(i)>47){
                l=i;
                break;
            }
        }
        for (int r =length-1 ; r >0; r--) {
            if(input.charAt(r)<58&&input.charAt(r)>47){
                rightindex=r;
                break;
            }
        }
        String content = input.substring(l, rightindex+1 ); // 获取 "1.1, 11.0" 或 " 2.5 ,3.14 , -0.5 "

        // 2. 按逗号分割
        String[] numberStrings1 = content.split("，"); // 得到 ["1.1", " 11.0"] 或 [" 2.5 ", "3.14 ", " -0.5 "]
        String[] numberStrings2 = content.split(","); // 得到 ["1.1", " 11.0"] 或 [" 2.5 ", "3.14 ", " -0.5 "]
        String[] numberStrings= numberStrings1.length> numberStrings2.length?numberStrings1:numberStrings2;
//        System.out.println(numberStrings[0]);
//        System.out.println(numberStrings[1]);
        // 3. & 4. 遍历、清理、解析并存储
        List<Double> numberList = new ArrayList<>();
        try {
            for (String numStr : numberStrings) {
                String trimmedStr = numStr.trim(); // 去除首尾空格
                if (!trimmedStr.isEmpty()) { // 避免分割后产生空字符串（例如 "[1.1, , 2.2]"）
                    numberList.add(Double.parseDouble(trimmedStr)); // 解析为 double
                }
            }
        } catch (NumberFormatException e) {
            System.err.println("错误：字符串无法解析为 double 类型。");
            return null; // 或者抛出异常
        }

        // 将 List<Double> 转换为 double[]
        double[] result = new double[numberList.size()];
        for (int i = 0; i < numberList.size(); i++) {
            result[i] = numberList.get(i);
        }
        return result;
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\Impl\TransactionServiceImpl.java`:

```java
package Service.Impl;

import Constants.ConfigConstants;
import DAO.Impl.CsvTransactionDao;
import Service.TransactionService;
import Utils.CacheUtil;
import model.Transaction;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;
import static Constants.ConfigConstants.CSV_PATH;

public class TransactionServiceImpl implements TransactionService {
    public static CsvTransactionDao csvTransactionDao;

    /**
     * 定义缓存：键为固定值（因为只有一个CSV文件），值为交易列表
     */
    public final CacheUtil<String, List<Transaction>, Exception> cache;

    /**
     * 通过构造函数注入路径和csvTransactionDao
     * @param csvTransactionDao
     * @throws IOException
     */
    public TransactionServiceImpl(CsvTransactionDao csvTransactionDao)  {
        // 1. 注入Dao层接口
        TransactionServiceImpl.csvTransactionDao = csvTransactionDao;
        // 2. 初始化CacheUtil
        this.cache = new CacheUtil<String, List<Transaction>, Exception>(
                key -> {
                    try {
                        return csvTransactionDao.loadFromCSV(CSV_PATH);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }, // 定义缓存未命中的执行逻辑
                1, 10, 1
        );
    }

    /**
     * 从transactions缓存中读取transactions如果没有则从csv文件中找
     * @return
     * @throws IOException
     */
    private List<Transaction> getAllTransactions() throws Exception {
        return cache.get(TRANSACTION_CAFFEINE_KEY);
    }


    /**
     * 新增交易
     * @param transaction
     */
    @Override
    public void addTransaction(Transaction transaction) throws IOException {
        // 设置交易时间为当前时间
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
        String currentTime = now.format(formatter);
        transaction.setTransactionTime(currentTime);

        // 调用 DAO 层方法添加交易
        csvTransactionDao.addTransaction(CSV_PATH, transaction);
    }

    @Override
    public void changeTransaction(Transaction updatedTransaction) throws Exception {
        // 1. 加载所有交易记录 先加载 caffeine存储的缓存
        List<Transaction> allTransactions = getAllTransactions();

        // 2. 查找并修改目标交易
        boolean found = false;
        for (int i = 0; i < allTransactions.size(); i++) {
            Transaction t = allTransactions.get(i);
            // 根据交易单号匹配记录（唯一标识）
            if (t.getOrderNumber().equals(updatedTransaction.getOrderNumber())) {
                // 3. 更新非空字段
                updateTransactionFields(t, updatedTransaction);
                found = true;
                break;
            }
        }
        if (!found) {
            throw new IllegalArgumentException("未找到交易单号: " + updatedTransaction.getOrderNumber());
        }
        // 使用事务将写后数据写回csv文件
        csvTransactionDao.writeTransactionsToCSV(CSV_PATH, allTransactions);
        // 修改后使缓存失效 （删缓存）
        cache.invalidate("transactions");
    }

    /**
     *  辅助方法：更新非空字段
     * @param target
     * @param source
     */
    private void updateTransactionFields(Transaction target, Transaction source) {
        if (source.getTransactionTime() != null && !source.getTransactionTime().isEmpty()) {
            target.setTransactionTime(source.getTransactionTime());
        }
        if (source.getTransactionType() != null && !source.getTransactionType().isEmpty()) {
            target.setTransactionType(source.getTransactionType());
        }
        if (source.getCounterparty() != null && !source.getCounterparty().isEmpty()) {
            target.setCounterparty(source.getCounterparty());
        }
        if (source.getCommodity() != null && !source.getCommodity().isEmpty()) {
            target.setCommodity(source.getCommodity());
        }
        if (source.getInOut() != null && !source.getInOut().isEmpty()) {
            target.setInOut(source.getInOut());
        }
        if (source.getPaymentAmount() != 0.0) { // 假设金额为0表示未修改
            target.setPaymentAmount(source.getPaymentAmount());
        }
        if (source.getPaymentMethod() != null && !source.getPaymentMethod().isEmpty()) {
            target.setPaymentMethod(source.getPaymentMethod());
        }
        if (source.getCurrentStatus() != null && !source.getCurrentStatus().isEmpty()) {
            target.setCurrentStatus(source.getCurrentStatus());
        }
        if (source.getMerchantNumber() != null && !source.getMerchantNumber().isEmpty()) {
            target.setMerchantNumber(source.getMerchantNumber());
        }
        if (source.getRemarks() != null && !source.getRemarks().isEmpty()) {
            target.setRemarks(source.getRemarks());
        }
    }

    /**
     * 根据订单号删除交易 (若成功则返回true)
     * @param orderNumber
     */
    @Override
    public boolean deleteTransaction(String orderNumber) throws Exception {
        boolean result = csvTransactionDao.deleteTransaction(CSV_PATH, orderNumber);
        if (!result) {
            throw new Exception("未找到交易单号: " + orderNumber); // 或记录日志
        }
        cache.invalidate("transactions");
        return result;
    }

    /**
     * 按照查询条件查询交易信息
     * @param searchCriteria
     * @return
     */
    @Override
    public List<Transaction> searchTransaction(Transaction searchCriteria) {
        try {
            // 1. 读取所有交易记录 首先读取caffeine
            List<Transaction> allTransactions = getAllTransactions();

            // 2. 动态模糊匹配
            List<Transaction> matched = new ArrayList<>();
            for (Transaction t : allTransactions) {
                if (matchesCriteria(t, searchCriteria)) {
                    matched.add(t);
                }
            }

            // 3. 按交易时间倒序排序
            matched.sort((t1, t2) -> compareTransactionTime(t2.getTransactionTime(), t1.getTransactionTime()));

            return matched;
        } catch (IOException e) {
            e.printStackTrace();
            return List.of(); // 实际应用中应处理异常
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * 辅助方法:判断单个交易记录是否匹配条件
     * @param transaction
     * @param criteria
     * @return
     */
    private boolean matchesCriteria(Transaction transaction, Transaction criteria) {
        return (criteria.getTransactionTime() == null || containsIgnoreCase(transaction.getTransactionTime(), criteria.getTransactionTime()))
                && (criteria.getTransactionType() == null || containsIgnoreCase(transaction.getTransactionType(), criteria.getTransactionType()))
                && (criteria.getCounterparty() == null || containsIgnoreCase(transaction.getCounterparty(), criteria.getCounterparty()))
                && (criteria.getCommodity() == null || containsIgnoreCase(transaction.getCommodity(), criteria.getCommodity()))
                && (criteria.getInOut() == null || containsIgnoreCase(transaction.getInOut(), criteria.getInOut()))
                && (criteria.getPaymentMethod() == null || containsIgnoreCase(transaction.getPaymentMethod(), criteria.getPaymentMethod()));
    }

    /**
     * 辅助方法：字符串模糊匹配（空条件视为匹配）
     * @param source
     * @param target
     * @return
     */
    private boolean containsIgnoreCase(String source, String target) {
        if (target == null || target.trim().isEmpty()) return true; // 空条件不参与筛选
        if (source == null) return false;
        return source.toLowerCase().contains(target.toLowerCase().trim());
    }

    /**
     * 辅助方法：安全的时间比较（处理 null 值）
     * @param time1
     * @param time2
     * @return
     */
    private int compareTransactionTime(String time1, String time2) {
        if (time1 == null && time2 == null) return 0;
        if (time1 == null) return -1;
        if (time2 == null) return 1;
        return time2.compareTo(time1); // 倒序排序
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\TransactionService.java`:

```java
package Service;

import model.Transaction;

import java.io.IOException;
import java.util.List;

public interface TransactionService {

    /**
     * 新增交易
     * @param transaction
     */
    void addTransaction(Transaction transaction) throws IOException;

    /**
     * 修改交易
     * @param transaction
     */
    void changeTransaction(Transaction transaction) throws Exception;

    /**
     * 根据订单号删除交易
     * @param orderNumber
     */
    boolean deleteTransaction(String orderNumber) throws Exception;

    /**
     * 根据用户输入信息查询交易
     * @param transaction
     * @return
     */
    List<Transaction> searchTransaction(Transaction transaction);

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Service\deepseek\ChatCompletionsExample.java`:

```java
package Service.deepseek;

import com.volcengine.ark.runtime.model.completion.chat.ChatCompletionRequest;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessage;
import com.volcengine.ark.runtime.model.completion.chat.ChatMessageRole;
import com.volcengine.ark.runtime.service.ArkService;
import okhttp3.ConnectionPool;
import okhttp3.Dispatcher;
import org.apache.commons.lang.StringUtils;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
public class ChatCompletionsExample {
    static String apiKey = System.getenv("ARK_API_KEY");
    static ConnectionPool connectionPool = new ConnectionPool(5, 1, TimeUnit.SECONDS);
    static Dispatcher dispatcher = new Dispatcher();
    // The output time of the reasoning model is relatively long. Please increase the timeout period.//
    static ArkService service = ArkService.builder().timeout(Duration.ofSeconds(1800)).connectTimeout(Duration.ofSeconds(20)).dispatcher(dispatcher).connectionPool(connectionPool).baseUrl("https://ark.cn-beijing.volces.com/api/v3").apiKey(apiKey).build();

//    public static void main(String[] args) {
//        System.out.println(" [Recommended]----- streaming request -----");
//        final List<ChatMessage> streamMessages = new ArrayList<>();
//        final ChatMessage streamUserMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("请回答15.11和15.9哪个大？").build();
//        streamMessages.add(streamUserMessage);
//        ChatCompletionRequest streamChatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(streamMessages)
//                .build();
//        service.streamChatCompletion(streamChatCompletionRequest)
//                .doOnError(Throwable::printStackTrace)
//                .blockingForEach(
//                        delta -> {
//                            if (!delta.getChoices().isEmpty()) {
//                                if (StringUtils.isNotEmpty(delta.getChoices().get(0).getMessage().getReasoningContent())) {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getReasoningContent());
//                                } else {
//                                    System.out.print(delta.getChoices().get(0).getMessage().getContent());
//                                }
//                            }
//                        }
//                );
//        System.out.println(" ----- standard request -----");
//        final List<ChatMessage> messages = new ArrayList<>();
//        final ChatMessage userMessage = ChatMessage.builder().role(ChatMessageRole.USER).content("常见的十字花科植物有哪些？").build();
//        messages.add(userMessage);
//        ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest.builder()
//                .model("ep-20250308174053-7pbkq")
//                .messages(messages)
//                .build();
//        service.createChatCompletion(chatCompletionRequest).getChoices().forEach(
//                choice -> {
//                    System.out.println(choice.getMessage().getReasoningContent());
//                    System.out.println(choice.getMessage().getContent());
//                }
//        );
//        // shutdown service after all requests is finished
//        service.shutdownExecutor();
//    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\Utils\CacheUtil.java`:

```java
package Utils;

import com.github.benmanes.caffeine.cache.*;

import java.util.concurrent.TimeUnit;
import java.util.function.Function;

import com.github.benmanes.caffeine.cache.Caffeine;

/**
 * 通用缓存工具类（支持泛型和异常传播）
 * @param <K> 键类型
 * @param <V> 值类型
 * @param <E> 异常类型（如 IOException）
 */
public class CacheUtil<K, V, E extends Exception> {
    private final LoadingCache<K, V> cache;

    public CacheUtil(Function<K, V> loader,
                     int maxSize,
                     long expireAfterWrite,
                     long refreshAfterWrite) {

        this.cache = Caffeine.newBuilder()
                .maximumSize(maxSize)
                .expireAfterWrite(expireAfterWrite, TimeUnit.MINUTES)
                .refreshAfterWrite(refreshAfterWrite, TimeUnit.MINUTES)
                .build(loader::apply); // 关键修改：使用build(loader)创建LoadingCache
    }

    /**
     * 获取缓存值
     */
    public V get(K key) {
        return cache.get(key);
    }

    /**
     * 手动更新缓存
     */
    public void put(K key, V value) {
        cache.put(key, value);
    }

    /**
     * 手动移除缓存
     */
    public void invalidate(K key) {
        cache.invalidate(key);
    }
}



```

`Ai-Bill-Application-Group21/Ai Bill Application\src\main\java\model\Transaction.java`:

```java
package model;
//Transaction time, transaction type, transaction counterparty,
// commodity receipt/payment amount (yuan), payment method, current status,
// transaction order number, merchant order number, remarks
public class Transaction {
    private String transactionTime;
    private String transactionType;
    private String counterparty;
    private String commodity;
    private String inOut;
    private double paymentAmount;
    private String paymentMethod;
    private String currentStatus;
    private String orderNumber;
    private String merchantNumber;
    private String remarks;

    public Transaction() {
    }

    public Transaction(String transactionTime, String transactionType, String counterparty, String commodity, String inOut, double paymentAmount, String paymentMethod, String currentStatus, String orderNumber, String merchantNumber, String remarks) {
        this.transactionTime = transactionTime;
        this.transactionType = transactionType;
        this.counterparty = counterparty;
        this.commodity = commodity;
        this.inOut = inOut;
        this.paymentAmount = paymentAmount;
        this.paymentMethod = paymentMethod;
        this.currentStatus = currentStatus;
        this.orderNumber = orderNumber;
        this.merchantNumber = merchantNumber;
        this.remarks = remarks;
    }

    public String getInOut() {
        return inOut;
    }

    public void setInOut(String inOut) {
        this.inOut = inOut;
    }

    public void setTransactionTime(String transactionTime) {
        this.transactionTime = transactionTime;
    }

    public void setTransactionType(String transactionType) {
        this.transactionType = transactionType;
    }

    public void setCounterparty(String counterparty) {
        this.counterparty = counterparty;
    }

    public void setCommodity(String commodity) {
        this.commodity = commodity;
    }

    public void setPaymentAmount(double paymentAmount) {
        this.paymentAmount = paymentAmount;
    }

    public void setPaymentMethod(String paymentMethod) {
        this.paymentMethod = paymentMethod;
    }

    public void setCurrentStatus(String currentStatus) {
        this.currentStatus = currentStatus;
    }

    public void setOrderNumber(String orderNumbe) {
        this.orderNumber = orderNumbe;
    }

    public void setMerchantNumber(String merchantNumber) {
        this.merchantNumber = merchantNumber;
    }

    public void setRemarks(String remarks) {
        this.remarks = remarks;
    }

    public String getTransactionTime() {
        return transactionTime;
    }

    public String getTransactionType() {
        return transactionType;
    }

    public String getCounterparty() {
        return counterparty;
    }

    public String getCommodity() {
        return commodity;
    }

    public double getPaymentAmount() {
        return paymentAmount;
    }

    public String getPaymentMethod() {
        return paymentMethod;
    }

    public String getCurrentStatus() {
        return currentStatus;
    }

    public String getOrderNumber() {
        return orderNumber;
    }

    public String getMerchantNumber() {
        return merchantNumber;
    }

    public String getRemarks() {
        return remarks;
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\ControllerTest\AITest.java`:

```java
package ControllerTest;

import Controller.HistogramPanelContainer;
import org.junit.Test;

import javax.swing.*;
import java.awt.*;

public class AITest {

    @Test
    public void testHistogramPanel() throws Exception {
        EventQueue.invokeAndWait(() -> {
            JFrame frame = new JFrame("数据分析界面 - 测试");
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setSize(800, 600);
            frame.add(new HistogramPanelContainer());
            frame.setVisible(true);
        });




        // 保持窗口显示一段时间，防止测试结束时窗口立即关闭
        Thread.sleep(5000);
    }

}




```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\ControllerTest\MenuUITest.java`:

```java
package ControllerTest;

import Controller.HistogramExample;
import Controller.HistogramPanelContainer;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.io.IOException;
import Controller.MenuUI;

import Service.Impl.TransactionServiceImpl;

import Service.Impl.TransactionServiceImpl;

import DAO.Impl.CsvTransactionDao;

public class MenuUITest {

    private MenuUI menuUI;

    @BeforeEach
    public void setUp() {
        menuUI = new MenuUI();

        // 手动初始化 TransactionServiceImpl 的 csvTransactionDao
        TransactionServiceImpl.csvTransactionDao = new CsvTransactionDao();
    }

    @Test
    public void testSearchFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取输入字段和搜索按钮
        JTextField transactionTimeField = findTextField(inputPanel, 0);
        JTextField transactionTypeField = findTextField(inputPanel, 1);
        JTextField counterpartyField = findTextField(inputPanel, 2);
        JTextField commodityField = findTextField(inputPanel, 3);
        JComboBox<String> inOutComboBox = findComboBox(inputPanel);
        JTextField paymentMethodField = findTextField(inputPanel, 4);
        JButton searchButton = findButton(inputPanel,"Search");

        assertNotNull(transactionTimeField, "交易时间输入字段不应为空");
        assertNotNull(transactionTypeField, "交易类型输入字段不应为空");
        assertNotNull(counterpartyField, "交易对方输入字段不应为空");
        assertNotNull(commodityField, "商品输入字段不应为空");
        assertNotNull(inOutComboBox, "收/支下拉框不应为空");
        assertNotNull(paymentMethodField, "支付方式输入字段不应为空");
        assertNotNull(searchButton, "搜索按钮不应为空");

        // 设置搜索条件
        transactionTimeField.setText("2025/3/14 11:48"); // 交易时间
        transactionTypeField.setText("商户消费");       // 交易类型
        counterpartyField.setText("物美WUMART");         // 交易对方
        commodityField.setText("扫码支付");            // 商品
        inOutComboBox.setSelectedItem("支出");     // 收/支
        paymentMethodField.setText("零钱");    // 支付方式

        // 模拟点击搜索按钮
        searchButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证搜索结果是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);

            // 验证每一行数据是否符合搜索条件
            assertTrue(rowTransactionTime.contains("2025/3/14 11:48"), "交易时间应符合搜索条件");
            assertTrue(rowTransactionType.contains("商户消费"), "交易类型应符合搜索条件");
            assertTrue(rowCounterparty.contains("物美WUMART"), "交易对方应符合搜索条件");
            assertTrue(rowCommodity.contains("扫码支付"), "商品应符合搜索条件");
            assertTrue(rowInOut.contains("支出"), "收/支应符合搜索条件");
            assertTrue(rowPaymentMethod.contains("零钱"), "支付方式应符合搜索条件");
        }
    }

    @Test
    public void testDeleteFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 获取初始行数
        int initialRowCount = tableModel.getRowCount();

        // 模拟删除第一行
        menuUI.deleteRow(0);

        // 验证行数是否减少
        assertEquals(initialRowCount - 1, tableModel.getRowCount(), "删除后行数应减少");

        // 验证删除后的数据是否正确
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            assertNotEquals("2025/3/14 11:48", rowTransactionTime, "删除的行不应再出现在表格中");
        }
    }

    @Test
    public void testEditFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 模拟编辑第一行
        menuUI.editRow(0);

        // 验证编辑后的数据是否正确
        String editedTransactionTime = (String) tableModel.getValueAt(0, 0);
        String editedTransactionType = (String) tableModel.getValueAt(0, 1);
        String editedCounterparty = (String) tableModel.getValueAt(0, 2);
        String editedCommodity = (String) tableModel.getValueAt(0, 3);
        String editedInOut = (String) tableModel.getValueAt(0, 4);
        String editedPaymentMethod = (String) tableModel.getValueAt(0, 6);

        // 验证编辑后的数据是否符合预期
        assertNotNull(editedTransactionTime, "编辑后的交易时间不应为空");
        assertNotNull(editedTransactionType, "编辑后的交易类型不应为空");
        assertNotNull(editedCounterparty, "编辑后的交易对方不应为空");
        assertNotNull(editedCommodity, "编辑后的商品不应为空");
        assertNotNull(editedInOut, "编辑后的收/支不应为空");
        assertNotNull(editedPaymentMethod, "编辑后的支付方式不应为空");
    }

    @Test
    public void testAddFunction() throws IOException {
        // 创建主面板
        JPanel mainPanel = menuUI.createMainPanel();

        // 显示界面以便手动验证
        showUI(mainPanel);

        // 获取输入面板中的组件
        JPanel inputPanel = findInputPanel(mainPanel);
        assertNotNull(inputPanel, "输入面板不应为空");

        // 获取 Add 按钮
        JButton addButton = findButton(inputPanel, "Add");
        assertNotNull(addButton, "Add 按钮不应为空");

        // 模拟点击 Add 按钮
        addButton.doClick();

        // 获取对话框
        Window[] windows = Window.getWindows();
        JDialog addDialog = null;
        for (Window window : windows) {
            if (window instanceof JDialog && "添加交易".equals(((JDialog) window).getTitle())) {
                addDialog = (JDialog) window;
                break;
            }
        }
        assertNotNull(addDialog, "添加交易的对话框应弹出");

        // 获取对话框中的输入字段
        JTextField transactionTimeField = findTextField(addDialog.getContentPane(), 0);
        JTextField transactionTypeField = findTextField(addDialog.getContentPane(), 1);
        JTextField counterpartyField = findTextField(addDialog.getContentPane(), 2);
        JTextField commodityField = findTextField(addDialog.getContentPane(), 3);
        JComboBox<String> inOutComboBox = findComboBox(addDialog.getContentPane());
        JTextField paymentAmountField = findTextField(addDialog.getContentPane(), 4);
        JTextField paymentMethodField = findTextField(addDialog.getContentPane(), 5);
        JTextField currentStatusField = findTextField(addDialog.getContentPane(), 6);
        JTextField orderNumberField = findTextField(addDialog.getContentPane(), 7);
        JTextField merchantNumberField = findTextField(addDialog.getContentPane(), 8);
        JTextField remarksField = findTextField(addDialog.getContentPane(), 9);

        // 设置新交易的输入值
        transactionTimeField.setText("2025/3/15 12:00"); // 交易时间
        transactionTypeField.setText("转账");            // 交易类型
        counterpartyField.setText("张三");               // 交易对方
        commodityField.setText("转账");                 // 商品
        inOutComboBox.setSelectedItem("支出");          // 收/支
        paymentAmountField.setText("100.0");            // 金额(元)
        paymentMethodField.setText("银行卡");           // 支付方式
        currentStatusField.setText("已完成");           // 当前状态
        orderNumberField.setText("123456789");          // 交易单号
        merchantNumberField.setText("987654321");       // 商户单号
        remarksField.setText("测试备注");               // 备注

        // 获取确认按钮
        JButton confirmButton = findButton(addDialog.getContentPane(), "确认");
        assertNotNull(confirmButton, "确认按钮不应为空");

        // 模拟点击确认按钮
        confirmButton.doClick();

        // 获取表格模型
        DefaultTableModel tableModel = (DefaultTableModel) menuUI.getTable().getModel();

        // 验证表格模型不为空
        assertNotNull(tableModel, "表格模型不应为空");

        // 验证新交易是否添加到表格中
        boolean isTransactionAdded = false;
        for (int i = 0; i < tableModel.getRowCount(); i++) {
            String rowTransactionTime = (String) tableModel.getValueAt(i, 0);
            String rowTransactionType = (String) tableModel.getValueAt(i, 1);
            String rowCounterparty = (String) tableModel.getValueAt(i, 2);
            String rowCommodity = (String) tableModel.getValueAt(i, 3);
            String rowInOut = (String) tableModel.getValueAt(i, 4);
            String rowPaymentAmount = (String) tableModel.getValueAt(i, 5);
            String rowPaymentMethod = (String) tableModel.getValueAt(i, 6);
            String rowCurrentStatus = (String) tableModel.getValueAt(i, 7);
            String rowOrderNumber = (String) tableModel.getValueAt(i, 8);
            String rowMerchantNumber = (String) tableModel.getValueAt(i, 9);
            String rowRemarks = (String) tableModel.getValueAt(i, 10);

            if (rowTransactionTime.equals("2025/3/15 12:00") &&
                    rowTransactionType.equals("转账") &&
                    rowCounterparty.equals("张三") &&
                    rowCommodity.equals("转账") &&
                    rowInOut.equals("支出") &&
                    rowPaymentAmount.equals("100.0") &&
                    rowPaymentMethod.equals("银行卡") &&
                    rowCurrentStatus.equals("已完成") &&
                    rowOrderNumber.equals("123456789") &&
                    rowMerchantNumber.equals("987654321") &&
                    rowRemarks.equals("测试备注")) {
                isTransactionAdded = true;
                break;
            }
        }

        // 验证新交易是否成功添加
        assertTrue(isTransactionAdded, "新交易应成功添加到表格中");
    }

    /**
     * 显示界面以便手动验证
     *
     * @param panel 要显示的面板
     */
    private void showUI(JPanel panel) {
        JFrame frame = new JFrame("MenuUI Test");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(1200, 600);
        frame.add(panel);
        frame.setVisible(true);

        // 保持界面显示一段时间（5秒）
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        frame.dispose(); // 关闭界面
    }

    /**
     * 查找输入面板
     *
     * @param mainPanel 主面板
     * @return 输入面板
     */
    private JPanel findInputPanel(JPanel mainPanel) {
        // 获取右边的面板
        Component[] components = mainPanel.getComponents();
        JPanel rightPanel = null;
        for (Component component : components) {
            if (component instanceof JPanel && ((JPanel) component).getComponentCount() > 0) {
                rightPanel = (JPanel) component;
                break;
            }
        }

        if (rightPanel != null) {
            // 在右边面板中查找输入面板
            for (Component component : rightPanel.getComponents()) {
                if (component instanceof JPanel) {
                    JPanel panel = (JPanel) component;
                    System.out.println("Panel found: " + panel.getName()); // 打印面板名称
                    if (panel.getComponentCount() > 0 && panel.getComponent(0) instanceof JLabel) {
                        return panel; // 输入面板通常包含 JLabel
                    }
                }
            }
        }
        return null;
    }

    /**
     * 查找输入字段
     *
     * @param container     输入面板
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0;
        for (Component component : container.getComponents()) {
            if (component instanceof JTextField) {
                if (count == index) {
                    return (JTextField) component;
                }
                count++;
            }
        }
        return null;
    }


    /**
     * 查找下拉框
     *
     * @param container 输入面板
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) {
            if (component instanceof JComboBox) {
                return (JComboBox<String>) component;
            }
        }
        return null;
    }

    /**
     * 查找按钮
     *
     * @param panel 输入面板
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    /**
     * 查找按钮
     *
     * @param container  容器（可以是 JPanel 或 JDialog）
     * @param buttonText 按钮的文本
     * @return 按钮
     */
    private JButton findButton(Container container, String buttonText) {
        for (Component component : container.getComponents()) {
            if (component instanceof JButton) {
                JButton button = (JButton) component;
                if (button.getText().equals(buttonText)) {
                    return button;
                }
            }
        }
        return null;
    }
}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\DAOTest\CsvTransactionDaoTest.java`:

```java
package DAOTest;

import DAO.Impl.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static Constants.ConfigConstants.CSV_PATH;
import static org.assertj.core.api.Assertions.*;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

class CsvTransactionDaoTest {
    // 测试文件路径（根据实际结构调整）
    private static final String TEST_CSV_PATH = CSV_PATH;
    private static CsvTransactionDao dao;

    @Test
    void testLoadFromCSV_ValidFile_ReturnsTransactions() throws Exception {
        // Given
        CsvTransactionDao dao = new CsvTransactionDao();

        // When
        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);

        // 验证第一条记录的字段
        for (int i = 0; i < transactions.size(); i++) {
            System.out.println(transactions.get(i).getRemarks());
            System.out.println(transactions.get(i).getCommodity());
        }


    }
    @Test
    void testAddTransaction() throws IOException {
        dao=new CsvTransactionDao();
        Transaction newTx = new Transaction(
                "2025-03-09 10:00",
                "转账",
                "小明",
                "书籍",
                "支",
                99.99,
                "微信",
                "已完成",
                "TX123456",
                "M789012",
                "");

        dao.addTransaction("src/test/resources/001.csv", newTx);

        List<Transaction> transactions = dao.loadFromCSV(TEST_CSV_PATH);

    }

    @Test
    void testDeleteTransaction() throws IOException {
        dao=new CsvTransactionDao();

        dao.deleteTransaction("CSV_RELATIVE_PATH", "4200057899202502250932735481");

        List<Transaction> transactions = dao.loadFromCSV(CSV_PATH);
    }
    @Test
    void testChangeInfo() throws IOException{
        dao=new CsvTransactionDao();
        dao.changeInformation("TX123456","remarks","测试修改信息",TEST_CSV_PATH);
        dao.changeInformation("TX123456","paymentAmount","116156",TEST_CSV_PATH);
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\AIAnalyzerThreadTest.java`:

```java
package Service;



import Service.AIservice.AIAnalyzerThread;
import org.junit.jupiter.api.Test;

public class AIAnalyzerThreadTest {

    @Test
    public void testRunAIAnalyzerThread() throws InterruptedException {
        String userRequest = "请帮我分析最近的交易收支情况";
        String filePath = "src/test/resources/sample_transactions.csv";
        String startTimeStr = "2025/03/20";
        String endTimeStr = "";

        // 启动线程
        Thread thread = new Thread(new AIAnalyzerThread(userRequest, filePath, startTimeStr, endTimeStr));
        thread.start();

        // 等待线程执行完成
        thread.join();
    }
}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\AIserviceTest.java`:

```java
package Service;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

public class AIserviceTest {

    @Test
    public void testAnalyzeTransactions() {
        AITransactionService service = new AITransactionService();

        String userRequest = "请帮我分析这个月的收支情况";
        String filePath = "src/test/resources/sample_transactions.csv";

        String result = service.analyzeTransactions(userRequest, filePath,"2025/03/20","");

        assertNotNull(result, "AI分析结果不能为空");
        System.out.println("AI分析结果: " + result);
    }


}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\AiFunctionTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import model.Transaction;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import Service.AIservice.AITransactionService;

import java.io.IOException;
import java.util.List;

public class AiFunctionTest {

    @Test
    public void testAnalyzeTransactions() throws IOException {

        String filePath = "src/test/resources/sample_transactions.csv";
        CsvTransactionDao transactionDao = new CsvTransactionDao();

        List<Transaction> transactions = transactionDao.loadFromCSV(filePath);

        // 实例化服务类
        AITransactionService service = new AITransactionService();

        // 调用合并格式化函数
        List<String> result = service.formatTransactions(transactions,"2025/03/29","2025/04/10");

        // 输出结果
        result.forEach(System.out::println);
    }




}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\CacheTest.java`:

```java
package Service;

import Constants.CaffeineKeys;
import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import Utils.CacheUtil;
import com.github.benmanes.caffeine.cache.Caffeine;
import model.Transaction;
import org.junit.jupiter.api.Test;

import java.util.List;

import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY;

public class CacheTest {

    TransactionServiceImpl transactionService = new TransactionServiceImpl(new CsvTransactionDao());

    @Test
    void DeleteCache(){
        CacheUtil<String, List<Transaction>, Exception> cache = transactionService.cache;
        cache.invalidate(TRANSACTION_CAFFEINE_KEY);
    }

}

```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\CollegeStudentNeedsTest.java`:

```java
package Service;

import Service.AIservice.ColledgeStudentThread;
import Service.AIservice.CollegeStudentNeeds;
import org.junit.jupiter.api.*;

import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.*;

// No @ExtendWith needed as we are not using Mockito extensions
class CollegeStudentNeedsTest {



    private CollegeStudentNeeds collegeStudentNeeds=new CollegeStudentNeeds();
    private static final String TEST_CSV_FILENAME = "src/test/resources/001.csv";
    @Test
    public void testGenerateBudget() throws IOException, InterruptedException {
        Thread t=new Thread( new ColledgeStudentThread(TEST_CSV_FILENAME));
        t.start();
        t.join();
//        collegeStudentNeeds.generateBudget(TEST_CSV_FILENAME);
    }
    @Test
    public void testParseStringToDouble(){
        String s="asdas[369.39,1090.1]das";
        double[] arr=collegeStudentNeeds.parseDoubleArrayFromString(s);
        System.out.println(arr[0]+" "+arr[1]);
    }


}
```

`Ai-Bill-Application-Group21/Ai Bill Application\src\test\java\Service\TransactionServiceTest.java`:

```java
package Service;

import DAO.Impl.CsvTransactionDao;
import Service.Impl.TransactionServiceImpl;
import model.Transaction;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.io.IOException;
import java.util.List;

class TransactionServiceTest {
    private TransactionService transactionService;

    @BeforeEach
    void setUp() {
        // 初始化 DAO 和 Service
        CsvTransactionDao csvTransactionDao = new CsvTransactionDao();
        transactionService = new TransactionServiceImpl(csvTransactionDao);
    }

    @Test
    void testAddTransaction() throws IOException {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );

        // 执行添加操作
        transactionService.addTransaction(transaction);

        // 验证是否添加成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertFalse(transactions.isEmpty());
        assertEquals("T123456789", transactions.get(0).getOrderNumber());
    }

    @Test
    void testChangeTransaction() throws Exception {
        // 准备测试数据
        Transaction originalTransaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(originalTransaction);

        // 准备更新数据
        Transaction updatedTransaction = new Transaction(
                null, "充值", null, null, null, 0.0, "微信支付", null, "T123456789", null, "更新备注"
        );

        // 执行更新操作
        transactionService.changeTransaction(updatedTransaction);

        // 验证是否更新成功
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertEquals("充值", transactions.get(0).getTransactionType());
        assertEquals("微信支付", transactions.get(0).getPaymentMethod());
        assertEquals("更新备注", transactions.get(0).getRemarks());
    }

    @Test
    void testDeleteTransaction() throws Exception {
        // 准备测试数据
        Transaction transaction = new Transaction(
                "2023-08-20 15:30:00", "转账", "李四", "虚拟商品", "支出", 500.0,
                "银行卡", "已完成", "T123456789", "M987654321", "测试"
        );
        transactionService.addTransaction(transaction);

        // 执行删除操作
        boolean result = transactionService.deleteTransaction("T123456789");

        // 验证是否删除成功
        assertTrue(result);
        List<Transaction> transactions = transactionService.searchTransaction(new Transaction());
        assertTrue(transactions.isEmpty());
    }

    @Test
    void testSearchTransaction() throws IOException {

        // 设置搜索条件
        Transaction searchCriteria = new Transaction();
        searchCriteria.setCounterparty("支付宝");

        // 执行搜索操作
        List<Transaction> result = transactionService.searchTransaction(searchCriteria);

        // 验证搜索结果
        result.forEach(res -> System.out.println(res.getCommodity()));
    }


}
```
```

`软工/Ai-Bill-Application-Group21\README.md`:

```md
## Project Overview
This module is a transaction record management 
system in the Service layer of the project that connects 
with the Dao layer that provides CRUD (Create, Read, Update
, Delete) functionality and data processing for
transaction data. Core features include transaction 
creation, modification, deletion, and flexible querying,
all accessible through standardized interfaces.

## Structure and Function
Swing GUI (Controller) <- Service <- DAO <-data(CSV/JSON)<-model

##  Model 

### Overview

This Java class, located in the `model` package, serves 
as a Plain Old Java Object (POJO) or data model to 
represent a single financial transaction record. It 
encapsulates all the standard details associated with 
a transaction, such as its time, type, amount, parties 
involved, status, and unique identifiers.

This class is typically used in conjunction with Data 
Access Objects (DAOs) like `TransactionDao` and
`CsvTransactionDao` to load, save, and manipulate 
transaction data from a persistent store (e.g., a CSV 
file or database).

### Package

`model`

### Fields

The `Transaction` class contains the following fields:

* `transactionTime` (String): The date and time when the transaction occurred (e.g., "2023-10-27 15:30:00").
* `transactionType` (String): The category or type of the transaction (e.g., "在线支付" - Online Payment, "转账" - Transfer, "退款" - Refund).
* `counterparty` (String): The name or identifier of the other party involved in the transaction.
* `commodity` (String): A description of the goods, service, or reason for the transaction (e.g., "Coffee", "Salary", "Online Course Fee").
* `inOut` (String): Indicates the direction of the money flow relative to the account holder. Typically:
* `paymentAmount` (double): The monetary value of the transaction. The currency unit (e.g., Yuan) is implied by the context where this class is used (often indicated by header names like "金额(元)" in associated CSV files).
* `paymentMethod` (String): The method used for the payment (e.g., "支付宝" - Alipay, "微信支付" - WeChat Pay, "银行卡" - Bank Card, "现金" - Cash).
* `currentStatus` (String): The current processing status of the transaction (e.g., "交易成功" - Transaction Successful, "等待付款" - Awaiting Payment, "已关闭" - Closed, "退款成功" - Refund Successful).
* `orderNumber` (String): A unique identifier assigned to this specific transaction instance by the payment system or application. Often used as a primary key.
* `merchantNumber` (String): An order number or identifier associated with the merchant's system, often provided for reconciliation purposes. May be empty or null if not applicable.
* `remarks` (String): An optional field for any additional notes, comments, or user-provided descriptions about the transaction.

### Constructors

* **`public Transaction()`**
    * Default no-argument constructor. Creates an empty `Transaction` object with all fields initialized to their default values (null for String, 0.0 for double).

* **`public Transaction(String transactionTime, String transactionType, ..., String remarks)`**
    * Parameterized constructor that accepts values for all fields. Allows for quick instantiation of a fully populated `Transaction` object.

### Methods

The class provides standard public **getter** (`get...()`) and **setter** (`set...()`) methods for all its private fields. These methods allow controlled access and modification of the transaction's attributes from other parts of the application.

* `getTransactionTime()` / `setTransactionTime(String time)`
* `getTransactionType()` / `setTransactionType(String type)`
* `getCounterparty()` / `setCounterparty(String counterparty)`
* `getCommodity()` / `setCommodity(String commodity)`
* `getInOut()` / `setInOut(String inOut)`
* `getPaymentAmount()` / `setPaymentAmount(double amount)`
* `getPaymentMethod()` / `setPaymentMethod(String method)`
* `getCurrentStatus()` / `setCurrentStatus(String status)`
* `getOrderNumber()` / `setOrderNumber(String orderNumber)`
* `getMerchantNumber()` / `setMerchantNumber(String merchantNumber)`
* `getRemarks()` / `setRemarks(String remarks)`

 
### Service (Business logic)
- Responsibilities:
Transaction CRUD operations, calling the DAO layer to read and write local files,
User-defined classification logic (e.g. modifying transaction categories)
  (3) Operations:

Add Transaction:

Transaction t = new Transaction();
// Set field values
service.addTransaction(t);

Modify Transaction:

Transaction update = new Transaction();
update.setOrderNumber("ORD123");
// Set fields to update
service.changeTransaction(update);

Query Transactions:

Transaction criteria = new Transaction();
criteria.setCounterparty("Alipay");
List<Transaction> results = service.searchTransaction(criteria);
Code structure
   Directory Layout:
   src/main/java/
   └── Service/
   ├── Impl/
   │   └── TransactionServiceImpl.java  # Service implementation
   └── TransactionService.java          # Service interface
   TransactionService.java:
   Defines the service interface with business-agnostic method signatures, enforcing decoupling 
   between business logic and implementation details.
   TransactionServiceImpl.java:
   Implements the concrete business logic while depending only on the interface-defined contract, maintaining loose coupling with the data access layer through dependency injection.


- AIService (Intelligent Analytics) Responsibilities: Generate budget recommendations based
on historical data, and detect cost-cutting recommendations for seasonal spending in China
(e.g. Spring Festival) (e.g. marking high-frequency small spending)


- **`AITransactionService`**

The central class that performs the full AI-driven transaction analysis. It:

- Loads transaction data from a CSV file via `CsvTransactionDao`.
- Filters transactions by user-specified time range (`startTimeStr`, `endTimeStr`).
- Aggregates data by counterparty (income/spending, transaction counts).
- Formats the result into concise summaries sent to the AI.
- Sends user questions and formatted data to the Volcengine Ark AI API.
- Returns a response within **400 characters** for efficient display.

Key methods:
- `analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr)`
  → Returns an AI-generated analysis result string.
- `runAiInThread(...)`
  → Runs the AI logic in a background thread (single-threaded executor).
- `formatTransactions(...)`
  → Groups transactions and summarizes them by counterparty and time range.
- `parseDateTime(...)`
  → Supports flexible input formats like `yyyy/MM/dd`, `yyyy/MM/dd HH:mm`, and more. - **`AIAnalyzerThread`** A `Runnable` implementation for threading scenarios (especially GUI usage). It calls `AITransactionService.analyzeTransactions(...)` and prints the result. UI developers can replace the console output with GUI updates using `SwingUtilities.invokeLater()`. --- ### Tests (`test/java/Service/AIservice/`) - **`AIserviceTest`** Unit tests for `AITransactionService`, verifying: - Correct loading and filtering of transactions. - Accurate AI response generation and formatting. - Graceful handling of edge cases (e.g., no transactions in range, invalid time formats). - **`AIAnalyzerThreadTest`** Validates threading logic: - Ensures `AIAnalyzerThread` executes `Runnable` correctly. - Demonstrates clean and concurrent AI analysis flow. - Simulates integration with a GUI environment. - **`AiFunctionTest`** Utility-level tests: - Ensures proper CSV parsing and data transformation. - Verifies output formatting before sending to the AI. - Tests various time formats and edge case behaviors

## DAO (File Storage)
- Responsibilities: Save transaction data in CSV or JSON format and provide interfaces for adding,
  deleting, and modifying in-memory data
### CsvTransactionDao Class

#### Package

`DAO`

#### Dependencies

* **`model.Transaction`**: The data model class representing a single transaction.
* **`DAO.TransactionDao`**: The interface this class is intended to implement (though the implementation is incomplete).
* **Apache Commons CSV (`org.apache.commons.csv.*`)**: Used for robust parsing and writing of CSV data.
* **Apache Commons IO (`org.apache.commons.io.input.BOMInputStream`)**: Used specifically to handle potential Byte Order Marks (BOM) often found in UTF-8 encoded files, particularly those edited in Windows.
* **Java Standard Libraries**: `java.io.*`, `java.nio.*`.

#### Key Features & Implementation Details

* **CSV Loading (`loadFromCSV`)**:
  * Reads data from a specified CSV file path.
  * Expects UTF-8 encoding.
  * Handles potential Byte Order Mark (BOM) at the beginning of the file.
  * Uses the first row of the CSV as the header to map columns to `Transaction` fields. Assumes specific header names (e.g., "交易时间", "交易类型", "金额(元)").
  * Parses transaction records into a `List<Transaction>`.
  * Includes basic caching using an internal `transactions` list and an `isLoad` flag to avoid redundant file reads within the same instance lifecycle (unless forced by methods like `deleteTransaction` or `changeInformation`).
* **Record Parsing (`parseRecord`)**:
  * Converts a `CSVRecord` object (from Apache Commons CSV) into a `Transaction` object.
  * Specifically handles the "金额(元)" (Amount) field by removing the leading "¥" symbol before parsing it as a `double`.
* **Adding Transactions (`addTransaction(String filePath, Transaction newTransaction)`)**:
  * **Appends** a new transaction record to the *end* of the specified CSV file.
  * Creates the file if it doesn't exist.
  * Writes the header row only if the file is new or was empty.
  * Formats the payment amount by prepending "¥".
* **Deleting Transactions (`deleteTransaction(String filePath, String orderNumber)`)**:
  * Loads data from the file if not already cached.
  * Filters the cached list to remove the transaction matching the given `orderNumber`.
  * **Overwrites** the *entire* original CSV file with the filtered list using `writeTransactionsToCSV`.
  * Returns `true` if a transaction was removed, `false` otherwise.
* **Updating Transactions (`changeInformation`)**:
  * Loads data if not already cached.
  * Finds the transaction by `orderNumber`.
  * Modifies the specified field (`head`) of the found transaction object in memory.
  * **Crucially, it attempts the update by first *deleting* the original record (using `deleteTransaction`, which overwrites the file) and then *adding* the modified record (using `addTransaction`, which appends to the file).** This logic is inefficient and potentially problematic due to the conflicting file write strategies (overwrite vs. append).
  * Error handling for invalid `head` parameters prints to `System.err`. The method often returns `true` even if the underlying delete/add fails.
* **CSV Writing (`writeTransactionsToCSV`)**:
  * Helper method used by `deleteTransaction`.
  * Writes a given `List<Transaction>` to the specified file path, **overwriting** any existing content.
  * Writes a standard header row.
  * Formats the payment amount by prepending "¥".

#### Important Issues & Considerations

1.  **Incomplete `TransactionDao` Implementation**: The methods declared in the `TransactionDao` interface (`getAllTransactions`, `addTransaction(Transaction)`, `deleteTransaction(String)`, `updateTransaction`, `getTransactionByOrderNumber`) are present but contain only placeholder/stub code. The actual working logic uses separate methods that require the `filePath` to be passed explicitly each time. **This class, in its current state, does not correctly function as a `TransactionDao` implementation.**
2.  **Inconsistent File Writing Strategy**: `addTransaction` *appends* to the file, while `deleteTransaction` and `writeTransactionsToCSV` (used by `deleteTransaction` and `changeInformation`) *overwrite* the entire file. This inconsistency can lead to unexpected behavior, especially within the `changeInformation` method.
3.  **Inefficient Updates/Deletes**: Rewriting the entire CSV file for every single deletion or modification (`changeInformation`) is highly inefficient, especially for large transaction files.
4.  **Flawed Update Logic (`changeInformation`)**: The delete-then-add approach for updates is problematic due to the inconsistent write strategies and potential race conditions or partial failures. The modified record will likely appear at the *end* of the file, not its original position.
5.  **Basic Caching**: The caching mechanism (`isLoad` flag) is simple and does not account for external modifications to the CSV file during the application's runtime.
6.  **Hardcoded Dependencies**: The code relies on specific header names (in Chinese) and the "¥" currency symbol format within the CSV data. Changes to the CSV format would require code modifications.

#### Usage Example (Using Functional Methods)

```java
import DAO.Impl.CsvTransactionDao; // Assuming TransactionDao interface exists but is not used directly here due to stub methods
import model.Transaction;
import java.io.IOException;
import java.util.List;

public class CsvDataManager {

    public static void main(String[] args) {
        // NOTE: Using the class directly, not via the TransactionDao interface
        // because the interface methods are not fully implemented.
        CsvTransactionDao csvDao = new CsvTransactionDao();
        String csvFilePath = "path/to/your/transactions.csv"; // <--- Specify your file path

        try {
            // --- Load Data ---
            System.out.println("Loading transactions...");
            List<Transaction> transactions = csvDao.loadFromCSV(csvFilePath);
            System.out.println("Loaded " + transactions.size() + " transactions.");
            // Display first transaction if available
            if (!transactions.isEmpty()) {
                 System.out.println("First transaction order number: " + transactions.get(0).getOrderNumber());
            }

            // --- Add a New Transaction (Appends) ---
            Transaction newTx = new Transaction(
                 "2025-04-20 08:14:00", "Test Add", "Counterparty", "Item", "支",
                 10.0, "支付宝", "交易成功", "NEW_ORDER_123", "MERCH_456", "Test via DAO add"
            );
            System.out.println("\nAdding new transaction (append): " + newTx.getOrderNumber());
            // csvDao.addTransaction(csvFilePath, newTx); // Uncomment to actually add
            System.out.println("Transaction potentially added.");

            // --- Delete a Transaction (Overwrites File) ---
            String orderToDelete = "SOME_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number from your file
            System.out.println("\nAttempting to delete transaction: " + orderToDelete);
            // boolean deleted = csvDao.deleteTransaction(csvFilePath, orderToDelete); // Uncomment to actually delete
            // if (deleted) {
            //     System.out.println("Transaction deleted successfully (File rewritten).");
            // } else {
            //     System.out.println("Transaction not found for deletion.");
            // }

            // --- Change Information (Overwrites then Appends - Use with Caution) ---
             String orderToChange = "ANOTHER_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number
             String fieldToChange = "remarks";
             String newValue = "Updated remark via changeInformation";
             System.out.println("\nAttempting to change info for: " + orderToChange);
             // boolean changed = csvDao.changeInformation(orderToChange, fieldToChange, newValue, csvFilePath); // Uncomment with caution
             // System.out.println("Change operation attempted (File rewritten and appended). Result: " + changed);


        } catch (IOException e) {
            System.err.println("Error interacting with CSV file: " + e.getMessage());
            e.printStackTrace();
        } catch (NumberFormatException e) {
            System.err.println("Error parsing amount in CSV: " + e.getMessage());
        }
    }
}
```

## Controller (Swing GUI)

Responsibilities: Manage user interface components (buttons, tables, text boxes) to listen for 
events (clicks, inputs) and call service layer methods to update the interface data display

## attention
encoding with UTF-8

```

`软工/Ai-Bill-Application-Group21\README.txt`:

```txt
## Project Overview

This module is a transaction record management 
system in the Service layer of the project that connects 
with the Dao layer that provides CRUD (Create, Read, Update
, Delete) functionality and data processing for
transaction data. Core features include transaction 
creation, modification, deletion, and flexible querying,
all accessible through standardized interfaces.

## Structure and Function

Swing GUI (Controller) <- Service <- DAO <-data(CSV/JSON)<-model

##  Model 

### Overview

This Java class, located in the `model` package, serves 
as a Plain Old Java Object (POJO) or data model to 
represent a single financial transaction record. It 
encapsulates all the standard details associated with 
a transaction, such as its time, type, amount, parties 
involved, status, and unique identifiers.

This class is typically used in conjunction with Data 
Access Objects (DAOs) like `TransactionDao` and
`CsvTransactionDao` to load, save, and manipulate 
transaction data from a persistent store (e.g., a CSV 
file or database).

### Package

`model`

### Fields

The `Transaction` class contains the following fields:

* `transactionTime` (String): The date and time when the transaction occurred (e.g., "2023-10-27 15:30:00").
* `transactionType` (String): The category or type of the transaction (e.g., "在线支付" - Online Payment, "转账" - Transfer, "退款" - Refund).
* `counterparty` (String): The name or identifier of the other party involved in the transaction.
* `commodity` (String): A description of the goods, service, or reason for the transaction (e.g., "Coffee", "Salary", "Online Course Fee").
* `inOut` (String): Indicates the direction of the money flow relative to the account holder. Typically:
* `paymentAmount` (double): The monetary value of the transaction. The currency unit (e.g., Yuan) is implied by the context where this class is used (often indicated by header names like "金额(元)" in associated CSV files).
* `paymentMethod` (String): The method used for the payment (e.g., "支付宝" - Alipay, "微信支付" - WeChat Pay, "银行卡" - Bank Card, "现金" - Cash).
* `currentStatus` (String): The current processing status of the transaction (e.g., "交易成功" - Transaction Successful, "等待付款" - Awaiting Payment, "已关闭" - Closed, "退款成功" - Refund Successful).
* `orderNumber` (String): A unique identifier assigned to this specific transaction instance by the payment system or application. Often used as a primary key.
* `merchantNumber` (String): An order number or identifier associated with the merchant's system, often provided for reconciliation purposes. May be empty or null if not applicable.
* `remarks` (String): An optional field for any additional notes, comments, or user-provided descriptions about the transaction.

### Constructors

* **`public Transaction()`**
  * Default no-argument constructor. Creates an empty `Transaction` object with all fields initialized to their default values (null for String, 0.0 for double).

* **`public Transaction(String transactionTime, String transactionType, ..., String remarks)`**
  * Parameterized constructor that accepts values for all fields. Allows for quick instantiation of a fully populated `Transaction` object.

### Methods

The class provides standard public **getter** (`get...()`) and **setter** (`set...()`) methods for all its private fields. These methods allow controlled access and modification of the transaction's attributes from other parts of the application.

* `getTransactionTime()` / `setTransactionTime(String time)`
* `getTransactionType()` / `setTransactionType(String type)`
* `getCounterparty()` / `setCounterparty(String counterparty)`
* `getCommodity()` / `setCommodity(String commodity)`
* `getInOut()` / `setInOut(String inOut)`
* `getPaymentAmount()` / `setPaymentAmount(double amount)`
* `getPaymentMethod()` / `setPaymentMethod(String method)`
* `getCurrentStatus()` / `setCurrentStatus(String status)`
* `getOrderNumber()` / `setOrderNumber(String orderNumber)`
* `getMerchantNumber()` / `setMerchantNumber(String merchantNumber)`
* `getRemarks()` / `setRemarks(String remarks)`


### Service (Business logic)

- Responsibilities:
  Transaction CRUD operations, calling the DAO layer to read and write local files,
  User-defined classification logic (e.g. modifying transaction categories)
  (3) Operations:

Add Transaction:

Transaction t = new Transaction();
// Set field values
service.addTransaction(t);

Modify Transaction:

Transaction update = new Transaction();
update.setOrderNumber("ORD123");
// Set fields to update
service.changeTransaction(update);

Query Transactions:

Transaction criteria = new Transaction();
criteria.setCounterparty("Alipay");
List<Transaction> results = service.searchTransaction(criteria);
Code structure
   Directory Layout:
   src/main/java/
   └── Service/
   ├── Impl/
   │   └── TransactionServiceImpl.java  # Service implementation
   └── TransactionService.java          # Service interface
   TransactionService.java:
   Defines the service interface with business-agnostic method signatures, enforcing decoupling 
   between business logic and implementation details.
   TransactionServiceImpl.java:
   Implements the concrete business logic while depending only on the interface-defined contract, maintaining loose coupling with the data access layer through dependency injection.


- AIService (Intelligent Analytics) Responsibilities: Generate budget recommendations based
  on historical data, and detect cost-cutting recommendations for seasonal spending in China
  (e.g. Spring Festival) (e.g. marking high-frequency small spending)


- **`AITransactionService`**

The central class that performs the full AI-driven transaction analysis. It:

- Loads transaction data from a CSV file via `CsvTransactionDao`.
- Filters transactions by user-specified time range (`startTimeStr`, `endTimeStr`).
- Aggregates data by counterparty (income/spending, transaction counts).
- Formats the result into concise summaries sent to the AI.
- Sends user questions and formatted data to the Volcengine Ark AI API.
- Returns a response within **400 characters** for efficient display.

Key methods:

- `analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr)`
  → Returns an AI-generated analysis result string.
- `runAiInThread(...)`
  → Runs the AI logic in a background thread (single-threaded executor).
- `formatTransactions(...)`
  → Groups transactions and summarizes them by counterparty and time range.
- `parseDateTime(...)`
  → Supports flexible input formats like `yyyy/MM/dd`, `yyyy/MM/dd HH:mm`, and more. - **`AIAnalyzerThread`** A `Runnable` implementation for threading scenarios (especially GUI usage). It calls `AITransactionService.analyzeTransactions(...)` and prints the result. UI developers can replace the console output with GUI updates using `SwingUtilities.invokeLater()`. --- ### Tests (`test/java/Service/AIservice/`) - **`AIserviceTest`** Unit tests for `AITransactionService`, verifying: - Correct loading and filtering of transactions. - Accurate AI response generation and formatting. - Graceful handling of edge cases (e.g., no transactions in range, invalid time formats). - **`AIAnalyzerThreadTest`** Validates threading logic: - Ensures `AIAnalyzerThread` executes `Runnable` correctly. - Demonstrates clean and concurrent AI analysis flow. - Simulates integration with a GUI environment. - **`AiFunctionTest`** Utility-level tests: - Ensures proper CSV parsing and data transformation. - Verifies output formatting before sending to the AI. - Tests various time formats and edge case behaviors

## DAO (File Storage)

- Responsibilities: Save transaction data in CSV or JSON format and provide interfaces for adding,
  deleting, and modifying in-memory data

### CsvTransactionDao Class

#### Package

`DAO`

#### Dependencies

* **`model.Transaction`**: The data model class representing a single transaction.
* **`DAO.TransactionDao`**: The interface this class is intended to implement (though the implementation is incomplete).
* **Apache Commons CSV (`org.apache.commons.csv.*`)**: Used for robust parsing and writing of CSV data.
* **Apache Commons IO (`org.apache.commons.io.input.BOMInputStream`)**: Used specifically to handle potential Byte Order Marks (BOM) often found in UTF-8 encoded files, particularly those edited in Windows.
* **Java Standard Libraries**: `java.io.*`, `java.nio.*`.

#### Key Features & Implementation Details

* **CSV Loading (`loadFromCSV`)**:
  * Reads data from a specified CSV file path.
  * Expects UTF-8 encoding.
  * Handles potential Byte Order Mark (BOM) at the beginning of the file.
  * Uses the first row of the CSV as the header to map columns to `Transaction` fields. Assumes specific header names (e.g., "交易时间", "交易类型", "金额(元)").
  * Parses transaction records into a `List<Transaction>`.
  * Includes basic caching using an internal `transactions` list and an `isLoad` flag to avoid redundant file reads within the same instance lifecycle (unless forced by methods like `deleteTransaction` or `changeInformation`).
* **Record Parsing (`parseRecord`)**:
  * Converts a `CSVRecord` object (from Apache Commons CSV) into a `Transaction` object.
  * Specifically handles the "金额(元)" (Amount) field by removing the leading "¥" symbol before parsing it as a `double`.
* **Adding Transactions (`addTransaction(String filePath, Transaction newTransaction)`)**:
  * **Appends** a new transaction record to the *end* of the specified CSV file.
  * Creates the file if it doesn't exist.
  * Writes the header row only if the file is new or was empty.
  * Formats the payment amount by prepending "¥".
* **Deleting Transactions (`deleteTransaction(String filePath, String orderNumber)`)**:
  * Loads data from the file if not already cached.
  * Filters the cached list to remove the transaction matching the given `orderNumber`.
  * **Overwrites** the *entire* original CSV file with the filtered list using `writeTransactionsToCSV`.
  * Returns `true` if a transaction was removed, `false` otherwise.
* **Updating Transactions (`changeInformation`)**:
  * Loads data if not already cached.
  * Finds the transaction by `orderNumber`.
  * Modifies the specified field (`head`) of the found transaction object in memory.
  * **Crucially, it attempts the update by first *deleting* the original record (using `deleteTransaction`, which overwrites the file) and then *adding* the modified record (using `addTransaction`, which appends to the file).** This logic is inefficient and potentially problematic due to the conflicting file write strategies (overwrite vs. append).
  * Error handling for invalid `head` parameters prints to `System.err`. The method often returns `true` even if the underlying delete/add fails.
* **CSV Writing (`writeTransactionsToCSV`)**:
  * Helper method used by `deleteTransaction`.
  * Writes a given `List<Transaction>` to the specified file path, **overwriting** any existing content.
  * Writes a standard header row.
  * Formats the payment amount by prepending "¥".

#### Important Issues & Considerations

1.  **Incomplete `TransactionDao` Implementation**: The methods declared in the `TransactionDao` interface (`getAllTransactions`, `addTransaction(Transaction)`, `deleteTransaction(String)`, `updateTransaction`, `getTransactionByOrderNumber`) are present but contain only placeholder/stub code. The actual working logic uses separate methods that require the `filePath` to be passed explicitly each time. **This class, in its current state, does not correctly function as a `TransactionDao` implementation.**
2.  **Inconsistent File Writing Strategy**: `addTransaction` *appends* to the file, while `deleteTransaction` and `writeTransactionsToCSV` (used by `deleteTransaction` and `changeInformation`) *overwrite* the entire file. This inconsistency can lead to unexpected behavior, especially within the `changeInformation` method.
3.  **Inefficient Updates/Deletes**: Rewriting the entire CSV file for every single deletion or modification (`changeInformation`) is highly inefficient, especially for large transaction files.
4.  **Flawed Update Logic (`changeInformation`)**: The delete-then-add approach for updates is problematic due to the inconsistent write strategies and potential race conditions or partial failures. The modified record will likely appear at the *end* of the file, not its original position.
5.  **Basic Caching**: The caching mechanism (`isLoad` flag) is simple and does not account for external modifications to the CSV file during the application's runtime.
6.  **Hardcoded Dependencies**: The code relies on specific header names (in Chinese) and the "¥" currency symbol format within the CSV data. Changes to the CSV format would require code modifications.

#### Usage Example (Using Functional Methods)

```java
import DAO.Impl.CsvTransactionDao; // Assuming TransactionDao interface exists but is not used directly here due to stub methods
import model.Transaction;
import java.io.IOException;
import java.util.List;

public class CsvDataManager {

    public static void main(String[] args) {
        // NOTE: Using the class directly, not via the TransactionDao interface
        // because the interface methods are not fully implemented.
        CsvTransactionDao csvDao = new CsvTransactionDao();
        String csvFilePath = "path/to/your/transactions.csv"; // <--- Specify your file path

        try {
            // --- Load Data ---
            System.out.println("Loading transactions...");
            List<Transaction> transactions = csvDao.loadFromCSV(csvFilePath);
            System.out.println("Loaded " + transactions.size() + " transactions.");
            // Display first transaction if available
            if (!transactions.isEmpty()) {
                 System.out.println("First transaction order number: " + transactions.get(0).getOrderNumber());
            }

            // --- Add a New Transaction (Appends) ---
            Transaction newTx = new Transaction(
                 "2025-04-20 08:14:00", "Test Add", "Counterparty", "Item", "支",
                 10.0, "支付宝", "交易成功", "NEW_ORDER_123", "MERCH_456", "Test via DAO add"
            );
            System.out.println("\nAdding new transaction (append): " + newTx.getOrderNumber());
            // csvDao.addTransaction(csvFilePath, newTx); // Uncomment to actually add
            System.out.println("Transaction potentially added.");

            // --- Delete a Transaction (Overwrites File) ---
            String orderToDelete = "SOME_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number from your file
            System.out.println("\nAttempting to delete transaction: " + orderToDelete);
            // boolean deleted = csvDao.deleteTransaction(csvFilePath, orderToDelete); // Uncomment to actually delete
            // if (deleted) {
            //     System.out.println("Transaction deleted successfully (File rewritten).");
            // } else {
            //     System.out.println("Transaction not found for deletion.");
            // }

            // --- Change Information (Overwrites then Appends - Use with Caution) ---
             String orderToChange = "ANOTHER_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number
             String fieldToChange = "remarks";
             String newValue = "Updated remark via changeInformation";
             System.out.println("\nAttempting to change info for: " + orderToChange);
             // boolean changed = csvDao.changeInformation(orderToChange, fieldToChange, newValue, csvFilePath); // Uncomment with caution
             // System.out.println("Change operation attempted (File rewritten and appended). Result: " + changed);


        } catch (IOException e) {
            System.err.println("Error interacting with CSV file: " + e.getMessage());
            e.printStackTrace();
        } catch (NumberFormatException e) {
            System.err.println("Error parsing amount in CSV: " + e.getMessage());
        }
    }
}
```

## Controller (Swing GUI)

Responsibilities: Manage user interface components (buttons, tables, text boxes) to listen for 
events (clicks, inputs) and call service layer methods to update the interface data display

## attention

encoding with UTF-8
```

`软工/Ai-Bill-Application-Group21\项目要求.txt`:

```txt
1. General Information 
In the next few weeks, your team will be required to develop a software application that 
will serve as a smart personal finance manager that helps users track expenses, set 
savings goals, and analyses spending habits using AI. Agile methods should be applied 
in all activities, from requirements through analysis/design, implementation, and testing. 
Iterations should be planned, and outcomes should be submitted. 
There are no restrictions on what you can include in the final product, and the given 
specification contains only high-level abstract requirements. It should be noted that 
determining the software requirements is one of the most important and complex phases 
in any development project. You should apply requirement-finding techniques and Agile 
methods to identify the actual requirements at an appropriate level. Most importantly, you 
need to prioritize the features that are implemented in accordance with both ease of 
implementation and meeting requirements. As in real software, you should define the 
project scope properly. Keep your design SIMPLE. Bear in mind that there is no absolute 
right answer – your solution may be perfectly appropriate.

2. Project Specification 
2.1 Basic Requirements 
Managing personal finances effectively is crucial in today’s digital economy, where 
transactions occur across multiple platforms like WeChat Pay, Alipay, and traditional 
banking. Many individuals struggle with tracking expenses, categorizing spending, and 
setting realistic budgets. An AI-powered personal finance tracker simplifies financial 
management by automatically classifying transactions, detecting spending patterns, and 
offering personalized savings recommendations. However, AI is not perfect – users must 
manually review to ensure accuracy. By integrating AI with manual validation, this 
software helps users make informed financial decisions while adapting to regional 
spending habits and economic conditions, improving financial literacy and budgeting 
skills. Here are some suggested functions to assist you in getting started. Suggested 
features can include the following, but not limited to: 
• Manual & Automated Data Entry: End users may input transactions manually or 
import structured CSV files from banking/financial apps. 
• Expense Categorisation (AI + Manual Correction): AI classifies transactions into 
categories (e.g., groceries, rent, entertainment), but end users can verify & correct 
misclassifications. 
• Spending Insights & Predictions: AI suggests monthly budgets, savings goals, and 
cost-cutting recommendations based on spending behaviour. 
• Local Financial Context: Customisable to China-specific budgeting habits, for 
example detects seasonal spending habits, such as higher expenses during Chinese 
New Year. 
A full prototype of the application should be produced. It is not required to implement the 
full working code for all functions in the prototype, however your team should implement 
core functions of your choice. 

2.2 Other Requirements 
• The software must be developed using Java as a stand-alone application running 
on computers. A simple graphic user interface (GUI) should be used. The recent 
Java Edition should be used. Do NOT build a Web-based application or Phone 
App. 
• All input and output data should be in simple text file format. You may use plain 
text (txt), CSV, JSON, or XML. Do NOT use a database. 
• Basic restrictions and error checking must be considered. 
• Your design must be flexible and extensible to adapt to future changes, e.g. 
modify existing features and add new features. When doing so, you should be 
able to reuse the existing components and make the least impact on the existing 
code. 
Page 2 of 8 
Your tasks are to define detailed requirements, design, develop and test the above software 
using Agile methods. Feel free to design the software as long as it satisfies the basic 
requirements, define the SCOPE properly.  

2.3 AI-Assisted Development 
To prevent over-reliance on AI, 
the following constraints apply: 
• Live Data Collection: AI cannot generate user-specific data patterns – you must 
gather real data. 请给出相应的数据搜集渠道（但是我们已经设计好了csv表，相应字段也设计了）
• Manual Data Cleaning and Validation: AI assistance is allowed, but the team must 
need to manually check for missing information, inconsistency, and inappropriate 
categorisation, etc. 
• Context-Specific Constraints: AI may struggle with domain-specific rules – you 
must implement real-world constraints (e.g. AI may count a WeChat Red Packet as a 
personal income where it is in fact a gift money and not a regular income.) 
• Oral Spot-Check: During the vivas, you will need to answer questions like “Why did 
AI make this recommendation?”, “How did you modify AI’s solution?”, etc, to 
demonstrate your understanding.
```

`软工/Submission\Labs\lab5\lab5.iml`:

```iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="GENERAL_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="module-library">
      <library name="JUnit4">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/junit/junit/4.13.1/junit-4.13.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="JUnit5.8.1">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter/5.8.1/junit-jupiter-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-api/5.8.1/junit-jupiter-api-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/opentest4j/opentest4j/1.2.0/opentest4j-1.2.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-commons/1.8.1/junit-platform-commons-1.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-params/5.8.1/junit-jupiter-params-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-engine/5.8.1/junit-jupiter-engine-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-engine/1.8.1/junit-platform-engine-1.8.1.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
  </component>
</module>
```

`软工/Submission\Labs\lab5\out\production\lab5\lab5.iml`:

```iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="GENERAL_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="module-library">
      <library name="JUnit4">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/junit/junit/4.13.1/junit-4.13.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="JUnit5.8.1">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter/5.8.1/junit-jupiter-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-api/5.8.1/junit-jupiter-api-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/opentest4j/opentest4j/1.2.0/opentest4j-1.2.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-commons/1.8.1/junit-platform-commons-1.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-params/5.8.1/junit-jupiter-params-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-engine/5.8.1/junit-jupiter-engine-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-engine/1.8.1/junit-platform-engine-1.8.1.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
  </component>
</module>
```

`软工/Submission\Labs\lab5\src\main\java\DegreeClassifier.java`:

```java
package src.main.java;

public class DegreeClassifier {
    /**
     * Classifies a degree based on the average mark.
     *
     * @param averageMark The average mark of the degree.
     * @return The classification of the degree.
     */
    public String classify(double averageMark) {
        if (averageMark >= 70) {
            return "First-Class";
        } else if (averageMark >= 60) {
            return "Upper Second-Class";
        } else if (averageMark >= 50) {
            return "Lower Second-Class";
        } else if (averageMark >= 40) {
            return "Third-Class";
        } else {
            return "Non-Honours";
        }
    }
}
```

`软工/Submission\Labs\lab5\src\test\java\DegreeClassifierTest.java`:

```java
package src.test.java;

import org.junit.jupiter.api.Test;
import src.main.java.DegreeClassifier;

import static org.junit.jupiter.api.Assertions.*;

public class DegreeClassifierTest {
    // We can see that all the test examples ran successfully !
    @Test
    public void testFirstClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("First-Class", classifier.classify(85));
    }

    @Test
    public void testUpperSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Upper Second-Class", classifier.classify(65));
    }

    @Test
    public void testLowerSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Lower Second-Class", classifier.classify(55));
    }

    @Test
    public void testThirdClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Third-Class", classifier.classify(45));
    }

    @Test
    public void testNonHonours() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Non-Honours", classifier.classify(35));
    }
}
```

`软工/Submission\Labs\lab6\lab6.iml`:

```iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="GENERAL_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="module-library">
      <library name="JUnit4">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/junit/junit/4.13.1/junit-4.13.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="JUnit5.8.1">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter/5.8.1/junit-jupiter-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-api/5.8.1/junit-jupiter-api-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/opentest4j/opentest4j/1.2.0/opentest4j-1.2.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-commons/1.8.1/junit-platform-commons-1.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-params/5.8.1/junit-jupiter-params-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-engine/5.8.1/junit-jupiter-engine-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-engine/1.8.1/junit-platform-engine-1.8.1.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="testng">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/testng/testng/7.1.0/testng-7.1.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/com/beust/jcommander/1.72/jcommander-1.72.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/com/google/inject/guice/4.1.0/guice-4.1.0-no_aop.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/javax/inject/javax.inject/1/javax.inject-1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/aopalliance/aopalliance/1.0/aopalliance-1.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/com/google/guava/guava/19.0/guava-19.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/yaml/snakeyaml/1.21/snakeyaml-1.21.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
  </component>
</module>
```

`软工/Submission\Labs\lab6\out\production\lab6\lab6.iml`:

```iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="GENERAL_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="module-library">
      <library name="JUnit4">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/junit/junit/4.13.1/junit-4.13.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="JUnit5.8.1">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter/5.8.1/junit-jupiter-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-api/5.8.1/junit-jupiter-api-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/opentest4j/opentest4j/1.2.0/opentest4j-1.2.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-commons/1.8.1/junit-platform-commons-1.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/apiguardian/apiguardian-api/1.1.2/apiguardian-api-1.1.2.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-params/5.8.1/junit-jupiter-params-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/jupiter/junit-jupiter-engine/5.8.1/junit-jupiter-engine-5.8.1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/junit/platform/junit-platform-engine/1.8.1/junit-platform-engine-1.8.1.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
    <orderEntry type="module-library">
      <library name="testng">
        <CLASSES>
          <root url="jar://$MAVEN_REPOSITORY$/org/testng/testng/7.1.0/testng-7.1.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/com/beust/jcommander/1.72/jcommander-1.72.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/com/google/inject/guice/4.1.0/guice-4.1.0-no_aop.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/javax/inject/javax.inject/1/javax.inject-1.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/aopalliance/aopalliance/1.0/aopalliance-1.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/com/google/guava/guava/19.0/guava-19.0.jar!/" />
          <root url="jar://$MAVEN_REPOSITORY$/org/yaml/snakeyaml/1.21/snakeyaml-1.21.jar!/" />
        </CLASSES>
        <JAVADOC />
        <SOURCES />
      </library>
    </orderEntry>
  </component>
</module>
```

`软工/Submission\Labs\lab6\src\main\java\DegreeClassifier.java`:

```java
package src.main.java;


/**
 * First Mutation
 */
//public class DegreeClassifier {
//    public String classify(double averageMark) {
//        if (averageMark > 70) { // Turn >= into >
//            return "First-Class";
//        } else if (averageMark >= 60) {
//            return "Upper Second-Class";
//        } else if (averageMark >= 50) {
//            return "Lower Second-Class";
//        } else if (averageMark >= 40) {
//            return "Third-Class";
//        } else {
//            return "Non-Honours";
//        }
//    }
//}

/**
 * Second Mutation Now we run the 2nd mutation test
 */
//public class DegreeClassifier {
//    public String classify(double averageMark) {
//        if (averageMark >= 70) {
//            return "First-Class";
//        } else if (averageMark > 60) { // Turn >= into > this time we change this
//            return "Upper Second-Class";
//        } else if (averageMark >= 50) {
//            return "Lower Second-Class";
//        } else if (averageMark >= 40) {
//            return "Third-Class";
//        } else {
//            return "Non-Honours";
//        }
//    }
//}

/**
 * Third Mutation last mutation test
 */
public class DegreeClassifier {
    public String classify(double averageMark) {
        if (averageMark >= 70) {
            return "First-Class";
        } else if (averageMark >= 60) {
            return "Upper Second-Class";
        } else if (averageMark >= 50) {
            return "Lower Second-Class";
        } else if (averageMark >= 40) {
            return "Second-Class"; // Modify the return value this time we directly change the return value
        } else {
            return "Non-Honours";
        }
    }
}

// That's it, all the mutation tests have been run
```

`软工/Submission\Labs\lab6\src\test\java\DegreeClassifierTest.java`:

```java
package src.test.java;

import org.junit.jupiter.api.Test;
import src.main.java.DegreeClassifier;

import static org.junit.jupiter.api.Assertions.*;

public class DegreeClassifierTest {
    // First Test no problem
    @Test
    public void testFirstClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("First-Class", classifier.classify(85));
    }



    /**
     * First Mutation Test, this test, problem occurred because >= was turned into >
     */
    @Test
    public void testFirstClassBoundary() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("First-Class", classifier.classify(70.0));
    }

    @Test
    public void testUpperSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Upper Second-Class", classifier.classify(65));
    }

    /**
     * Second Mutation Test second mutation test has problem because >= was turned into > aslo
     */
    @Test
    public void testUpperSecondClassBoundary() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Upper Second-Class", classifier.classify(60.0));
    }

    @Test
    public void testLowerSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Lower Second-Class", classifier.classify(55));
    }

    /**
     * Third Mutation Test
     */
    @Test
    public void testThirdClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Third-Class", classifier.classify(45)); // score >= 40 but honor is "Second-class" it should be wrong
    }

    @Test
    public void testNonHonours() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Non-Honours", classifier.classify(35));
    }
}
```

`软工/Submission\Submission(Test & Production)\Production\DegreeClassifierLab5.java`:

```java
package src.main.java;

public class DegreeClassifier {
    /**
     * Classifies a degree based on the average mark.
     *
     * @param averageMark The average mark of the degree.
     * @return The classification of the degree.
     */
    public String classify(double averageMark) {
        if (averageMark >= 70) {
            return "First-Class";
        } else if (averageMark >= 60) {
            return "Upper Second-Class";
        } else if (averageMark >= 50) {
            return "Lower Second-Class";
        } else if (averageMark >= 40) {
            return "Third-Class";
        } else {
            return "Non-Honours";
        }
    }
}
```

`软工/Submission\Submission(Test & Production)\Production\DegreeClassifierLab6.java`:

```java
package src.main.java;


/**
 * First Mutation
 */
//public class DegreeClassifier {
//    public String classify(double averageMark) {
//        if (averageMark > 70) { // Turn >= into >
//            return "First-Class";
//        } else if (averageMark >= 60) {
//            return "Upper Second-Class";
//        } else if (averageMark >= 50) {
//            return "Lower Second-Class";
//        } else if (averageMark >= 40) {
//            return "Third-Class";
//        } else {
//            return "Non-Honours";
//        }
//    }
//}

/**
 * Second Mutation Now we run the 2nd mutation test
 */
//public class DegreeClassifier {
//    public String classify(double averageMark) {
//        if (averageMark >= 70) {
//            return "First-Class";
//        } else if (averageMark > 60) { // Turn >= into > this time we change this
//            return "Upper Second-Class";
//        } else if (averageMark >= 50) {
//            return "Lower Second-Class";
//        } else if (averageMark >= 40) {
//            return "Third-Class";
//        } else {
//            return "Non-Honours";
//        }
//    }
//}

/**
 * Third Mutation last mutation test
 */
public class DegreeClassifier {
    public String classify(double averageMark) {
        if (averageMark >= 70) {
            return "First-Class";
        } else if (averageMark >= 60) {
            return "Upper Second-Class";
        } else if (averageMark >= 50) {
            return "Lower Second-Class";
        } else if (averageMark >= 40) {
            return "Second-Class"; // Modify the return value this time we directly change the return value
        } else {
            return "Non-Honours";
        }
    }
}

// That's it, all the mutation tests have been run
```

`软工/Submission\Submission(Test & Production)\Test\DegreeClassifierTestLab5.java`:

```java
package src.test.java;

import org.junit.jupiter.api.Test;
import src.main.java.DegreeClassifier;

import static org.junit.jupiter.api.Assertions.*;

public class DegreeClassifierTest {
    // We can see that all the test examples ran successfully !
    @Test
    public void testFirstClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("First-Class", classifier.classify(85));
    }

    @Test
    public void testUpperSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Upper Second-Class", classifier.classify(65));
    }

    @Test
    public void testLowerSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Lower Second-Class", classifier.classify(55));
    }

    @Test
    public void testThirdClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Third-Class", classifier.classify(45));
    }

    @Test
    public void testNonHonours() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Non-Honours", classifier.classify(35));
    }
}
```

`软工/Submission\Submission(Test & Production)\Test\DegreeClassifierTestLab6.java`:

```java
package src.test.java;

import org.junit.jupiter.api.Test;
import src.main.java.DegreeClassifier;

import static org.junit.jupiter.api.Assertions.*;

public class DegreeClassifierTest {
    // First Test no problem
    @Test
    public void testFirstClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("First-Class", classifier.classify(85));
    }



    /**
     * First Mutation Test, this test, problem occurred because >= was turned into >
     */
    @Test
    public void testFirstClassBoundary() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("First-Class", classifier.classify(70.0));
    }

    @Test
    public void testUpperSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Upper Second-Class", classifier.classify(65));
    }

    /**
     * Second Mutation Test second mutation test has problem because >= was turned into > aslo
     */
    @Test
    public void testUpperSecondClassBoundary() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Upper Second-Class", classifier.classify(60.0));
    }

    @Test
    public void testLowerSecondClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Lower Second-Class", classifier.classify(55));
    }

    /**
     * Third Mutation Test
     */
    @Test
    public void testThirdClass() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Third-Class", classifier.classify(45)); // score >= 40 but honor is "Second-class" it should be wrong
    }

    @Test
    public void testNonHonours() {
        DegreeClassifier classifier = new DegreeClassifier();
        assertEquals("Non-Honours", classifier.classify(35));
    }
}
```

`软工/大代码\MenuUI-post.txt`:

```txt
 package Controller;

 import Constants.ConfigConstants;
 // Remove import DAO.CsvTransactionDao;

 import Service.Impl.TransactionServiceImpl;
 import Service.TransactionService;
 import Utils.CacheManager;
 import model.Transaction;
 import model.User;

 import javax.swing.*;
 import java.awt.*;
 import java.io.IOException;
 import java.util.List;
 import java.util.Vector; // Still used for table row data structure
 import javax.swing.table.DefaultTableModel;

 // Remove static imports related to CSV_PATH

 public class MenuUI {
     private final User currentUser;
     private final TransactionService transactionService;

     // Make tableModel an instance field
     private DefaultTableModel tableModel;
     // Remove the static or instance allData field: private Vector<Vector<String>> allData = new Vector<>();

     // Add instance fields for search input components (for Question 2 & 3)
     private JTextField searchTransactionTimeField;
     private JTextField searchTransactionTypeField;
     private JTextField searchCounterpartyField;
     private JTextField searchCommodityField;
     private JComboBox<String> searchInOutComboBox;
     private JTextField searchPaymentMethodField;
     private JButton searchButton; // Keep reference to the search button

     private JTable table;
     private HistogramPanelContainer histogramPanelContainer;
     private JPanel rightPanel;
     private CardLayout cardLayout;

     // Constructor now accepts the authenticated User and their TransactionService instance
     public MenuUI(User authenticatedUser, TransactionService transactionService){
         this.currentUser = authenticatedUser;
         this.transactionService = transactionService; // Inject the user-specific service

         // Initialize table model (now non-static)
         String[] columnNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注", "Modify", "Delete"};
         this.tableModel = new DefaultTableModel(columnNames, 0);
         this.table = new JTable(this.tableModel);

         this.histogramPanelContainer = new HistogramPanelContainer();
         this.cardLayout = new CardLayout();
         this.rightPanel = new JPanel(this.cardLayout);

         // DEBUG: Print user info
         System.out.println("MenuUI initialized for user: " + currentUser.getUsername());
         System.out.println("Using transaction file: " + currentUser.getTransactionFilePath());

         // Data loading will be called in createMainPanel() after UI setup
     }

     public JPanel createMainPanel() {
         // Main panel, use BorderLayout
         JPanel mainPanel = new JPanel(new BorderLayout());

         // Left panel with Menu and AI buttons
         JPanel leftPanel = createLeftPanel();
         mainPanel.add(leftPanel, BorderLayout.WEST);

         // Right panel for table or AI view
         setupRightPanel();
         mainPanel.add(rightPanel, BorderLayout.CENTER);

         // Load the user's data and display initial view (only income)
         loadCSVDataForCurrentUser("收入"); // Load and display only income initially

         return mainPanel;
     }

     // Method to load CSV data for the current user with optional initial filter
     // This replaces the old loadCSVDataForCurrentUser() method
     public void loadCSVDataForCurrentUser(String initialInOutFilter) {
         this.tableModel.setRowCount(0); // Clear the table model

         try {
             // Get all transactions for the current user using the injected service
             List<Transaction> transactions = transactionService.getAllTransactions();
             System.out.println("Loaded total " + transactions.size() + " transactions from service for user " + currentUser.getUsername());

             // Filter transactions based on the initialInOutFilter
             List<Transaction> filteredTransactions = new java.util.ArrayList<>();
             if (initialInOutFilter == null || initialInOutFilter.trim().isEmpty()) {
                  // If no filter specified, add all transactions
                  filteredTransactions.addAll(transactions);
             } else {
                  // Filter by the specified 收/支 type
                  String filter = initialInOutFilter.trim();
                  filteredTransactions = transactions.stream()
                          .filter(t -> t.getInOut() != null && (t.getInOut().equalsIgnoreCase(filter) ||
                                  (filter.equalsIgnoreCase("收入") && t.getInOut().equalsIgnoreCase("收")) ||
                                  (filter.equalsIgnoreCase("支出") && t.getInOut().equalsIgnoreCase("支")) ))
                          .collect(java.util.stream.Collectors.toList());
             }


             // Add filtered transactions to the table model
             for (Transaction transaction : filteredTransactions) {
                 Vector<String> row = createRowFromTransaction(transaction);
                 this.tableModel.addRow(row);
             }
             System.out.println("Displayed " + filteredTransactions.size() + " transactions in the table.");

         } catch (Exception e) {
             e.printStackTrace();
             JOptionPane.showMessageDialog(null, "加载用户交易数据失败！", "错误", JOptionPane.ERROR_MESSAGE);
         }
     }

     // Method to create the left panel (Menu/AI buttons) - no changes needed here
     private JPanel createLeftPanel() { /* ... existing code ... */ return null; }

     // Method to set up the right panel (Table/Histogram) - no changes needed here
     private void setupRightPanel() { /* ... existing code ... */ }

     // Method to create the table panel - update button editors/renderers to use 'this' MenuUI instance
     private JPanel createTablePanel() {
         JPanel tablePanel = new JPanel(new BorderLayout());

         JPanel inputPanel = createInputPanel(); // This method now initializes search fields
         tablePanel.add(inputPanel, BorderLayout.NORTH);

         JScrollPane tableScrollPane = new JScrollPane(this.table);
         tableScrollPane.setPreferredSize(new Dimension(1000, 250));
         this.table.setRowHeight(30);

         tablePanel.add(tableScrollPane, BorderLayout.CENTER);

         // Set cell renderers and editors - pass 'this' MenuUI instance
         this.table.getColumnModel().getColumn(11).setCellRenderer(new ButtonRenderer());
         this.table.getColumnModel().getColumn(11).setCellEditor(new ButtonEditor(this));

         this.table.getColumnModel().getColumn(12).setCellRenderer(new ButtonRenderer());
         this.table.getColumnModel().getColumn(12).setCellEditor(new ButtonEditor(this));

         // Data loading is now called in createMainPanel()

         return tablePanel;
     }

     // Method to create input panel - Capture references to search fields and button (for Question 2 & 3)
     private JPanel createInputPanel() {
         JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));

         // Create input fields and capture references
         searchTransactionTimeField = new JTextField(10); // 交易时间输入框
         searchTransactionTypeField = new JTextField(10); // 交易类型输入框
         searchCounterpartyField = new JTextField(10);    // 交易对方输入框
         searchCommodityField = new JTextField(10);      // 商品输入框
         searchInOutComboBox = new JComboBox<>(new String[]{"", "收入", "支出"}); // Add empty option for "any"
         searchPaymentMethodField = new JTextField(10);  // 支付方式输入框

         // Add labels and input fields
         inputPanel.add(new JLabel("交易时间:"));
         inputPanel.add(searchTransactionTimeField);
         inputPanel.add(new JLabel("交易类型:"));
         inputPanel.add(searchTransactionTypeField);
         inputPanel.add(new JLabel("交易对方:"));
         inputPanel.add(searchCounterpartyField);
         inputPanel.add(new JLabel("商品:"));
         inputPanel.add(searchCommodityField);
         inputPanel.add(new JLabel("收/支:"));
         inputPanel.add(searchInOutComboBox);
         inputPanel.add(new JLabel("支付方式:"));
         inputPanel.add(searchPaymentMethodField);

         // Create Search and Add buttons and capture reference to search button
         searchButton = new JButton("Search");
         JButton addButton = new JButton("Add");

         // Add buttons
         inputPanel.add(searchButton);
         inputPanel.add(addButton);

         // Add ActionListener for Search button
         searchButton.addActionListener(e -> {
             // Call searchData with current values from the input fields
             searchData(
                     searchTransactionTimeField.getText().trim(),
                     searchTransactionTypeField.getText().trim(),
                     searchCounterpartyField.getText().trim(),
                     searchCommodityField.getText().trim(),
                     (String) searchInOutComboBox.getSelectedItem(),
                     searchPaymentMethodField.getText().trim()
             );
         });

         // Add ActionListener for Add button
         addButton.addActionListener(e -> {
             showAddTransactionDialog();
         });

         return inputPanel;
     }

     // Method to show add transaction dialog - update to use injected service
     private void showAddTransactionDialog() {
         // ... existing code to create dialog and fields ...
         JDialog addDialog = new JDialog();
         addDialog.setTitle("添加交易");
         addDialog.setLayout(new GridLayout(12, 2));

         JTextField transactionTimeField = new JTextField();
         JTextField transactionTypeField = new JTextField();
         JTextField counterpartyField = new JTextField();
         JTextField commodityField = new JTextField();
         JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"}); // Or maybe allow empty for "other"?
         JTextField paymentAmountField = new JTextField();
         JTextField paymentMethodField = new JTextField();
         JTextField currentStatusField = new JTextField();
         JTextField orderNumberField = new JTextField();
         JTextField merchantNumberField = new JTextField();
         JTextField remarksField = new JTextField();

         addDialog.add(new JLabel("交易时间:")); addDialog.add(transactionTimeField);
         addDialog.add(new JLabel("交易类型:")); addDialog.add(transactionTypeField);
         addDialog.add(new JLabel("交易对方:")); addDialog.add(counterpartyField);
         addDialog.add(new JLabel("商品:")); addDialog.add(commodityField);
         addDialog.add(new JLabel("收/支:")); addDialog.add(inOutComboBox);
         addDialog.add(new JLabel("金额(元):")); addDialog.add(paymentAmountField);
         addDialog.add(new JLabel("支付方式:")); addDialog.add(paymentMethodField);
         addDialog.add(new JLabel("当前状态:")); addDialog.add(currentStatusField);
         addDialog.add(new JLabel("交易单号:")); addDialog.add(orderNumberField);
         addDialog.add(new JLabel("商户单号:")); addDialog.add(merchantNumberField);
         addDialog.add(new JLabel("备注:")); addDialog.add(remarksField);


         // Add confirm button
         JButton confirmButton = new JButton("确认");
         confirmButton.addActionListener(e -> {
             String paymentAmountText = paymentAmountField.getText().trim();
             double paymentAmount = 0.0;
             if (!paymentAmountText.isEmpty()) {
                 try {
                      paymentAmount = Double.parseDouble(paymentAmountText);
                 } catch (NumberFormatException ex) {
                      JOptionPane.showMessageDialog(addDialog, "金额格式不正确！请输入数字。", "输入错误", JOptionPane.ERROR_MESSAGE);
                      return;
                 }
             }

             Transaction newTransaction = new Transaction(
                     emptyIfNull(transactionTimeField.getText().trim()),
                     emptyIfNull(transactionTypeField.getText().trim()),
                     emptyIfNull(counterpartyField.getText().trim()),
                     emptyIfNull(commodityField.getText().trim()),
                     (String) inOutComboBox.getSelectedItem(),
                     paymentAmount,
                     emptyIfNull(paymentMethodField.getText().trim()),
                     emptyIfNull(currentStatusField.getText().trim()),
                     emptyIfNull(orderNumberField.getText().trim()), // Ensure order number is provided
                     emptyIfNull(merchantNumberField.getText().trim()),
                     emptyIfNull(remarksField.getText().trim())
             );

             if (newTransaction.getOrderNumber().isEmpty()) {
                  JOptionPane.showMessageDialog(addDialog, "交易单号不能为空！", "输入错误", JOptionPane.ERROR_MESSAGE);
                  return;
             }

             try {
                 transactionService.addTransaction(newTransaction);

                 // After adding, decide what to display.
                 // Option 1: Reload the default (income only) view:
                 // loadCSVDataForCurrentUser("收入");
                 // Option 2: Reload all data:
                 // loadCSVDataForCurrentUser("");
                 // Option 3: Reload the *current* search/filter view (more complex, requires storing current criteria)
                 // Let's choose Option 2 for simplicity - show all data after adding a new transaction.
                 // The user can then filter if needed.
                 loadCSVDataForCurrentUser(""); // Load all data after adding

                 // Also clear search fields after adding
                 clearSearchFields();


                 addDialog.dispose();
                 JOptionPane.showMessageDialog(null, "交易添加成功！", "提示", JOptionPane.INFORMATION_MESSAGE);

             } catch (IOException ex) {
                 ex.printStackTrace();
                 JOptionPane.showMessageDialog(null, "交易添加失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
             }
         });

         addDialog.add(confirmButton);
         addDialog.setSize(400, 300);
         addDialog.setModal(true);
         addDialog.setVisible(true);
     }


     // Method to search data - update to clear tableModel only (remove allData usage)
     public void searchData(String query1, String query2, String query3, String query4, String query6, String query5) { // Renamed query params for clarity
         System.out.println("Searching with criteria: time='" + query1 + "', type='" + query2 + "', counterparty='" + query3 + "', commodity='" + query4 + "', inOut='" + query6 + "', paymentMethod='" + query5 + "'");
         this.tableModel.setRowCount(0); // Clear the table model

         // Create search criteria Transaction object
         Transaction searchCriteria = new Transaction(
                 query1, query2, query3, query4, query6,
                 0, // paymentAmount not used in search criteria from UI
                 query5,
                 "", "", "", ""
         );

         try {
             // Use the injected transactionService instance
             List<Transaction> transactions = transactionService.searchTransaction(searchCriteria);
             System.out.println("Search results count: " + transactions.size());
             for (Transaction transaction : transactions) {
                 Vector<String> row = createRowFromTransaction(transaction);
                 this.tableModel.addRow(row);
             }

         } catch (Exception ex) {
             ex.printStackTrace();
             JOptionPane.showMessageDialog(null, "查询失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
         }
     }

     // Method to create table row from Transaction object - no changes needed here
     private Vector<String> createRowFromTransaction(Transaction transaction) {
         Vector<String> row = new Vector<>();
         row.add(emptyIfNull(transaction.getTransactionTime()));
         row.add(emptyIfNull(transaction.getTransactionType()));
         row.add(emptyIfNull(transaction.getCounterparty()));
         row.add(emptyIfNull(transaction.getCommodity()));
         row.add(emptyIfNull(transaction.getInOut()));
         row.add(String.valueOf(transaction.getPaymentAmount())); // Keep as String for table
         row.add(emptyIfNull(transaction.getPaymentMethod()));
         row.add(emptyIfNull(transaction.getCurrentStatus()));
         row.add(emptyIfNull(transaction.getOrderNumber()));
         row.add(emptyIfNull(transaction.getMerchantNumber()));
         row.add(emptyIfNull(transaction.getRemarks()));
         row.add("Modify"); // Modify button text
         row.add("Delete"); // Delete button text
         return row;
     }


     // Method to delete row - get data from tableModel (remove allData usage)
     public void deleteRow(int rowIndex) {
         System.out.println("尝试删除行: " + rowIndex + " for user " + currentUser.getUsername());
         if (rowIndex >= 0 && rowIndex < this.tableModel.getRowCount()) { // Use tableModel row count

             // Get the order number directly from the displayed table row
             String orderNumber = (String) this.tableModel.getValueAt(rowIndex, 8); // OrderNumber is at index 8
             if (orderNumber == null || orderNumber.trim().isEmpty()) {
                  JOptionPane.showMessageDialog(null, "无法删除：交易单号为空！", "错误", JOptionPane.ERROR_MESSAGE);
                  System.err.println("Attempted to delete row " + rowIndex + " but order number is null or empty.");
                  return; // Cannot delete without an order number
             }
             orderNumber = orderNumber.trim();
             System.out.println("Deleting transaction with order number: " + orderNumber);

             try {
                 // Use the injected transactionService instance
                 boolean deleted = transactionService.deleteTransaction(orderNumber);

                 if (deleted) {
                     // Data is removed from CSV and cache invalidated by service.
                     // Update the UI model directly by removing the row.
                     this.tableModel.removeRow(rowIndex); // Remove the row from the displayed table


                     JOptionPane.showMessageDialog(null, "删除成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                     System.out.println("Deleted row " + rowIndex + " with order number " + orderNumber + " from UI.");

                     // After delete, refresh the view. Let's reload the *current* search/filter view.
                     // Get the current search criteria from the UI fields and re-apply search.
                     triggerCurrentSearch();

                 } else {
                     // This case means the service said it wasn't deleted (likely not found)
                     JOptionPane.showMessageDialog(null, "删除失败：未找到对应的交易单号 " + orderNumber, "错误", JOptionPane.ERROR_MESSAGE);
                     System.err.println("Delete failed: order number " + orderNumber + " not found by service.");
                 }
             } catch (Exception ex) {
                 ex.printStackTrace();
                 JOptionPane.showMessageDialog(null, "删除失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
                 System.err.println("Error during deletion for order number " + orderNumber);
             }
         } else {
              System.err.println("Attempted to delete row with invalid index: " + rowIndex + ". Table row count: " + this.tableModel.getRowCount());
         }
     }

     // Method to edit row - get data from tableModel and update display after edit (remove allData usage)
     public void editRow(int rowIndex) {
         System.out.println("编辑行: " + rowIndex + " for user " + currentUser.getUsername());
         if (rowIndex >= 0 && rowIndex < this.tableModel.getRowCount()) { // Use tableModel row count

             // Get the data for the displayed row directly from the table model
             Vector<String> rowData = new Vector<>();
             // Get data for all columns that correspond to Transaction fields (up to index 10)
             for (int i = 0; i <= 10; i++) { // Columns 0 to 10 are Transaction fields
                 Object value = this.tableModel.getValueAt(rowIndex, i);
                 rowData.add(value != null ? value.toString() : "");
             }
             System.out.println("Retrieved row data from table model for editing: " + rowData);

             // Get the original order number, which is the key for update
             String originalOrderNumber = rowData.get(8).trim(); // Index 8 is OrderNumber
              if (originalOrderNumber.isEmpty()) {
                 JOptionPane.showMessageDialog(null, "无法编辑：交易单号为空！", "错误", JOptionPane.ERROR_MESSAGE);
                 System.err.println("Attempted to edit row " + rowIndex + " but order number is empty.");
                 return; // Cannot edit without an order number
              }


             // Create a panel for edit fields
             JPanel panel = new JPanel(new GridLayout(11, 2)); // 11 Transaction fields

             // Create fields array, populate panel and fields
             JTextField[] fields = new JTextField[11]; // 11 fields for Transaction data
             String[] fieldNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注"};

             for (int i = 0; i < fieldNames.length; i++) {
                 panel.add(new JLabel(fieldNames[i] + ":")); // Add label
                 fields[i] = new JTextField(rowData.get(i)); // Set field value from row data
                 panel.add(fields[i]);
             }

             // Disable editing the order number field if it's the primary key and shouldn't be changed
             // If you decide OrderNumber is immutable via edit:
             fields[8].setEditable(false); // Disable editing OrderNumber field


             // Show the dialog
             int result = JOptionPane.showConfirmDialog(null, panel, "修改交易信息 (订单号: " + originalOrderNumber + ")", JOptionPane.OK_CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE);

             if (result == JOptionPane.OK_OPTION) {
                 // User clicked OK, get updated values from fields

                 // Handle paymentAmount parsing carefully
                 double paymentAmount = safeParseDouble(fields[5].getText().trim()); // 金额(元)

                 // Create a Transaction object with updated values
                 // Use the original order number as the key for the update operation
                 Transaction updatedTransaction = new Transaction(
                         fields[0].getText().trim(), // 交易时间
                         fields[1].getText().trim(), // 交易类型
                         fields[2].getText().trim(), // 交易对方
                         fields[3].getText().trim(), // 商品
                         fields[4].getText().trim(), // 收/支
                         paymentAmount,
                         fields[6].getText().trim(), // 支付方式
                         fields[7].getText().trim(), // 当前状态
                         originalOrderNumber, // Use the ORIGINAL order number as the identifier for update
                         fields[9].getText().trim(), // 商户单号
                         fields[10].getText().trim() // 备注
                 );

                 try {
                     // Use the injected transactionService instance to change the transaction
                     transactionService.changeTransaction(updatedTransaction);

                     // *** IMPORTANT CHANGE FOR QUESTION 2 ***
                     // After successful edit, update the search fields and trigger search
                     System.out.println("Edit successful. Preparing to refresh display filtered by InOut: " + updatedTransaction.getInOut());
                     // Clear all search text fields
                     clearSearchFields();
                     // Set the InOut dropdown to the updated value
                     searchInOutComboBox.setSelectedItem(updatedTransaction.getInOut());
                     // Trigger the search based on the updated criteria
                     triggerCurrentSearch();


                     JOptionPane.showMessageDialog(null, "修改成功！", "提示", JOptionPane.INFORMATION_MESSAGE);
                     System.out.println("Edited row " + rowIndex + " for order number " + originalOrderNumber + " and refreshed display.");

                 } catch (IllegalArgumentException e) {
                     JOptionPane.showMessageDialog(null, "修改失败！\n" + e.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
                     e.printStackTrace();
                 } catch (Exception ex) {
                     ex.printStackTrace();
                     JOptionPane.showMessageDialog(null, "修改失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE);
                     System.err.println("Error during editing for order number " + originalOrderNumber);
                 }
             } else {
                  System.out.println("Edit dialog cancelled.");
             }
         } else {
              System.err.println("Attempted to edit row with invalid index: " + rowIndex + ". Table row count: " + this.tableModel.getRowCount());
         }
     }

     // Helper method to safely parse double, return 0.0 on error
     private double safeParseDouble(String value) {
         if (value == null || value.trim().isEmpty()) {
             return 0.0;
         }
         try {
             return Double.parseDouble(value.trim());
         } catch (NumberFormatException e) {
             System.err.println("Failed to parse double from string: '" + value + "'");
             // Consider showing a warning message to the user here
             return 0.0;
         }
     }

      // Helper method to clear all search input fields
     private void clearSearchFields() {
         searchTransactionTimeField.setText("");
         searchTransactionTypeField.setText("");
         searchCounterpartyField.setText("");
         searchCommodityField.setText("");
         searchInOutComboBox.setSelectedItem(""); // Set to the empty option
         searchPaymentMethodField.setText("");
          System.out.println("Cleared search fields.");
     }

      // Helper method to trigger search based on current search field values
      private void triggerCurrentSearch() {
         searchData(
                 searchTransactionTimeField.getText().trim(),
                 searchTransactionTypeField.getText().trim(),
                 searchCounterpartyField.getText().trim(),
                 searchCommodityField.getText().trim(),
                 (String) searchInOutComboBox.getSelectedItem(),
                 searchPaymentMethodField.getText().trim()
         );
          System.out.println("Triggered search with current field values.");
      }


     /**
      * If field is null, return empty string.
      * @param value Field value
      * @return Non-null field value
      */
     private String emptyIfNull(String value) {
         return value == null ? "" : value;
     }

     // Keep getTable() for testing
     public JTable getTable() {
         return table;
     }
 }
```

`软工/大代码\MenuUI-pre.txt`:

```txt
package Controller;

import Constants.ConfigConstants; // [cite: 240]
// Remove import DAO.CsvTransactionDao; // No longer directly initialized here // [cite: 240]

import Service.Impl.TransactionServiceImpl; // [cite: 240]
// Import the specific implementation // [cite: 241]
import Service.TransactionService; // [cite: 241]
// Import the interface as well // [cite: 242]
import Utils.CacheManager; // [cite: 242]
// Might be needed if UI directly invalidates cache (less ideal) // [cite: 243]
import model.Transaction; // [cite: 243]
import model.User; // [cite: 243]
import javax.swing.*; // [cite: 244]
import java.awt.*; // [cite: 244]
import java.io.IOException; // [cite: 244]
import java.util.List; // [cite: 244]
import java.util.Vector; // [cite: 244]
import javax.swing.table.DefaultTableModel; // [cite: 244]
// Remove static imports related to CSV_PATH // [cite: 245]
// import static Constants.CaffeineKeys.TRANSACTION_CAFFEINE_KEY; // [cite: 245]
// import static Constants.ConfigConstants.CSV_PATH; // [cite: 245]

public class MenuUI {
    private final User currentUser; // [cite: 246]
    // private final String currentUserTransactionFilePath; // Can get this from currentUser // [cite: 247]

    // Make tableModel and allData instance fields, not static // [cite: 247]
    private DefaultTableModel tableModel; // [cite: 247]
    private Vector<Vector<String>> allData = new Vector<>(); // Non-static data // [cite: 248]

    // Make transactionService an instance field // [cite: 248]
    private final TransactionService transactionService; // [cite: 248]
    private JTable table; // [cite: 249]
    private HistogramPanelContainer histogramPanelContainer; // [cite: 249]
    private JPanel rightPanel; // [cite: 249]
    private CardLayout cardLayout; // [cite: 249]

    // Constructor now accepts the authenticated User and their TransactionService instance // [cite: 250]
    public MenuUI(User authenticatedUser, TransactionService transactionService){
        this.currentUser = authenticatedUser; // [cite: 250]
        this.transactionService = transactionService; // Inject the user-specific service // [cite: 251]

        // Initialize table model (now non-static) // [cite: 251]
        String[] columnNames = {"交易时间", "交易类型", "交易对方", "商品", "收/支", "金额(元)", "支付方式", "当前状态", "交易单号", "商户单号", "备注", "Modify", "Delete"}; // [cite: 251]
        this.tableModel = new DefaultTableModel(columnNames, 0); // Use 'this' for instance field // [cite: 252]
        this.table = new JTable(this.tableModel); // [cite: 252]
        // Use 'this' // [cite: 253]

        this.histogramPanelContainer = new HistogramPanelContainer(); // [cite: 253]
        // Use 'this' // [cite: 254]
        this.cardLayout = new CardLayout(); // [cite: 254]
        // Use 'this' // [cite: 255]
        this.rightPanel = new JPanel(this.cardLayout); // [cite: 255]
        // Use 'this' // [cite: 256]

        // DEBUG: Print user info // [cite: 256]
        System.out.println("MenuUI initialized for user: " + currentUser.getUsername()); // [cite: 256]
        System.out.println("Using transaction file: " + currentUser.getTransactionFilePath()); // [cite: 257]

        // The rest of the UI setup...
    }

    public JPanel createMainPanel() {
        // Main panel, using BorderLayout // [cite: 257]
        JPanel mainPanel = new JPanel(new BorderLayout()); // [cite: 258]
        // Left panel with Menu and AI buttons // [cite: 258]
        JPanel leftPanel = createLeftPanel(); // [cite: 258]
        mainPanel.add(leftPanel, BorderLayout.WEST); // [cite: 259]

        // Right panel for table or AI view // [cite: 259]
        setupRightPanel(); // [cite: 259]
        mainPanel.add(rightPanel, BorderLayout.CENTER); // [cite: 260]

        // *** IMPORTANT CHANGE *** // [cite: 260]
        // After the UI components are created and the panel is added, // [cite: 260]
        // load the user's data. // [cite: 261]
        // This happens once when the main panel is created/displayed. // [cite: 261]
        loadCSVDataForCurrentUser(); // [cite: 261]
        // Call the loading method here // [cite: 262]

        return mainPanel; // [cite: 262]
    }

    // Method to load CSV data for the current user // [cite: 263]
    // This replaces the old loadCSVData(String caffeineKey) method // [cite: 263]
    public void loadCSVDataForCurrentUser() {
        this.allData.clear(); // [cite: 263]
        // Use 'this' for instance field // [cite: 264]
        this.tableModel.setRowCount(0); // [cite: 264]
        // Use 'this' // [cite: 265]

        try {
            // Get all transactions for the current user using the injected service // [cite: 265]
            // Note: TransactionServiceImpl's getAllTransactionsForCurrentUser is private. // [cite: 266]
            // We need a public method in TransactionService to get all data for the UI. // [cite: 267]
            // Let's add one to TransactionService interface. // [cite: 267]
            // For now, assuming we can get all via search with empty criteria. // [cite: 268]
            // Or, better, add a public getAllTransactions() method to the service interface. // [cite: 268]
            // Let's add `List<Transaction> getAllTransactions()` to TransactionService. // [cite: 269]
            // And implement it in TransactionServiceImpl using `getAllTransactionsForCurrentUser()`. // [cite: 269]

            List<Transaction> transactions = transactionService.getAllTransactions(); // [cite: 269]
            // Call the new public method // [cite: 270]

            for (Transaction transaction : transactions) {
                Vector<String> row = createRowFromTransaction(transaction); // [cite: 270]
                this.allData.add(row); // Use 'this' // [cite: 271]
                this.tableModel.addRow(row); // [cite: 271]
                // Use 'this' // [cite: 272]
            }
            System.out.println("Loaded " + transactions.size() + " transactions into table for user " + currentUser.getUsername()); // [cite: 272]
        } catch (Exception e) {
            e.printStackTrace(); // [cite: 273]
            JOptionPane.showMessageDialog(null, "加载用户交易数据失败！", "错误", JOptionPane.ERROR_MESSAGE); // [cite: 274]
        }
    }

    // Method to create the left panel (Menu/AI buttons) - no changes needed here // [cite: 274]
    private JPanel createLeftPanel() {
        JPanel leftPanel = new JPanel(new GridLayout(2, 1)); // [cite: 384]
        JButton menuButton = new JButton("Menu"); // [cite: 385]
        JButton aiButton = new JButton("AI"); // [cite: 385]

        leftPanel.add(menuButton); // [cite: 385]
        leftPanel.add(aiButton); // [cite: 386]
        // 为 Menu 按钮添加 ActionListener // [cite: 386]
        menuButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Table"); // 切换到表格界面 // [cite: 386]
        });
        // 为 AI 按钮添加 ActionListener // [cite: 387]
        aiButton.addActionListener(e -> {
            cardLayout.show(rightPanel, "Histogram"); // 切换到直方图界面 // [cite: 387]
        });
        return leftPanel; // [cite: 388]
    }

    // Method to set up the right panel (Table/Histogram) - no changes needed here // [cite: 275]
    private void setupRightPanel() {
        // 创建搜索和表格的面板 // [cite: 388]
        JPanel tablePanel = createTablePanel(); // [cite: 389]
        // 将表格面板和直方图面板添加到 rightPanel // [cite: 389]
        rightPanel.add(tablePanel, "Table"); // [cite: 389]
        rightPanel.add(histogramPanelContainer, "Histogram"); // [cite: 390]
    }

    // Method to create the table // [cite: 275]
    // panel - update button editors/renderers to use 'this' MenuUI instance // [cite: 275]
    private JPanel createTablePanel() {
        JPanel tablePanel = new JPanel(new BorderLayout()); // [cite: 276]
        JPanel inputPanel = createInputPanel(); // [cite: 276]
        tablePanel.add(inputPanel, BorderLayout.NORTH); // [cite: 277]

        JScrollPane tableScrollPane = new JScrollPane(this.table); // [cite: 277]
        // Use 'this' // [cite: 277]
        tableScrollPane.setPreferredSize(new Dimension(1000, 250)); // [cite: 277]
        this.table.setRowHeight(30); // [cite: 278]
        // Use 'this' // [cite: 278]

        tablePanel.add(tableScrollPane, BorderLayout.CENTER); // [cite: 279]
        // Set cell renderers and editors - pass 'this' MenuUI instance // [cite: 279]
        this.table.getColumnModel().getColumn(11).setCellRenderer(new ButtonRenderer()); // [cite: 279]
        this.table.getColumnModel().getColumn(11).setCellEditor(new ButtonEditor(this)); // Pass 'this' // [cite: 280]

        this.table.getColumnModel().getColumn(12).setCellRenderer(new ButtonRenderer()); // [cite: 280]
        this.table.getColumnModel().getColumn(12).setCellEditor(new ButtonEditor(this)); // Pass 'this' // [cite: 281]

        // Data loading is now called in createMainPanel()

        return tablePanel; // [cite: 282]
    }

    // Method to create input panel - no changes needed here // [cite: 282]
    private JPanel createInputPanel() {
        JPanel inputPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10)); // [cite: 394]
        // 创建输入字段 // [cite: 395]
        JTextField transactionTimeField = new JTextField(10); // [cite: 395]
        // 交易时间输入框 // [cite: 396]
        JTextField transactionTypeField = new JTextField(10); // [cite: 396]
        // 交易类型输入框 // [cite: 397]
        JTextField counterpartyField = new JTextField(10); // [cite: 397]
        // 交易对方输入框 // [cite: 398]
        JTextField commodityField = new JTextField(10); // [cite: 398]
        // 商品输入框 // [cite: 399]
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"}); // [cite: 399]
        // 收/支下拉框 // [cite: 400]
        JTextField paymentMethodField = new JTextField(10); // [cite: 400]
        // 支付方式输入框 // [cite: 401]

        // 添加标签和输入字段到输入面板 // [cite: 401]
        inputPanel.add(new JLabel("交易时间:")); // [cite: 402]
        inputPanel.add(transactionTimeField); // [cite: 402]
        inputPanel.add(new JLabel("交易类型:")); // [cite: 402]
        inputPanel.add(transactionTypeField); // [cite: 402]
        inputPanel.add(new JLabel("交易对方:")); // [cite: 402]
        inputPanel.add(counterpartyField); // [cite: 402]
        inputPanel.add(new JLabel("商品:")); // [cite: 403]
        inputPanel.add(commodityField); // [cite: 403]
        inputPanel.add(new JLabel("收/支:")); // [cite: 403]
        inputPanel.add(inOutComboBox); // [cite: 403]
        inputPanel.add(new JLabel("支付方式:")); // [cite: 403]
        inputPanel.add(paymentMethodField); // [cite: 403]
        // 创建 Search 和 Add 按钮 // [cite: 403]
        JButton searchButton = new JButton("Search"); // [cite: 404]
        JButton addButton = new JButton("Add"); // [cite: 404]

        // 将按钮添加到输入面板 // [cite: 404]
        inputPanel.add(searchButton); // [cite: 404]
        inputPanel.add(addButton); // [cite: 405]
        // 为 Search 按钮添加 ActionListener // [cite: 405]
        searchButton.addActionListener(e -> {
            // 获取输入字段的值 // [cite: 405]
            searchData(
                    transactionTimeField.getText().trim(), // [cite: 406]
                    transactionTypeField.getText().trim(), // [cite: 406]
                    counterpartyField.getText().trim(), // [cite: 406]
                    commodityField.getText().trim(), // [cite: 406]
                    (String) inOutComboBox.getSelectedItem(), // [cite: 406]
                    paymentMethodField.getText().trim() // [cite: 406]
            );
        });
        // 为 Add 按钮添加 ActionListener // [cite: 407]
        addButton.addActionListener(e -> {
            // 弹出对话框，输入交易信息 // [cite: 407]
            showAddTransactionDialog(); // [cite: 407]
        });
        return inputPanel; // [cite: 408]
    }

    // Method to show add transaction dialog - update to use injected service // [cite: 282]
    private void showAddTransactionDialog() {
        JDialog addDialog = new JDialog(); // [cite: 283]
        addDialog.setTitle("添加交易"); // [cite: 283]
        addDialog.setLayout(new GridLayout(12, 2)); // 11 fields + 1 button row // [cite: 283]
        // ... create fields ...
        // Add labels and fields...

        // Create input fields for the dialog
        JTextField transactionTimeField = new JTextField(); // [cite: 409]
        JTextField transactionTypeField = new JTextField(); // [cite: 410]
        JTextField counterpartyField = new JTextField(); // [cite: 410]
        JTextField commodityField = new JTextField(); // [cite: 410]
        JComboBox<String> inOutComboBox = new JComboBox<>(new String[]{"收入", "支出"}); // [cite: 411]
        JTextField paymentAmountField = new JTextField(); // [cite: 411]
        JTextField paymentMethodField = new JTextField(); // [cite: 411]
        JTextField currentStatusField = new JTextField(); // [cite: 412]
        JTextField orderNumberField = new JTextField(); // [cite: 412]
        JTextField merchantNumberField = new JTextField(); // [cite: 412]
        JTextField remarksField = new JTextField(); // [cite: 412]

        // Add labels and input fields to the dialog // [cite: 413]
        addDialog.add(new JLabel("交易时间:")); // [cite: 413]
        addDialog.add(transactionTimeField); // [cite: 413]
        addDialog.add(new JLabel("交易类型:")); // [cite: 413]
        addDialog.add(transactionTypeField); // [cite: 413]
        addDialog.add(new JLabel("交易对方:")); // [cite: 413]
        addDialog.add(counterpartyField); // [cite: 413]
        addDialog.add(new JLabel("商品:")); // [cite: 414]
        addDialog.add(commodityField); // [cite: 414]
        addDialog.add(new JLabel("收/支:")); // [cite: 414]
        addDialog.add(inOutComboBox); // [cite: 414]
        addDialog.add(new JLabel("金额(元):")); // [cite: 414]
        addDialog.add(paymentAmountField); // [cite: 414]
        addDialog.add(new JLabel("支付方式:")); // [cite: 414]
        addDialog.add(paymentMethodField); // [cite: 414]
        addDialog.add(new JLabel("当前状态:")); // [cite: 415]
        addDialog.add(currentStatusField); // [cite: 415]
        addDialog.add(new JLabel("交易单号:")); // [cite: 415]
        addDialog.add(orderNumberField); // [cite: 415]
        addDialog.add(new JLabel("商户单号:")); // [cite: 415]
        addDialog.add(merchantNumberField); // [cite: 415]
        addDialog.add(new JLabel("备注:")); // [cite: 415]
        addDialog.add(remarksField); // [cite: 415]

        // Add confirm button // [cite: 284]
        JButton confirmButton = new JButton("确认"); // [cite: 284]
        confirmButton.addActionListener(e -> {
            // ... get field values ...
            String paymentAmountText = paymentAmountField.getText().trim(); // [cite: 284]
            double paymentAmount = 0.0; // Default to 0.0 // [cite: 284]
            if (!paymentAmountText.isEmpty()) { // [cite: 284]
                try { // [cite: 285]
                    paymentAmount = Double.parseDouble(paymentAmountText); // [cite: 285]
                } catch (NumberFormatException ex) {
                    JOptionPane.showMessageDialog(addDialog, "金额格式不正确！请输入数字。", "输入错误", JOptionPane.ERROR_MESSAGE); // [cite: 285]
                    return; // Stop processing if amount is invalid // [cite: 286]
                }
            }

            // Create Transaction object // [cite: 286]
            Transaction newTransaction = new Transaction( // [cite: 287]
                    emptyIfNull(transactionTimeField.getText().trim()), // [cite: 287]
                    emptyIfNull(transactionTypeField.getText().trim()), // [cite: 287]
                    emptyIfNull(counterpartyField.getText().trim()), // [cite: 288]
                    emptyIfNull(commodityField.getText().trim()), // [cite: 288]
                    (String) inOutComboBox.getSelectedItem(), // [cite: 288]
                    paymentAmount, // [cite: 288]
                    emptyIfNull(paymentMethodField.getText().trim()), // [cite: 289]
                    emptyIfNull(currentStatusField.getText().trim()), // [cite: 289]
                    emptyIfNull(orderNumberField.getText().trim()), // Ensure order number is provided if it's the key // [cite: 289]
                    emptyIfNull(merchantNumberField.getText().trim()), // [cite: 289]
                    emptyIfNull(remarksField.getText().trim()) // [cite: 290]
            );
            // Basic validation for order number if it's the primary key // [cite: 290]
            if (newTransaction.getOrderNumber().isEmpty()) { // [cite: 290]
                JOptionPane.showMessageDialog(addDialog, "交易单号不能为空！", "输入错误", JOptionPane.ERROR_MESSAGE); // [cite: 291]
                return; // Stop if order number is missing // [cite: 291]
            }

            try {
                // Use the injected transactionService instance // [cite: 291]
                transactionService.addTransaction(newTransaction); // [cite: 292]
                // Reload CSV data to update the table for the current user // [cite: 292]
                loadCSVDataForCurrentUser(); // [cite: 292]
                // Reload data after add // [cite: 293]

                addDialog.dispose(); // [cite: 293]
                JOptionPane.showMessageDialog(null, "交易添加成功！", "提示", JOptionPane.INFORMATION_MESSAGE); // [cite: 294]
            } catch (IOException ex) {
                ex.printStackTrace(); // [cite: 294]
                JOptionPane.showMessageDialog(null, "交易添加失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE); // [cite: 295]
            }
        });
        // ... add components to dialog ...
        addDialog.add(confirmButton); // [cite: 296]
        // Set dialog size and visibility
        addDialog.setSize(400, 300); // [cite: 426]
        addDialog.setModal(true); // [cite: 426]
        // Set as modal dialog // [cite: 427]
        addDialog.setVisible(true); // [cite: 427]
    }


    // Method to search data - update to use injected service // [cite: 297]
    public void searchData(String query1, String query2, String query3, String query4, String query6, String query5) {
        this.tableModel.setRowCount(0); // [cite: 297]
        // Use 'this' // [cite: 298]
        // Create search criteria Transaction object // [cite: 298]
        Transaction searchCriteria = new Transaction(
                query1, query2, query3, query4, query6, // [cite: 298]
                0, // paymentAmount is not used in search criteria based on MenuUI input fields // [cite: 299]
                query5, // [cite: 299]
                "", "", "", "" // [cite: 299]
        );
        try { // [cite: 300]
            // Use the injected transactionService instance // [cite: 300]
            List<Transaction> transactions = transactionService.searchTransaction(searchCriteria); // [cite: 300]
            for (Transaction transaction : transactions) {
                Vector<String> row = createRowFromTransaction(transaction); // [cite: 301]
                this.tableModel.addRow(row); // Use 'this' // [cite: 302]
            }
            System.out.println("Search completed. Displaying " + transactions.size() + " results."); // [cite: 302]
        } catch (Exception ex) { // searchTransaction can throw Exception from cache loading // [cite: 303]
            ex.printStackTrace(); // [cite: 303]
            JOptionPane.showMessageDialog(null, "查询失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE); // [cite: 304]
        }
    }

    // Method to create table row from Transaction object - no changes needed here // [cite: 304]
    private Vector<String> createRowFromTransaction(Transaction transaction) {
        Vector<String> row = new Vector<>(); // [cite: 436]
        row.add(transaction.getTransactionTime()); // [cite: 437]
        row.add(transaction.getTransactionType()); // [cite: 437]
        row.add(transaction.getCounterparty()); // [cite: 437]
        row.add(transaction.getCommodity()); // [cite: 437]
        row.add(transaction.getInOut()); // [cite: 437]
        row.add(String.valueOf(transaction.getPaymentAmount())); // [cite: 437]
        row.add(transaction.getPaymentMethod()); // [cite: 437]
        row.add(transaction.getCurrentStatus()); // [cite: 438]
        row.add(transaction.getOrderNumber()); // [cite: 438]
        row.add(transaction.getMerchantNumber()); // [cite: 438]
        row.add(transaction.getRemarks()); // [cite: 438]
        row.add("Modify"); // [cite: 438]
        // Modify 按钮 // [cite: 438]
        row.add("Delete"); // [cite: 439]
        // 添加 Delete 按钮 // [cite: 439]
        return row; // [cite: 440]
    }

    // Method to delete row - update to use injected service // [cite: 304]
    public void deleteRow(int rowIndex) {
        if (rowIndex >= 0 && rowIndex < this.allData.size()) { // Use 'this' for allData // [cite: 305]
            String orderNumber = this.allData.get(rowIndex).get(8).trim(); // [cite: 305]
            // Use 'this' // [cite: 306]
            System.out.println("尝试删除的交易单号: " + orderNumber + " for user " + currentUser.getUsername()); // [cite: 306]
            try {
                // Use the injected transactionService instance // [cite: 307]
                boolean deleted = transactionService.deleteTransaction(orderNumber); // [cite: 307]
                if (deleted) { // [cite: 308]
                    // Data is removed from CSV and cache invalidated by service. // [cite: 308]
                    // Now update the UI model. // [cite: 309]
                    // Removing directly from allData and tableModel is acceptable here // [cite: 309]
                    // as loadCSVDataForCurrentUser() reloads from the single source of truth (cache/file). // [cite: 310]
                    // However, if allData is meant to be the in-memory representation used by search, // [cite: 310]
                    // it should be updated consistently. // [cite: 311]
                    // For simplicity and consistency with reloading, let's just reload the UI data. // [cite: 311]
                    loadCSVDataForCurrentUser(); // [cite: 311]
                    // Reload data after delete // [cite: 312]
                    // Alternatively, remove from allData and tableModel directly if allData is kept in sync. // [cite: 312]
                    // this.allData.remove(rowIndex); // If keeping allData perfectly in sync // [cite: 313]
                    // this.tableModel.removeRow(rowIndex); // [cite: 314]
                    // If keeping tableModel perfectly in sync // [cite: 314]


                    JOptionPane.showMessageDialog(null, "删除成功！", "提示", JOptionPane.INFORMATION_MESSAGE); // [cite: 314]
                    System.out.println("Deleted row " + rowIndex + " with order number " + orderNumber); // [cite: 315]
                } else {
                    // This case should be handled by the service throwing an exception or returning false. // [cite: 316]
                    JOptionPane.showMessageDialog(null, "删除失败：未找到对应的交易单号 " + orderNumber, "错误", JOptionPane.ERROR_MESSAGE); // [cite: 317]
                    System.err.println("Delete failed: order number " + orderNumber + " not found."); // [cite: 317]
                }
            } catch (Exception ex) { // deleteTransaction can throw Exception // [cite: 318]
                ex.printStackTrace(); // [cite: 318]
                JOptionPane.showMessageDialog(null, "删除失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE); // [cite: 319]
                System.err.println("Error during deletion for order number " + orderNumber); // [cite: 319]
            }
        } else {
            System.err.println("Attempted to delete row with invalid index: " + rowIndex); // [cite: 320]
        }
    }

    // Method to edit row - update to use injected service // [cite: 321]
    public void editRow(int rowIndex) {
        System.out.println("编辑行: " + rowIndex + " for user " + currentUser.getUsername()); // [cite: 321]
        if (rowIndex >= 0 && rowIndex < this.allData.size()) { // Use 'this' for allData // [cite: 322]
            Vector<String> rowData = new Vector<>(this.allData.get(rowIndex)); // [cite: 322]
            // Use 'this', create a copy // [cite: 323]


            // Create a panel for edit fields // [cite: 323]
            JPanel panel = new JPanel(new GridLayout(rowData.size() - 2, 2)); // [cite: 324]
            // Exclude last two columns ("Modify", "Delete") // [cite: 324]

            // Create fields array // [cite: 324]
            JTextField[] fields = new JTextField[rowData.size() - 2]; // [cite: 325]
            // Populate panel and fields from rowData, skipping last two columns // [cite: 325]
            for (int i = 0; i < rowData.size() - 2; i++) {
                panel.add(new JLabel(this.tableModel.getColumnName(i))); // [cite: 325]
                // Use 'this' // [cite: 326]
                fields[i] = new JTextField(rowData.get(i)); // [cite: 326]
                panel.add(fields[i]); // [cite: 327]
            }

            // Get the original order number, which is the key // [cite: 327]
            String originalOrderNumber = rowData.get(8).trim(); // [cite: 327]
            // Index 8 is OrderNumber // [cite: 328]


            // Show the dialog // [cite: 328]
            int result = JOptionPane.showConfirmDialog(null, panel, "修改交易信息 (订单号: " + originalOrderNumber + ")", JOptionPane.OK_CANCEL_OPTION); // [cite: 329]
            if (result == JOptionPane.OK_OPTION) {
                // User clicked OK, get updated values from fields // [cite: 329]

                // Create a Transaction object with updated values // [cite: 329]
                // Use the original order number as the key for the update operation // [cite: 330]
                Transaction updatedTransaction = new Transaction( // [cite: 330]
                        fields[0].getText().trim(), // 交易时间 // [cite: 330]
                        fields[1].getText().trim(), // 交易类型 // [cite: 331]
                        fields[2].getText().trim(), // 交易对方 // [cite: 331]
                        fields[3].getText().trim(), // 商品 // [cite: 331]
                        fields[4].getText().trim(), // 收/支 // [cite: 332]
                        // Handle paymentAmount parsing carefully // [cite: 332]
                        safeParseDouble(fields[5].getText().trim()), // 金额(元) - Use helper for parsing // [cite: 332]
                        fields[6].getText().trim(), // 支付方式 // [cite: 333]
                        fields[7].getText().trim(), // 当前状态 // [cite: 333]
                        originalOrderNumber, // Use the ORIGINAL order number as the identifier // [cite: 333]
                        fields[9].getText().trim(), // 商户单号 // [cite: 334]
                        fields[10].getText().trim() // 备注 // [cite: 334]
                );
                // Validate key fields if necessary (e.g., ensure OrderNumber wasn't changed in dialog implicitly) // [cite: 335]
                // If OrderNumber was editable, you'd need to handle the change, which is complex. // [cite: 336]
                // Assuming OrderNumber field in dialog is just for display/reference, or its change is handled separately. // [cite: 336]
                // If you want to allow changing OrderNumber, the updateTransaction logic in DAO needs adjustment // [cite: 337]
                // to delete the old and add with the new ON, which is tricky. // [cite: 337]
                // Let's assume OrderNumber is the stable key for updates. // [cite: 338]
                String dialogOrderNumber = fields[8].getText().trim(); // [cite: 338]
                if (!dialogOrderNumber.equals(originalOrderNumber)) { // [cite: 339]
                    System.err.println("Warning: Order number changed in edit dialog from '" + originalOrderNumber + "' to '" + dialogOrderNumber + "'. Using original ON for update."); // [cite: 339]
                    // Or handle this as an error: JOptionPane.showMessageDialog(null, "交易单号不允许修改！", "错误", JOptionPane.ERROR_MESSAGE); return; // [cite: 340]
                }
                // Ensure the updatedTransaction object uses the originalOrderNumber // [cite: 341]
                updatedTransaction.setOrderNumber(originalOrderNumber); // [cite: 341]
                try {
                    // Use the injected transactionService instance // [cite: 342]
                    transactionService.changeTransaction(updatedTransaction); // [cite: 342]
                    // Reload CSV data to update the table for the current user // [cite: 343]
                    loadCSVDataForCurrentUser(); // [cite: 343]
                    // Reload data after edit // [cite: 344]

                    JOptionPane.showMessageDialog(null, "修改成功！", "提示", JOptionPane.INFORMATION_MESSAGE); // [cite: 344]
                    System.out.println("Edited row " + rowIndex + " for order number " + originalOrderNumber); // [cite: 345]
                } catch (IllegalArgumentException e) {
                    // Catch specific exceptions from service, e.g., transaction not found // [cite: 346]
                    JOptionPane.showMessageDialog(null, "修改失败！\n" + e.getMessage(), "错误", JOptionPane.ERROR_MESSAGE); // [cite: 347]
                    e.printStackTrace(); // [cite: 347]
                }
                catch (Exception ex) { // Catch other exceptions from service // [cite: 347]
                    ex.printStackTrace(); // [cite: 348]
                    JOptionPane.showMessageDialog(null, "修改失败！\n" + ex.getMessage(), "错误", JOptionPane.ERROR_MESSAGE); // [cite: 348]
                    System.err.println("Error during editing for order number " + originalOrderNumber); // [cite: 349]
                }
            }
        } else {
            System.err.println("Attempted to edit row with invalid index: " + rowIndex); // [cite: 350]
        }
    }

    // Helper method to safely parse double, return 0.0 on error // [cite: 350]
    private double safeParseDouble(String value) {
        if (value == null || value.trim().isEmpty()) { // [cite: 351]
            return 0.0; // [cite: 351]
        }
        try {
            return Double.parseDouble(value.trim()); // [cite: 352]
        } catch (NumberFormatException e) {
            System.err.println("Failed to parse double from string: '" + value + "'"); // [cite: 352]
            return 0.0; // Or handle as error // [cite: 353]
        }
    }

    // Keep helper methods like findTextField, findComboBox, emptyIfNull // [cite: 353]
    // Note: findTextField, findComboBox might be less reliable if dialog structure changes. // [cite: 354]
    // Consider making dialogs their own classes that return a Transaction object. // [cite: 354]
    /**
     * If field is null, return empty string. // [cite: 355]
     * @param value Field value // [cite: 356]
     * @return Non-null field value // [cite: 356]
     */
    private String emptyIfNull(String value) {
        return value == null ? "" : value; // [cite: 357]
    }

    // Keep getTable() for testing // [cite: 357]
    public JTable getTable() {
        return table; // [cite: 358]
    }

    // The findTextField and findComboBox methods that were in pre.txt but missing in post.txt
    /**
     * 查找容器中的输入字段
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @param index     输入字段的索引
     * @return 输入字段
     */
    private JTextField findTextField(Container container, int index) {
        int count = 0; // [cite: 469]
        for (Component component : container.getComponents()) { // [cite: 470]
            if (component instanceof JTextField) { // [cite: 470]
                if (count == index) { // [cite: 470]
                    return (JTextField) component; // [cite: 471]
                }
                count++; // [cite: 472]
            }
        }
        return null; // [cite: 473]
    }

    /**
     * 查找容器中的下拉框
     *
     * @param container 容器（可以是 JPanel 或 JDialog）
     * @return 下拉框
     */
    private JComboBox<String> findComboBox(Container container) {
        for (Component component : container.getComponents()) { // [cite: 474]
            if (component instanceof JComboBox) { // [cite: 474]
                return (JComboBox<String>) component; // [cite: 475]
            }
        }
        return null; // [cite: 476]
    }
}
```
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\HistogramPanelContainer.java`:

```java
package Controller;
import Service.AIservice.AITransactionService;
import Service.TransactionService;

import javax.swing.*;
import java.awt.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class HistogramPanelContainer extends JPanel {
    private HistogramPanel histogramPanel;
    private JTextArea textArea;
    private JSplitPane splitPane;
    private boolean isHistogramVisible = true;
    private boolean isTextVisible = true;

    String userRequest = "分析账单";
    String filePath = "data/transactions.csv";
    String startTime = "2024-01-01";
    String endTime = "2024-12-31";

    private String aiResultText = ""; // 存储 AI 分析结果

    public HistogramPanelContainer() {
        setLayout(new BorderLayout(10, 10));

        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));
        JButton btnShowHistogram = new JButton("显示直方图");
        JButton btnShowText1 = new JButton("显示文本 1");
        JButton btnShowText2 = new JButton("显示文本 2");

        buttonPanel.add(btnShowHistogram);
        buttonPanel.add(btnShowText1);
        buttonPanel.add(btnShowText2);
        add(buttonPanel, BorderLayout.NORTH);

        textArea = new JTextArea();
        textArea.setFont(new Font("微软雅黑", Font.PLAIN, 18));
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setEditable(false);
        JScrollPane textScrollPane = new JScrollPane(textArea);

        histogramPanel = new HistogramPanel();
        splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, textScrollPane, histogramPanel);
        splitPane.setResizeWeight(0.5);
        add(splitPane, BorderLayout.CENTER);

        // 按钮点击监听器
        btnShowHistogram.addActionListener(e -> toggleHistogram());
        btnShowText1.addActionListener(e -> {
            // 调用后台分析并显示结果
            analyzeTransactionsInBackground(userRequest, filePath, startTime, endTime);
        });
        btnShowText2.addActionListener(e -> {
            // 你可以根据需求设置其他的文本显示
            analyzeTransactionsInBackground(userRequest, filePath, startTime, endTime);
        });
    }

    // 切换直方图的显示和隐藏
    private void toggleHistogram() {
        if (isHistogramVisible) {
            histogramPanel.setVisible(false);
        } else {
            showHistogram();
            histogramPanel.setVisible(true);
        }
        isHistogramVisible = !isHistogramVisible;
        SwingUtilities.invokeLater(() -> splitPane.setDividerLocation(isHistogramVisible ? 0.5 : 0.0));
    }



    // 显示直方图的函数，模拟数据
    private void showHistogram() {
        int[] data = DataGenerator.generateData(1000, 100);
        Histogram histogram = new Histogram(data, 10);
        histogramPanel.updateData(histogram.computeFrequency());
    }

    // 设置 AI 结果文本（供 AI 结果处理后调用）
    public void setAiResultText(String result) {
        this.aiResultText = result;
    }

    // 从后台线程调用，获取 AI 分析结果并更新界面
    public void analyzeTransactionsInBackground(String userRequest, String filePath, String startTimeStr, String endTimeStr) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.submit(() -> {
            System.out.println("分析任务开始...");  // 调试输出
            String result = new AITransactionService().analyzeTransactions(userRequest, filePath, startTimeStr, endTimeStr);

            // 输出结果查看是否有返回
            System.out.println("AI分析结果: " + result);

            if (result != null && !result.isEmpty()) {
                SwingUtilities.invokeLater(() -> {
                    setAiResultText(result);  // 更新 AI 结果文本
                    toggleText(result);       // 显示 AI 结果
                });
            } else {
                System.out.println("AI分析没有返回结果!");
            }
        });
        executor.shutdown();
    }

    public void toggleText(String text) {
        System.out.println("切换文本显示...");  // 调试输出
        if (isTextVisible) {
            textArea.setText("");  // 清空文本区域
            textArea.setVisible(false);
        } else {
            aiResultText = text;
            textArea.setText(text);
            textArea.setVisible(true);
        }
        isTextVisible = !isTextVisible;
        SwingUtilities.invokeLater(() -> {
            System.out.println("更新分割条位置...");  // 调试输出
            splitPane.setDividerLocation(isTextVisible ? 0.5 : 0.0);
        });
    }

}


```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\Individual Contribution.txt`:

```txt

DAO

关熙辰：


负责模块: 数据访问层 (DAO) 的实现、核心数据模型设计、部分基础设施、 AI API 访问基础。

Individual Contribution:

CSV 数据访问实现: 完成并维护所有 DAO.Impl 包下的类 (CsvTransactionDao.java, CsvUserDao.java, CsvSummaryStatisticDao.java)，确保其能正确地读写 CSV 文件，并实现 DAO.TransactionDao, DAO.UserDao, DAO.SummaryStatisticDao 接口中定义的所有方法。

核心数据模型设计: 负责设计并维护 model 包下的类 (Transaction.java, User.java, SummaryStatistic.java, MonthlySummary.java)，确保其字段和结构满足业务需求。

AI API Key 获取: 负责获取和配置 AI 服务的 API Key，并在 AITransactionService 中安全地使用它（从环境变量）。

用户使用场景设计: 参与项目需求和用户故事的讨论，设计不同角色的使用场景和流程（与 backlog 相关，代码实现内容较少，但有助于理解数据模型和 DAO 需求）。

设置和维护项目的构建工具（Maven），管理所有外部依赖（如 Apache Commons CSV, Caffeine, XChart, VolcEngine SDK）

Service
陈鸿帆：

负责模块: AI 相关的业务逻辑实现、用户认证逻辑、跨用户统计计算逻辑、部分实用工具。
Individual Contribution:

AI 服务逻辑实现: 完成并维护 Service.AIservice 包下的类 (AITransactionService.java, CollegeStudentNeeds.java)，实现个人财务分析、预算建议、储蓄目标建议、个性化节约建议、交易类型识别等核心 AI 业务逻辑。确保这些服务能够利用 TransactionService 提供的结构化数据（如月度摘要）。

跨用户统计计算: 完成并维护 Service.Impl.SummaryStatisticService.java，实现读取所有用户数据、聚合计算每周汇总统计数据（包括总收支、最高支出类别、参与用户数）并将结果通过 SummaryStatisticDao 保存的功能。

日期/时间解析工具: 负责编写和维护日期/时间解析相关的工具方法或类（例如，确保在 TransactionServiceImpl, SummaryStatisticService, CollegeStudentNeeds 中使用的日期解析逻辑一致且健壮，考虑将其提取到 Utils 包下）。

AI 分类建议 UI 交互（UI层）: 在 showAddTransactionDialog() 和 editRow() 方法中，实现“AI分类建议”按钮的 ActionListener 逻辑，包括调用 CollegeStudentNeeds.RecognizeTransaction、显示/隐藏等待对话框、在 AI 返回后更新交易类型文本框。



唐梓茗

负责模块: 项目总体设计与集成、核心交易业务逻辑、缓存管理、常量定义、构建与配置管理、主程序入口。
Individual Contribution:

核心交易服务逻辑: 完成并维护 Service.TransactionService.java 接口和 Service.Impl.TransactionServiceImpl.java 实现类，实现基于单个用户数据的 CRUD (创建、读取、更新、删除)、搜索、获取月度摘要、从 CSV 导入等核心业务操作。依赖 TransactionDao。

缓存管理: 完成并维护 Utils.CacheManager.java，利用 Caffeine 实现用户交易数据的缓存管理逻辑，并集成到 TransactionServiceImpl 和 AITransactionService 中。负责废弃或移除 CacheUtil.java。

配置文件和常量定义: 负责 Constants.ConfigConstants.java 的实现和维护，确保能正确加载配置文件中的各项路径（CSV 文件路径、用户文件路径、统计文件路径）。负责编写常量类（Constants.CaffeineKeys.java, Constants.ConfigConstants.java, Constants.StandardCategories.java 等），定义项目使用的各种常量和配置键。

登录校验功能设计 (存储): 完成并维护 Service.User.UserService.java，实现用户登录校验逻辑，依赖 UserDao 获取用户数据。设计用户校验信息的数据存储格式（users.csv）和其与 User 模型的对应关系。与组别一人负责的 CsvUserDao 协作实现存取。

多用户数据处理设计: 设计不同用户交易数据文件的命名规则和存储位置，确保 User 模型的 transactionFilePath 字段能够正确关联用户与其数据文件。协调 Service 层和 DAO 层使用正确的用户文件路径。

CSV 数据导入 UI: 在 createInputPanel() 中添加“导入 CSV”按钮（与人员 1 协作布局），并实现其 ActionListener 逻辑 (showImportDialog())，包括弹出 JFileChooser 文件选择器，获取用户选择的文件路径，并调用 TransactionService.importTransactionsFromCsv() 进行导入（在后台线程中运行）。


UI

陈冠儒

负责模块: 核心 UI 框架、交易列表界面布局与基础元素、 Service 层与 UI 的基础联调。
Individual Contribution:

整体 UI 框架: 设计并维护 Controller.MenuUI.java 的主结构，包括继承 JPanel，设置主布局管理器 (BorderLayout)，创建左侧导航面板和右侧内容切换面板 (CardLayout)。

左侧导航面板: 创建并布局左侧导航面板 (createLeftPanel()) 中的所有按钮（“交易列表”, “AI分析”, “管理员统计” (管理员可见), “可视化”），设置其基础样式和布局，和其点击事件的 Service 层调用逻辑。

交易列表界面: 设计并实现交易列表面板 (createTablePanel()) 的布局，包括搜索输入面板 (createInputPanel() 的布局和基础组件创建，包含 action listeners) 和表格显示区域 (JTable 和 JScrollPane 的设置)。

表格行操作按钮: 实现 Controller.ButtonRenderer.java 和 Controller.ButtonEditor.java 类，为表格的“Modify”和“Delete”列提供按钮的显示和点击事件处理。

表格行操作逻辑: 在 MenuUI.java 中，实现由 ButtonEditor 调用的 deleteRow() 和 editRow() 方法中的业务逻辑，包括从表格模型获取数据、调用 TransactionService 进行删除和修改、更新 UI（刷新表格显示）。也包括 createInputPanel() 中“Add”按钮调用的 showAddTransactionDialog() 的逻辑实现（与人员 2 协作 AI 部分）。

基础 Service 联调: 负责将 MenuUI 实例（作为 Controller）与 Service 层对象（transactionService, summaryStatisticService, aiTransactionService, collegeStudentNeeds）通过构造函数注入进行关联，确保 UI 能够持有 Service 层的引用。

表格基础设置: 完成 JTable 的基本设置，如列名、行高、自动调整模式等。


李昊洋


负责模块: AI 相关 UI 界面、个人可视化界面（数据准备部分）、 AI 与 UI 的业务逻辑联调。
Individual Contribution:

AI 分析界面: 设计并实现 AI 分析面板 (createAIPanel()) 的详细布局，包括文本输入框、时间范围输入框、文本显示区域 (JTextArea) 以及所有 AI 功能按钮（“通用分析”, “个人消费总结”, “储蓄目标建议”, “个性化节约建议”, “预算建议”, “省钱技巧”）。

AI 按钮行为: 实现 AI 分析面板中所有按钮的 ActionListener 逻辑，包括从输入字段获取参数、调用 Service.AIservice 包下的相应方法（AITransactionService, CollegeStudentNeeds），在后台线程中运行 AI 调用，并在 AI 返回结果后通过 SwingUtilities.invokeLater 更新 aiResultArea。

可视化界面（数据准备）: 设计并实现可视化面板 (VisualizationPanel.java) 的布局，包括图表类型选择器 (chartTypeSelector)、月份选择器 (monthSelector)、“生成图表”按钮 (generateChartButton) 以及图表显示区域 (chartDisplayPanel)。实现根据用户选择从 transactionService.getMonthlyTransactionSummary() 获取数据的逻辑。

可视化控件行为: 实现可视化面板中选择器和“生成图表”按钮的 ActionListener 逻辑，包括根据选择器的值判断需要的数据和图表类型，调用 Service 获取数据，但不包含实际的图表绘制代码。实现 populateMonthSelector() 和 refreshPanelData() 方法。



林海天

负责模块: 管理员统计界面、数据导入 UI、表格行操作按钮、整体界面美化。
Individual Contribution:

管理员统计界面: 设计并实现管理员统计面板 (createAdminStatsPanel()) 的布局，包括按钮（“生成/更新统计数据”, “刷新显示”）和统计结果文本区域 (adminStatsArea)。

管理员按钮行为: 实现管理员统计面板中按钮的 ActionListener 逻辑，包括调用 SummaryStatisticService 的相应方法（generateAndSaveWeeklyStatistics, getAllSummaryStatistics）并在后台线程中运行，更新 adminStatsArea 显示统计结果。

整体界面美化: 负责统一应用程序的视觉风格，包括字体、颜色、组件间距、边框等，确保界面整洁、专业、用户友好。这贯穿所有 UI 模块。

图表绘制实现: 在 VisualizationPanel.generateAndDisplayChart() 方法中，使用 XChart 库根据数据绘制实际的饼图和柱状图，并将 XChartPanel 添加到 chartDisplayPanel 中。（将图表绘制这个相对独立的任务分配给美化人员，增加其代码工作量）



```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\README.md`:

```md
## Project Overview
This module is a transaction record management 
system in the Service layer of the project that connects 
with the Dao layer that provides CRUD (Create, Read, Update
, Delete) functionality and data processing for
transaction data. Core features include transaction 
creation, modification, deletion, and flexible querying,
all accessible through standardized interfaces.

## Structure and Function
Swing GUI (Controller) <- Service <- DAO <-data(CSV/JSON)<-model

##  Model 

### Overview

This Java class, located in the `model` package, serves 
as a Plain Old Java Object (POJO) or data model to 
represent a single financial transaction record. It 
encapsulates all the standard details associated with 
a transaction, such as its time, type, amount, parties 
involved, status, and unique identifiers.

This class is typically used in conjunction with Data 
Access Objects (DAOs) like `TransactionDao` and
`CsvTransactionDao` to load, save, and manipulate 
transaction data from a persistent store (e.g., a CSV 
file or database).

### Package

`model`

### Fields

The `Transaction` class contains the following fields:

* `transactionTime` (String): The date and time when the transaction occurred (e.g., "2023-10-27 15:30:00").
* `transactionType` (String): The category or type of the transaction (e.g., "在线支付" - Online Payment, "转账" - Transfer, "退款" - Refund).
* `counterparty` (String): The name or identifier of the other party involved in the transaction.
* `commodity` (String): A description of the goods, service, or reason for the transaction (e.g., "Coffee", "Salary", "Online Course Fee").
* `inOut` (String): Indicates the direction of the money flow relative to the account holder. Typically:
* `paymentAmount` (double): The monetary value of the transaction. The currency unit (e.g., Yuan) is implied by the context where this class is used (often indicated by header names like "金额(元)" in associated CSV files).
* `paymentMethod` (String): The method used for the payment (e.g., "支付宝" - Alipay, "微信支付" - WeChat Pay, "银行卡" - Bank Card, "现金" - Cash).
* `currentStatus` (String): The current processing status of the transaction (e.g., "交易成功" - Transaction Successful, "等待付款" - Awaiting Payment, "已关闭" - Closed, "退款成功" - Refund Successful).
* `orderNumber` (String): A unique identifier assigned to this specific transaction instance by the payment system or application. Often used as a primary key.
* `merchantNumber` (String): An order number or identifier associated with the merchant's system, often provided for reconciliation purposes. May be empty or null if not applicable.
* `remarks` (String): An optional field for any additional notes, comments, or user-provided descriptions about the transaction.

### Constructors

* **`public Transaction()`**
    * Default no-argument constructor. Creates an empty `Transaction` object with all fields initialized to their default values (null for String, 0.0 for double).

* **`public Transaction(String transactionTime, String transactionType, ..., String remarks)`**
    * Parameterized constructor that accepts values for all fields. Allows for quick instantiation of a fully populated `Transaction` object.

### Methods

The class provides standard public **getter** (`get...()`) and **setter** (`set...()`) methods for all its private fields. These methods allow controlled access and modification of the transaction's attributes from other parts of the application.

* `getTransactionTime()` / `setTransactionTime(String time)`
* `getTransactionType()` / `setTransactionType(String type)`
* `getCounterparty()` / `setCounterparty(String counterparty)`
* `getCommodity()` / `setCommodity(String commodity)`
* `getInOut()` / `setInOut(String inOut)`
* `getPaymentAmount()` / `setPaymentAmount(double amount)`
* `getPaymentMethod()` / `setPaymentMethod(String method)`
* `getCurrentStatus()` / `setCurrentStatus(String status)`
* `getOrderNumber()` / `setOrderNumber(String orderNumber)`
* `getMerchantNumber()` / `setMerchantNumber(String merchantNumber)`
* `getRemarks()` / `setRemarks(String remarks)`

 
### Service (Business logic)
- Responsibilities:
Transaction CRUD operations, calling the DAO layer to read and write local files,
User-defined classification logic (e.g. modifying transaction categories)
  (3) Operations:

Add Transaction:

Transaction t = new Transaction();
// Set field values
service.addTransaction(t);

Modify Transaction:

Transaction update = new Transaction();
update.setOrderNumber("ORD123");
// Set fields to update
service.changeTransaction(update);

Query Transactions:

Transaction criteria = new Transaction();
criteria.setCounterparty("Alipay");
List<Transaction> results = service.searchTransaction(criteria);
Code structure
   Directory Layout:
   src/main/java/
   └── Service/
   ├── Impl/
   │   └── TransactionServiceImpl.java  # Service implementation
   └── TransactionService.java          # Service interface
   TransactionService.java:
   Defines the service interface with business-agnostic method signatures, enforcing decoupling 
   between business logic and implementation details.
   TransactionServiceImpl.java:
   Implements the concrete business logic while depending only on the interface-defined contract, maintaining loose coupling with the data access layer through dependency injection.


- AIService (Intelligent Analytics) Responsibilities: Generate budget recommendations based
on historical data, and detect cost-cutting recommendations for seasonal spending in China
(e.g. Spring Festival) (e.g. marking high-frequency small spending)


- **`AITransactionService`**

The central class that performs the full AI-driven transaction analysis. It:

- Loads transaction data from a CSV file via `CsvTransactionDao`.
- Filters transactions by user-specified time range (`startTimeStr`, `endTimeStr`).
- Aggregates data by counterparty (income/spending, transaction counts).
- Formats the result into concise summaries sent to the AI.
- Sends user questions and formatted data to the Volcengine Ark AI API.
- Returns a response within **400 characters** for efficient display.

Key methods:
- `analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr)`
  → Returns an AI-generated analysis result string.
- `runAiInThread(...)`
  → Runs the AI logic in a background thread (single-threaded executor).
- `formatTransactions(...)`
  → Groups transactions and summarizes them by counterparty and time range.
- `parseDateTime(...)`
  → Supports flexible input formats like `yyyy/MM/dd`, `yyyy/MM/dd HH:mm`, and more. - **`AIAnalyzerThread`** A `Runnable` implementation for threading scenarios (especially GUI usage). It calls `AITransactionService.analyzeTransactions(...)` and prints the result. UI developers can replace the console output with GUI updates using `SwingUtilities.invokeLater()`. --- ### Tests (`test/java/Service/AIservice/`) - **`AIserviceTest`** Unit tests for `AITransactionService`, verifying: - Correct loading and filtering of transactions. - Accurate AI response generation and formatting. - Graceful handling of edge cases (e.g., no transactions in range, invalid time formats). - **`AIAnalyzerThreadTest`** Validates threading logic: - Ensures `AIAnalyzerThread` executes `Runnable` correctly. - Demonstrates clean and concurrent AI analysis flow. - Simulates integration with a GUI environment. - **`AiFunctionTest`** Utility-level tests: - Ensures proper CSV parsing and data transformation. - Verifies output formatting before sending to the AI. - Tests various time formats and edge case behaviors

## DAO (File Storage)
- Responsibilities: Save transaction data in CSV or JSON format and provide interfaces for adding,
  deleting, and modifying in-memory data
### CsvTransactionDao Class

#### Package

`DAO`

#### Dependencies

* **`model.Transaction`**: The data model class representing a single transaction.
* **`DAO.TransactionDao`**: The interface this class is intended to implement (though the implementation is incomplete).
* **Apache Commons CSV (`org.apache.commons.csv.*`)**: Used for robust parsing and writing of CSV data.
* **Apache Commons IO (`org.apache.commons.io.input.BOMInputStream`)**: Used specifically to handle potential Byte Order Marks (BOM) often found in UTF-8 encoded files, particularly those edited in Windows.
* **Java Standard Libraries**: `java.io.*`, `java.nio.*`.

#### Key Features & Implementation Details

* **CSV Loading (`loadFromCSV`)**:
  * Reads data from a specified CSV file path.
  * Expects UTF-8 encoding.
  * Handles potential Byte Order Mark (BOM) at the beginning of the file.
  * Uses the first row of the CSV as the header to map columns to `Transaction` fields. Assumes specific header names (e.g., "交易时间", "交易类型", "金额(元)").
  * Parses transaction records into a `List<Transaction>`.
  * Includes basic caching using an internal `transactions` list and an `isLoad` flag to avoid redundant file reads within the same instance lifecycle (unless forced by methods like `deleteTransaction` or `changeInformation`).
* **Record Parsing (`parseRecord`)**:
  * Converts a `CSVRecord` object (from Apache Commons CSV) into a `Transaction` object.
  * Specifically handles the "金额(元)" (Amount) field by removing the leading "¥" symbol before parsing it as a `double`.
* **Adding Transactions (`addTransaction(String filePath, Transaction newTransaction)`)**:
  * **Appends** a new transaction record to the *end* of the specified CSV file.
  * Creates the file if it doesn't exist.
  * Writes the header row only if the file is new or was empty.
  * Formats the payment amount by prepending "¥".
* **Deleting Transactions (`deleteTransaction(String filePath, String orderNumber)`)**:
  * Loads data from the file if not already cached.
  * Filters the cached list to remove the transaction matching the given `orderNumber`.
  * **Overwrites** the *entire* original CSV file with the filtered list using `writeTransactionsToCSV`.
  * Returns `true` if a transaction was removed, `false` otherwise.
* **Updating Transactions (`changeInformation`)**:
  * Loads data if not already cached.
  * Finds the transaction by `orderNumber`.
  * Modifies the specified field (`head`) of the found transaction object in memory.
  * **Crucially, it attempts the update by first *deleting* the original record (using `deleteTransaction`, which overwrites the file) and then *adding* the modified record (using `addTransaction`, which appends to the file).** This logic is inefficient and potentially problematic due to the conflicting file write strategies (overwrite vs. append).
  * Error handling for invalid `head` parameters prints to `System.err`. The method often returns `true` even if the underlying delete/add fails.
* **CSV Writing (`writeTransactionsToCSV`)**:
  * Helper method used by `deleteTransaction`.
  * Writes a given `List<Transaction>` to the specified file path, **overwriting** any existing content.
  * Writes a standard header row.
  * Formats the payment amount by prepending "¥".

#### Important Issues & Considerations

1.  **Incomplete `TransactionDao` Implementation**: The methods declared in the `TransactionDao` interface (`getAllTransactions`, `addTransaction(Transaction)`, `deleteTransaction(String)`, `updateTransaction`, `getTransactionByOrderNumber`) are present but contain only placeholder/stub code. The actual working logic uses separate methods that require the `filePath` to be passed explicitly each time. **This class, in its current state, does not correctly function as a `TransactionDao` implementation.**
2.  **Inconsistent File Writing Strategy**: `addTransaction` *appends* to the file, while `deleteTransaction` and `writeTransactionsToCSV` (used by `deleteTransaction` and `changeInformation`) *overwrite* the entire file. This inconsistency can lead to unexpected behavior, especially within the `changeInformation` method.
3.  **Inefficient Updates/Deletes**: Rewriting the entire CSV file for every single deletion or modification (`changeInformation`) is highly inefficient, especially for large transaction files.
4.  **Flawed Update Logic (`changeInformation`)**: The delete-then-add approach for updates is problematic due to the inconsistent write strategies and potential race conditions or partial failures. The modified record will likely appear at the *end* of the file, not its original position.
5.  **Basic Caching**: The caching mechanism (`isLoad` flag) is simple and does not account for external modifications to the CSV file during the application's runtime.
6.  **Hardcoded Dependencies**: The code relies on specific header names (in Chinese) and the "¥" currency symbol format within the CSV data. Changes to the CSV format would require code modifications.

#### Usage Example (Using Functional Methods)

```java
import DAO.Impl.CsvTransactionDao; // Assuming TransactionDao interface exists but is not used directly here due to stub methods
import model.Transaction;
import java.io.IOException;
import java.util.List;

public class CsvDataManager {

    public static void main(String[] args) {
        // NOTE: Using the class directly, not via the TransactionDao interface
        // because the interface methods are not fully implemented.
        CsvTransactionDao csvDao = new CsvTransactionDao();
        String csvFilePath = "path/to/your/transactions.csv"; // <--- Specify your file path

        try {
            // --- Load Data ---
            System.out.println("Loading transactions...");
            List<Transaction> transactions = csvDao.loadFromCSV(csvFilePath);
            System.out.println("Loaded " + transactions.size() + " transactions.");
            // Display first transaction if available
            if (!transactions.isEmpty()) {
                 System.out.println("First transaction order number: " + transactions.get(0).getOrderNumber());
            }

            // --- Add a New Transaction (Appends) ---
            Transaction newTx = new Transaction(
                 "2025-04-20 08:14:00", "Test Add", "Counterparty", "Item", "支",
                 10.0, "支付宝", "交易成功", "NEW_ORDER_123", "MERCH_456", "Test via DAO add"
            );
            System.out.println("\nAdding new transaction (append): " + newTx.getOrderNumber());
            // csvDao.addTransaction(csvFilePath, newTx); // Uncomment to actually add
            System.out.println("Transaction potentially added.");

            // --- Delete a Transaction (Overwrites File) ---
            String orderToDelete = "SOME_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number from your file
            System.out.println("\nAttempting to delete transaction: " + orderToDelete);
            // boolean deleted = csvDao.deleteTransaction(csvFilePath, orderToDelete); // Uncomment to actually delete
            // if (deleted) {
            //     System.out.println("Transaction deleted successfully (File rewritten).");
            // } else {
            //     System.out.println("Transaction not found for deletion.");
            // }

            // --- Change Information (Overwrites then Appends - Use with Caution) ---
             String orderToChange = "ANOTHER_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number
             String fieldToChange = "remarks";
             String newValue = "Updated remark via changeInformation";
             System.out.println("\nAttempting to change info for: " + orderToChange);
             // boolean changed = csvDao.changeInformation(orderToChange, fieldToChange, newValue, csvFilePath); // Uncomment with caution
             // System.out.println("Change operation attempted (File rewritten and appended). Result: " + changed);


        } catch (IOException e) {
            System.err.println("Error interacting with CSV file: " + e.getMessage());
            e.printStackTrace();
        } catch (NumberFormatException e) {
            System.err.println("Error parsing amount in CSV: " + e.getMessage());
        }
    }
}
```

## Controller (Swing GUI)

Responsibilities: Manage user interface components (buttons, tables, text boxes) to listen for 
events (clicks, inputs) and call service layer methods to update the interface data display

## attention
encoding with UTF-8

```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\README.txt`:

```txt
## Project Overview

This module is a transaction record management 
system in the Service layer of the project that connects 
with the Dao layer that provides CRUD (Create, Read, Update
, Delete) functionality and data processing for
transaction data. Core features include transaction 
creation, modification, deletion, and flexible querying,
all accessible through standardized interfaces.

## Structure and Function

Swing GUI (Controller) <- Service <- DAO <-data(CSV/JSON)<-model

##  Model 

### Overview

This Java class, located in the `model` package, serves 
as a Plain Old Java Object (POJO) or data model to 
represent a single financial transaction record. It 
encapsulates all the standard details associated with 
a transaction, such as its time, type, amount, parties 
involved, status, and unique identifiers.

This class is typically used in conjunction with Data 
Access Objects (DAOs) like `TransactionDao` and
`CsvTransactionDao` to load, save, and manipulate 
transaction data from a persistent store (e.g., a CSV 
file or database).

### Package

`model`

### Fields

The `Transaction` class contains the following fields:

* `transactionTime` (String): The date and time when the transaction occurred (e.g., "2023-10-27 15:30:00").
* `transactionType` (String): The category or type of the transaction (e.g., "在线支付" - Online Payment, "转账" - Transfer, "退款" - Refund).
* `counterparty` (String): The name or identifier of the other party involved in the transaction.
* `commodity` (String): A description of the goods, service, or reason for the transaction (e.g., "Coffee", "Salary", "Online Course Fee").
* `inOut` (String): Indicates the direction of the money flow relative to the account holder. Typically:
* `paymentAmount` (double): The monetary value of the transaction. The currency unit (e.g., Yuan) is implied by the context where this class is used (often indicated by header names like "金额(元)" in associated CSV files).
* `paymentMethod` (String): The method used for the payment (e.g., "支付宝" - Alipay, "微信支付" - WeChat Pay, "银行卡" - Bank Card, "现金" - Cash).
* `currentStatus` (String): The current processing status of the transaction (e.g., "交易成功" - Transaction Successful, "等待付款" - Awaiting Payment, "已关闭" - Closed, "退款成功" - Refund Successful).
* `orderNumber` (String): A unique identifier assigned to this specific transaction instance by the payment system or application. Often used as a primary key.
* `merchantNumber` (String): An order number or identifier associated with the merchant's system, often provided for reconciliation purposes. May be empty or null if not applicable.
* `remarks` (String): An optional field for any additional notes, comments, or user-provided descriptions about the transaction.

### Constructors

* **`public Transaction()`**
  * Default no-argument constructor. Creates an empty `Transaction` object with all fields initialized to their default values (null for String, 0.0 for double).

* **`public Transaction(String transactionTime, String transactionType, ..., String remarks)`**
  * Parameterized constructor that accepts values for all fields. Allows for quick instantiation of a fully populated `Transaction` object.

### Methods

The class provides standard public **getter** (`get...()`) and **setter** (`set...()`) methods for all its private fields. These methods allow controlled access and modification of the transaction's attributes from other parts of the application.

* `getTransactionTime()` / `setTransactionTime(String time)`
* `getTransactionType()` / `setTransactionType(String type)`
* `getCounterparty()` / `setCounterparty(String counterparty)`
* `getCommodity()` / `setCommodity(String commodity)`
* `getInOut()` / `setInOut(String inOut)`
* `getPaymentAmount()` / `setPaymentAmount(double amount)`
* `getPaymentMethod()` / `setPaymentMethod(String method)`
* `getCurrentStatus()` / `setCurrentStatus(String status)`
* `getOrderNumber()` / `setOrderNumber(String orderNumber)`
* `getMerchantNumber()` / `setMerchantNumber(String merchantNumber)`
* `getRemarks()` / `setRemarks(String remarks)`


### Service (Business logic)

- Responsibilities:
  Transaction CRUD operations, calling the DAO layer to read and write local files,
  User-defined classification logic (e.g. modifying transaction categories)
  (3) Operations:

Add Transaction:

Transaction t = new Transaction();
// Set field values
service.addTransaction(t);

Modify Transaction:

Transaction update = new Transaction();
update.setOrderNumber("ORD123");
// Set fields to update
service.changeTransaction(update);

Query Transactions:

Transaction criteria = new Transaction();
criteria.setCounterparty("Alipay");
List<Transaction> results = service.searchTransaction(criteria);
Code structure
   Directory Layout:
   src/main/java/
   └── Service/
   ├── Impl/
   │   └── TransactionServiceImpl.java  # Service implementation
   └── TransactionService.java          # Service interface
   TransactionService.java:
   Defines the service interface with business-agnostic method signatures, enforcing decoupling 
   between business logic and implementation details.
   TransactionServiceImpl.java:
   Implements the concrete business logic while depending only on the interface-defined contract, maintaining loose coupling with the data access layer through dependency injection.


- AIService (Intelligent Analytics) Responsibilities: Generate budget recommendations based
  on historical data, and detect cost-cutting recommendations for seasonal spending in China
  (e.g. Spring Festival) (e.g. marking high-frequency small spending)


- **`AITransactionService`**

The central class that performs the full AI-driven transaction analysis. It:

- Loads transaction data from a CSV file via `CsvTransactionDao`.
- Filters transactions by user-specified time range (`startTimeStr`, `endTimeStr`).
- Aggregates data by counterparty (income/spending, transaction counts).
- Formats the result into concise summaries sent to the AI.
- Sends user questions and formatted data to the Volcengine Ark AI API.
- Returns a response within **400 characters** for efficient display.

Key methods:

- `analyzeTransactions(String userRequest, String filePath, String startTimeStr, String endTimeStr)`
  → Returns an AI-generated analysis result string.
- `runAiInThread(...)`
  → Runs the AI logic in a background thread (single-threaded executor).
- `formatTransactions(...)`
  → Groups transactions and summarizes them by counterparty and time range.
- `parseDateTime(...)`
  → Supports flexible input formats like `yyyy/MM/dd`, `yyyy/MM/dd HH:mm`, and more. - **`AIAnalyzerThread`** A `Runnable` implementation for threading scenarios (especially GUI usage). It calls `AITransactionService.analyzeTransactions(...)` and prints the result. UI developers can replace the console output with GUI updates using `SwingUtilities.invokeLater()`. --- ### Tests (`test/java/Service/AIservice/`) - **`AIserviceTest`** Unit tests for `AITransactionService`, verifying: - Correct loading and filtering of transactions. - Accurate AI response generation and formatting. - Graceful handling of edge cases (e.g., no transactions in range, invalid time formats). - **`AIAnalyzerThreadTest`** Validates threading logic: - Ensures `AIAnalyzerThread` executes `Runnable` correctly. - Demonstrates clean and concurrent AI analysis flow. - Simulates integration with a GUI environment. - **`AiFunctionTest`** Utility-level tests: - Ensures proper CSV parsing and data transformation. - Verifies output formatting before sending to the AI. - Tests various time formats and edge case behaviors

## DAO (File Storage)

- Responsibilities: Save transaction data in CSV or JSON format and provide interfaces for adding,
  deleting, and modifying in-memory data

### CsvTransactionDao Class

#### Package

`DAO`

#### Dependencies

* **`model.Transaction`**: The data model class representing a single transaction.
* **`DAO.TransactionDao`**: The interface this class is intended to implement (though the implementation is incomplete).
* **Apache Commons CSV (`org.apache.commons.csv.*`)**: Used for robust parsing and writing of CSV data.
* **Apache Commons IO (`org.apache.commons.io.input.BOMInputStream`)**: Used specifically to handle potential Byte Order Marks (BOM) often found in UTF-8 encoded files, particularly those edited in Windows.
* **Java Standard Libraries**: `java.io.*`, `java.nio.*`.

#### Key Features & Implementation Details

* **CSV Loading (`loadFromCSV`)**:
  * Reads data from a specified CSV file path.
  * Expects UTF-8 encoding.
  * Handles potential Byte Order Mark (BOM) at the beginning of the file.
  * Uses the first row of the CSV as the header to map columns to `Transaction` fields. Assumes specific header names (e.g., "交易时间", "交易类型", "金额(元)").
  * Parses transaction records into a `List<Transaction>`.
  * Includes basic caching using an internal `transactions` list and an `isLoad` flag to avoid redundant file reads within the same instance lifecycle (unless forced by methods like `deleteTransaction` or `changeInformation`).
* **Record Parsing (`parseRecord`)**:
  * Converts a `CSVRecord` object (from Apache Commons CSV) into a `Transaction` object.
  * Specifically handles the "金额(元)" (Amount) field by removing the leading "¥" symbol before parsing it as a `double`.
* **Adding Transactions (`addTransaction(String filePath, Transaction newTransaction)`)**:
  * **Appends** a new transaction record to the *end* of the specified CSV file.
  * Creates the file if it doesn't exist.
  * Writes the header row only if the file is new or was empty.
  * Formats the payment amount by prepending "¥".
* **Deleting Transactions (`deleteTransaction(String filePath, String orderNumber)`)**:
  * Loads data from the file if not already cached.
  * Filters the cached list to remove the transaction matching the given `orderNumber`.
  * **Overwrites** the *entire* original CSV file with the filtered list using `writeTransactionsToCSV`.
  * Returns `true` if a transaction was removed, `false` otherwise.
* **Updating Transactions (`changeInformation`)**:
  * Loads data if not already cached.
  * Finds the transaction by `orderNumber`.
  * Modifies the specified field (`head`) of the found transaction object in memory.
  * **Crucially, it attempts the update by first *deleting* the original record (using `deleteTransaction`, which overwrites the file) and then *adding* the modified record (using `addTransaction`, which appends to the file).** This logic is inefficient and potentially problematic due to the conflicting file write strategies (overwrite vs. append).
  * Error handling for invalid `head` parameters prints to `System.err`. The method often returns `true` even if the underlying delete/add fails.
* **CSV Writing (`writeTransactionsToCSV`)**:
  * Helper method used by `deleteTransaction`.
  * Writes a given `List<Transaction>` to the specified file path, **overwriting** any existing content.
  * Writes a standard header row.
  * Formats the payment amount by prepending "¥".

#### Important Issues & Considerations

1.  **Incomplete `TransactionDao` Implementation**: The methods declared in the `TransactionDao` interface (`getAllTransactions`, `addTransaction(Transaction)`, `deleteTransaction(String)`, `updateTransaction`, `getTransactionByOrderNumber`) are present but contain only placeholder/stub code. The actual working logic uses separate methods that require the `filePath` to be passed explicitly each time. **This class, in its current state, does not correctly function as a `TransactionDao` implementation.**
2.  **Inconsistent File Writing Strategy**: `addTransaction` *appends* to the file, while `deleteTransaction` and `writeTransactionsToCSV` (used by `deleteTransaction` and `changeInformation`) *overwrite* the entire file. This inconsistency can lead to unexpected behavior, especially within the `changeInformation` method.
3.  **Inefficient Updates/Deletes**: Rewriting the entire CSV file for every single deletion or modification (`changeInformation`) is highly inefficient, especially for large transaction files.
4.  **Flawed Update Logic (`changeInformation`)**: The delete-then-add approach for updates is problematic due to the inconsistent write strategies and potential race conditions or partial failures. The modified record will likely appear at the *end* of the file, not its original position.
5.  **Basic Caching**: The caching mechanism (`isLoad` flag) is simple and does not account for external modifications to the CSV file during the application's runtime.
6.  **Hardcoded Dependencies**: The code relies on specific header names (in Chinese) and the "¥" currency symbol format within the CSV data. Changes to the CSV format would require code modifications.

#### Usage Example (Using Functional Methods)

```java
import DAO.Impl.CsvTransactionDao; // Assuming TransactionDao interface exists but is not used directly here due to stub methods
import model.Transaction;
import java.io.IOException;
import java.util.List;

public class CsvDataManager {

    public static void main(String[] args) {
        // NOTE: Using the class directly, not via the TransactionDao interface
        // because the interface methods are not fully implemented.
        CsvTransactionDao csvDao = new CsvTransactionDao();
        String csvFilePath = "path/to/your/transactions.csv"; // <--- Specify your file path

        try {
            // --- Load Data ---
            System.out.println("Loading transactions...");
            List<Transaction> transactions = csvDao.loadFromCSV(csvFilePath);
            System.out.println("Loaded " + transactions.size() + " transactions.");
            // Display first transaction if available
            if (!transactions.isEmpty()) {
                 System.out.println("First transaction order number: " + transactions.get(0).getOrderNumber());
            }

            // --- Add a New Transaction (Appends) ---
            Transaction newTx = new Transaction(
                 "2025-04-20 08:14:00", "Test Add", "Counterparty", "Item", "支",
                 10.0, "支付宝", "交易成功", "NEW_ORDER_123", "MERCH_456", "Test via DAO add"
            );
            System.out.println("\nAdding new transaction (append): " + newTx.getOrderNumber());
            // csvDao.addTransaction(csvFilePath, newTx); // Uncomment to actually add
            System.out.println("Transaction potentially added.");

            // --- Delete a Transaction (Overwrites File) ---
            String orderToDelete = "SOME_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number from your file
            System.out.println("\nAttempting to delete transaction: " + orderToDelete);
            // boolean deleted = csvDao.deleteTransaction(csvFilePath, orderToDelete); // Uncomment to actually delete
            // if (deleted) {
            //     System.out.println("Transaction deleted successfully (File rewritten).");
            // } else {
            //     System.out.println("Transaction not found for deletion.");
            // }

            // --- Change Information (Overwrites then Appends - Use with Caution) ---
             String orderToChange = "ANOTHER_EXISTING_ORDER_NUMBER"; // <--- Change to a real order number
             String fieldToChange = "remarks";
             String newValue = "Updated remark via changeInformation";
             System.out.println("\nAttempting to change info for: " + orderToChange);
             // boolean changed = csvDao.changeInformation(orderToChange, fieldToChange, newValue, csvFilePath); // Uncomment with caution
             // System.out.println("Change operation attempted (File rewritten and appended). Result: " + changed);


        } catch (IOException e) {
            System.err.println("Error interacting with CSV file: " + e.getMessage());
            e.printStackTrace();
        } catch (NumberFormatException e) {
            System.err.println("Error parsing amount in CSV: " + e.getMessage());
        }
    }
}
```

## Controller (Swing GUI)

Responsibilities: Manage user interface components (buttons, tables, text boxes) to listen for 
events (clicks, inputs) and call service layer methods to update the interface data display

## attention

encoding with UTF-8
```

`新建 WinRAR ZIP 压缩文件(2)/Ai-Bill-Application-Group211\项目要求.txt`:

```txt
1. General Information 
In the next few weeks, your team will be required to develop a software application that 
will serve as a smart personal finance manager that helps users track expenses, set 
savings goals, and analyses spending habits using AI. Agile methods should be applied 
in all activities, from requirements through analysis/design, implementation, and testing. 
Iterations should be planned, and outcomes should be submitted. 
There are no restrictions on what you can include in the final product, and the given 
specification contains only high-level abstract requirements. It should be noted that 
determining the software requirements is one of the most important and complex phases 
in any development project. You should apply requirement-finding techniques and Agile 
methods to identify the actual requirements at an appropriate level. Most importantly, you 
need to prioritize the features that are implemented in accordance with both ease of 
implementation and meeting requirements. As in real software, you should define the 
project scope properly. Keep your design SIMPLE. Bear in mind that there is no absolute 
right answer – your solution may be perfectly appropriate.

2. Project Specification 
2.1 Basic Requirements 
Managing personal finances effectively is crucial in today’s digital economy, where 
transactions occur across multiple platforms like WeChat Pay, Alipay, and traditional 
banking. Many individuals struggle with tracking expenses, categorizing spending, and 
setting realistic budgets. An AI-powered personal finance tracker simplifies financial 
management by automatically classifying transactions, detecting spending patterns, and 
offering personalized savings recommendations. However, AI is not perfect – users must 
manually review to ensure accuracy. By integrating AI with manual validation, this 
software helps users make informed financial decisions while adapting to regional 
spending habits and economic conditions, improving financial literacy and budgeting 
skills. Here are some suggested functions to assist you in getting started. Suggested 
features can include the following, but not limited to: 
• Manual & Automated Data Entry: End users may input transactions manually or 
import structured CSV files from banking/financial apps. 
• Expense Categorisation (AI + Manual Correction): AI classifies transactions into 
categories (e.g., groceries, rent, entertainment), but end users can verify & correct 
misclassifications. 
• Spending Insights & Predictions: AI suggests monthly budgets, savings goals, and 
cost-cutting recommendations based on spending behaviour. 
• Local Financial Context: Customisable to China-specific budgeting habits, for 
example detects seasonal spending habits, such as higher expenses during Chinese 
New Year. 
A full prototype of the application should be produced. It is not required to implement the 
full working code for all functions in the prototype, however your team should implement 
core functions of your choice. 

2.2 Other Requirements 
• The software must be developed using Java as a stand-alone application running 
on computers. A simple graphic user interface (GUI) should be used. The recent 
Java Edition should be used. Do NOT build a Web-based application or Phone 
App. 
• All input and output data should be in simple text file format. You may use plain 
text (txt), CSV, JSON, or XML. Do NOT use a database. 
• Basic restrictions and error checking must be considered. 
• Your design must be flexible and extensible to adapt to future changes, e.g. 
modify existing features and add new features. When doing so, you should be 
able to reuse the existing components and make the least impact on the existing 
code. 
Page 2 of 8 
Your tasks are to define detailed requirements, design, develop and test the above software 
using Agile methods. Feel free to design the software as long as it satisfies the basic 
requirements, define the SCOPE properly.  

2.3 AI-Assisted Development 
To prevent over-reliance on AI, 
the following constraints apply: 
• Live Data Collection: AI cannot generate user-specific data patterns – you must 
gather real data. 请给出相应的数据搜集渠道（但是我们已经设计好了csv表，相应字段也设计了）
• Manual Data Cleaning and Validation: AI assistance is allowed, but the team must 
need to manually check for missing information, inconsistency, and inappropriate 
categorisation, etc. 
• Context-Specific Constraints: AI may struggle with domain-specific rules – you 
must implement real-world constraints (e.g. AI may count a WeChat Red Packet as a 
personal income where it is in fact a gift money and not a regular income.) 
• Oral Spot-Check: During the vivas, you will need to answer questions like “Why did 
AI make this recommendation?”, “How did you modify AI’s solution?”, etc, to 
demonstrate your understanding.
```